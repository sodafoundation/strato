
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/soda/multi-cloud/api/pkg/common/common.go (0.0%)</option>
				
				<option value="file1">github.com/soda/multi-cloud/api/pkg/context/context.go (0.0%)</option>
				
				<option value="file2">github.com/soda/multi-cloud/api/pkg/model/error.go (0.0%)</option>
				
				<option value="file3">github.com/soda/multi-cloud/api/pkg/policy/checks.go (18.9%)</option>
				
				<option value="file4">github.com/soda/multi-cloud/api/pkg/policy/parser.go (74.4%)</option>
				
				<option value="file5">github.com/soda/multi-cloud/api/pkg/policy/policy.go (47.1%)</option>
				
				<option value="file6">github.com/soda/multi-cloud/api/pkg/s3/abortmultipartupload.go (0.0%)</option>
				
				<option value="file7">github.com/soda/multi-cloud/api/pkg/s3/acl.go (0.0%)</option>
				
				<option value="file8">github.com/soda/multi-cloud/api/pkg/s3/api-headers.go (0.0%)</option>
				
				<option value="file9">github.com/soda/multi-cloud/api/pkg/s3/api-response.go (0.0%)</option>
				
				<option value="file10">github.com/soda/multi-cloud/api/pkg/s3/bucketacl.go (0.0%)</option>
				
				<option value="file11">github.com/soda/multi-cloud/api/pkg/s3/bucketdelete.go (0.0%)</option>
				
				<option value="file12">github.com/soda/multi-cloud/api/pkg/s3/bucketget.go (0.0%)</option>
				
				<option value="file13">github.com/soda/multi-cloud/api/pkg/s3/bucketlifecycledelete.go (0.0%)</option>
				
				<option value="file14">github.com/soda/multi-cloud/api/pkg/s3/bucketlifecycleget.go (0.0%)</option>
				
				<option value="file15">github.com/soda/multi-cloud/api/pkg/s3/bucketlifecycleput.go (0.0%)</option>
				
				<option value="file16">github.com/soda/multi-cloud/api/pkg/s3/bucketput.go (0.0%)</option>
				
				<option value="file17">github.com/soda/multi-cloud/api/pkg/s3/bucketsseput.go (0.0%)</option>
				
				<option value="file18">github.com/soda/multi-cloud/api/pkg/s3/bucketversioningput.go (0.0%)</option>
				
				<option value="file19">github.com/soda/multi-cloud/api/pkg/s3/completemultipartupload.go (0.0%)</option>
				
				<option value="file20">github.com/soda/multi-cloud/api/pkg/s3/datatype/acl.go (0.0%)</option>
				
				<option value="file21">github.com/soda/multi-cloud/api/pkg/s3/datatype/datetime.go (0.0%)</option>
				
				<option value="file22">github.com/soda/multi-cloud/api/pkg/s3/datatype/httprange.go (0.0%)</option>
				
				<option value="file23">github.com/soda/multi-cloud/api/pkg/s3/handler-utils.go (0.0%)</option>
				
				<option value="file24">github.com/soda/multi-cloud/api/pkg/s3/listbuckets.go (0.0%)</option>
				
				<option value="file25">github.com/soda/multi-cloud/api/pkg/s3/listbucketuploadrecrds.go (0.0%)</option>
				
				<option value="file26">github.com/soda/multi-cloud/api/pkg/s3/listobjectparts.go (0.0%)</option>
				
				<option value="file27">github.com/soda/multi-cloud/api/pkg/s3/liststorageclasses.go (0.0%)</option>
				
				<option value="file28">github.com/soda/multi-cloud/api/pkg/s3/multipartuploadinit.go (0.0%)</option>
				
				<option value="file29">github.com/soda/multi-cloud/api/pkg/s3/object-handlers-common.go (0.0%)</option>
				
				<option value="file30">github.com/soda/multi-cloud/api/pkg/s3/object-utils.go (0.0%)</option>
				
				<option value="file31">github.com/soda/multi-cloud/api/pkg/s3/objectacl.go (0.0%)</option>
				
				<option value="file32">github.com/soda/multi-cloud/api/pkg/s3/objectcopy.go (0.0%)</option>
				
				<option value="file33">github.com/soda/multi-cloud/api/pkg/s3/objectdelete.go (0.0%)</option>
				
				<option value="file34">github.com/soda/multi-cloud/api/pkg/s3/objectget.go (0.0%)</option>
				
				<option value="file35">github.com/soda/multi-cloud/api/pkg/s3/objectpartcopy.go (0.0%)</option>
				
				<option value="file36">github.com/soda/multi-cloud/api/pkg/s3/objectpost.go (0.0%)</option>
				
				<option value="file37">github.com/soda/multi-cloud/api/pkg/s3/objectput.go (0.0%)</option>
				
				<option value="file38">github.com/soda/multi-cloud/api/pkg/s3/routbucketdelete.go (0.0%)</option>
				
				<option value="file39">github.com/soda/multi-cloud/api/pkg/s3/routbucketget.go (0.0%)</option>
				
				<option value="file40">github.com/soda/multi-cloud/api/pkg/s3/routbuckethead.go (0.0%)</option>
				
				<option value="file41">github.com/soda/multi-cloud/api/pkg/s3/routbucketput.go (0.0%)</option>
				
				<option value="file42">github.com/soda/multi-cloud/api/pkg/s3/routeobjectdelete.go (0.0%)</option>
				
				<option value="file43">github.com/soda/multi-cloud/api/pkg/s3/routeobjectget.go (0.0%)</option>
				
				<option value="file44">github.com/soda/multi-cloud/api/pkg/s3/routeobjecthead.go (0.0%)</option>
				
				<option value="file45">github.com/soda/multi-cloud/api/pkg/s3/routeobjectpost.go (0.0%)</option>
				
				<option value="file46">github.com/soda/multi-cloud/api/pkg/s3/routeobjectput.go (0.0%)</option>
				
				<option value="file47">github.com/soda/multi-cloud/api/pkg/s3/router.go (0.0%)</option>
				
				<option value="file48">github.com/soda/multi-cloud/api/pkg/s3/service.go (0.0%)</option>
				
				<option value="file49">github.com/soda/multi-cloud/api/pkg/s3/uploadpart.go (0.0%)</option>
				
				<option value="file50">github.com/soda/multi-cloud/api/pkg/s3/utils.go (25.7%)</option>
				
				<option value="file51">github.com/soda/multi-cloud/api/pkg/utils/obs/auth.go (0.0%)</option>
				
				<option value="file52">github.com/soda/multi-cloud/api/pkg/utils/obs/client.go (0.0%)</option>
				
				<option value="file53">github.com/soda/multi-cloud/api/pkg/utils/obs/conf.go (0.0%)</option>
				
				<option value="file54">github.com/soda/multi-cloud/api/pkg/utils/obs/convert.go (0.0%)</option>
				
				<option value="file55">github.com/soda/multi-cloud/api/pkg/utils/obs/error.go (0.0%)</option>
				
				<option value="file56">github.com/soda/multi-cloud/api/pkg/utils/obs/http.go (0.0%)</option>
				
				<option value="file57">github.com/soda/multi-cloud/api/pkg/utils/obs/log.go (87.1%)</option>
				
				<option value="file58">github.com/soda/multi-cloud/api/pkg/utils/obs/temporary.go (0.0%)</option>
				
				<option value="file59">github.com/soda/multi-cloud/api/pkg/utils/obs/trait.go (0.0%)</option>
				
				<option value="file60">github.com/soda/multi-cloud/api/pkg/utils/obs/util.go (0.0%)</option>
				
				<option value="file61">github.com/soda/multi-cloud/api/pkg/utils/utils.go (7.1%)</option>
				
				<option value="file62">github.com/soda/multi-cloud/backend/proto/backend.micro.go (15.7%)</option>
				
				<option value="file63">github.com/soda/multi-cloud/backend/proto/backend.pb.go (10.5%)</option>
				
				<option value="file64">github.com/soda/multi-cloud/s3/cmd/main.go (80.0%)</option>
				
				<option value="file65">github.com/soda/multi-cloud/s3/error/s3errors.go (30.8%)</option>
				
				<option value="file66">github.com/soda/multi-cloud/s3/pkg/datastore/aws/aws.go (31.2%)</option>
				
				<option value="file67">github.com/soda/multi-cloud/s3/pkg/datastore/aws/factory.go (92.3%)</option>
				
				<option value="file68">github.com/soda/multi-cloud/s3/pkg/datastore/azure/azure.go (0.0%)</option>
				
				<option value="file69">github.com/soda/multi-cloud/s3/pkg/datastore/azure/factory.go (10.0%)</option>
				
				<option value="file70">github.com/soda/multi-cloud/s3/pkg/datastore/ceph/ceph.go (0.0%)</option>
				
				<option value="file71">github.com/soda/multi-cloud/s3/pkg/datastore/ceph/factory.go (14.3%)</option>
				
				<option value="file72">github.com/soda/multi-cloud/s3/pkg/datastore/common/utils.go (25.0%)</option>
				
				<option value="file73">github.com/soda/multi-cloud/s3/pkg/datastore/driver/clean.go (100.0%)</option>
				
				<option value="file74">github.com/soda/multi-cloud/s3/pkg/datastore/driver/factory.go (75.0%)</option>
				
				<option value="file75">github.com/soda/multi-cloud/s3/pkg/datastore/huawei/factory.go (11.1%)</option>
				
				<option value="file76">github.com/soda/multi-cloud/s3/pkg/datastore/huawei/huawei.go (0.0%)</option>
				
				<option value="file77">github.com/soda/multi-cloud/s3/pkg/datastore/ibm/factory.go (100.0%)</option>
				
				<option value="file78">github.com/soda/multi-cloud/s3/pkg/datastore/yig/config/config.go (43.1%)</option>
				
				<option value="file79">github.com/soda/multi-cloud/s3/pkg/datastore/yig/config/enum.go (53.3%)</option>
				
				<option value="file80">github.com/soda/multi-cloud/s3/pkg/datastore/yig/config/watcher.go (0.0%)</option>
				
				<option value="file81">github.com/soda/multi-cloud/s3/pkg/datastore/yig/crypto/client.go (30.0%)</option>
				
				<option value="file82">github.com/soda/multi-cloud/s3/pkg/datastore/yig/crypto/error.go (0.0%)</option>
				
				<option value="file83">github.com/soda/multi-cloud/s3/pkg/datastore/yig/crypto/header.go (0.0%)</option>
				
				<option value="file84">github.com/soda/multi-cloud/s3/pkg/datastore/yig/crypto/key.go (0.0%)</option>
				
				<option value="file85">github.com/soda/multi-cloud/s3/pkg/datastore/yig/crypto/kms.go (0.0%)</option>
				
				<option value="file86">github.com/soda/multi-cloud/s3/pkg/datastore/yig/crypto/metadata.go (0.0%)</option>
				
				<option value="file87">github.com/soda/multi-cloud/s3/pkg/datastore/yig/crypto/sse.go (0.0%)</option>
				
				<option value="file88">github.com/soda/multi-cloud/s3/pkg/datastore/yig/crypto/vault.go (0.0%)</option>
				
				<option value="file89">github.com/soda/multi-cloud/s3/pkg/datastore/yig/factory.go (44.9%)</option>
				
				<option value="file90">github.com/soda/multi-cloud/s3/pkg/datastore/yig/log/log.go (0.0%)</option>
				
				<option value="file91">github.com/soda/multi-cloud/s3/pkg/datastore/yig/meta/cluster.go (0.0%)</option>
				
				<option value="file92">github.com/soda/multi-cloud/s3/pkg/datastore/yig/meta/db/driver/factory.go (81.8%)</option>
				
				<option value="file93">github.com/soda/multi-cloud/s3/pkg/datastore/yig/meta/db/tidb/cluster.go (0.0%)</option>
				
				<option value="file94">github.com/soda/multi-cloud/s3/pkg/datastore/yig/meta/db/tidb/db.go (0.0%)</option>
				
				<option value="file95">github.com/soda/multi-cloud/s3/pkg/datastore/yig/meta/db/tidb/driver.go (83.3%)</option>
				
				<option value="file96">github.com/soda/multi-cloud/s3/pkg/datastore/yig/meta/db/tidb/gc.go (0.0%)</option>
				
				<option value="file97">github.com/soda/multi-cloud/s3/pkg/datastore/yig/meta/db/tidb/multiparts.go (0.0%)</option>
				
				<option value="file98">github.com/soda/multi-cloud/s3/pkg/datastore/yig/meta/gc.go (0.0%)</option>
				
				<option value="file99">github.com/soda/multi-cloud/s3/pkg/datastore/yig/meta/meta.go (66.7%)</option>
				
				<option value="file100">github.com/soda/multi-cloud/s3/pkg/datastore/yig/meta/multipart.go (0.0%)</option>
				
				<option value="file101">github.com/soda/multi-cloud/s3/pkg/datastore/yig/meta/types/multiparts.go (0.0%)</option>
				
				<option value="file102">github.com/soda/multi-cloud/s3/pkg/datastore/yig/storage/ceph.go (0.0%)</option>
				
				<option value="file103">github.com/soda/multi-cloud/s3/pkg/datastore/yig/storage/gc.go (0.0%)</option>
				
				<option value="file104">github.com/soda/multi-cloud/s3/pkg/datastore/yig/storage/multipart.go (0.0%)</option>
				
				<option value="file105">github.com/soda/multi-cloud/s3/pkg/datastore/yig/storage/multipart_reader.go (0.0%)</option>
				
				<option value="file106">github.com/soda/multi-cloud/s3/pkg/datastore/yig/storage/object.go (0.0%)</option>
				
				<option value="file107">github.com/soda/multi-cloud/s3/pkg/datastore/yig/storage/storage.go (21.7%)</option>
				
				<option value="file108">github.com/soda/multi-cloud/s3/pkg/datastore/yig/utils/global_id.go (44.8%)</option>
				
				<option value="file109">github.com/soda/multi-cloud/s3/pkg/db/db.go (16.7%)</option>
				
				<option value="file110">github.com/soda/multi-cloud/s3/pkg/db/drivers/mongo/bucketdelete.go (0.0%)</option>
				
				<option value="file111">github.com/soda/multi-cloud/s3/pkg/db/drivers/mongo/bucketget.go (0.0%)</option>
				
				<option value="file112">github.com/soda/multi-cloud/s3/pkg/db/drivers/mongo/bucketput.go (0.0%)</option>
				
				<option value="file113">github.com/soda/multi-cloud/s3/pkg/db/drivers/mongo/listbuckets.go (0.0%)</option>
				
				<option value="file114">github.com/soda/multi-cloud/s3/pkg/db/drivers/mongo/listobjects.go (0.0%)</option>
				
				<option value="file115">github.com/soda/multi-cloud/s3/pkg/db/drivers/mongo/mongo.go (0.0%)</option>
				
				<option value="file116">github.com/soda/multi-cloud/s3/pkg/db/drivers/mongo/multipartuploadrecord.go (0.0%)</option>
				
				<option value="file117">github.com/soda/multi-cloud/s3/pkg/db/drivers/mongo/objectdelete.go (0.0%)</option>
				
				<option value="file118">github.com/soda/multi-cloud/s3/pkg/db/drivers/mongo/objectget.go (0.0%)</option>
				
				<option value="file119">github.com/soda/multi-cloud/s3/pkg/db/drivers/mongo/objectput.go (0.0%)</option>
				
				<option value="file120">github.com/soda/multi-cloud/s3/pkg/exception/exception.go (0.0%)</option>
				
				<option value="file121">github.com/soda/multi-cloud/s3/pkg/gc/gc.go (50.0%)</option>
				
				<option value="file122">github.com/soda/multi-cloud/s3/pkg/helper/config.go (95.3%)</option>
				
				<option value="file123">github.com/soda/multi-cloud/s3/pkg/helper/escape.go (0.0%)</option>
				
				<option value="file124">github.com/soda/multi-cloud/s3/pkg/helper/file.go (0.0%)</option>
				
				<option value="file125">github.com/soda/multi-cloud/s3/pkg/helper/functional.go (0.0%)</option>
				
				<option value="file126">github.com/soda/multi-cloud/s3/pkg/helper/helper.go (92.3%)</option>
				
				<option value="file127">github.com/soda/multi-cloud/s3/pkg/helper/http.go (0.0%)</option>
				
				<option value="file128">github.com/soda/multi-cloud/s3/pkg/helper/msgpack.go (0.0%)</option>
				
				<option value="file129">github.com/soda/multi-cloud/s3/pkg/helper/string.go (0.0%)</option>
				
				<option value="file130">github.com/soda/multi-cloud/s3/pkg/meta/bucket.go (14.9%)</option>
				
				<option value="file131">github.com/soda/multi-cloud/s3/pkg/meta/cache.go (9.1%)</option>
				
				<option value="file132">github.com/soda/multi-cloud/s3/pkg/meta/db/drivers/tidb/bucket.go (50.8%)</option>
				
				<option value="file133">github.com/soda/multi-cloud/s3/pkg/meta/db/drivers/tidb/client.go (38.2%)</option>
				
				<option value="file134">github.com/soda/multi-cloud/s3/pkg/meta/db/drivers/tidb/gc.go (20.4%)</option>
				
				<option value="file135">github.com/soda/multi-cloud/s3/pkg/meta/db/drivers/tidb/multipart.go (0.0%)</option>
				
				<option value="file136">github.com/soda/multi-cloud/s3/pkg/meta/db/drivers/tidb/object.go (40.2%)</option>
				
				<option value="file137">github.com/soda/multi-cloud/s3/pkg/meta/db/drivers/tidb/objmap.go (0.0%)</option>
				
				<option value="file138">github.com/soda/multi-cloud/s3/pkg/meta/db/drivers/tidb/transation.go (66.7%)</option>
				
				<option value="file139">github.com/soda/multi-cloud/s3/pkg/meta/gc.go (33.3%)</option>
				
				<option value="file140">github.com/soda/multi-cloud/s3/pkg/meta/meta.go (60.0%)</option>
				
				<option value="file141">github.com/soda/multi-cloud/s3/pkg/meta/multipart.go (0.0%)</option>
				
				<option value="file142">github.com/soda/multi-cloud/s3/pkg/meta/object.go (37.3%)</option>
				
				<option value="file143">github.com/soda/multi-cloud/s3/pkg/meta/redis/redis.go (0.0%)</option>
				
				<option value="file144">github.com/soda/multi-cloud/s3/pkg/meta/redis/redis_client.go (0.0%)</option>
				
				<option value="file145">github.com/soda/multi-cloud/s3/pkg/meta/types/bucket.go (19.6%)</option>
				
				<option value="file146">github.com/soda/multi-cloud/s3/pkg/meta/types/cluster.go (0.0%)</option>
				
				<option value="file147">github.com/soda/multi-cloud/s3/pkg/meta/types/gc.go (0.0%)</option>
				
				<option value="file148">github.com/soda/multi-cloud/s3/pkg/meta/types/multipart.go (0.0%)</option>
				
				<option value="file149">github.com/soda/multi-cloud/s3/pkg/meta/types/object-errors.go (0.0%)</option>
				
				<option value="file150">github.com/soda/multi-cloud/s3/pkg/meta/types/object.go (21.6%)</option>
				
				<option value="file151">github.com/soda/multi-cloud/s3/pkg/meta/types/objectmap.go (0.0%)</option>
				
				<option value="file152">github.com/soda/multi-cloud/s3/pkg/meta/types/simpleindex.go (0.0%)</option>
				
				<option value="file153">github.com/soda/multi-cloud/s3/pkg/meta/types/storage-class.go (0.0%)</option>
				
				<option value="file154">github.com/soda/multi-cloud/s3/pkg/meta/util/util.go (55.0%)</option>
				
				<option value="file155">github.com/soda/multi-cloud/s3/pkg/model/xmlstruct.go (0.0%)</option>
				
				<option value="file156">github.com/soda/multi-cloud/s3/pkg/service/bucket.go (28.2%)</option>
				
				<option value="file157">github.com/soda/multi-cloud/s3/pkg/service/multipart.go (0.0%)</option>
				
				<option value="file158">github.com/soda/multi-cloud/s3/pkg/service/object.go (27.2%)</option>
				
				<option value="file159">github.com/soda/multi-cloud/s3/pkg/service/service.go (57.5%)</option>
				
				<option value="file160">github.com/soda/multi-cloud/s3/pkg/utils/encryptionutils.go (62.2%)</option>
				
				<option value="file161">github.com/soda/multi-cloud/s3/pkg/utils/utils.go (50.0%)</option>
				
				<option value="file162">github.com/soda/multi-cloud/s3/proto/s3.pb.go (7.1%)</option>
				
				<option value="file163">github.com/soda/multi-cloud/s3/proto/s3.pb.micro.go (5.8%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package common

import (
        "context"
        "fmt"
        "strconv"
        "strings"

        "github.com/emicklei/go-restful"
        "github.com/micro/go-micro/metadata"
        c "github.com/soda/multi-cloud/api/pkg/context"
        log "github.com/sirupsen/logrus"
)

const (
        MaxPaginationLimit      = 1000
        DefaultPaginationLimit  = MaxPaginationLimit
        DefaultPaginationOffset = 0
        MaxObjectSize           = 5 * 1024 * 1024 * 1024 // 5GB
        SortDirectionAsc        = "asc"
        SortDirectionDesc       = "desc"
)

const (
        KLimit        = "limit"
        KOffset       = "offset"
        KSort         = "sort"
        KLastModified = "lastmodified"
        KObjKey       = "objkey"
        KStorageTier  = "tier"
        KPrefix       = "prefix"
        KMarker       = "marker"
        KDelimiter    = "delimiter"
        KVerMarker    = "verMarker"
)

const (
        CTX_KEY_TENANT_ID   = "Tenantid"
        CTX_KEY_USER_ID     = "Userid"
        CTX_KEY_IS_ADMIN    = "Isadmin"
        CTX_VAL_TRUE        = "true"
        CTX_KEY_OBJECT_KEY  = "ObjectKey"
        CTX_KEY_BUCKET_NAME = "BucketName"
        CTX_KEY_SIZE        = "ObjectSize"
        CTX_KEY_LOCATION    = "Location"
)

const (
        REQUEST_PATH_BUCKET_NAME         = "bucketName"
        REQUEST_PATH_OBJECT_KEY          = "objectKey"
        REQUEST_HEADER_CONTENT_LENGTH    = "Content-Length"
        REQUEST_HEADER_STORAGE_CLASS     = "x-amz-storage-class"
        REQUEST_HEADER_COPY_SOURCE       = "X-Amz-Copy-Source"
        REQUEST_HEADER_COPY_SOURCE_RANGE = "X-Amz-Copy-Source-Range"
        REQUEST_HEADER_ACL               = "X-Amz-Acl"
        REQUEST_HEADER_CONTENT_MD5       = "Content-Md5"
        REQUEST_HEADER_CONTENT_TYPE      = "Content-Type"
)

const (
        REQUEST_FORM_KEY    = "Key"
        REQUEST_FORM_BUCKET = "Bucket"
)

func GetPaginationParam(request *restful.Request) (int32, int32, error) <span class="cov0" title="0">{
        limit := int32(DefaultPaginationLimit)
        offset := int32(DefaultPaginationOffset)

        if request.QueryParameter(KLimit) != "" </span><span class="cov0" title="0">{
                limitVal, err := strconv.Atoi(request.QueryParameter("limit"))
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("limit is invalid: %v", err)
                        return limit, offset, err
                }</span>
                <span class="cov0" title="0">if limit &gt; int32(limitVal) </span><span class="cov0" title="0">{
                        limit = int32(limitVal)
                }</span>
        }

        <span class="cov0" title="0">if request.QueryParameter(KOffset) != "" </span><span class="cov0" title="0">{
                offsetVal, err := strconv.Atoi(request.QueryParameter("offset"))
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("offset is invalid: %v", err)
                        return limit, offset, err
                }</span>
                <span class="cov0" title="0">offset = int32(offsetVal)</span>
        }
        <span class="cov0" title="0">return limit, offset, nil</span>
}

// An example of sort key parameter will be like this: sort=key1:asc,key2:desc
func GetSortParam(request *restful.Request) (sortKeys []string, sortDirs []string, err error) <span class="cov0" title="0">{
        sortStr := request.QueryParameter(KSort)
        if sortStr != "" </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">sortStr = strings.TrimSpace(sortStr)
        for _, sort := range strings.Split(sortStr, ",") </span><span class="cov0" title="0">{
                parts := strings.Split(sort, ":")
                switch </span>{
                case len(parts) &gt; 2:<span class="cov0" title="0">
                        err = fmt.Errorf("invalid sort value %s", sort)
                        return</span>
                case len(parts) == 1:<span class="cov0" title="0">
                        parts = append(parts, SortDirectionAsc)</span>
                }
                <span class="cov0" title="0">sortKeys = append(sortKeys, parts[0])
                sortDirs = append(sortDirs, parts[1])</span>
        }
        <span class="cov0" title="0">return</span>
}

func GetFilter(request *restful.Request, filterOpts []string) (map[string]string, error) <span class="cov0" title="0">{

        filter := make(map[string]string)
        for _, opt := range filterOpts </span><span class="cov0" title="0">{
                v := request.QueryParameter(opt)
                if v == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">filter[opt] = v</span>
        }
        <span class="cov0" title="0">return filter, nil</span>
}

func InitCtxWithAuthInfo(request *restful.Request) context.Context <span class="cov0" title="0">{
        actx := request.Attribute(c.KContext).(*c.Context)
        ctx := metadata.NewContext(context.Background(), map[string]string{
                CTX_KEY_USER_ID:   actx.UserId,
                CTX_KEY_TENANT_ID: actx.TenantId,
                CTX_KEY_IS_ADMIN:  strconv.FormatBool(actx.IsAdmin),
        })

        return ctx
}</span>

func InitCtxWithVal(request *restful.Request, md map[string]string) context.Context <span class="cov0" title="0">{
        actx := request.Attribute(c.KContext).(*c.Context)
        md[CTX_KEY_USER_ID] = actx.UserId
        md[CTX_KEY_TENANT_ID] = actx.TenantId
        md[CTX_KEY_IS_ADMIN] = strconv.FormatBool(actx.IsAdmin)

        return metadata.NewContext(context.Background(), md)
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may
// not use this file except in compliance with the License. You may obtain
// a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations
// under the License.

// This is self defined context which is stored in context.Input.data.
// It is used to transport data in the pipe line.

package context

import (
        "encoding/json"
        "reflect"

        "github.com/emicklei/go-restful"
        log "github.com/sirupsen/logrus"
)

const (
        KContext = "context"
)

const (
        DefaultTenantId     = "tenantId"
        DefaultUserId       = "userId"
        NoAuthAdminTenantId = "adminTenantId"
)

func NewAdminContext() *Context <span class="cov0" title="0">{
        return &amp;Context{
                TenantId: NoAuthAdminTenantId,
                IsAdmin:  true,
                UserId:   "unknown",
        }
}</span>

func NewContext() *Context <span class="cov0" title="0">{
        return &amp;Context{
                TenantId: DefaultTenantId,
                IsAdmin:  false,
                UserId:   DefaultUserId,
        }
}</span>

func NewContextFromJson(s string) *Context <span class="cov0" title="0">{
        ctx := &amp;Context{}
        err := json.Unmarshal([]byte(s), ctx)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("Unmarshal json to context failed, reason: %v", err)
        }</span>
        <span class="cov0" title="0">return ctx</span>
}

func NewInternalTenantContext(tenantId, userId string, isAdmin bool) *Context <span class="cov0" title="0">{
        return &amp;Context{
                TenantId: tenantId,
                UserId:   userId,
                IsAdmin:  isAdmin,
        }
}</span>

func GetContext(req *restful.Request) *Context <span class="cov0" title="0">{
        ctx, _ := req.Attribute("context").(*Context)
        if ctx == nil </span><span class="cov0" title="0">{
                ctx = &amp;Context{}
        }</span>
        <span class="cov0" title="0">return ctx</span>
}

type Context struct {
        IsAdmin           bool     `policy:"true" json:"is_admin"`
        AuthToken         string   `policy:"true" json:"auth_token"`
        UserId            string   `policy:"true" json:"user_id"`
        TenantId          string   `policy:"true" json:"tenant_id"`
        DomainId          string   `policy:"true" json:"domain_id"`
        UserDomainId      string   `policy:"true" json:"user_domain_id"`
        ProjectDomainId   string   `policy:"true" json:"project_domain_id"`
        Roles             []string `policy:"true" json:"roles"`
        UserName          string   `policy:"true" json:"user_name"`
        ProjectName       string   `policy:"true" json:"project_name"`
        DomainName        string   `policy:"true" json:"domain_name"`
        UserDomainName    string   `policy:"true" json:"user_domain_name"`
        ProjectDomainName string   `policy:"true" json:"project_domain_name"`
        IsAdminTenant     bool     `policy:"true" json:"is_admin_tenant"`
}

func (ctx *Context) ToPolicyValue() map[string]interface{} <span class="cov0" title="0">{
        ctxMap := map[string]interface{}{}
        t := reflect.TypeOf(ctx).Elem()
        v := reflect.ValueOf(ctx).Elem()

        for i := 0; i &lt; t.NumField(); i++ </span><span class="cov0" title="0">{
                field := v.Field(i)
                name := t.Field(i).Tag.Get("json")
                if t.Field(i).Tag.Get("policy") == "false" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if field.Kind() == reflect.String &amp;&amp; field.String() == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if field.Kind() == reflect.Slice &amp;&amp; field.Len() == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if field.Kind() == reflect.Map &amp;&amp; field.Len() == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">ctxMap[name] = field.Interface()</span>
        }
        <span class="cov0" title="0">return ctxMap</span>
}

func (ctx *Context) ToJson() string <span class="cov0" title="0">{
        b, err := json.Marshal(ctx)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("Context convert to json failed, reason: %v", err)
        }</span>
        <span class="cov0" title="0">return string(b)</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*
This module implements the common data structure.

*/

package model

import (
        "encoding/json"
        "errors"
        "fmt"

        "github.com/emicklei/go-restful"
        log "github.com/sirupsen/logrus"
)

const (
        // ErrorBadRequest
        ErrorBadRequest = 400
        // ErrorUnauthorized
        ErrorUnauthorized = 401
        // ErrorForbidden
        ErrorForbidden = 403
        // ErrorNotFound
        ErrorNotFound = 404
        // ErrorInternalServer
        ErrorInternalServer = 500
        // ErrorNotImplemented
        ErrorNotImplemented = 501
)

// ErrorSpec describes Detailed HTTP error response, which consists of a HTTP
// status code, and a custom error message unique for each failure case.
type ErrorSpec struct {
        Code    int    `json:"code,omitempty"`
        Message string `json:"message,omitempty"`
}

// ErrorBadRequestStatus
func ErrorBadRequestStatus(message string) []byte <span class="cov0" title="0">{
        return errorStatus(ErrorBadRequest, message)
}</span>

// ErrorForbiddenStatus
func ErrorForbiddenStatus(message string) []byte <span class="cov0" title="0">{
        return errorStatus(ErrorForbidden, message)
}</span>

// ErrorUnauthorizedStatus
func ErrorUnauthorizedStatus(message string) []byte <span class="cov0" title="0">{
        return errorStatus(ErrorUnauthorized, message)
}</span>

// ErrorNotFoundStatus
func ErrorNotFoundStatus(message string) []byte <span class="cov0" title="0">{
        return errorStatus(ErrorNotFound, message)
}</span>

// ErrorInternalServerStatus
func ErrorInternalServerStatus(message string) []byte <span class="cov0" title="0">{
        return errorStatus(ErrorInternalServer, message)
}</span>

// ErrorNotImplementedStatus
func ErrorNotImplementedStatus(message string) []byte <span class="cov0" title="0">{
        return errorStatus(ErrorNotImplemented, message)
}</span>

func errorStatus(code int, message string) []byte <span class="cov0" title="0">{
        errStatus := &amp;ErrorSpec{
                Code:    code,
                Message: message,
        }

        // Mashal the error status.
        body, err := json.Marshal(errStatus)
        if err != nil </span><span class="cov0" title="0">{
                return []byte("Failed to mashal error response: " + err.Error())
        }</span>
        <span class="cov0" title="0">return body</span>
}

/*
func HttpError(ctx *context.Context, code int, format string, a ...interface{}) error {
        ctx.Output.SetStatus(code)
        msg := fmt.Sprintf(format, a...)
        ctx.Output.Body(errorStatus(code, msg))
        errInfo := fmt.Sprintf("Code:%d, Reason:%s", code, msg)
        log.Error(errInfo)
        return fmt.Errorf(errInfo)
}
*/

func HttpError(res *restful.Response, code int, format string, a ...interface{}) error <span class="cov0" title="0">{
        msg := fmt.Sprintf(format, a...)
        res.WriteError(code, errors.New(msg))
        errInfo := fmt.Sprintf("Code:%d, Reason:%s", code, msg)
        log.Error(errInfo)
        return fmt.Errorf(errInfo)
}</span>

// Volume group error
type NotImplementError struct {
        S string
}

func (e *NotImplementError) Error() string <span class="cov0" title="0">{
        return e.S
}</span>

type NotFoundError struct {
        S string
}

func NewNotFoundError(msg string) error <span class="cov0" title="0">{
        return &amp;NotFoundError{S: msg}
}</span>

func (e *NotFoundError) Error() string <span class="cov0" title="0">{
        return e.S
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may
// not use this file except in compliance with the License. You may obtain
// a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations
// under the License.

package policy

import (
        "fmt"
        "reflect"
        "regexp"
        "strings"

        log "github.com/sirupsen/logrus"
        "github.com/soda/multi-cloud/api/pkg/utils"
)

func init() <span class="cov8" title="1">{
        registerAll()
}</span>

type NewCheckFunc func(kind string, match string) BaseCheck

var registeredChecks map[string]NewCheckFunc

func register(name string, f NewCheckFunc) <span class="cov8" title="1">{
        registeredChecks[name] = f
}</span>

func registerAll() <span class="cov8" title="1">{
        if registeredChecks == nil </span><span class="cov8" title="1">{
                registeredChecks = make(map[string]NewCheckFunc)
        }</span>
        <span class="cov8" title="1">register("rule", NewRuleCheck)
        register("role", NewRoleCheck)
        register("generic", NewGenericCheck)</span>
}

type BaseCheck interface {
        String() string
        Exec(target map[string]string, cred map[string]interface{}, enforcer Enforcer, currentRule string) bool
}

func check(rule BaseCheck,
        target map[string]string,
        cred map[string]interface{},
        enforcer Enforcer,
        currentRule string) bool <span class="cov0" title="0">{
        ret := rule.Exec(target, cred, enforcer, currentRule)
        log.Infof("check rules:%s -- %v", rule, ret)
        return ret
}</span>

func NewFalseCheck() BaseCheck <span class="cov0" title="0">{
        return &amp;FalseCheck{}
}</span>

type FalseCheck struct{}

func (this *FalseCheck) String() string <span class="cov0" title="0">{
        return "!"
}</span>

func (this *FalseCheck) Exec(target map[string]string,
        cred map[string]interface{},
        enforcer Enforcer,
        currentRule string) bool <span class="cov0" title="0">{
        return false
}</span>

func NewTrueCheck() BaseCheck <span class="cov0" title="0">{
        return &amp;TrueCheck{}
}</span>

type TrueCheck struct {
        rule string
}

func (this *TrueCheck) String() string <span class="cov0" title="0">{
        return "@"
}</span>

func (this *TrueCheck) Exec(target map[string]string,
        cred map[string]interface{},
        enforcer Enforcer,
        currentRule string) bool <span class="cov0" title="0">{
        return true
}</span>

func NewNotCheck(check BaseCheck) *NotCheck <span class="cov0" title="0">{
        return &amp;NotCheck{check}
}</span>

type NotCheck struct {
        rule BaseCheck
}

func (this *NotCheck) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("not %s", this.rule)
}</span>

func (this *NotCheck) Exec(target map[string]string,
        cred map[string]interface{},
        enforcer Enforcer,
        currentRule string) bool <span class="cov0" title="0">{
        return !check(this.rule, target, cred, enforcer, currentRule)
}</span>

func NewAndCheck(check1 BaseCheck, check2 BaseCheck) *AndCheck <span class="cov8" title="1">{
        ac := &amp;AndCheck{}
        ac.AddCheck(check1)
        ac.AddCheck(check2)
        return ac
}</span>

type AndCheck struct {
        rules []BaseCheck
}

func (this *AndCheck) String() string <span class="cov0" title="0">{
        var r []string
        for _, rule := range this.rules </span><span class="cov0" title="0">{
                r = append(r, rule.String())
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("(%s)", strings.Join(r, " and "))</span>
}

func (this *AndCheck) Exec(target map[string]string,
        cred map[string]interface{},
        enforcer Enforcer,
        currentRule string) bool <span class="cov0" title="0">{
        for _, rule := range this.rules </span><span class="cov0" title="0">{
                if !check(rule, target, cred, enforcer, currentRule) </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov0" title="0">return true</span>
}

func (this *AndCheck) AddCheck(rule BaseCheck) *AndCheck <span class="cov8" title="1">{
        this.rules = append(this.rules, rule)
        return this
}</span>

func NewOrCheck(check1 BaseCheck, check2 BaseCheck) *OrCheck <span class="cov8" title="1">{
        oc := &amp;OrCheck{}
        oc.AddCheck(check1)
        oc.AddCheck(check2)
        return oc
}</span>

type OrCheck struct {
        rules []BaseCheck
}

func (this *OrCheck) String() string <span class="cov0" title="0">{
        var r []string
        for _, rule := range this.rules </span><span class="cov0" title="0">{
                r = append(r, rule.String())
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("(%s)", strings.Join(r, " or "))</span>
}

func (this *OrCheck) Exec(target map[string]string,
        cred map[string]interface{},
        enforcer Enforcer,
        currentRule string) bool <span class="cov0" title="0">{
        for _, rule := range this.rules </span><span class="cov0" title="0">{
                if check(rule, target, cred, enforcer, currentRule) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func (this *OrCheck) AddCheck(rule BaseCheck) *OrCheck <span class="cov8" title="1">{
        this.rules = append(this.rules, rule)
        return this
}</span>

func (this *OrCheck) PopCheck() (*OrCheck, BaseCheck) <span class="cov0" title="0">{
        x := this.rules[len(this.rules)-1]
        this.rules = this.rules[:len(this.rules)-1]
        return this, x
}</span>

func NewRuleCheck(kind string, match string) BaseCheck <span class="cov0" title="0">{
        return &amp;RuleCheck{kind, match}
}</span>

type RuleCheck struct {
        kind  string
        match string
}

func (this *RuleCheck) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("%s:%s", this.kind, this.match)
}</span>

func (this *RuleCheck) Exec(target map[string]string,
        cred map[string]interface{},
        enforcer Enforcer,
        currentRule string) bool <span class="cov0" title="0">{
        if len(enforcer.Rules) == 0 </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return check(enforcer.Rules[this.match], target, cred, enforcer, currentRule)</span>
}

func keyWorkFormatter(target map[string]string, match string) (string, error) <span class="cov0" title="0">{
        reg := regexp.MustCompile(`%([[:graph:]]+)s`)
        if ms := reg.FindAllString(match, -1); len(ms) == 1 </span><span class="cov0" title="0">{
                s := ms[0][2 : len(ms[0])-2]
                for key, val := range target </span><span class="cov0" title="0">{
                        if s == key </span><span class="cov0" title="0">{
                                return val, nil
                                break</span>
                        }
                }
                <span class="cov0" title="0">return "", fmt.Errorf("target key doesn`t match")</span>
        }
        <span class="cov0" title="0">return match, nil</span>
}

func NewRoleCheck(kind string, match string) BaseCheck <span class="cov8" title="1">{
        return &amp;RoleCheck{kind, match}
}</span>

type RoleCheck struct {
        kind  string
        match string
}

func (this *RoleCheck) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("%s:%s", this.kind, this.match)
}</span>

func (this *RoleCheck) Exec(target map[string]string,
        cred map[string]interface{},
        enforcer Enforcer,
        currentRule string) bool <span class="cov0" title="0">{
        match, err := keyWorkFormatter(target, this.match)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">if roles, ok := cred["roles"]; ok </span><span class="cov0" title="0">{
                for _, role := range roles.([]string) </span><span class="cov0" title="0">{
                        if strings.ToLower(match) == strings.ToLower(role) </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
        }
        <span class="cov0" title="0">return false</span>
}

func NewGenericCheck(kind string, match string) BaseCheck <span class="cov8" title="1">{
        return &amp;GenericCheck{kind, match}
}</span>

type GenericCheck struct {
        kind  string
        match string
}

func (this *GenericCheck) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("%s:%s", this.kind, this.match)
}</span>

func (this *GenericCheck) simpleLiteral(expr string) (string, error) <span class="cov0" title="0">{
        s := fmt.Sprintf("%c%c", expr[0], expr[len(expr)-1])
        if len(expr) &gt;= 2 &amp;&amp; (s == "\"\"" || s == "''") </span><span class="cov0" title="0">{
                return expr[1 : len(expr)-1], nil
        }</span>
        <span class="cov0" title="0">if utils.Contained(strings.ToLower(expr), []string{"true", "false"}) </span><span class="cov0" title="0">{
                return strings.ToLower(expr), nil
        }</span>
        <span class="cov0" title="0">return "", fmt.Errorf("Not support right now")</span>
}

func (this *GenericCheck) findInMap(testVal interface{}, pathSegs []string, match string) bool <span class="cov0" title="0">{
        if len(pathSegs) == 0 </span><span class="cov0" title="0">{
                switch testVal.(type) </span>{
                case string:<span class="cov0" title="0">
                        return strings.ToLower(match) == strings.ToLower(testVal.(string))</span>
                case bool:<span class="cov0" title="0">
                        return strings.ToLower(match) == fmt.Sprint(testVal.(bool))</span>
                default:<span class="cov0" title="0">
                        return false</span>
                }
        }
        <span class="cov0" title="0">key, pathSegs := pathSegs[0], pathSegs[1:]
        if val, ok := testVal.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                testVal = val[key]
        }</span> else<span class="cov0" title="0"> {
                return false
        }</span>
        <span class="cov0" title="0">if testVal == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">if reflect.TypeOf(testVal).Kind() == reflect.Slice </span><span class="cov0" title="0">{
                if vList, ok := testVal.([]interface{}); ok </span><span class="cov0" title="0">{
                        for _, val := range vList </span><span class="cov0" title="0">{
                                if this.findInMap(val, pathSegs, match) </span><span class="cov0" title="0">{
                                        return true
                                }</span>
                        }
                } else<span class="cov0" title="0"> {
                        for _, val := range testVal.([]string) </span><span class="cov0" title="0">{
                                if this.findInMap(val, pathSegs, match) </span><span class="cov0" title="0">{
                                        return true
                                }</span>
                        }
                }
                <span class="cov0" title="0">return false</span>
        } else<span class="cov0" title="0"> {
                return this.findInMap(testVal, pathSegs, match)
        }</span>
}

func (this *GenericCheck) Exec(target map[string]string,
        cred map[string]interface{},
        enforcer Enforcer,
        currentRule string) bool <span class="cov0" title="0">{
        match, err := keyWorkFormatter(target, strings.ToLower(this.match))
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">if test_value, err := this.simpleLiteral(this.kind); err == nil </span><span class="cov0" title="0">{
                return strings.ToLower(match) == test_value
        }</span>
        <span class="cov0" title="0">if len(cred) == 0 </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return this.findInMap(cred, strings.Split(this.kind, "."), match)</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may
// not use this file except in compliance with the License. You may obtain
// a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations
// under the License.

package policy

import (
        "fmt"
        "strings"

        "github.com/soda/multi-cloud/api/pkg/utils"
)

type TokenPair struct {
        token string
        value interface{}
}

func parseCheck(rule string) BaseCheck <span class="cov8" title="1">{
        if rule == "!" </span><span class="cov0" title="0">{
                return &amp;FalseCheck{}
        }</span> else<span class="cov8" title="1"> if rule == "@" </span><span class="cov0" title="0">{
                return &amp;TrueCheck{}
        }</span>
        <span class="cov8" title="1">items := strings.SplitN(rule, ":", 2)
        if len(items) != 2 </span><span class="cov0" title="0">{
                return &amp;FalseCheck{}
        }</span>
        <span class="cov8" title="1">kind, match := items[0], items[1]
        if check, ok := registeredChecks[kind]; ok </span><span class="cov8" title="1">{
                return check(kind, match)
        }</span> else<span class="cov8" title="1"> if check, ok := registeredChecks["generic"]; ok </span><span class="cov8" title="1">{
                return check(kind, match)
        }</span> else<span class="cov0" title="0"> {
                return &amp;FalseCheck{}
        }</span>
}

func parseTokenize(rule string) []TokenPair <span class="cov8" title="1">{
        var tokPairs []TokenPair
        for _, tok := range strings.Fields(rule) </span><span class="cov8" title="1">{
                if tok == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">clean := strings.TrimLeft(tok, "(")
                for i := 0; i &lt; len(tok)-len(clean); i++ </span><span class="cov8" title="1">{
                        tokPairs = append(tokPairs, TokenPair{"(", "("})
                }</span>

                // If it was only parentheses, continue
                <span class="cov8" title="1">if clean == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">tok = clean
                // Handle trailing parens on the token
                clean = strings.TrimRight(tok, ")")
                trail := len(tok) - len(clean)
                lowered := strings.ToLower(clean)

                if utils.Contained(lowered, []string{"and", "or", "not"}) </span><span class="cov8" title="1">{
                        tokPairs = append(tokPairs, TokenPair{lowered, clean})
                }</span> else<span class="cov8" title="1"> if clean != "" </span><span class="cov8" title="1">{
                        s := fmt.Sprintf("%c%c", tok[0], tok[len(tok)-1])
                        if len(tok) &gt;= 2 &amp;&amp; (s == "\"\"" || s == "''") </span><span class="cov0" title="0">{
                                tokPairs = append(tokPairs, TokenPair{"string", tok[1 : len(tok)-1]})
                        }</span> else<span class="cov8" title="1"> {
                                tokPairs = append(tokPairs, TokenPair{"check", parseCheck(clean)})
                        }</span>
                }

                <span class="cov8" title="1">for i := 0; i &lt; trail; i++ </span><span class="cov8" title="1">{
                        tokPairs = append(tokPairs, TokenPair{")", ")"})
                }</span>
        }

        <span class="cov8" title="1">return tokPairs</span>
}

func parseRule(rule string) BaseCheck <span class="cov8" title="1">{
        if rule == "" </span><span class="cov8" title="1">{
                return &amp;TrueCheck{}
        }</span>
        <span class="cov8" title="1">state := NewParseState()
        tokPairs := parseTokenize(rule)
        for _, tp := range tokPairs </span><span class="cov8" title="1">{
                state.Shift(tp.token, tp.value)
        }</span>
        <span class="cov8" title="1">if result, err := state.Result(); err == nil </span><span class="cov8" title="1">{
                return result.(BaseCheck)
        }</span>
        <span class="cov0" title="0">return &amp;FalseCheck{}</span>
}

var ReduceFuncMap = map[string]ReduceFunc{
        "(,check,)":          wrapCheck,
        "(,and_expr,)":       wrapCheck,
        "(,or_expr,)":        wrapCheck,
        "check,and,check":    makeAndExpr,
        "or_expr,and,check":  mixOrAndExpr,
        "and_expr,and,check": extendAndExpr,
        "check,or,check":     makeOrExpr,
        "and_expr,or,check":  makeOrExpr,
        "or_expr,or,check":   extendOrExpr,
        "not,check":          makeNotExpr,
}

func NewParseState() *ParseState <span class="cov8" title="1">{
        return &amp;ParseState{}
}</span>

type ParseState struct {
        tokens []string
        values []interface{}
}

type ReduceFunc func(args ...interface{}) []TokenPair

func (p *ParseState) reduce() <span class="cov8" title="1">{
        tokenStr := strings.Join(p.tokens, ",")
        for key, fun := range ReduceFuncMap </span><span class="cov8" title="1">{
                if strings.HasSuffix(tokenStr, key) </span><span class="cov8" title="1">{
                        argNum := strings.Count(key, ",") + 1
                        argIdx := len(p.values) - argNum
                        args := p.values[argIdx:]
                        results := fun(args...)
                        p.tokens = append(p.tokens[:argIdx], results[0].token)
                        p.values = append(p.values[:argIdx], results[0].value)
                        p.reduce()
                }</span>
        }
}

func (p *ParseState) Shift(tok string, val interface{}) <span class="cov8" title="1">{
        p.tokens = append(p.tokens, tok)
        p.values = append(p.values, val)
        p.reduce()
}</span>

func (p *ParseState) Result() (interface{}, error) <span class="cov8" title="1">{
        if len(p.values) != 1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Could not parse rule")
        }</span>
        <span class="cov8" title="1">return p.values[0], nil</span>
}

func wrapCheck(args ...interface{}) []TokenPair <span class="cov8" title="1">{
        check := args[1].(BaseCheck)
        return []TokenPair{{"check", check}}
}</span>

func makeAndExpr(args ...interface{}) []TokenPair <span class="cov8" title="1">{
        check1 := args[0].(BaseCheck)
        check2 := args[2].(BaseCheck)
        return []TokenPair{{"and_expr", NewAndCheck(check1, check2)}}
}</span>

func mixOrAndExpr(args ...interface{}) []TokenPair <span class="cov0" title="0">{
        orExpr := args[0].(*OrCheck)
        check := args[2].(BaseCheck)
        var andExpr *AndCheck
        orExpr, check1 := orExpr.PopCheck()
        if v, ok := check1.(*AndCheck); ok </span><span class="cov0" title="0">{
                andExpr = v
                andExpr.AddCheck(check)
        }</span> else<span class="cov0" title="0"> {
                andExpr = NewAndCheck(check1, check)
        }</span>
        <span class="cov0" title="0">return []TokenPair{{"or_expr", orExpr.AddCheck(andExpr)}}</span>
}

func extendAndExpr(args ...interface{}) []TokenPair <span class="cov0" title="0">{
        andExpr := args[0].(*AndCheck)
        check2 := args[2].(BaseCheck)
        return []TokenPair{{"and_expr", andExpr.AddCheck(check2)}}
}</span>

func makeOrExpr(args ...interface{}) []TokenPair <span class="cov8" title="1">{
        check1 := args[0].(BaseCheck)
        check2 := args[2].(BaseCheck)
        return []TokenPair{{"or_expr", NewOrCheck(check1, check2)}}
}</span>

func extendOrExpr(args ...interface{}) []TokenPair <span class="cov8" title="1">{
        orExpr := args[0].(*OrCheck)
        check := args[2].(BaseCheck)
        return []TokenPair{{"or_expr", orExpr.AddCheck(check)}}
}</span>

func makeNotExpr(args ...interface{}) []TokenPair <span class="cov0" title="0">{
        return []TokenPair{{"check", NewNotCheck(args[1].(BaseCheck))}}
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may
// not use this file except in compliance with the License. You may obtain
// a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations
// under the License.

package policy

import (
        "encoding/json"
        "fmt"
        "io/ioutil"
        "net/http"
        "os"
        "strings"

        "github.com/emicklei/go-restful"
        log "github.com/sirupsen/logrus"
        "github.com/soda/multi-cloud/api/pkg/context"
        "github.com/soda/multi-cloud/api/pkg/model"
        "github.com/soda/multi-cloud/api/pkg/utils"
        "github.com/soda/multi-cloud/api/pkg/utils/constants"
)

var enforcer *Enforcer

func init() <span class="cov8" title="1">{
        enforcer = NewEnforcer(false)
        RegisterRules(enforcer)
        enforcer.LoadRules(false)
}</span>

type DefaultRule struct {
        Name     string
        CheckStr string
}

func listRules() []DefaultRule <span class="cov8" title="1">{
        return []DefaultRule{
                {Name: "context_is_admin", CheckStr: "role:admin"},
        }
}</span>

func RegisterRules(e *Enforcer) <span class="cov8" title="1">{
        e.RegisterDefaults(listRules())
}</span>

func NewEnforcer(overWrite bool) *Enforcer <span class="cov8" title="1">{
        return &amp;Enforcer{OverWrite: overWrite}
}</span>

type Enforcer struct {
        Rules        map[string]BaseCheck
        DefaultRules []DefaultRule
        OverWrite    bool
}

func (e *Enforcer) RegisterDefaults(rules []DefaultRule) <span class="cov8" title="1">{
        e.DefaultRules = rules
}</span>

func (e *Enforcer) Enforce(rule string, target map[string]string, cred map[string]interface{}) (bool, error) <span class="cov0" title="0">{
        if err := e.LoadRules(false); err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">toRule, ok := e.Rules[rule]
        if !ok </span><span class="cov0" title="0">{
                err := fmt.Errorf("rule [%s] does not exist", rule)
                return false, err
        }</span>
        <span class="cov0" title="0">return check(toRule, target, cred, *e, ""), nil</span>
}

func (e *Enforcer) Authorize(rule string, target map[string]string, cred map[string]interface{}) (bool, error) <span class="cov0" title="0">{
        return e.Enforce(rule, target, cred)
}</span>

func (e *Enforcer) LoadRules(forcedReload bool) error <span class="cov8" title="1">{
        path := os.Getenv("POLICY_PATH")
        if path == "" </span><span class="cov8" title="1">{
                path = constants.DefaultPolicyPath
        }</span>

        <span class="cov8" title="1">fileInfo, err := os.Stat(path)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // Load all policy files that in the specified path
        <span class="cov8" title="1">if fileInfo.IsDir() </span><span class="cov0" title="0">{
                files, err := ioutil.ReadDir(path)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">for _, f := range files </span><span class="cov0" title="0">{
                        if !f.IsDir() &amp;&amp; strings.HasSuffix(f.Name(), ".json") </span><span class="cov0" title="0">{
                                err := e.LoadPolicyFile(path, forcedReload, false)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                }
                <span class="cov0" title="0">return nil</span>
        } else<span class="cov8" title="1"> {
                return e.LoadPolicyFile(path, forcedReload, e.OverWrite)
        }</span>

}

func (e *Enforcer) UpdateRules(rules map[string]BaseCheck) <span class="cov8" title="1">{
        if e.Rules == nil </span><span class="cov8" title="1">{
                e.Rules = make(map[string]BaseCheck)
        }</span>
        <span class="cov8" title="1">for k, c := range rules </span><span class="cov8" title="1">{
                e.Rules[k] = c
        }</span>
}

func (e *Enforcer) LoadPolicyFile(path string, forcedReload bool, overWrite bool) error <span class="cov8" title="1">{
        // if rules is already set or user doesn't want to force reload, return it.
        if e.Rules != nil &amp;&amp; !forcedReload </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">data, err := ioutil.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                msg := fmt.Sprintf("read policy file (%s) failed, reason:(%v)", path, err)
                log.Infof(msg)
                return fmt.Errorf(msg)
        }</span>
        <span class="cov8" title="1">r, err := NewRules(data, e.DefaultRules)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if overWrite </span><span class="cov0" title="0">{
                e.Rules = r.Rules
        }</span> else<span class="cov8" title="1"> {
                e.UpdateRules(r.Rules)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func NewRules(data []byte, defaultRule []DefaultRule) (*Rules, error) <span class="cov8" title="1">{
        r := &amp;Rules{}
        err := r.Load(data, defaultRule)
        return r, err
}</span>

type Rules struct {
        Rules map[string]BaseCheck
}

func (r *Rules) Load(data []byte, defaultRules []DefaultRule) error <span class="cov8" title="1">{
        rulesMap := map[string]string{}
        err := json.Unmarshal(data, &amp;rulesMap)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf(err.Error())
                return err
        }</span>
        // add default value
        <span class="cov8" title="1">for _, r := range defaultRules </span><span class="cov8" title="1">{
                if v, ok := rulesMap[r.Name]; ok </span><span class="cov0" title="0">{
                        log.Errorf("policy rule (%s:%s) has conflict with default rule(%s:%s),abandon default value\n",
                                r.Name, v, r.Name, r.CheckStr)
                }</span> else<span class="cov8" title="1"> {
                        rulesMap[r.Name] = r.CheckStr
                }</span>
        }

        <span class="cov8" title="1">if r.Rules == nil </span><span class="cov8" title="1">{
                r.Rules = make(map[string]BaseCheck)
        }</span>
        <span class="cov8" title="1">for k, v := range rulesMap </span><span class="cov8" title="1">{
                r.Rules[k] = parseRule(v)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (r *Rules) String() string <span class="cov0" title="0">{
        b, _ := json.MarshalIndent(r.Rules, "", "  ")
        return string(b)
}</span>

func Authorize(req *restful.Request, res *restful.Response, action string) bool <span class="cov0" title="0">{
        if os.Getenv("OS_AUTH_AUTHSTRATEGY") != "keystone" </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">ctx := context.GetContext(req)
        credentials := ctx.ToPolicyValue()
        //TenantId := httpCtx.Input.Param(":tenantId")
        TenantId := req.PathParameter("tenantId")
        target := map[string]string{
                "tenant_id": TenantId,
        }
        log.Infof("Action: %v", action)
        log.Infof("Target: %v", target)
        log.Infof("policy-Credentials: %v", credentials)
        ok, err := enforcer.Authorize(action, target, credentials)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("authorize failed, %s", err)
        }</span>
        <span class="cov0" title="0">if !ok </span><span class="cov0" title="0">{
                model.HttpError(res, http.StatusForbidden, "Operation is not permitted")
        }</span> else<span class="cov0" title="0"> {
                ctx.IsAdmin = utils.Contained("admin", ctx.Roles)
        }</span>
        <span class="cov0" title="0">return ok</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package s3

import (
        "github.com/emicklei/go-restful"
        "github.com/soda/multi-cloud/api/pkg/common"
        pb "github.com/soda/multi-cloud/s3/proto"
        log "github.com/sirupsen/logrus"
)

func (s *APIService) AbortMultipartUpload(request *restful.Request, response *restful.Response) <span class="cov0" title="0">{
        bucketName := request.PathParameter("bucketName")
        objectKey := request.PathParameter("objectKey")
        uploadId := request.QueryParameter("uploadId")

        multipartUpload := pb.MultipartUpload{}
        multipartUpload.Key = objectKey
        multipartUpload.Bucket = bucketName
        multipartUpload.UploadId = uploadId

        ctx := common.InitCtxWithAuthInfo(request)
        result, err := s.s3Client.AbortMultipartUpload(ctx, &amp;pb.AbortMultipartRequest{BucketName:bucketName,ObjectKey:objectKey,UploadId:uploadId})
        if HandleS3Error(response, request, err, result.GetErrorCode()) != nil </span><span class="cov0" title="0">{
                log.Errorf("unable to abort multipart. err:%v, errCode:%v", err, result.ErrorCode)
                return
        }</span>

        <span class="cov0" title="0">WriteSuccessNoContent(response)
        log.Infof("Abort multipart upload[bucketName=%s, objectKey=%s, uploadId=%s] successfully.\n",
                bucketName, objectKey, uploadId)</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package s3

import (
        "net/http"

        "github.com/emicklei/go-restful"
        "github.com/soda/multi-cloud/api/pkg/common"
        . "github.com/soda/multi-cloud/api/pkg/s3/datatype"
)

func getAclFromHeader(request *restful.Request) (acl Acl, err error) <span class="cov0" title="0">{
        acl.CannedAcl = request.HeaderParameter(common.REQUEST_HEADER_ACL)
        if acl.CannedAcl == "" </span><span class="cov0" title="0">{
                acl.CannedAcl = "private"
        }</span>
        <span class="cov0" title="0">err = IsValidCannedAcl(acl)
        return</span>
}

func getAclFromFormValues(formValues map[string]string) (acl Acl, err error) <span class="cov0" title="0">{
        headerfiedFormValues := make(http.Header)
        for key := range formValues </span><span class="cov0" title="0">{
                headerfiedFormValues.Add(key, formValues[key])
        }</span>
        <span class="cov0" title="0">acl.CannedAcl = headerfiedFormValues.Get("acl")
        if acl.CannedAcl == "" </span><span class="cov0" title="0">{
                acl.CannedAcl = "private"
        }</span>
        <span class="cov0" title="0">err = IsValidCannedAcl(acl)
        return</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">/*
 * Minio Cloud Storage, (C) 2015 Minio, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package s3

import (
        "bytes"
        "encoding/xml"
        "net/http"
        "strconv"
        "time"

        "github.com/emicklei/go-restful"
        . "github.com/soda/multi-cloud/api/pkg/s3/datatype"
        "github.com/soda/multi-cloud/s3/pkg/meta/types"
        pb "github.com/soda/multi-cloud/s3/proto"
)

// Refer: https://docs.aws.amazon.com/AmazonS3/latest/API/RESTCommonResponseHeaders.html
var CommonS3ResponseHeaders = []string{"Content-Length", "Content-Type", "Connection", "Date", "ETag", "Server",
        "x-amz-delete-marker", "x-amz-id-2", "x-amz-request-id", "x-amz-version-id"}

// Encodes the response headers into XML format.
func EncodeResponse(response interface{}) []byte <span class="cov0" title="0">{
        var bytesBuffer bytes.Buffer
        bytesBuffer.WriteString(xml.Header)
        e := xml.NewEncoder(&amp;bytesBuffer)
        e.Encode(response)
        return bytesBuffer.Bytes()
}</span>

// Write object header
func SetObjectHeaders(response *restful.Response, object *pb.Object, contentRange *HttpRange) <span class="cov0" title="0">{
        // set object-related metadata headers
        w := response.ResponseWriter
        lastModified := time.Unix(object.LastModified, 0).UTC().Format(http.TimeFormat)
        response.ResponseWriter.Header().Set("Last-Modified", lastModified)

        w.Header().Set("Content-Type", object.ContentType)
        if object.Etag != "" </span><span class="cov0" title="0">{
                w.Header()["ETag"] = []string{"\"" + object.Etag + "\""}
        }</span>

        <span class="cov0" title="0">for key, val := range object.CustomAttributes </span><span class="cov0" title="0">{
                w.Header().Set(key, val)
        }</span>
        //default cache-control is no-store
        <span class="cov0" title="0">if _, ok := object.CustomAttributes["Cache-Control"]; !ok </span><span class="cov0" title="0">{
                w.Header().Set("Cache-Control", "no-store")
        }</span>

        <span class="cov0" title="0">w.Header().Set("X-Amz-Object-Type", (&amp;types.Object{Object: object}).ObjectTypeToString())
        w.Header().Set("X-Amz-Storage-Class", object.StorageClass)
        w.Header().Set("Content-Length", strconv.FormatInt(object.Size, 10))

        // for providing ranged content
        if contentRange != nil &amp;&amp; contentRange.OffsetBegin &gt; -1 </span><span class="cov0" title="0">{
                // Override content-length
                w.Header().Set("Content-Length", strconv.FormatInt(contentRange.GetLength(), 10))
                w.Header().Set("Content-Range", contentRange.String())
                w.WriteHeader(http.StatusPartialContent)
        }</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">/*
 * Minio Cloud Storage, (C) 2015, 2016 Minio, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package s3

import (
        "encoding/xml"
        "net/http"
        "net/url"
        "path"
        "strconv"
        "time"

        "github.com/emicklei/go-restful"
        . "github.com/soda/multi-cloud/api/pkg/s3/datatype"
        . "github.com/soda/multi-cloud/s3/error"
        "github.com/soda/multi-cloud/s3/pkg/helper"
        log "github.com/sirupsen/logrus"
)

const (
        timeFormatAMZ = "2006-01-02T15:04:05.000Z" // Reply date format
)

func GetFinalError(err error, errorCode int32) error <span class="cov0" title="0">{
        if errorCode != int32(ErrNoErr) </span><span class="cov0" title="0">{
                return S3ErrorCode(errorCode)
        }</span> else<span class="cov0" title="0"> {
                return err
        }</span>
}

// WriteSuccessResponse write success headers and response if any.
func WriteSuccessResponse(response *restful.Response, data []byte) <span class="cov0" title="0">{
        if data == nil </span><span class="cov0" title="0">{
                response.WriteHeader(http.StatusOK)
                return
        }</span>

        <span class="cov0" title="0">response.AddHeader("Content-Length", strconv.Itoa(len(data)))
        response.WriteHeader(http.StatusOK)
        response.Write(data)
        response.Flush()</span>
}

// writeErrorResponse write error headers
// w http.ResponseWriter, r *http.Request
func WriteErrorResponse(response *restful.Response, request *restful.Request, err error) <span class="cov0" title="0">{
        WriteErrorResponseHeaders(response, err)
        WriteErrorResponseNoHeader(response, request, err, request.Request.URL.Path)
}</span>

func WriteErrorResponseWithResource(response *restful.Response, request *restful.Request, err error, resource string) <span class="cov0" title="0">{
        WriteErrorResponseHeaders(response, err)
        WriteErrorResponseNoHeader(response, request, err, resource)
}</span>

func WriteErrorResponseHeaders(response *restful.Response, err error) <span class="cov0" title="0">{
        var status int
        apiErrorCode, ok := err.(S3Error)
        if ok </span><span class="cov0" title="0">{
                status = apiErrorCode.HttpStatusCode()
        }</span> else<span class="cov0" title="0"> {
                status = http.StatusInternalServerError
        }</span>

        <span class="cov0" title="0">response.WriteHeader(status)</span>
}

func WriteErrorResponseNoHeader(response *restful.Response, request *restful.Request, err error, resource string) <span class="cov0" title="0">{
        // HEAD should have no body, do not attempt to write to it
        if request.Request.Method == "HEAD" </span><span class="cov0" title="0">{
                return
        }</span>

        // Generate error response.
        <span class="cov0" title="0">errorResponse := ApiErrorResponse{}
        apiErrorCode, ok := err.(S3Error)
        if ok </span><span class="cov0" title="0">{
                errorResponse.AwsErrorCode = apiErrorCode.AwsErrorCode()
                errorResponse.Message = apiErrorCode.Description()
        }</span> else<span class="cov0" title="0"> {
                errorResponse.AwsErrorCode = "InternalError"
                errorResponse.Message = "We encountered an internal error, please try again."
        }</span>
        <span class="cov0" title="0">errorResponse.Resource = resource
        errorResponse.HostId = helper.CONFIG.InstanceId

        encodedErrorResponse := EncodeResponse(errorResponse)

        response.Write(encodedErrorResponse)
        response.ResponseWriter.(http.Flusher).Flush()</span>
}

// getLocation get URL location.
func GetLocation(r *http.Request) string <span class="cov0" title="0">{
        return path.Clean(r.URL.Path) // Clean any trailing slashes.
}</span>

// writeSuccessNoContent write success headers with http status 204
func WriteSuccessNoContent(response *restful.Response) <span class="cov0" title="0">{
        response.ResponseWriter.WriteHeader(http.StatusNoContent)
}</span>

func WriteApiErrorResponse(response *restful.Response, request *restful.Request, status int, awsErrCode, message string) <span class="cov0" title="0">{
        // write header
        response.WriteHeader(status)

        // HEAD should have no body, do not attempt to write to it
        if request.Request.Method == "HEAD" </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">errorResponse := ApiErrorResponse{}
        errorResponse.AwsErrorCode = awsErrCode
        errorResponse.Message = message
        errorResponse.Resource = request.Request.URL.Path
        errorResponse.HostId = helper.CONFIG.InstanceId

        encodedErrorResponse := EncodeResponse(errorResponse)

        response.Write(encodedErrorResponse)
        response.ResponseWriter.(http.Flusher).Flush()</span>
}

// GenerateCopyObjectResponse
func GenerateCopyObjectResponse(etag string, lastModified time.Time) CopyObjectResponse <span class="cov0" title="0">{
        return CopyObjectResponse{
                ETag:         "\"" + etag + "\"",
                LastModified: lastModified.UTC().Format(timeFormatAMZ),
        }
}</span>

func GenerateCopyObjectPartResponse(etag string, lastModified int64) CopyObjectPartResponse <span class="cov0" title="0">{
        return CopyObjectPartResponse{
                LastModified: time.Unix(lastModified, 0).UTC().Format(timeFormatAMZ),
                ETag:         "\"" + etag + "\"",
        }
}</span>

// GenerateInitiateMultipartUploadResponse
func GenerateInitiateMultipartUploadResponse(bucket, key, uploadID string) InitiateMultipartUploadResponse <span class="cov0" title="0">{
        return InitiateMultipartUploadResponse{
                Bucket:   bucket,
                Key:      key,
                UploadID: uploadID,
        }
}</span>

// GenerateCompleteMultipartUploadResponse
func GenerateCompleteMultipartUploadResponse(bucket, key, location, etag string) CompleteMultipartUploadResponse <span class="cov0" title="0">{
        return CompleteMultipartUploadResponse{
                Location: location,
                Bucket:   bucket,
                Key:      key,
                ETag:     etag,
        }
}</span>

// APIErrorResponse - error response format
type ApiErrorResponse struct {
        XMLName      xml.Name `xml:"Error" json:"-"`
        AwsErrorCode string   `xml:"Code"`
        Message      string
        Key          string
        BucketName   string
        Resource     string
        RequestId    string
        HostId       string
}

// Parse bucket url queries for ?uploads
func parseListUploadsQuery(query url.Values) (request ListUploadsRequest, err error) <span class="cov0" title="0">{
        request.Delimiter = query.Get("delimiter")
        request.EncodingType = query.Get("encoding-type")
        if query.Get("max-uploads") == "" </span><span class="cov0" title="0">{
                request.MaxUploads = MaxUploadsList
        }</span> else<span class="cov0" title="0"> {
                request.MaxUploads, err = strconv.Atoi(query.Get("max-uploads"))
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">if request.MaxUploads &gt; MaxUploadsList || request.MaxUploads &lt; 1 </span><span class="cov0" title="0">{
                        err = ErrInvalidMaxUploads
                        return
                }</span>
        }
        <span class="cov0" title="0">request.KeyMarker = query.Get("key-marker")
        request.Prefix = query.Get("prefix")
        request.UploadIdMarker = query.Get("upload-id-marker")
        return</span>
}

// Parse object url queries
func parseListObjectPartsQuery(query url.Values) (request ListPartsRequest, err error) <span class="cov0" title="0">{
        request.EncodingType = query.Get("encoding-type")
        request.UploadId = query.Get("uploadId")
        if request.UploadId == "" </span><span class="cov0" title="0">{
                err = ErrNoSuchUpload
                return
        }</span>
        <span class="cov0" title="0">if query.Get("max-parts") == "" </span><span class="cov0" title="0">{
                request.MaxParts = MaxPartsList
        }</span> else<span class="cov0" title="0"> {
                request.MaxParts, err = strconv.Atoi(query.Get("max-parts"))
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorln("failed to convert from string to integer. err:", err)
                        return
                }</span>
                <span class="cov0" title="0">if request.MaxParts &gt; MaxPartsList || request.MaxParts &lt; 1 </span><span class="cov0" title="0">{
                        err = ErrInvalidMaxParts
                        return
                }</span>
        }
        <span class="cov0" title="0">if query.Get("part-number-marker") != "" </span><span class="cov0" title="0">{
                request.PartNumberMarker, err = strconv.Atoi(query.Get("part-number-marker"))
                if err != nil </span><span class="cov0" title="0">{
                        err = ErrInvalidPartNumberMarker
                        return
                }</span>
                <span class="cov0" title="0">if request.PartNumberMarker &lt; 0 </span><span class="cov0" title="0">{
                        err = ErrInvalidPartNumberMarker
                        return
                }</span>
        }
        <span class="cov0" title="0">return</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package s3

import (
        "encoding/xml"
        "io"
        "io/ioutil"
        "strings"

        "github.com/emicklei/go-restful"
        "github.com/journeymidnight/yig/helper"
        "github.com/soda/multi-cloud/api/pkg/common"
        "github.com/soda/multi-cloud/api/pkg/s3/datatype"
        s3error "github.com/soda/multi-cloud/s3/error"
        pb "github.com/soda/multi-cloud/s3/proto"
        log "github.com/sirupsen/logrus"
)

func (s *APIService) BucketAclPut(request *restful.Request, response *restful.Response) <span class="cov0" title="0">{
        bucketName := strings.ToLower(request.PathParameter(common.REQUEST_PATH_BUCKET_NAME))
        log.Infof("received request: PUT bucket[name=%s] acl\n", bucketName)

        var err error
        var acl datatype.Acl
        var policy datatype.AccessControlPolicy
        if _, ok := request.Request.Header[common.REQUEST_HEADER_ACL]; ok </span><span class="cov0" title="0">{
                acl, err = getAclFromHeader(request)
                if err != nil </span><span class="cov0" title="0">{
                        WriteErrorResponse(response, request, err)
                        return
                }</span>
        } else<span class="cov0" title="0"> {
                // because we only support canned acl, the body of request must be not too big, and 1024 is enough
                aclBuffer, err := ioutil.ReadAll(io.LimitReader(request.Request.Body, 1024))
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("unable to read acls body, err:", err)
                        WriteErrorResponse(response, request, s3error.ErrInvalidAcl)
                        return
                }</span>
                <span class="cov0" title="0">err = xml.Unmarshal(aclBuffer, &amp;policy)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("unable to parse acls xml body, err:", err)
                        WriteErrorResponse(response, request, s3error.ErrInternalError)
                        return
                }</span>
        }

        <span class="cov0" title="0">if acl.CannedAcl == "" </span><span class="cov0" title="0">{
                newCannedAcl, err := datatype.GetCannedAclFromPolicy(policy)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error("failed to get canned acl from policy. err:", err)
                        WriteErrorResponse(response, request, err)
                        return
                }</span>
                <span class="cov0" title="0">acl = newCannedAcl</span>
        }

        <span class="cov0" title="0">ctx := common.InitCtxWithAuthInfo(request)
        res, err := s.s3Client.PutBucketACL(ctx, &amp;pb.PutBucketACLRequest{ACLConfig: &amp;pb.BucketACL{BucketName: bucketName, CannedAcl: acl.CannedAcl}})
        if err != nil || res.ErrorCode != int32(s3error.ErrNoErr) </span><span class="cov0" title="0">{
                WriteErrorResponse(response, request, GetFinalError(err, res.ErrorCode))
                return
        }</span>

        <span class="cov0" title="0">log.Infoln("PUT bucket acl successfully.")
        WriteSuccessResponse(response, nil)</span>
}

func (s *APIService) BucketAclGet(request *restful.Request, response *restful.Response) <span class="cov0" title="0">{
        bucketName := strings.ToLower(request.PathParameter(common.REQUEST_PATH_BUCKET_NAME))
        log.Infof("received request: GET bucket[name=%s] acl\n", bucketName)

        ctx := common.InitCtxWithAuthInfo(request)
        bucket, err := s.getBucketMeta(ctx, bucketName)
        if err != nil </span><span class="cov0" title="0">{
                log.Error("failed to get bucket[%s] acl policy for bucket", bucketName)
                WriteErrorResponse(response, request, err)
                return
        }</span>

        <span class="cov0" title="0">owner := datatype.Owner{ID: bucket.TenantId, DisplayName: bucket.TenantId}
        bucketOwner := datatype.Owner{}
        policy, err := datatype.CreatePolicyFromCanned(owner, bucketOwner, datatype.Acl{CannedAcl: bucket.Acl.CannedAcl})
        if err != nil </span><span class="cov0" title="0">{
                log.Error("failed to create policy. err:", err)
                WriteErrorResponse(response, request, err)
                return
        }</span>

        <span class="cov0" title="0">aclBuffer, err := xmlFormat(policy)
        if err != nil </span><span class="cov0" title="0">{
                helper.ErrorIf(err, "failed to marshal acl XML for bucket", bucketName)
                WriteErrorResponse(response, request, s3error.ErrInternalError)
                return
        }</span>

        <span class="cov0" title="0">setXmlHeader(response, aclBuffer)
        WriteSuccessResponse(response, aclBuffer)
        log.Infoln("GET bucket acl successfully.")</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package s3

import (
        "github.com/emicklei/go-restful"
        "github.com/soda/multi-cloud/api/pkg/common"
        "github.com/soda/multi-cloud/s3/proto"
        log "github.com/sirupsen/logrus"
)

func (s *APIService) BucketDelete(request *restful.Request, response *restful.Response) <span class="cov0" title="0">{
        bucketName := request.PathParameter("bucketName")
        log.Infof("Received request for deleting bucket[name=%s].\n", bucketName)

        ctx := common.InitCtxWithAuthInfo(request)
        rsp, err := s.s3Client.DeleteBucket(ctx, &amp;s3.Bucket{Name: bucketName})
        if HandleS3Error(response, request, err, rsp.GetErrorCode()) != nil </span><span class="cov0" title="0">{
                log.Errorf("delete bucket[%s] failed, err=%v, errCode=%d\n", bucketName, err, rsp.GetErrorCode())
                return
        }</span>

        <span class="cov0" title="0">log.Infof("delete bucket[%s] successfully\n", bucketName)</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package s3

import (
        "net/url"
        "strconv"
        "time"
        "unicode/utf8"

        "github.com/emicklei/go-restful"
        "github.com/soda/multi-cloud/api/pkg/common"
        "github.com/soda/multi-cloud/api/pkg/s3/datatype"
        "github.com/soda/multi-cloud/api/pkg/utils/constants"
        . "github.com/soda/multi-cloud/s3/error"
        "github.com/soda/multi-cloud/s3/pkg/helper"
        "github.com/soda/multi-cloud/s3/pkg/utils"
        "github.com/soda/multi-cloud/s3/proto"
        log "github.com/sirupsen/logrus"
)

func (s *APIService) BucketGet(request *restful.Request, response *restful.Response) <span class="cov0" title="0">{
        bucketName := request.PathParameter("bucketName")
        log.Infof("Received request for bucket details: %s\n", bucketName)

        var err error
        req, err := parseListObjectsQuery(request.Request.URL.Query())
        if err != nil </span><span class="cov0" title="0">{
                WriteErrorResponse(response, request, err)
                return
        }</span>
        <span class="cov0" title="0">req.Bucket = bucketName

        ctx := common.InitCtxWithAuthInfo(request)
        lsRsp, err := s.s3Client.ListObjects(ctx, &amp;req)
        if HandleS3Error(response, request, err, lsRsp.GetErrorCode()) != nil </span><span class="cov0" title="0">{
                log.Errorf("get bucket[%s] failed, err=%v, errCode=%d\n", bucketName, err, lsRsp.GetErrorCode())
                return
        }</span>

        <span class="cov0" title="0">rsp := CreateListObjectsResponse(bucketName, &amp;req, lsRsp)
        log.Debugf("rsp:%+v\n", rsp)
        // Write success response.
        response.WriteEntity(rsp)

        return</span>
}

func parseListObjectsQuery(query url.Values) (request s3.ListObjectsRequest, err error) <span class="cov0" title="0">{
        if query.Get("list-type") == constants.ListObjectsType2Str </span><span class="cov0" title="0">{
                request.Version = constants.ListObjectsType2Int
                request.ContinuationToken = query.Get("continuation-token")
                request.StartAfter = query.Get("start-after")
                if !utf8.ValidString(request.StartAfter) </span><span class="cov0" title="0">{
                        err = ErrNonUTF8Encode
                        return
                }</span>
                <span class="cov0" title="0">request.FetchOwner = helper.Ternary(query.Get("fetch-owner") == "true",
                        true, false).(bool)</span>
        } else<span class="cov0" title="0"> {
                request.Version = constants.ListObjectsType1Int
                request.Marker = query.Get("marker")
                if !utf8.ValidString(request.Marker) </span><span class="cov0" title="0">{
                        err = ErrNonUTF8Encode
                        return
                }</span>
        }
        <span class="cov0" title="0">request.Delimiter = query.Get("delimiter")
        if !utf8.ValidString(request.Delimiter) </span><span class="cov0" title="0">{
                err = ErrNonUTF8Encode
                return
        }</span>
        <span class="cov0" title="0">request.EncodingType = query.Get("encoding-type")
        if request.EncodingType != "" &amp;&amp; request.EncodingType != "url" </span><span class="cov0" title="0">{
                err = ErrInvalidEncodingType
                return
        }</span>
        <span class="cov0" title="0">if query.Get("max-keys") == "" </span><span class="cov0" title="0">{
                request.MaxKeys = utils.MaxObjectList
        }</span> else<span class="cov0" title="0"> {
                var maxKey int
                maxKey, err = strconv.Atoi(query.Get("max-keys"))
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("parsing max-keys error:%v\n", err)
                        return request, ErrInvalidMaxKeys
                }</span>
                <span class="cov0" title="0">request.MaxKeys = int32(maxKey)
                if request.MaxKeys &gt; utils.MaxObjectList || request.MaxKeys &lt; 1 </span><span class="cov0" title="0">{
                        err = ErrInvalidMaxKeys
                        return
                }</span>
        }
        <span class="cov0" title="0">request.Prefix = query.Get("prefix")
        if !utf8.ValidString(request.Prefix) </span><span class="cov0" title="0">{
                err = ErrNonUTF8Encode
                return
        }</span>

        <span class="cov0" title="0">request.KeyMarker = query.Get("key-marker")
        if !utf8.ValidString(request.KeyMarker) </span><span class="cov0" title="0">{
                err = ErrNonUTF8Encode
                return
        }</span>
        <span class="cov0" title="0">request.VersionIdMarker = query.Get("version-id-marker")
        if !utf8.ValidString(request.VersionIdMarker) </span><span class="cov0" title="0">{
                err = ErrNonUTF8Encode
                return
        }</span>

        <span class="cov0" title="0">log.Infof("request:%+v\n", request)
        return</span>
}

// this function refers to GenerateListObjectsResponse in api-response.go from Minio Cloud Storage.
func CreateListObjectsResponse(bucketName string, request *s3.ListObjectsRequest,
        listRsp *s3.ListObjectsResponse) (response datatype.ListObjectsResponse) <span class="cov0" title="0">{
        for _, o := range listRsp.Objects </span><span class="cov0" title="0">{
                obj := datatype.Object{
                        Key:          o.ObjectKey,
                        LastModified: time.Unix(o.LastModified, 0).In(time.Local).Format(timeFormatAMZ),
                        ETag:         o.Etag,
                        Size:         o.Size,
                        StorageClass: o.StorageClass,
                        Location:     o.Location,
                        Tier:         o.Tier,
                }
                if request.EncodingType != "" </span><span class="cov0" title="0">{ // only support "url" encoding for now
                        obj.Key = url.QueryEscape(obj.Key)
                }</span>
                <span class="cov0" title="0">if request.FetchOwner </span><span class="cov0" title="0">{
                        obj.Owner.ID = o.TenantId //TODO: DisplayName
                }</span>
                <span class="cov0" title="0">response.Contents = append(response.Contents, obj)</span>
        }

        <span class="cov0" title="0">var prefixes []datatype.CommonPrefix
        for _, prefix := range listRsp.Prefixes </span><span class="cov0" title="0">{
                item := datatype.CommonPrefix{
                        Prefix: prefix,
                }
                prefixes = append(prefixes, item)
        }</span>
        <span class="cov0" title="0">response.CommonPrefixes = prefixes

        response.Delimiter = request.Delimiter
        response.EncodingType = request.EncodingType
        response.IsTruncated = listRsp.IsTruncated
        response.MaxKeys = int(request.MaxKeys)
        response.Prefix = request.Prefix
        response.BucketName = bucketName

        if request.Version == constants.ListObjectsType2Int </span><span class="cov0" title="0">{
                response.KeyCount = len(response.Contents)
                response.ContinuationToken = request.ContinuationToken
                response.NextContinuationToken = listRsp.NextMarker
                response.StartAfter = request.StartAfter
        }</span> else<span class="cov0" title="0"> { // version 1
                response.Marker = request.Marker
                response.NextMarker = listRsp.NextMarker
        }</span>

        <span class="cov0" title="0">if request.EncodingType != "" </span><span class="cov0" title="0">{
                response.Delimiter = url.QueryEscape(response.Delimiter)
                response.Prefix = url.QueryEscape(response.Prefix)
                response.StartAfter = url.QueryEscape(response.StartAfter)
                response.Marker = url.QueryEscape(response.Marker)
        }</span>

        <span class="cov0" title="0">return</span>
}

func (s *APIService) HeadBucket(request *restful.Request, response *restful.Response) <span class="cov0" title="0">{
        bucketName := request.PathParameter("bucketName")
        log.Infof("Received request for head bucket: %s\n", bucketName)

        var err error

        ctx := common.InitCtxWithAuthInfo(request)
        _, err = s.getBucketMeta(ctx, bucketName)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("get bucket[%s] failed, err=%v\n", bucketName, err)
                WriteErrorResponse(response, request, err)
                return
        }</span>

        <span class="cov0" title="0">log.Debugln("head bucket succeed")
        WriteSuccessResponse(response, nil)</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package s3

import (
        "github.com/emicklei/go-restful"
        "github.com/soda/multi-cloud/api/pkg/common"
        "github.com/soda/multi-cloud/s3/proto"
        log "github.com/sirupsen/logrus"
)

func (s *APIService) BucketLifecycleDelete(request *restful.Request, response *restful.Response) <span class="cov0" title="0">{
        bucketName := request.PathParameter("bucketName")
        log.Infof("received request for creating lifecycle of bucket: %s", bucketName)

        ctx := common.InitCtxWithAuthInfo(request)
        rsp, err := s.s3Client.DeleteBucketLifecycle(ctx, &amp;s3.BaseRequest{Id: bucketName})
        log.Infof("rsp:%s, err:%v\n", rsp, err)
        if HandleS3Error(response, request, err, rsp.GetErrorCode()) != nil </span><span class="cov0" title="0">{
                log.Errorf("delete bucket[%s] lifecycle failed, err=%v, errCode=%d\n", bucketName, err, rsp.GetErrorCode())
                return
        }</span>

        <span class="cov0" title="0">log.Info("delete bucket lifecycle end.")</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package s3

import (
        "fmt"
        "github.com/emicklei/go-restful"
        "github.com/soda/multi-cloud/api/pkg/common"
        . "github.com/soda/multi-cloud/api/pkg/utils/constants"
        . "github.com/soda/multi-cloud/s3/error"
        "github.com/soda/multi-cloud/s3/pkg/model"
        "github.com/soda/multi-cloud/s3/proto"
        log "github.com/sirupsen/logrus"
)

//Convert function from storage tier to storage class for XML format output
func (s *APIService) tier2class(tier int32) (string, error) <span class="cov0" title="0">{
        </span><span class="cov0" title="0">{
                mutext.Lock()
                defer mutext.Unlock()
                if len(ClassAndTier) == 0 </span><span class="cov0" title="0">{
                        err := s.loadStorageClassDefinition()
                        if err != nil </span><span class="cov0" title="0">{
                                log.Errorf("load storage classes failed: %v.\n", err)
                                return "", err
                        }</span>
                }
        }
        <span class="cov0" title="0">className := ""
        for k, v := range ClassAndTier </span><span class="cov0" title="0">{
                if v == tier </span><span class="cov0" title="0">{
                        className = k
                }</span>
        }
        <span class="cov0" title="0">if className == "" </span><span class="cov0" title="0">{
                log.Infof("invalid tier: %d\n", tier)
                return "", fmt.Errorf(InvalidTier)
        }</span>
        <span class="cov0" title="0">return className, nil</span>
}

//Function for GET Bucket Lifecycle API
func (s *APIService) BucketLifecycleGet(request *restful.Request, response *restful.Response) <span class="cov0" title="0">{
        bucketName := request.PathParameter("bucketName")
        log.Infof("received request for bucket details in GET lifecycle: %s", bucketName)

        ctx := common.InitCtxWithAuthInfo(request)
        rsp, err := s.s3Client.GetBucketLifecycle(ctx, &amp;s3.BaseRequest{Id: bucketName})
        if HandleS3Error(response, request, err, rsp.GetErrorCode()) != nil </span><span class="cov0" title="0">{
                log.Errorf("get bucket[%s] lifecycle failed, err=%v, errCode=%d\n", bucketName, err, rsp.GetErrorCode())
                return
        }</span>

        // convert back to xml struct
        <span class="cov0" title="0">lifecycleConfXml := model.LifecycleConfiguration{}

        // convert lifecycle rule to xml Rule
        for _, lcRule := range rsp.Lc </span><span class="cov0" title="0">{
                xmlRule := model.Rule{}

                xmlRule.Status = lcRule.Status
                xmlRule.ID = lcRule.Id
                xmlRule.Filter = converts3FilterToRuleFilter(lcRule.Filter)
                xmlRule.AbortIncompleteMultipartUpload = converts3UploadToRuleUpload(lcRule.AbortIncompleteMultipartUpload)
                xmlRule.Transition = make([]model.Transition, 0)

                //Arranging the transition and expiration actions in XML
                for _, action := range lcRule.Actions </span><span class="cov0" title="0">{
                        log.Infof("action is : %v\n", action)

                        if action.Name == ActionNameTransition </span><span class="cov0" title="0">{
                                xmlTransition := model.Transition{}
                                xmlTransition.Days = action.Days
                                xmlTransition.Backend = action.Backend
                                className, err := s.tier2class(action.Tier)
                                if err == nil </span><span class="cov0" title="0">{
                                        xmlTransition.StorageClass = className
                                }</span>
                                <span class="cov0" title="0">xmlRule.Transition = append(xmlRule.Transition, xmlTransition)</span>
                        }
                        <span class="cov0" title="0">if action.Name == ActionNameExpiration </span><span class="cov0" title="0">{
                                xmlExpiration := model.Expiration{}
                                xmlExpiration.Days = action.Days
                                xmlRule.Expiration = append(xmlRule.Expiration, xmlExpiration)
                        }</span>
                }
                // append each xml rule to xml array
                <span class="cov0" title="0">lifecycleConfXml.Rule = append(lifecycleConfXml.Rule, xmlRule)</span>
        }

        // marshall the array back to xml format
        <span class="cov0" title="0">err = response.WriteAsXml(lifecycleConfXml)
        if err != nil </span><span class="cov0" title="0">{
                log.Infof("write lifecycle of bucket[%s] as xml failed, lifecycle =%s, err=%v.\n", bucketName,
                        lifecycleConfXml, err)
                WriteErrorResponse(response, request, ErrInternalError)
                return
        }</span>

        <span class="cov0" title="0">log.Info("GET lifecycle succeed.")</span>
}

func converts3FilterToRuleFilter(filter *s3.LifecycleFilter) model.Filter <span class="cov0" title="0">{
        retFilter := model.Filter{}
        if filter != nil </span><span class="cov0" title="0">{
                retFilter.Prefix = filter.Prefix
        }</span>
        <span class="cov0" title="0">return retFilter</span>
}

func converts3UploadToRuleUpload(upload *s3.AbortMultipartUpload) model.AbortIncompleteMultipartUpload <span class="cov0" title="0">{
        retUpload := model.AbortIncompleteMultipartUpload{}
        if upload != nil </span><span class="cov0" title="0">{
                retUpload.DaysAfterInitiation = upload.DaysAfterInitiation
        }</span>
        <span class="cov0" title="0">return retUpload</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package s3

import (
        "crypto/md5"
        "encoding/xml"
        "fmt"
        "net/http"
        "sync"

        "github.com/emicklei/go-restful"
        "github.com/soda/multi-cloud/api/pkg/common"
        . "github.com/soda/multi-cloud/api/pkg/utils/constants"
        . "github.com/soda/multi-cloud/s3/error"
        "github.com/soda/multi-cloud/s3/pkg/model"
        "github.com/soda/multi-cloud/s3/pkg/utils"
        "github.com/soda/multi-cloud/s3/proto"
        log "github.com/sirupsen/logrus"
        "golang.org/x/net/context"
)

// Map from storage calss to tier
var ClassAndTier map[string]int32
var mutext sync.Mutex

func (s *APIService) loadStorageClassDefinition() error <span class="cov0" title="0">{
        ctx := context.Background()
        log.Info("Load storage classes.")
        res, err := s.s3Client.GetStorageClasses(ctx, &amp;s3.BaseRequest{})
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("get storage classes from s3 service failed: %v\n", err)
                return err
        }</span>
        <span class="cov0" title="0">ClassAndTier = make(map[string]int32)
        for _, v := range res.Classes </span><span class="cov0" title="0">{
                ClassAndTier[v.Name] = v.Tier
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (s *APIService) class2tier(name string) (int32, error) <span class="cov0" title="0">{
        </span><span class="cov0" title="0">{
                mutext.Lock()
                defer mutext.Unlock()
                if len(ClassAndTier) == 0 </span><span class="cov0" title="0">{
                        err := s.loadStorageClassDefinition()
                        if err != nil </span><span class="cov0" title="0">{
                                log.Errorf("load storage classes failed: %v.\n", err)
                                return 0, err
                        }</span>
                }
        }
        <span class="cov0" title="0">tier, ok := ClassAndTier[name]
        if !ok </span><span class="cov0" title="0">{
                log.Errorf("translate storage class name[%s] to tier failed: %s.\n", name)
                return 0, fmt.Errorf("invalid storage class:%s", name)
        }</span>
        <span class="cov0" title="0">log.Infof("class[%s] to tier[%d]\n", name, tier)
        return tier, nil</span>
}

func checkValidationOfActions(actions []*s3.Action) error <span class="cov0" title="0">{
        var pre *s3.Action = nil
        for _, action := range actions </span><span class="cov0" title="0">{
                log.Infof("action: %+v\n", *action)
                if pre == nil </span><span class="cov0" title="0">{
                        if action.Name == ActionNameExpiration &amp;&amp; action.Days &lt; ExpirationMinDays </span><span class="cov0" title="0">{
                                // If only an expiration action for a rule, the days for that action should be more than ExpirationMinDays
                                return fmt.Errorf(InvalidExpireDays, ExpirationMinDays)
                        }</span>
                        <span class="cov0" title="0">if action.Name == ActionNameTransition &amp;&amp; action.Days &lt; TransitionMinDays </span><span class="cov0" title="0">{
                                // the days for transition to tiers except tier999 should not less than TransitionMinDays
                                minDays := int32(TransitionMinDays)
                                if action.Tier == utils.Tier999 </span><span class="cov0" title="0">{
                                        // the days for transition to tier999 should not less than TransitionToArchiveMinDays
                                        minDays = TransitionToArchiveMinDays
                                }</span>
                                <span class="cov0" title="0">if action.Days &lt; minDays </span><span class="cov0" title="0">{
                                        return fmt.Errorf(InvalidTransistionDays, action.Tier, minDays)
                                }</span>

                        }
                } else<span class="cov0" title="0"> {
                        if pre.Name == ActionNameExpiration </span><span class="cov0" title="0">{
                                // Only one expiration action for each rule is supported
                                return fmt.Errorf(MoreThanOneExpirationAction)
                        }</span>

                        <span class="cov0" title="0">if action.Name == ActionNameExpiration &amp;&amp; pre.Days+ExpirationMinDays &gt; action.Days </span><span class="cov0" title="0">{
                                return fmt.Errorf(DaysInStorageClassBeforeExpiration)
                        }</span>

                        <span class="cov0" title="0">if action.Name == ActionNameTransition &amp;&amp; pre.Days+LifecycleTransitionDaysStep &gt; action.Days </span><span class="cov0" title="0">{
                                return fmt.Errorf(DaysInStorageClassBeforeTransition)
                        }</span>
                }
                <span class="cov0" title="0">pre = action</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (s *APIService) BucketLifecyclePut(request *restful.Request, response *restful.Response) <span class="cov0" title="0">{
        bucketName := request.PathParameter("bucketName")
        log.Infof("received request for creating lifecycle of bucket: %s", bucketName)

        ctx := common.InitCtxWithAuthInfo(request)
        _, err := s.getBucketMeta(ctx, bucketName)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("get bucket[%s] failed, err=%v\n", bucketName, err)
                WriteErrorResponse(response, request, err)
                return
        }</span>

        <span class="cov0" title="0">body := ReadBody(request)
        log.Infof("MD5 sum for body is %x", md5.Sum(body))
        if body == nil </span><span class="cov0" title="0">{
                log.Info("no request body provided for creating lifecycle configuration")
                WriteErrorResponse(response, request, S3ErrorCode(ErrInvalidLc))
                return
        }</span>

        <span class="cov0" title="0">createLifecycleConf := model.LifecycleConfiguration{}
        err = xml.Unmarshal(body, &amp;createLifecycleConf)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("unmarshal error:%v\n", err)
                WriteErrorResponse(response, request, S3ErrorCode(ErrInvalidLc))
                return
        }</span>

        <span class="cov0" title="0">dupIdCheck := make(map[string]interface{})
        s3RulePtrArr := make([]*s3.LifecycleRule, 0)
        ruleCount := 0
        for _, rule := range createLifecycleConf.Rule </span><span class="cov0" title="0">{
                if ruleCount &gt; 1000 </span><span class="cov0" title="0">{
                        log.Error("too many rules\n")
                        WriteApiErrorResponse(response, request, http.StatusBadRequest, AWSErrCodeInvalidArgument,
                                fmt.Sprintf(TooMuchLCRuls, 1000))
                        return
                }</span>

                <span class="cov0" title="0">s3Rule := s3.LifecycleRule{}

                //check if the ruleID has any duplicate values
                if _, ok := dupIdCheck[rule.ID]; ok </span><span class="cov0" title="0">{
                        log.Errorf("duplicate ruleID found for rule : %s\n", rule.ID)
                        WriteApiErrorResponse(response, request, http.StatusBadRequest, AWSErrCodeInvalidArgument,
                                fmt.Sprintf(DuplicateRuleIDError, rule.ID))
                        return
                }</span>
                // Assigning the rule ID
                <span class="cov0" title="0">dupIdCheck[rule.ID] = struct{}{}
                s3Rule.Id = rule.ID

                //Assigning the status value to s3 status
                log.Infof("status in rule file is %v\n", rule.Status)
                s3Rule.Status = rule.Status

                //Assigning the filter, using convert function to convert xml struct to s3 struct
                s3Rule.Filter = convertRuleFilterToS3Filter(rule.Filter)

                // Create the type of transition array
                s3ActionArr := make([]*s3.Action, 0)

                for _, transition := range rule.Transition </span><span class="cov0" title="0">{

                        //Defining the Transition array and assigning the values tp populate fields
                        s3Transition := s3.Action{Name: ActionNameTransition}

                        //Assigning the value of days for transition to happen
                        s3Transition.Days = transition.Days

                        //Assigning the backend value to the s3 struct
                        s3Transition.Backend = transition.Backend

                        //Assigning the storage class of the object to s3 struct
                        tier, err := s.class2tier(transition.StorageClass)
                        if err != nil </span><span class="cov0" title="0">{
                                response.WriteError(http.StatusBadRequest, err)
                                return
                        }</span>
                        <span class="cov0" title="0">s3Transition.Tier = tier

                        //Adding the transition value to the main rule
                        s3ActionArr = append(s3ActionArr, &amp;s3Transition)
                        ruleCount++</span>
                }

                //Loop for getting the values from xml struct
                <span class="cov0" title="0">for _, expiration := range rule.Expiration </span><span class="cov0" title="0">{
                        s3Expiration := s3.Action{Name: ActionNameExpiration}
                        s3Expiration.Days = expiration.Days
                        s3ActionArr = append(s3ActionArr, &amp;s3Expiration)
                        ruleCount++
                }</span>

                //validate actions
                <span class="cov0" title="0">err := checkValidationOfActions(s3ActionArr)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("validation of actions failed: %v\n", err)
                        WriteApiErrorResponse(response, request, http.StatusBadRequest, AWSErrCodeInvalidArgument, err.Error())
                        return
                }</span>

                //Assigning the Expiration action to s3 struct expiration
                <span class="cov0" title="0">s3Rule.Actions = s3ActionArr

                s3Rule.AbortIncompleteMultipartUpload = convertRuleUploadToS3Upload(rule.AbortIncompleteMultipartUpload)

                // add to the s3 array
                s3RulePtrArr = append(s3RulePtrArr, &amp;s3Rule)</span>
        }

        <span class="cov0" title="0">lcRsp, err := s.s3Client.PutBucketLifecycle(ctx, &amp;s3.PutBucketLifecycleRequest{BucketName: bucketName, Lc: s3RulePtrArr})
        if HandleS3Error(response, request, err, lcRsp.GetErrorCode()) != nil </span><span class="cov0" title="0">{
                log.Errorf("put bucket[%s] lifecycle failed, err=%v, errCode=%d\n", bucketName, err, lcRsp.GetErrorCode())
                return
        }</span>

        <span class="cov0" title="0">log.Info("create bucket lifecycle successful.")
        WriteSuccessResponse(response, nil)</span>
}

func convertRuleFilterToS3Filter(filter model.Filter) *s3.LifecycleFilter <span class="cov0" title="0">{
        retFilter := s3.LifecycleFilter{}
        /*
                check if prefix is not empty
        */
        if filter.Prefix != "" </span><span class="cov0" title="0">{
                retFilter.Prefix = filter.Prefix
                return &amp;retFilter
        }</span> else<span class="cov0" title="0"> {
                return nil
        }</span>
}

func convertRuleUploadToS3Upload(upload model.AbortIncompleteMultipartUpload) *s3.AbortMultipartUpload <span class="cov0" title="0">{
        retUpload := s3.AbortMultipartUpload{}
        retUpload.DaysAfterInitiation = upload.DaysAfterInitiation
        return &amp;retUpload
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package s3

import (
        "encoding/xml"
        "strings"
        "time"

        "github.com/emicklei/go-restful"
        "github.com/soda/multi-cloud/api/pkg/common"
        c "github.com/soda/multi-cloud/api/pkg/context"
        "github.com/soda/multi-cloud/s3/error"
        "github.com/soda/multi-cloud/s3/pkg/model"
        "github.com/soda/multi-cloud/s3/pkg/utils"
        "github.com/soda/multi-cloud/s3/proto"
        pb "github.com/soda/multi-cloud/s3/proto"
        log "github.com/sirupsen/logrus"
)

func (s *APIService) BucketPut(request *restful.Request, response *restful.Response) <span class="cov0" title="0">{
        bucketName := strings.ToLower(request.PathParameter(common.REQUEST_PATH_BUCKET_NAME))
        if !isValidBucketName(bucketName) </span><span class="cov0" title="0">{
                WriteErrorResponse(response, request, s3error.ErrInvalidBucketName)
                return
        }</span>
        <span class="cov0" title="0">log.Infof("received request: PUT bucket[name=%s]\n", bucketName)

        if len(request.HeaderParameter(common.REQUEST_HEADER_CONTENT_LENGTH)) == 0 </span><span class="cov0" title="0">{
                log.Errorf("missing content length")
                WriteErrorResponse(response, request, s3error.ErrMissingContentLength)
                return
        }</span>

        <span class="cov0" title="0">acl, err := getAclFromHeader(request)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorln("failed to get canned acl. err:", err)
                WriteErrorResponse(response, request, err)
                return
        }</span>

        <span class="cov0" title="0">ctx := common.InitCtxWithAuthInfo(request)
        actx := request.Attribute(c.KContext).(*c.Context)
        bucket := s3.Bucket{Name: bucketName}
        bucket.TenantId = actx.TenantId
        bucket.UserId = actx.UserId
        bucket.Deleted = false
        bucket.CreateTime = time.Now().Unix()
        bucket.Versioning = &amp;s3.BucketVersioning{}
        bucket.Versioning.Status = utils.VersioningDisabled // it's the default
        bucket.Acl = &amp;pb.Acl{CannedAcl: acl.CannedAcl}
        log.Infof("Bucket PUT: TenantId=%s, UserId=%s\n", bucket.TenantId, bucket.UserId)

        body := ReadBody(request)
        flag := false
        if body != nil &amp;&amp; len(body) != 0 </span><span class="cov0" title="0">{
                log.Infof("request body is not empty")
                createBucketConf := model.CreateBucketConfiguration{}
                err := xml.Unmarshal(body, &amp;createBucketConf)
                if err != nil </span><span class="cov0" title="0">{
                        log.Infof("unmarshal failed, body:%v, err:%v\n", body, err)
                        WriteErrorResponse(response, request, s3error.ErrUnmarshalFailed)
                        return
                }</span>

                <span class="cov0" title="0">backendName := createBucketConf.LocationConstraint
                if backendName != "" </span><span class="cov0" title="0">{
                        log.Infof("backendName is %v\n", backendName)
                        bucket.DefaultLocation = backendName
                        flag = s.isBackendExist(ctx, backendName)
                }</span>
        }
        <span class="cov0" title="0">if flag == false </span><span class="cov0" title="0">{
                log.Errorf("default backend is not provided or it is not exist.")
                WriteErrorResponse(response, request, s3error.ErrGetBackendFailed)
                return
        }</span>

        <span class="cov0" title="0">rsp, err := s.s3Client.CreateBucket(ctx, &amp;bucket)
        if HandleS3Error(response, request, err, rsp.GetErrorCode()) != nil </span><span class="cov0" title="0">{
                log.Errorf("delete bucket[%s] failed, err=%v, errCode=%d\n", bucketName, err, rsp.GetErrorCode())
                return
        }</span>

        <span class="cov0" title="0">log.Infof("create bucket[name=%s, defaultLocation=%s] successfully.\n", bucket.Name, bucket.DefaultLocation)
        // Make sure to add Location information here only for bucket
        response.Header().Set("Location", GetLocation(request.Request))
        WriteSuccessResponse(response, nil)</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package s3

import (
        "crypto/md5"
        "encoding/xml"
        "fmt"
        "net/http"
        "sync"

        "github.com/emicklei/go-restful"
        "github.com/soda/multi-cloud/api/pkg/common"
        "github.com/soda/multi-cloud/s3/pkg/model"
        "github.com/soda/multi-cloud/s3/proto"
        log "github.com/sirupsen/logrus"
)

// Map from storage calss to tier
var ClassAndTier1 map[string]int32
var mutext1 sync.Mutex

func (s *APIService) BucketSSEPut(request *restful.Request, response *restful.Response) <span class="cov0" title="0">{
        bucketName := request.PathParameter("bucketName")
        log.Infof("received request for PUT bucket SSE: %s", bucketName)

        ctx := common.InitCtxWithAuthInfo(request)
        bucket, err := s.s3Client.GetBucket(ctx, &amp;s3.Bucket{Name: bucketName})
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("get bucket failed, err=%v\n", err)
                response.WriteError(http.StatusInternalServerError, fmt.Errorf("bucket does not exist"))
        }</span>
        <span class="cov0" title="0">if bucket.ErrorCode != 0 </span><span class="cov0" title="0">{
                log.Errorf("get bucket failed, err=%v\n", bucket.ErrorCode)
                response.WriteError(http.StatusInternalServerError, fmt.Errorf("Get bucket error code %v", bucket.ErrorCode))
        }</span>

        <span class="cov0" title="0">body := ReadBody(request)
        log.Infof("MD5 sum for request body is %x", md5.Sum(body))

        if body != nil </span><span class="cov0" title="0">{
                sseConf := model.SSEConfiguration{}
                errSSE := xml.Unmarshal(body, &amp;sseConf)
                if errSSE != nil </span><span class="cov0" title="0">{
                        response.WriteError(http.StatusInternalServerError, err)
                        return
                }</span>

                <span class="cov0" title="0">s3SSE := &amp;s3.ServerSideEncryption{
                        SseType:              "",
                        EncryptionKey:        nil,
                        InitilizationVector:  nil,
                        XXX_NoUnkeyedLiteral: struct{}{},
                        XXX_unrecognized:     nil,
                        XXX_sizecache:        0,
                }
                if sseConf.SSE.Enabled == "true" </span><span class="cov0" title="0">{
                        s3SSE.SseType = "SSE"
                }</span>

                <span class="cov0" title="0">bucket.BucketMeta.ServerSideEncryption = s3SSE

                baseResponse, errSSE := s.s3Client.UpdateBucket(ctx, bucket.BucketMeta)
                if baseResponse.ErrorCode != 0</span><span class="cov0" title="0">{
                        response.WriteError(http.StatusInternalServerError, fmt.Errorf("Update bucket SSE options failed, error code %v", baseResponse.ErrorCode))
                }</span>
                <span class="cov0" title="0">if errSSE != nil</span><span class="cov0" title="0">{
                        response.WriteError(http.StatusInternalServerError, fmt.Errorf("Update bucket SSE options failed"))
                }</span>

        } else<span class="cov0" title="0"> {
                log.Info("no request body provided for creating SSE configuration")
                response.WriteError(http.StatusBadRequest, fmt.Errorf(NoRequestBodySSE))
                return
        }</span>

        // Create bucket with bucket name will check if the bucket exists or not, if it exists
        // it will internally call UpdateBucket function
        <span class="cov0" title="0">res, err := s.s3Client.UpdateBucket(ctx, bucket.BucketMeta)
        if err != nil </span><span class="cov0" title="0">{
                response.WriteError(http.StatusInternalServerError, err)
                return
        }</span>
        <span class="cov0" title="0">log.Info("create bucket SSE successful.")
        response.WriteEntity(res)</span>

}
</pre>
		
		<pre class="file" id="file18" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package s3

import (
        "crypto/md5"
        "encoding/xml"
        "github.com/emicklei/go-restful"
        "github.com/soda/multi-cloud/api/pkg/common"
        . "github.com/soda/multi-cloud/s3/error"
        "github.com/soda/multi-cloud/s3/pkg/model"
        "github.com/soda/multi-cloud/s3/pkg/utils"
        s3 "github.com/soda/multi-cloud/s3/proto"
        log "github.com/sirupsen/logrus"
)

func (s *APIService) BucketVersioningPut(request *restful.Request, response *restful.Response) <span class="cov0" title="0">{
        bucketName := request.PathParameter("bucketName")
        log.Infof("received request for creating versioning of bucket: %s", bucketName)

        ctx := common.InitCtxWithAuthInfo(request)
        bucket, err := s.getBucketMeta(ctx, bucketName)
        if err != nil </span><span class="cov0" title="0">{
                WriteErrorResponse(response, request, err)
                log.Errorf("get bucket[%s] failed, err=%v\n", bucketName, err)
                return
        }</span>

        <span class="cov0" title="0">body := ReadBody(request)
        if body == nil </span><span class="cov0" title="0">{
                log.Info("no request body provided for creating versioning configuration")
                WriteErrorResponse(response, request, S3ErrorCode(ErrInvalidVersioning))
                return
        }</span>
        <span class="cov0" title="0">log.Infof("MD5 sum for body is %x", md5.Sum(body))

        versionConf := model.VersioningConfiguration{}
        err = xml.Unmarshal(body, &amp;versionConf)
        if err != nil </span><span class="cov0" title="0">{
                WriteErrorResponse(response, request, S3ErrorCode(ErrInvalidVersioning))
                return
        }</span>

        <span class="cov0" title="0">s3version := &amp;s3.BucketVersioning{
                Status:               "",
                XXX_NoUnkeyedLiteral: struct{}{},
                XXX_unrecognized:     nil,
                XXX_sizecache:        0,
        }

        if versionConf.Status == utils.VersioningEnabled </span><span class="cov0" title="0">{
                s3version.Status = utils.VersioningEnabled
        }</span> else<span class="cov0" title="0"> {
                s3version.Status = utils.VersioningDisabled
        }</span>

        <span class="cov0" title="0">bucket.Versioning = s3version

        _, err = s.s3Client.UpdateBucket(ctx, bucket)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("versioning configuration failed, errCode=%d\n", bucketName, err)
                return
        }</span>

        <span class="cov0" title="0">log.Info("create bucket version configuration successful.")
        WriteSuccessResponse(response, nil)</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package s3

import (
        "encoding/xml"
        "errors"
        "io/ioutil"
        "sort"
        "strings"

        "github.com/emicklei/go-restful"
        "github.com/soda/multi-cloud/api/pkg/common"
        "github.com/soda/multi-cloud/s3/pkg/model"
        pb "github.com/soda/multi-cloud/s3/proto"
        log "github.com/sirupsen/logrus"

        . "github.com/soda/multi-cloud/s3/error"
)

func (s *APIService) CompleteMultipartUpload(request *restful.Request, response *restful.Response) <span class="cov0" title="0">{
        bucketName := request.PathParameter("bucketName")
        objectKey := request.PathParameter("objectKey")
        uploadId := request.QueryParameter("uploadId")

        multipartUpload := pb.MultipartUpload{}
        multipartUpload.Bucket = bucketName
        multipartUpload.Key = objectKey
        multipartUpload.UploadId = uploadId

        completeMultipartBytes, err := ioutil.ReadAll(request.Request.Body)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorln("unable to complete multipart upload when read request body. err:", err)
                WriteErrorResponse(response, request, ErrInternalError)
                return
        }</span>
        <span class="cov0" title="0">complMultipartUpload := &amp;model.CompleteMultipartUpload{}
        if err = xml.Unmarshal(completeMultipartBytes, complMultipartUpload); err != nil </span><span class="cov0" title="0">{
                log.Errorf("unable to parse complete multipart upload XML. data: %s, err: %v", string(completeMultipartBytes), err)
                WriteErrorResponse(response, request, ErrMalformedXML)
                return
        }</span>

        <span class="cov0" title="0">if len(complMultipartUpload.Parts) == 0 </span><span class="cov0" title="0">{
                log.Errorf("unable to complete multipart upload. err: %v", errors.New("len(complMultipartUpload.Parts) == 0"))
                WriteErrorResponse(response, request, ErrMalformedXML)
                return
        }</span>
        <span class="cov0" title="0">if !sort.IsSorted(model.CompletedParts(complMultipartUpload.Parts)) </span><span class="cov0" title="0">{
                log.Errorf("unable to complete multipart upload. data: %+v, err: %v", complMultipartUpload.Parts, errors.New("part not sorted."))
                WriteErrorResponse(response, request, ErrInvalidPartOrder)
                return
        }</span>

        // Complete parts.
        <span class="cov0" title="0">var completeParts []*pb.CompletePart
        for _, part := range complMultipartUpload.Parts </span><span class="cov0" title="0">{
                part.ETag = strings.TrimPrefix(part.ETag, "\"")
                part.ETag = strings.TrimSuffix(part.ETag, "\"")
                completeParts = append(completeParts, &amp;pb.CompletePart{PartNumber: part.PartNumber, ETag: part.ETag})
        }</span>

        <span class="cov0" title="0">ctx := common.InitCtxWithAuthInfo(request)
        result, err := s.s3Client.CompleteMultipartUpload(ctx, &amp;pb.CompleteMultipartRequest{
                BucketName:    bucketName,
                ObjectKey:     objectKey,
                UploadId:      uploadId,
                CompleteParts: completeParts,
        })
        if HandleS3Error(response, request, err, result.GetErrorCode()) != nil </span><span class="cov0" title="0">{
                log.Errorf("unable to complete multipart. err:%v, errCode:%v", err, result.ErrorCode)
                return
        }</span>

        // Get object location.
        <span class="cov0" title="0">location := GetLocation(request.Request)
        // Generate complete multipart response.
        data := GenerateCompleteMultipartUploadResponse(bucketName, objectKey, location, result.ETag)
        encodedSuccessResponse, err := xmlFormat(data)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorln("unable to parse CompleteMultipartUpload response, err:", err)
                WriteErrorResponseNoHeader(response, request, ErrInternalError, request.Request.URL.Path)
                return
        }</span>

        <span class="cov0" title="0">setXmlHeader(response, encodedSuccessResponse)
        // write success response.
        WriteSuccessResponse(response, encodedSuccessResponse)
        log.Infof("Complete multipart upload[bucketName=%s, objectKey=%s, uploadId=%s] successfully.\n",
                bucketName, objectKey, uploadId)</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package datatype

import (
        "encoding/xml"
        . "github.com/soda/multi-cloud/s3/error"
        "github.com/soda/multi-cloud/s3/pkg/helper"
        log "github.com/sirupsen/logrus"
)

var ValidCannedAcl = []string{
        "private",
        "public-read",
        "public-read-write",
}

const (
        CANNEDACL_PRIVATE                    = 0
        CANNEDACL_PUBLIC_READ                = 1
        CANNEDACL_PUBLIC_READ_WRITE          = 2
        CANNEDACL_AWS_EXEC_READ              = 3
        CANNEDACL_AUTHENTICATED_READ         = 4
        CANNEDACL_BUCKET_OWNER_READ          = 5
        CANNEDACL_BUCKET_OWNER_FULL_CONTROLL = 6
)

const (
        XMLNSXSI = "http://www.w3.org/2001/XMLSchema-instance"
        XMLNS    = "http://s3.amazonaws.com/doc/2006-03-01/"
)

const (
        ACL_TYPE_CANON_USER = "CanonicalUser"
        ACL_TYPE_GROUP      = "Group"
)

const (
        ACL_GROUP_TYPE_ALL_USERS           = "http://acs.amazonaws.com/groups/global/AllUsers"
        ACL_GROUP_TYPE_AUTHENTICATED_USERS = "http://acs.amazonaws.com/groups/global/AuthenticatedUsers"
)

const (
        ACL_PERM_READ         = "READ"
        ACL_PERM_WRITE        = "WRITE"
        ACL_PERM_READ_ACP     = "READ_ACP"
        ACL_PERM_WRITE_ACP    = "WRITE_ACP"
        ACL_PERM_FULL_CONTROL = "FULL_CONTROL"
)

type Acl struct {
        CannedAcl string
        // TODO fancy ACLs
}

type AccessControlPolicy struct {
        XMLName           xml.Name `xml:"AccessControlPolicy"`
        Xmlns             string   `xml:"xmlns,attr,omitempty"`
        ID                string   `xml:"Owner&gt;ID"`
        DisplayName       string   `xml:"Owner&gt;DisplayName"`
        AccessControlList []Grant  `xml:"AccessControlList&gt;Grant"`
}

type Grant struct {
        XMLName    xml.Name `xml:"Grant"`
        Grantee    Grantee  `xml:"Grantee"`
        Permission string   `xml:"Permission"`
}

type Grantee struct {
        XMLName      xml.Name `xml:"Grantee"`
        XmlnsXsi     string   `xml:"xmlns:xsi,attr"`
        XsiType      string   `xml:"http://www.w3.org/2001/XMLSchema-instance type,attr"`
        URI          string   `xml:"URI,omitempty"`
        ID           string   `xml:"ID,omitempty"`
        DisplayName  string   `xml:"DisplayName,omitempty"`
        EmailAddress string   `xml:"EmailAddress,omitempty"`
}

type AccessControlPolicyResponse struct {
        XMLName           xml.Name `xml:"AccessControlPolicy"`
        Xmlns             string   `xml:"xmlns,attr,omitempty"`
        ID                string   `xml:"Owner&gt;ID"`
        DisplayName       string   `xml:"Owner&gt;DisplayName"`
        AccessControlList []GrantResponse  `xml:"AccessControlList&gt;Grant"`
}

type GrantResponse struct {
        XMLName    xml.Name `xml:"Grant"`
        Grantee    GranteeResponse  `xml:"Grantee"`
        Permission string   `xml:"Permission"`
}

type GranteeResponse struct {
        XMLName      xml.Name `xml:"Grantee"`
        XmlnsXsi     string   `xml:"xmlns:xsi,attr"`
        XsiType      string   `xml:"xsi:type,attr"`
        URI          string   `xml:"URI,omitempty"`
        ID           string   `xml:"ID,omitempty"`
        DisplayName  string   `xml:"DisplayName,omitempty"`
        EmailAddress string   `xml:"EmailAddress,omitempty"`
}

func IsValidCannedAcl(acl Acl) (err error) <span class="cov0" title="0">{
        if !helper.StringInSlice(acl.CannedAcl, ValidCannedAcl) </span><span class="cov0" title="0">{
                err = ErrInvalidCannedAcl
                return
        }</span>
        <span class="cov0" title="0">return</span>
}

// the function will be deleted, because we will use AccessControlPolicy instead canned acl stored in hbase
func GetCannedAclFromPolicy(policy AccessControlPolicy) (acl Acl, err error) <span class="cov0" title="0">{
        aclOwner := Owner{ID: policy.ID, DisplayName: policy.DisplayName}
        var canonUser bool
        var group bool
        for _, grant := range policy.AccessControlList </span><span class="cov0" title="0">{
                log.Infoln("GetCannedAclFromPolicy")
                switch grant.Grantee.XsiType </span>{
                case ACL_TYPE_CANON_USER:<span class="cov0" title="0">
                        if grant.Grantee.ID != aclOwner.ID </span><span class="cov0" title="0">{
                                log.Infoln("grant.Grantee.ID:", grant.Grantee.ID, "not equals aclOwner.ID:", aclOwner.ID)
                                return acl, ErrUnsupportedAcl
                        }</span>
                        <span class="cov0" title="0">if grant.Permission != ACL_PERM_FULL_CONTROL </span><span class="cov0" title="0">{
                                log.Infoln("grant.Permission:", grant.Permission, "not equals", ACL_PERM_FULL_CONTROL)
                                return acl, ErrUnsupportedAcl
                        }</span>
                        <span class="cov0" title="0">canonUser = true</span>
                case ACL_TYPE_GROUP:<span class="cov0" title="0">
                        if grant.Grantee.URI == ACL_GROUP_TYPE_ALL_USERS </span><span class="cov0" title="0">{
                                log.Infoln("grant.Grantee.URI is", ACL_GROUP_TYPE_ALL_USERS)
                                if grant.Permission != ACL_PERM_READ </span><span class="cov0" title="0">{
                                        log.Infoln("grant.Permission:", grant.Permission, "not equals", ACL_PERM_READ)
                                        return acl, ErrUnsupportedAcl
                                }</span>
                                <span class="cov0" title="0">acl = Acl{CannedAcl: ValidCannedAcl[CANNEDACL_PUBLIC_READ]}
                                group = true</span>
                        } else<span class="cov0" title="0"> if grant.Grantee.URI == ACL_GROUP_TYPE_AUTHENTICATED_USERS </span><span class="cov0" title="0">{
                                log.Infoln("grant.Grantee.URI is", ACL_GROUP_TYPE_AUTHENTICATED_USERS)
                                if grant.Permission != ACL_PERM_READ </span><span class="cov0" title="0">{
                                        log.Infoln("grant.Permission:", grant.Permission, "not equals", ACL_PERM_FULL_CONTROL)
                                        return acl, ErrUnsupportedAcl
                                }</span>
                                <span class="cov0" title="0">acl = Acl{CannedAcl: ValidCannedAcl[CANNEDACL_AUTHENTICATED_READ]}
                                group = true</span>
                        } else<span class="cov0" title="0"> {
                                log.Infoln("grant.Grantee.URI is invalid:", grant.Grantee.URI)
                                return acl, ErrUnsupportedAcl
                        }</span>
                default:<span class="cov0" title="0">
                        log.Infoln("grant.Grantee.XsiType is invalid:", grant.Grantee.XsiType)
                        return acl, ErrUnsupportedAcl</span>
                }
        }

        <span class="cov0" title="0">if !canonUser </span><span class="cov0" title="0">{
                log.Infoln("canonUser is invalid:", canonUser)
                return acl, ErrUnsupportedAcl
        }</span>

        <span class="cov0" title="0">if !group </span><span class="cov0" title="0">{
                acl = Acl{CannedAcl: ValidCannedAcl[CANNEDACL_PRIVATE]}
        }</span>

        <span class="cov0" title="0">return acl, nil</span>
}

func createGrant(xsiType string, owner Owner, perm string, groupType string) (grant GrantResponse, err error) <span class="cov0" title="0">{

        if xsiType == ACL_TYPE_CANON_USER </span><span class="cov0" title="0">{
                grant.Grantee.ID = owner.ID
                grant.Grantee.DisplayName = owner.DisplayName
        }</span> else<span class="cov0" title="0"> if xsiType == ACL_TYPE_GROUP </span><span class="cov0" title="0">{
                grant.Grantee.URI = groupType
        }</span> else<span class="cov0" title="0"> {
                return grant, ErrUnsupportedAcl
        }</span>
        <span class="cov0" title="0">grant.Permission = perm
        grant.Grantee.XmlnsXsi = XMLNSXSI
        grant.Grantee.XsiType = xsiType
        return</span>
}

func CreatePolicyFromCanned(owner Owner, bucketOwner Owner, acl Acl) (
        policy AccessControlPolicyResponse, err error) <span class="cov0" title="0">{

        policy.ID = owner.ID
        policy.DisplayName = owner.DisplayName
        policy.Xmlns = XMLNS
        grant, err := createGrant(ACL_TYPE_CANON_USER, owner, ACL_PERM_FULL_CONTROL, "")
        if err != nil </span><span class="cov0" title="0">{
                return policy, err
        }</span>
        <span class="cov0" title="0">policy.AccessControlList = append(policy.AccessControlList, grant)
        if acl.CannedAcl == "private" </span><span class="cov0" title="0">{
                return policy, nil
        }</span>
        <span class="cov0" title="0">switch acl.CannedAcl </span>{
        case "public-read":<span class="cov0" title="0">
                owner := Owner{}
                grant, err := createGrant(ACL_TYPE_GROUP, owner, ACL_PERM_READ, ACL_GROUP_TYPE_ALL_USERS)
                if err != nil </span><span class="cov0" title="0">{
                        return policy, err
                }</span>
                <span class="cov0" title="0">policy.AccessControlList = append(policy.AccessControlList, grant)</span>
        case "public-read-write":<span class="cov0" title="0">
                owner := Owner{}
                rGrant, err := createGrant(ACL_TYPE_GROUP, owner, ACL_PERM_READ, ACL_GROUP_TYPE_ALL_USERS)
                if err != nil </span><span class="cov0" title="0">{
                        return policy, err
                }</span>
                <span class="cov0" title="0">wGrant, err := createGrant(ACL_TYPE_GROUP, owner, ACL_PERM_WRITE, ACL_GROUP_TYPE_ALL_USERS)
                if err != nil </span><span class="cov0" title="0">{
                        return policy, err
                }</span>
                <span class="cov0" title="0">policy.AccessControlList = append(policy.AccessControlList, rGrant, wGrant)</span>
        case "bucket-owner-full-control":<span class="cov0" title="0">
                grant, err := createGrant(ACL_TYPE_CANON_USER, bucketOwner, ACL_PERM_FULL_CONTROL, "")
                if err != nil </span><span class="cov0" title="0">{
                        return policy, err
                }</span>
                <span class="cov0" title="0">if bucketOwner.ID != owner.ID </span><span class="cov0" title="0">{
                        policy.AccessControlList = append(policy.AccessControlList, grant)
                }</span>
        default:<span class="cov0" title="0">
                return policy, ErrUnsupportedAcl</span>
        }
        <span class="cov0" title="0">return</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package datatype

import (
        . "github.com/soda/multi-cloud/s3/error"
        "time"
)

const (
        Iso8601Format           = "20060102T150405Z"
        YYYYMMDD                = "20060102"
        PresignedUrlExpireLimit = 7 * 24 * time.Hour
)

// Supported Amz date formats.
var amzDateFormats = []string{
        time.RFC1123,
        time.RFC1123Z,
        Iso8601Format,
        // Add new AMZ date formats here.
}

// parseAmzDate - parses date string into supported amz date formats.
func ParseAmzDate(amzDateStr string) (amzDate time.Time, apiErr error) <span class="cov0" title="0">{
        for _, dateFormat := range amzDateFormats </span><span class="cov0" title="0">{
                amzDate, e := time.Parse(dateFormat, amzDateStr)
                if e == nil </span><span class="cov0" title="0">{
                        return amzDate, nil
                }</span>
        }
        <span class="cov0" title="0">return time.Time{}, ErrMalformedDate</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">/*
 * Minio Cloud Storage, (C) 2015, 2016 Minio, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package datatype

import (
        "errors"
        "fmt"
        "regexp"
        "strconv"
        "strings"
)

const (
        byteRangePrefix = "bytes="
)

// Valid byte position regexp
var validBytePos = regexp.MustCompile(`^[0-9]+$`)

// ErrorInvalidRange - returned when given range value is not valid.
var ErrorInvalidRange = errors.New("Invalid range")

// HttpRange specifies the byte range to be sent to the client.
type HttpRange struct {
        OffsetBegin  int64
        OffsetEnd    int64
        ResourceSize int64
}

// String populate range stringer interface
func (hrange HttpRange) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("bytes %d-%d/%d", hrange.OffsetBegin, hrange.OffsetEnd, hrange.ResourceSize)
}</span>

// getlength - get length from the range.
func (hrange HttpRange) GetLength() int64 <span class="cov0" title="0">{
        return 1 + hrange.OffsetEnd - hrange.OffsetBegin
}</span>

func getOffset(offsetString string) (offset int64, err error) <span class="cov0" title="0">{
        offset = int64(-1)
        if len(offsetString) &gt; 0 </span><span class="cov0" title="0">{
                if !validBytePos.MatchString(offsetString) </span><span class="cov0" title="0">{
                        return offset, fmt.Errorf("'%s' does not have a valid first byte position value", offsetString)
                }</span>

                <span class="cov0" title="0">if offset, err = strconv.ParseInt(offsetString, 10, 64); err != nil </span><span class="cov0" title="0">{
                        return offset, fmt.Errorf("'%s' does not have a valid first byte position value", offsetString)
                }</span>
        }
        <span class="cov0" title="0">return</span>
}

func ParseRequestRange(rangeString string, resourceSize int64) (hrange *HttpRange, err error) <span class="cov0" title="0">{
        // TODO handle multi-range request
        // see https://tools.ietf.org/html/rfc7233

        // Return error if given range string doesn't start with byte range prefix.
        if !strings.HasPrefix(rangeString, byteRangePrefix) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("'%s' does not start with '%s'", rangeString, byteRangePrefix)
        }</span>

        // Trim byte range prefix.
        <span class="cov0" title="0">byteRangeString := strings.TrimPrefix(rangeString, byteRangePrefix)

        // Check if range string contains delimiter '-', else return error. eg. "bytes=8"
        sepIndex := strings.Index(byteRangeString, "-")
        if sepIndex == -1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("'%s' does not have a valid range value", rangeString)
        }</span>

        <span class="cov0" title="0">offsetBeginString := byteRangeString[:sepIndex]
        offsetBegin, err := getOffset(offsetBeginString)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">offsetEndString := byteRangeString[sepIndex+1:]
        offsetEnd, err := getOffset(offsetEndString)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // rangeString contains first and last byte positions. eg. "bytes=2-5"
        <span class="cov0" title="0">if offsetBegin &gt; -1 &amp;&amp; offsetEnd &gt; -1 </span><span class="cov0" title="0">{
                if offsetBegin &gt; offsetEnd </span><span class="cov0" title="0">{
                        // Last byte position is not greater than first byte position. eg. "bytes=5-2"
                        return nil, fmt.Errorf("'%s' does not have valid range value", rangeString)
                }</span>

                // First and last byte positions should not be &gt;= resourceSize.
                <span class="cov0" title="0">if offsetBegin &gt;= resourceSize </span><span class="cov0" title="0">{
                        return nil, ErrorInvalidRange
                }</span>

                <span class="cov0" title="0">if offsetEnd &gt;= resourceSize </span><span class="cov0" title="0">{
                        offsetEnd = resourceSize - 1
                }</span>
        } else<span class="cov0" title="0"> if offsetBegin &gt; -1 </span><span class="cov0" title="0">{
                // rangeString contains only first byte position. eg. "bytes=8-"
                if offsetBegin &gt;= resourceSize </span><span class="cov0" title="0">{
                        // First byte position should not be &gt;= resourceSize.
                        return nil, ErrorInvalidRange
                }</span>

                <span class="cov0" title="0">offsetEnd = resourceSize - 1</span>
        } else<span class="cov0" title="0"> if offsetEnd &gt; -1 </span><span class="cov0" title="0">{
                // rangeString contains only last byte position. eg. "bytes=-3"
                if offsetEnd == 0 </span><span class="cov0" title="0">{
                        // Last byte position should not be zero eg. "bytes=-0"
                        return nil, ErrorInvalidRange
                }</span>

                <span class="cov0" title="0">if offsetEnd &gt;= resourceSize </span><span class="cov0" title="0">{
                        offsetBegin = 0
                }</span> else<span class="cov0" title="0"> {
                        offsetBegin = resourceSize - offsetEnd
                }</span>

                <span class="cov0" title="0">offsetEnd = resourceSize - 1</span>
        } else<span class="cov0" title="0"> {
                // rangeString contains first and last byte positions missing. eg. "bytes=-"
                return nil, fmt.Errorf("'%s' does not have valid range value", rangeString)
        }</span>

        <span class="cov0" title="0">return &amp;HttpRange{offsetBegin, offsetEnd, resourceSize}, nil</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">/*
 * Minio Cloud Storage, (C) 2015, 2016 Minio, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package s3

import (
        "io"
        "io/ioutil"
        "mime/multipart"
        "net/http"
        "strings"

        "github.com/emicklei/go-restful"
        . "github.com/soda/multi-cloud/api/pkg/s3/datatype"
        . "github.com/soda/multi-cloud/s3/error"
        "github.com/soda/multi-cloud/s3/pkg/helper"
)

// validates location constraint from the request body.
// the location value in the request body should match the Region in serverConfig.
// other values of location are not accepted.
// make bucket fails in such cases.
func isValidLocationConstraint(reqBody io.Reader) (err error) <span class="cov0" title="0">{
        var region = helper.CONFIG.Region
        var locationConstraint CreateBucketLocationConfiguration
        e := xmlDecoder(reqBody, &amp;locationConstraint)
        if e != nil </span><span class="cov0" title="0">{
                if e == io.EOF </span><span class="cov0" title="0">{
                        // Failed due to empty request body. The location will be set to
                        // default value from the serverConfig
                        err = nil
                }</span> else<span class="cov0" title="0"> {
                        // Failed due to malformed configuration.
                        err = ErrMalformedXML
                }</span>
        } else<span class="cov0" title="0"> {
                // Region obtained from the body.
                // It should be equal to Region in serverConfig.
                // Else ErrInvalidRegion returned.
                // For empty value location will be to set to  default value from the serverConfig.
                if locationConstraint.Location != "" &amp;&amp; region != locationConstraint.Location </span><span class="cov0" title="0">{
                        err = ErrInvalidRegion
                }</span>
        }
        <span class="cov0" title="0">return err</span>
}

// Supported headers that needs to be extracted.
var supportedHeaders = []string{
        "cache-control",
        "content-disposition",
        "content-encoding",
        "content-language",
        "content-type",
        "expires",
        "website-redirect-location",
        // Add more supported headers here
}

// extractMetadataFromHeader extracts metadata from HTTP header.
func extractMetadataFromHeader(request *restful.Request) map[string]string <span class="cov0" title="0">{
        metadata := make(map[string]string)
        // Save standard supported headers.
        for _, supportedHeader := range supportedHeaders </span><span class="cov0" title="0">{
                if h := request.HeaderParameter(supportedHeader); h != "" </span><span class="cov0" title="0">{
                        metadata[supportedHeader] = h
                }</span>
        }

        // Go through all other headers for any additional headers that needs to be saved.
        <span class="cov0" title="0">for key := range request.Request.Header </span><span class="cov0" title="0">{
                if strings.HasPrefix(strings.ToLower(key), "x-amz-meta-") </span><span class="cov0" title="0">{
                        metadata[key] = request.HeaderParameter(key)
                }</span>
        }
        // Return.
        <span class="cov0" title="0">return metadata</span>
}

// Suffix matcher string matches suffix in a platform specific way.
// For example on windows since its case insensitive we are supposed
// to do case insensitive checks.
func hasSuffix(s string, suffix string) bool <span class="cov0" title="0">{
        return strings.HasSuffix(s, suffix)
}</span>

func extractHTTPFormValues(reader *multipart.Reader) (filePartReader io.Reader,
        formValues map[string]string, err error) <span class="cov0" title="0">{

        formValues = make(map[string]string)
        for </span><span class="cov0" title="0">{
                var part *multipart.Part
                part, err = reader.NextPart()
                if err == io.EOF </span><span class="cov0" title="0">{
                        err = nil
                        break</span>
                }
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, err
                }</span>

                <span class="cov0" title="0">if part.FormName() != "file" </span><span class="cov0" title="0">{
                        var buffer []byte
                        buffer, err = ioutil.ReadAll(part)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, nil, err
                        }</span>
                        <span class="cov0" title="0">formValues[http.CanonicalHeaderKey(part.FormName())] = string(buffer)</span>
                } else<span class="cov0" title="0"> {
                        // "All variables within the form are expanded prior to validating
                        // the POST policy"
                        fileName := part.FileName()
                        objectKey, ok := formValues["Key"]
                        if !ok </span><span class="cov0" title="0">{
                                return nil, nil, ErrMissingFields
                        }</span>
                        <span class="cov0" title="0">if strings.Contains(objectKey, "${filename}") </span><span class="cov0" title="0">{
                                formValues["Key"] = strings.Replace(objectKey, "${filename}", fileName, -1)
                        }</span>

                        <span class="cov0" title="0">filePartReader = part
                        // "The file or content must be the last field in the form.
                        // Any fields below it are ignored."
                        break</span>
                }
        }

        <span class="cov0" title="0">if filePartReader == nil </span><span class="cov0" title="0">{
                err = ErrEmptyEntity
        }</span>
        <span class="cov0" title="0">return</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package s3

import (
        "encoding/xml"
        "time"

        "github.com/emicklei/go-restful"
        "github.com/soda/multi-cloud/api/pkg/common"
        "github.com/soda/multi-cloud/api/pkg/policy"
        "github.com/soda/multi-cloud/s3/pkg/model"
        "github.com/soda/multi-cloud/s3/pkg/utils"
        s3 "github.com/soda/multi-cloud/s3/proto"
        log "github.com/sirupsen/logrus"
)

func parseListBuckets(list *s3.ListBucketsResponse) []byte <span class="cov0" title="0">{
        if list == nil || list.Buckets == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">temp := model.ListAllMyBucketsResult{}

        log.Infof("Parse ListBuckets: %v", list.Buckets)
        //default xmlns
        temp.Xmlns = model.Xmlns
        buckets := []model.Bucket{}
        for _, value := range list.Buckets </span><span class="cov0" title="0">{
                ctime := time.Unix(value.CreateTime, 0).Format(time.RFC3339)
                versionOpts := model.VersioningConfiguration{}
                versionOpts.Status = utils.VersioningDisabled
                if value.Versioning != nil </span><span class="cov0" title="0">{
                        if value.Versioning.Status == utils.VersioningEnabled </span><span class="cov0" title="0">{
                                versionOpts.Status = utils.VersioningEnabled
                        }</span>
                }
                <span class="cov0" title="0">sseOpts := model.SSEConfiguration{}
                if value.ServerSideEncryption != nil </span><span class="cov0" title="0">{
                        if value.ServerSideEncryption.SseType == "SSE" </span><span class="cov0" title="0">{
                                sseOpts.SSE.Enabled = "true"
                        }</span> else<span class="cov0" title="0"> {
                                sseOpts.SSE.Enabled = "false"
                        }</span>
                }
                <span class="cov0" title="0">bucket := model.Bucket{Name: value.Name, CreateTime: ctime, LocationConstraint: value.DefaultLocation,
                        VersionOpts: versionOpts, SSEOpts: sseOpts}
                buckets = append(buckets, bucket)</span>
        }
        <span class="cov0" title="0">temp.Buckets = buckets

        xmlstring, err := xml.MarshalIndent(temp, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("Parse ListBuckets error: %v", err)
                return nil
        }</span>
        <span class="cov0" title="0">xmlstring = []byte(xml.Header + string(xmlstring))
        return xmlstring</span>
}

func (s *APIService) ListBuckets(request *restful.Request, response *restful.Response) <span class="cov0" title="0">{
        if !policy.Authorize(request, response, "bucket:list") </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">log.Infof("Received request for all buckets")

        ctx := common.InitCtxWithAuthInfo(request)
        rsp, err := s.s3Client.ListBuckets(ctx, &amp;s3.BaseRequest{})
        if HandleS3Error(response, request, err, rsp.GetErrorCode()) != nil </span><span class="cov0" title="0">{
                log.Errorf("list bucket failed, err=%v, errCode=%d\n", err, rsp.GetErrorCode())
                return
        }</span>

        <span class="cov0" title="0">realRes := parseListBuckets(rsp)

        log.Infof("Get List of buckets successfully:%v\n", string(realRes))
        response.Write(realRes)</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package s3

import (
        "net/url"
        "sort"

        "github.com/emicklei/go-restful"
        "github.com/soda/multi-cloud/api/pkg/common"
        "github.com/soda/multi-cloud/api/pkg/s3/datatype"
        s3error "github.com/soda/multi-cloud/s3/error"
        pb "github.com/soda/multi-cloud/s3/proto"
        log "github.com/sirupsen/logrus"
)

func (s *APIService) ListBucketUploadRecords(request *restful.Request, response *restful.Response) <span class="cov0" title="0">{
        bucketName := request.PathParameter("bucketName")

        log.Infof("Received request for listing multipart uploads records: %s\n", bucketName)

        parameters, err := parseListUploadsQuery(request.Request.URL.Query())
        if err != nil </span><span class="cov0" title="0">{
                log.Errorln("failed to parse list upload query parameter. err:", err)
                WriteErrorResponse(response, request, err)
                return
        }</span>

        <span class="cov0" title="0">ctx := common.InitCtxWithAuthInfo(request)
        listMultipartsResponse, err := s.s3Client.ListBucketUploadRecords(ctx, &amp;pb.ListBucketUploadRequest{
                BucketName:     bucketName,
                Delimiter:      parameters.Delimiter,
                EncodingType:   parameters.EncodingType,
                MaxUploads:     int32(parameters.MaxUploads),
                KeyMarker:      parameters.KeyMarker,
                Prefix:         parameters.Prefix,
                UploadIdMarker: parameters.UploadIdMarker,
        })
        if err != nil || listMultipartsResponse.ErrorCode != int32(s3error.ErrNoErr) </span><span class="cov0" title="0">{
                log.Errorf("Unable to list multipart uploads. err:", err)
                WriteErrorResponse(response, request, err)
                return
        }</span>

        <span class="cov0" title="0">resData := datatype.ListMultipartUploadsResponse{}
        resData.IsTruncated = listMultipartsResponse.Result.IsTruncated
        resData.NextKeyMarker = listMultipartsResponse.Result.NextKeyMarker
        resData.NextUploadIdMarker = listMultipartsResponse.Result.NextUploadIdMarker
        sort.Strings(listMultipartsResponse.Result.CommonPrefix)
        for _, prefix := range listMultipartsResponse.Result.CommonPrefix </span><span class="cov0" title="0">{
                resData.CommonPrefixes = append(resData.CommonPrefixes, datatype.CommonPrefix{
                        Prefix: prefix,
                })
        }</span>
        <span class="cov0" title="0">for _, upload := range listMultipartsResponse.Result.Uploads </span><span class="cov0" title="0">{
                resData.Uploads = append(resData.Uploads, datatype.Upload{
                        Key:      upload.Key,
                        UploadId: upload.UploadId,
                        Initiator: datatype.Initiator{
                                ID:          upload.Initiator.Id,
                                DisplayName: upload.Initiator.DisplayName,
                        },
                        Owner: datatype.Owner{
                                ID:          upload.Owner.Id,
                                DisplayName: upload.Owner.DisplayName,
                        },
                        StorageClass: upload.StorageClass,
                        Initiated:    upload.Initiated,
                })
        }</span>

        <span class="cov0" title="0">resData.Bucket = bucketName
        resData.KeyMarker = parameters.KeyMarker
        resData.UploadIdMarker = parameters.UploadIdMarker
        resData.MaxUploads = parameters.MaxUploads
        resData.Prefix = parameters.Prefix
        resData.Delimiter = parameters.Delimiter
        resData.EncodingType = parameters.EncodingType
        if resData.EncodingType != "" </span><span class="cov0" title="0">{ // only support "url" encoding for now
                resData.Delimiter = url.QueryEscape(resData.Delimiter)
                resData.KeyMarker = url.QueryEscape(resData.KeyMarker)
                resData.Prefix = url.QueryEscape(resData.Prefix)
                resData.NextKeyMarker = url.QueryEscape(resData.NextKeyMarker)
                for _, upload := range resData.Uploads </span><span class="cov0" title="0">{
                        upload.Key = url.QueryEscape(upload.Key)
                }</span>
        }

        <span class="cov0" title="0">encodedSuccessResponse := EncodeResponse(resData)
        // write success response.
        WriteSuccessResponse(response, encodedSuccessResponse)
        log.Infoln("List bucket multipart uploads successfully.")</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package s3

import (
        "github.com/emicklei/go-restful"
        "github.com/soda/multi-cloud/api/pkg/common"
        "github.com/soda/multi-cloud/api/pkg/s3/datatype"
        pb "github.com/soda/multi-cloud/s3/proto"
        log "github.com/sirupsen/logrus"
)

func (s *APIService) ListObjectParts(request *restful.Request, response *restful.Response) <span class="cov0" title="0">{
        bucketName := request.PathParameter("bucketName")
        objectKey := request.PathParameter("objectKey")
        log.Infof("received request: list object multipart, bucketet[name=%s] object[name=%s]\n", bucketName, objectKey)

        listPartReq, err := parseListObjectPartsQuery(request.Request.URL.Query())
        if err != nil </span><span class="cov0" title="0">{
                log.Errorln("failed to parse object part query parameter. err:", err)
                WriteErrorResponse(response, request, err)
                return
        }</span>

        <span class="cov0" title="0">ctx := common.InitCtxWithAuthInfo(request)
        listObjectPartsRes, err := s.s3Client.ListObjectParts(ctx, &amp;pb.ListObjectPartsRequest{
                BucketName:       bucketName,
                ObjectKey:        objectKey,
                UploadId:         listPartReq.UploadId,
                EncodingType:     listPartReq.EncodingType,
                MaxParts:         int64(listPartReq.MaxParts),
                PartNumberMarker: int64(listPartReq.PartNumberMarker),
        })
        if err != nil </span><span class="cov0" title="0">{
                log.Errorln("unable to list uploaded parts. err:", err)
                WriteErrorResponse(response, request, err)
                return
        }</span>

        <span class="cov0" title="0">data := datatype.ListPartsResponse{
                Bucket:       bucketName,
                Key:          objectKey,
                UploadId:     listPartReq.UploadId,
                EncodingType: listPartReq.EncodingType,
                Initiator: datatype.Initiator(datatype.Owner{
                        ID:          listObjectPartsRes.Initiator.Id,
                        DisplayName: listObjectPartsRes.Initiator.DisplayName,
                }),
                Owner: datatype.Owner{
                        ID:          listObjectPartsRes.Owner.Id,
                        DisplayName: listObjectPartsRes.Owner.DisplayName,
                },
                PartNumberMarker:     int(listObjectPartsRes.PartNumberMarker),
                NextPartNumberMarker: int(listObjectPartsRes.NextPartNumberMarker),
                MaxParts:             int(listObjectPartsRes.MaxParts),
                IsTruncated:          listObjectPartsRes.IsTruncated,
        }
        data.Parts = make([]datatype.Part, 0)
        for _, part := range listObjectPartsRes.Parts </span><span class="cov0" title="0">{
                data.Parts = append(data.Parts, datatype.Part{
                        PartNumber:   int(part.PartNumber),
                        ETag:         part.ETag,
                        LastModified: part.LastModified,
                        Size:         part.Size,
                })
        }</span>

        <span class="cov0" title="0">encodedSuccessResponse := EncodeResponse(data)
        // Write success response.
        log.Infof("list object parts successfully.")
        WriteSuccessResponse(response, encodedSuccessResponse)</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package s3

import (
        "encoding/xml"
        "net/http"
        "github.com/emicklei/go-restful"
        log "github.com/sirupsen/logrus"
        "github.com/soda/multi-cloud/api/pkg/common"
        "github.com/soda/multi-cloud/api/pkg/policy"
        "github.com/soda/multi-cloud/s3/pkg/model"
        "github.com/soda/multi-cloud/s3/proto"
)

func (s *APIService) GetStorageClasses(request *restful.Request, response *restful.Response) <span class="cov0" title="0">{
        if !policy.Authorize(request, response, "storageclass:get") </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">log.Info("Received request for storage classes.")

        ctx := common.InitCtxWithAuthInfo(request)
        res, err := s.s3Client.GetStorageClasses(ctx, &amp;s3.BaseRequest{})
        if err != nil </span><span class="cov0" title="0">{
                response.WriteError(http.StatusInternalServerError, err)
                return
        }</span>

        <span class="cov0" title="0">tmp := model.ListStorageClasses{}
        classes := []model.StorageClass{}
        for _, v := range res.Classes </span><span class="cov0" title="0">{
                classes = append(classes, model.StorageClass{Name: v.Name, Tier: v.Tier})
        }</span>
        <span class="cov0" title="0">tmp.Classes = classes

        xmlstring, err := xml.MarshalIndent(tmp, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("parse ListStorageClasses error: %v\n", err)
                response.WriteError(http.StatusInternalServerError, err)
        }</span> else<span class="cov0" title="0"> {
                xmlstring = []byte(xml.Header + string(xmlstring))
                response.Write(xmlstring)
                log.Infof("Get List of storage classes successfully:%v\n", string(xmlstring))
        }</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package s3

import (
        "github.com/emicklei/go-restful"
        "github.com/soda/multi-cloud/api/pkg/common"
        pb "github.com/soda/multi-cloud/s3/proto"
        log "github.com/sirupsen/logrus"

        . "github.com/soda/multi-cloud/s3/error"
)

func (s *APIService) MultiPartUploadInit(request *restful.Request, response *restful.Response) <span class="cov0" title="0">{
        bucketName := request.PathParameter("bucketName")
        objectKey := request.PathParameter("objectKey")

        log.Infof("received request: multipart init, objectkey=%s, bucketName=%s\n:",
                objectKey, bucketName)

        if !isValidObjectName(objectKey) </span><span class="cov0" title="0">{
                log.Errorf("object name is not valid.")
                WriteErrorResponse(response, request, ErrInvalidObjectName)
                return
        }</span>

        <span class="cov0" title="0">acl, err := getAclFromHeader(request)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to get acl from http header, err:", err)
                WriteErrorResponse(response, request, err)
                return
        }</span>

        // Save metadata.
        <span class="cov0" title="0">attr := extractMetadataFromHeader(request)

        tier, err := getTierFromHeader(request)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to get storage class from http header. err:", err)
                WriteErrorResponse(response, request, err)
                return
        }</span>

        <span class="cov0" title="0">ctx := common.InitCtxWithAuthInfo(request)
        result, err := s.s3Client.InitMultipartUpload(ctx, &amp;pb.InitMultiPartRequest{
                BucketName: bucketName, ObjectKey: objectKey, Acl: &amp;pb.Acl{CannedAcl: acl.CannedAcl}, Tier: int32(tier), Attrs: attr})
        if HandleS3Error(response, request, err, result.GetErrorCode()) != nil </span><span class="cov0" title="0">{
                log.Errorln("unable to init multipart. err:%v, errcode:%v", err, result.ErrorCode)
                return
        }</span>

        <span class="cov0" title="0">data := GenerateInitiateMultipartUploadResponse(bucketName, objectKey, result.UploadID)
        encodedSuccessResponse := EncodeResponse(data)
        // write success response.
        WriteSuccessResponse(response, encodedSuccessResponse)

        log.Infof("Init multipart upload[bucketName=%s, objectKey=%s] successfully.\n",
                bucketName, objectKey)</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">/*
 * Minio Cloud Storage, (C) 2016 Minio, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package s3

import (
        "net/http"
        "strings"
        "time"

        . "github.com/soda/multi-cloud/s3/error"
        pb "github.com/soda/multi-cloud/s3/proto"
)

// Validates the preconditions for CopyObject, returns nil if validates
// Preconditions supported are:
//  x-amz-copy-source-if-modified-since
//  x-amz-copy-source-if-unmodified-since
//  x-amz-copy-source-if-match
//  x-amz-copy-source-if-none-match
func checkObjectPreconditions(w http.ResponseWriter, r *http.Request, object *pb.Object) error <span class="cov0" title="0">{
        // x-amz-copy-source-if-modified-since: Return the object only if it has been modified
        // since the specified time
        ifModifiedSinceHeader := r.Header.Get("x-amz-copy-source-if-modified-since")
        if ifModifiedSinceHeader != "" </span><span class="cov0" title="0">{
                givenTime, err := time.Parse(http.TimeFormat, ifModifiedSinceHeader)
                if err != nil </span><span class="cov0" title="0">{
                        return ErrInvalidPrecondition
                }</span>
                <span class="cov0" title="0">if time.Unix(object.LastModified, 0).Before(givenTime) </span><span class="cov0" title="0">{
                        // If the object is not modified since the specified time.
                        return ErrPreconditionFailed
                }</span>
        }

        // x-amz-copy-source-if-unmodified-since : Return the object only if it has not been
        // modified since the specified time
        <span class="cov0" title="0">ifUnmodifiedSinceHeader := r.Header.Get("x-amz-copy-source-if-unmodified-since")
        if ifUnmodifiedSinceHeader != "" </span><span class="cov0" title="0">{
                givenTime, err := time.Parse(http.TimeFormat, ifUnmodifiedSinceHeader)
                if err != nil </span><span class="cov0" title="0">{
                        return ErrInvalidPrecondition
                }</span>
                <span class="cov0" title="0">if time.Unix(object.LastModified, 0).After(givenTime) </span><span class="cov0" title="0">{
                        // If the object is modified since the specified time.
                        return ErrPreconditionFailed
                }</span>
        }

        // x-amz-copy-source-if-match : Return the object only if its entity tag (ETag) is the
        // same as the one specified
        <span class="cov0" title="0">ifMatchETagHeader := r.Header.Get("x-amz-copy-source-if-match")
        if ifMatchETagHeader != "" </span><span class="cov0" title="0">{
                if !isETagEqual(object.Etag, ifMatchETagHeader) </span><span class="cov0" title="0">{
                        // If the object ETag does not match with the specified ETag.
                        return ErrPreconditionFailed
                }</span>
        }

        // If-None-Match : Return the object only if its entity tag (ETag) is different from the
        // one specified
        <span class="cov0" title="0">ifNoneMatchETagHeader := r.Header.Get("x-amz-copy-source-if-none-match")
        if ifNoneMatchETagHeader != "" </span><span class="cov0" title="0">{
                if isETagEqual(object.Etag, ifNoneMatchETagHeader) </span><span class="cov0" title="0">{
                        // If the object ETag matches with the specified ETag.
                        return ErrPreconditionFailed
                }</span>
        }

        <span class="cov0" title="0">if ifNoneMatchETagHeader != "" &amp;&amp; ifUnmodifiedSinceHeader != "" </span><span class="cov0" title="0">{
                return ErrInvalidPrecondition
        }</span>
        <span class="cov0" title="0">if ifMatchETagHeader != "" &amp;&amp; ifModifiedSinceHeader != "" </span><span class="cov0" title="0">{
                return ErrInvalidPrecondition
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Validates the preconditions for GetObject/HeadObject. Returns nil if validates
// Preconditions supported are:
//  If-Modified-Since
//  If-Unmodified-Since
//  If-Match
//  If-None-Match
func checkPreconditions(header http.Header, object *pb.Object) error <span class="cov0" title="0">{
        // If-Modified-Since : Return the object only if it has been modified since the specified time,
        // otherwise return a 304 (not modified).
        ifModifiedSinceHeader := header.Get("If-Modified-Since")
        if ifModifiedSinceHeader != "" </span><span class="cov0" title="0">{
                givenTime, err := time.Parse(http.TimeFormat, ifModifiedSinceHeader)
                if err != nil </span><span class="cov0" title="0">{
                        return ErrInvalidPrecondition
                }</span>
                <span class="cov0" title="0">if time.Unix(object.LastModified, 0).Before(givenTime) </span><span class="cov0" title="0">{
                        // If the object is not modified since the specified time.
                        return ContentNotModified
                }</span>
        }

        // If-Unmodified-Since : Return the object only if it has not been modified since the specified
        // time, otherwise return a 412 (precondition failed).
        <span class="cov0" title="0">ifUnmodifiedSinceHeader := header.Get("If-Unmodified-Since")
        if ifUnmodifiedSinceHeader != "" </span><span class="cov0" title="0">{
                givenTime, err := time.Parse(http.TimeFormat, ifUnmodifiedSinceHeader)
                if err != nil </span><span class="cov0" title="0">{
                        return ErrInvalidPrecondition
                }</span>
                <span class="cov0" title="0">if time.Unix(object.LastModified, 0).After(givenTime) </span><span class="cov0" title="0">{
                        return ErrPreconditionFailed
                }</span>
        }

        // If-Match : Return the object only if its entity tag (ETag) is the same as the one specified;
        // otherwise return a 412 (precondition failed).
        <span class="cov0" title="0">ifMatchETagHeader := header.Get("If-Match")
        if ifMatchETagHeader != "" </span><span class="cov0" title="0">{
                if !isETagEqual(object.Etag, ifMatchETagHeader) </span><span class="cov0" title="0">{
                        // If the object ETag does not match with the specified ETag.
                        return ErrPreconditionFailed
                }</span>
        }

        // If-None-Match : Return the object only if its entity tag (ETag) is different from the
        // one specified otherwise, return a 304 (not modified).
        <span class="cov0" title="0">ifNoneMatchETagHeader := header.Get("If-None-Match")
        if ifNoneMatchETagHeader != "" </span><span class="cov0" title="0">{
                if isETagEqual(object.Etag, ifNoneMatchETagHeader) </span><span class="cov0" title="0">{
                        // If the object ETag matches with the specified ETag.
                        return ContentNotModified
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// canonicalizeETag returns ETag with leading and trailing double-quotes removed,
// if any present
func canonicalizeETag(etag string) string <span class="cov0" title="0">{
        canonicalETag := strings.TrimPrefix(etag, "\"")
        return strings.TrimSuffix(canonicalETag, "\"")
}</span>

// isETagEqual return true if the canonical representations of two ETag strings
// are equal, false otherwise
func isETagEqual(left, right string) bool <span class="cov0" title="0">{
        return canonicalizeETag(left) == canonicalizeETag(right)
}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">/*
 * Minio Cloud Storage, (C) 2015, 2016 Minio, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package s3

import (
        "regexp"
        "strconv"
        "strings"
        "unicode/utf8"
        "fmt"
)

// validBucket regexp.
var validBucket = regexp.MustCompile(`^[a-z0-9][a-z0-9\.\-]{1,61}[a-z0-9]$`)

// IsValidBucketName verifies a bucket name in accordance with Amazon's
// requirements. It must be 3-63 characters long, can contain dashes
// and periods, but must begin and end with a lowercase letter or a number.
// See: http://docs.aws.amazon.com/AmazonS3/latest/dev/BucketRestrictions.html
func isValidBucketName(bucketName string) bool <span class="cov0" title="0">{
        if !validBucket.MatchString(bucketName) </span><span class="cov0" title="0">{
                return false
        }</span>
        // make sure there're no continuous dots
        <span class="cov0" title="0">if strings.Contains(bucketName, "..") </span><span class="cov0" title="0">{
                return false
        }</span>
        // make sure it's not an IP address
        <span class="cov0" title="0">split := strings.Split(bucketName, ".")
        if len(split) == 4 </span><span class="cov0" title="0">{
                for _, p := range split </span><span class="cov0" title="0">{
                        n, err := strconv.Atoi(p)
                        if err == nil &amp;&amp; n &gt;= 0 &amp;&amp; n &lt;= 255 </span><span class="cov0" title="0">{
                                return false
                        }</span>
                }
        }
        <span class="cov0" title="0">return true</span>
}

// IsValidObjectName verifies an object name in accordance with Amazon's
// requirements. It cannot exceed 1024 characters and must be a valid UTF8
// string.
// Some characters require special handling:
// &amp; $ @ = ; : + (space) , ?
// and ASCII ranges 0x00-0x1F(0-31 decimal) and 7F(127 decimal)
// Some characters to avoid:
// \ { ^ } % ` [ ] ' " &lt; &gt; ~ # |
// and non-printable ASCII characters(128-255 decimal)
//
// As in YIG, we PROHIBIT ALL the characters listed above
// See http://docs.aws.amazon.com/AmazonS3/latest/dev/UsingMetadata.html
func isValidObjectName(objectName string) bool <span class="cov0" title="0">{
        if len(objectName) &lt;= 0 || len(objectName) &gt; 1024 </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">if !utf8.ValidString(objectName) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">for _, n := range objectName </span><span class="cov0" title="0">{
                if (n &gt;= 0 &amp;&amp; n &lt;= 31) || (n &gt;= 127 &amp;&amp; n &lt;= 255) </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov0" title="0">c := string(n)
                if strings.ContainsAny(c, "\\") </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov0" title="0">return true</span>
}

// Argument position in handler AppendObject must be non-negative integer
func checkPosition(position string) (uint64, error) <span class="cov0" title="0">{
        p, err := strconv.ParseUint(position, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">if p &lt; 0 </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("position must ben on-negative integer.")
        }</span>
        <span class="cov0" title="0">return p, nil</span>
}

func isFirstAppend(position uint64) bool <span class="cov0" title="0">{
        return position == 0
}</span>
</pre>
		
		<pre class="file" id="file31" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package s3

import (
        "encoding/xml"
        "io"
        "io/ioutil"
        "strings"

        "github.com/emicklei/go-restful"
        "github.com/journeymidnight/yig/helper"
        "github.com/soda/multi-cloud/api/pkg/common"
        "github.com/soda/multi-cloud/api/pkg/s3/datatype"
        s3error "github.com/soda/multi-cloud/s3/error"
        pb "github.com/soda/multi-cloud/s3/proto"
        log "github.com/sirupsen/logrus"
)

func (s *APIService) ObjectAclPut(request *restful.Request, response *restful.Response) <span class="cov0" title="0">{
        bucketName := strings.ToLower(request.PathParameter(common.REQUEST_PATH_BUCKET_NAME))
        objectKey := request.PathParameter(common.REQUEST_PATH_OBJECT_KEY)
        log.Infof("received request: PUT bucket[name=%s] object[name=%s] acl\n", bucketName, objectKey)

        var err error
        var acl datatype.Acl
        var policy datatype.AccessControlPolicy
        if _, ok := request.Request.Header[common.REQUEST_HEADER_ACL]; ok </span><span class="cov0" title="0">{
                acl, err = getAclFromHeader(request)
                if err != nil </span><span class="cov0" title="0">{
                        WriteErrorResponse(response, request, err)
                        return
                }</span>
        } else<span class="cov0" title="0"> {
                // because we only support canned acl, the body of request must be not too big, and 1024 is enough
                aclBuffer, err := ioutil.ReadAll(io.LimitReader(request.Request.Body, 1024))
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("unable to read acls body, err:", err)
                        WriteErrorResponse(response, request, s3error.ErrInvalidAcl)
                        return
                }</span>
                <span class="cov0" title="0">err = xml.Unmarshal(aclBuffer, &amp;policy)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("unable to parse acls xml body, err:", err)
                        WriteErrorResponse(response, request, s3error.ErrInternalError)
                        return
                }</span>
        }

        <span class="cov0" title="0">if acl.CannedAcl == "" </span><span class="cov0" title="0">{
                newCannedAcl, err := datatype.GetCannedAclFromPolicy(policy)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error("failed to get canned acl from policy. err:", err)
                        WriteErrorResponse(response, request, err)
                        return
                }</span>
                <span class="cov0" title="0">acl = newCannedAcl</span>
        }

        <span class="cov0" title="0">ctx := common.InitCtxWithAuthInfo(request)
        res, err := s.s3Client.PutObjACL(ctx, &amp;pb.PutObjACLRequest{ACLConfig: &amp;pb.ObjACL{BucketName: bucketName,
                ObjectKey: objectKey, CannedAcl: acl.CannedAcl}})
        if err != nil || res.ErrorCode != int32(s3error.ErrNoErr) </span><span class="cov0" title="0">{
                WriteErrorResponse(response, request, GetFinalError(err, res.ErrorCode))
                return
        }</span>

        <span class="cov0" title="0">log.Infoln("PUT object acl successfully.")
        WriteSuccessResponse(response, nil)</span>
}

func (s *APIService) ObjectAclGet(request *restful.Request, response *restful.Response) <span class="cov0" title="0">{
        bucketName := strings.ToLower(request.PathParameter(common.REQUEST_PATH_BUCKET_NAME))
        objectKey := request.PathParameter(common.REQUEST_PATH_OBJECT_KEY)
        log.Infof("received request: GET bucket[name=%s] object[name=%s] acl\n", bucketName, objectKey)

        ctx := common.InitCtxWithAuthInfo(request)
        object, err := s.getObjectMeta(ctx, bucketName, objectKey, "")
        if err != nil </span><span class="cov0" title="0">{
                log.Error("failed to get object[%s] meta", objectKey)
                WriteErrorResponse(response, request, err)
                return
        }</span>

        <span class="cov0" title="0">owner := datatype.Owner{ID: object.TenantId, DisplayName: object.TenantId}
        bucketOwner := datatype.Owner{}
        policy, err := datatype.CreatePolicyFromCanned(owner, bucketOwner, datatype.Acl{CannedAcl: object.Acl.CannedAcl})
        if err != nil </span><span class="cov0" title="0">{
                log.Error("failed to create policy. err:", err)
                WriteErrorResponse(response, request, err)
                return
        }</span>

        <span class="cov0" title="0">aclBuffer, err := xmlFormat(policy)
        if err != nil </span><span class="cov0" title="0">{
                helper.ErrorIf(err, "failed to marshal acl XML for bucket", bucketName)
                WriteErrorResponse(response, request, s3error.ErrInternalError)
                return
        }</span>

        <span class="cov0" title="0">setXmlHeader(response, aclBuffer)
        WriteSuccessResponse(response, aclBuffer)
        log.Infoln("GET object acl successfully.")</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package s3

import (
        "net/url"
        "strings"
        "time"

        "github.com/emicklei/go-restful"
        "github.com/micro/go-micro/client"
        "github.com/soda/multi-cloud/api/pkg/common"
        . "github.com/soda/multi-cloud/s3/error"
        "github.com/soda/multi-cloud/s3/pkg/meta/types"
        "github.com/soda/multi-cloud/s3/pkg/utils"
        pb "github.com/soda/multi-cloud/s3/proto"
        log "github.com/sirupsen/logrus"
)

func getTierFromHeader(request *restful.Request) (types.StorageClass, error) <span class="cov0" title="0">{
        storageClassStr := request.HeaderParameter(common.REQUEST_HEADER_STORAGE_CLASS)
        if storageClassStr != "" </span><span class="cov0" title="0">{
                return types.MatchStorageClassIndex(storageClassStr)
        }</span> else<span class="cov0" title="0"> {
                // If you don't specify this header, STANDARD will be used
                return utils.Tier1, nil
        }</span>
}

// ObjectCopy copy object from http header x-amz-copy-source
func (s *APIService) ObjectCopy(request *restful.Request, response *restful.Response) <span class="cov0" title="0">{
        log.Infof("received request: Copy object")

        targetBucketName := request.PathParameter(common.REQUEST_PATH_BUCKET_NAME)
        targetObjectName := request.PathParameter(common.REQUEST_PATH_OBJECT_KEY)
        //backendName := request.HeaderParameter(common.REQUEST_HEADER_STORAGE_CLASS)
        log.Infof("received request: Copy object, objectkey=%s, bucketName=%s\n:",
                targetObjectName, targetBucketName)

        // copy source is of form: /bucket-name/object-name?versionId=xxxxxx
        copySource := request.HeaderParameter(common.REQUEST_HEADER_COPY_SOURCE)
        if copySource == "" </span><span class="cov0" title="0">{
                WriteErrorResponse(response, request, ErrInvalidCopySource)
                return
        }</span>
        // Skip the first element if it is '/', split the rest.
        <span class="cov0" title="0">if strings.HasPrefix(copySource, "/") </span><span class="cov0" title="0">{
                copySource = copySource[1:]
        }</span>
        <span class="cov0" title="0">splits := strings.SplitN(copySource, "/", 2)

        // Save sourceBucket and sourceObject extracted from url Path.
        var err error
        var sourceBucketName, sourceObjectName, sourceVersion string
        if len(splits) == 2 </span><span class="cov0" title="0">{
                sourceBucketName = splits[0]
                sourceObjectName = splits[1]
        }</span> else<span class="cov0" title="0"> {
                log.Infoln("copy source should be splited at least two parts.")
                WriteErrorResponse(response, request, ErrInvalidCopySource)
                return
        }</span>
        // If source object is empty, reply back error.
        <span class="cov0" title="0">if sourceBucketName == "" || sourceObjectName == "" </span><span class="cov0" title="0">{
                WriteErrorResponse(response, request, ErrInvalidCopySource)
                return
        }</span>

        <span class="cov0" title="0">splits = strings.SplitN(sourceObjectName, "?", 2)
        if len(splits) == 2 </span><span class="cov0" title="0">{
                sourceObjectName = splits[0]
                if !strings.HasPrefix(splits[1], "versionId=") </span><span class="cov0" title="0">{
                        WriteErrorResponse(response, request, ErrInvalidCopySource)
                        return
                }</span>
                <span class="cov0" title="0">sourceVersion = strings.TrimPrefix(splits[1], "versionId=")</span>
        }

        // X-Amz-Copy-Source should be URL-encoded
        <span class="cov0" title="0">sourceBucketName, err = url.QueryUnescape(sourceBucketName)
        if err != nil </span><span class="cov0" title="0">{
                WriteErrorResponse(response, request, ErrInvalidCopySource)
                return
        }</span>
        <span class="cov0" title="0">sourceObjectName, err = url.QueryUnescape(sourceObjectName)
        if err != nil </span><span class="cov0" title="0">{
                WriteErrorResponse(response, request, ErrInvalidCopySource)
                return
        }</span>

        <span class="cov0" title="0">var isOnlyUpdateMetadata = false
        if sourceBucketName == targetBucketName &amp;&amp; sourceObjectName == targetObjectName </span><span class="cov0" title="0">{
                if request.HeaderParameter("X-Amz-Metadata-Directive") == "COPY" </span><span class="cov0" title="0">{
                        WriteErrorResponse(response, request, ErrInvalidCopyDest)
                        return
                }</span> else<span class="cov0" title="0"> if request.HeaderParameter("X-Amz-Metadata-Directive") == "REPLACE" </span><span class="cov0" title="0">{
                        isOnlyUpdateMetadata = true
                }</span> else<span class="cov0" title="0"> {
                        WriteErrorResponse(response, request, ErrInvalidRequestBody)
                        return
                }</span>
        }

        <span class="cov0" title="0">log.Infoln("sourceBucketName:", sourceBucketName, " sourceObjectName:", sourceObjectName, " sourceVersion:", sourceVersion)

        ctx := common.InitCtxWithAuthInfo(request)
        sourceObject, err := s.getObjectMeta(ctx, sourceBucketName, sourceObjectName, "")
        if err != nil </span><span class="cov0" title="0">{
                log.Errorln("unable to fetch object info. err:", err)
                WriteErrorResponse(response, request, err)
                return
        }</span>

        // Verify before x-amz-copy-source preconditions before continuing with CopyObject.
        <span class="cov0" title="0">if err = checkObjectPreconditions(response.ResponseWriter, request.Request, sourceObject); err != nil </span><span class="cov0" title="0">{
                WriteErrorResponse(response, request, err)
                return
        }</span>

        //TODO: In a versioning-enabled bucket, you cannot change the storage class of a specific version of an object. When you copy it, Amazon S3 gives it a new version ID.
        <span class="cov0" title="0">storClass, err := getTierFromHeader(request)
        if err != nil </span><span class="cov0" title="0">{
                WriteErrorResponse(response, request, err)
                return
        }</span>

        // if source == dest and X-Amz-Metadata-Directive == REPLACE, only update the meta;
        <span class="cov0" title="0">if isOnlyUpdateMetadata </span><span class="cov0" title="0">{
                log.Infoln("only update metadata.")
                targetObject := sourceObject

                //update custom attrs from headers
                newMetadata := extractMetadataFromHeader(request)
                if c, ok := newMetadata["Content-Type"]; ok </span><span class="cov0" title="0">{
                        targetObject.ContentType = c
                }</span> else<span class="cov0" title="0"> {
                        targetObject.ContentType = sourceObject.ContentType
                }</span>
                <span class="cov0" title="0">targetObject.CustomAttributes = newMetadata
                targetObject.Tier = int32(storClass)

                result, err := s.s3Client.UpdateObjectMeta(ctx, targetObject)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("unable to update object meta for %v", targetObject.ObjectId)
                        WriteErrorResponse(response, request, err)
                        return
                }</span>
                <span class="cov0" title="0">copyObjRes := GenerateCopyObjectResponse(result.Md5, time.Unix(result.LastModified, 0))
                encodedSuccessResponse := EncodeResponse(copyObjRes)
                // write headers
                if result.Md5 != "" </span><span class="cov0" title="0">{
                        response.ResponseWriter.Header()["ETag"] = []string{"\"" + result.Md5 + "\""}
                }</span>
                <span class="cov0" title="0">if sourceVersion != "" </span><span class="cov0" title="0">{
                        response.AddHeader("x-amz-copy-source-version-id", sourceVersion)
                }</span>
                <span class="cov0" title="0">if result.VersionId != "" </span><span class="cov0" title="0">{
                        response.AddHeader("x-amz-version-id", result.VersionId)
                }</span>

                <span class="cov0" title="0">log.Info("Update object meta successfully.")
                // write success response.
                WriteSuccessResponse(response, encodedSuccessResponse)
                return</span>
        }

        /// maximum Upload size for object in a single CopyObject operation.
        <span class="cov0" title="0">if isMaxObjectSize(sourceObject.Size) </span><span class="cov0" title="0">{
                WriteErrorResponseWithResource(response, request, ErrEntityTooLarge, copySource)
                return
        }</span>

        <span class="cov0" title="0">log.Infoln("srcBucket:", sourceBucketName, " srcObject:", sourceObjectName,
                " targetBucket:", targetBucketName, " targetObject:", targetObjectName)
        tmoutSec := sourceObject.Size / MiniSpeed
        opt := client.WithRequestTimeout(time.Duration(tmoutSec) * time.Second)
        result, err := s.s3Client.CopyObject(ctx, &amp;pb.CopyObjectRequest{
                SrcBucketName:    sourceBucketName,
                TargetBucketName: targetBucketName,
                SrcObjectName:    sourceObjectName,
                TargetObjectName: targetObjectName,
        }, opt)
        if HandleS3Error(response, request, err, result.GetErrorCode()) != nil </span><span class="cov0" title="0">{
                log.Errorf("unable to copy object, err=%v, errCode=%v\n", err, result.GetErrorCode())
                return
        }</span>

        <span class="cov0" title="0">copyObjRes := GenerateCopyObjectResponse(result.Md5, time.Unix(result.LastModified, 0))
        encodedSuccessResponse := EncodeResponse(copyObjRes)
        // write headers
        if result.Md5 != "" </span><span class="cov0" title="0">{
                response.ResponseWriter.Header()["ETag"] = []string{"\"" + result.Md5 + "\""}
        }</span>

        // write success response.
        <span class="cov0" title="0">WriteSuccessResponse(response, encodedSuccessResponse)
        log.Info("COPY object successfully.")</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package s3

import (
        "strings"

        "github.com/emicklei/go-restful"
        "github.com/soda/multi-cloud/api/pkg/common"
        . "github.com/soda/multi-cloud/s3/error"
        "github.com/soda/multi-cloud/s3/proto"
        log "github.com/sirupsen/logrus"
)

func (s *APIService) ObjectDelete(request *restful.Request, response *restful.Response) <span class="cov0" title="0">{
        url := request.Request.URL
        bucketName := request.PathParameter("bucketName")
        objectName := request.PathParameter("objectKey")
        version := url.Query().Get("versionId")
        if strings.HasSuffix(url.String(), "/") </span><span class="cov0" title="0">{ // This is for folder.
                objectName = objectName + "/"
        }</span>

        <span class="cov0" title="0">if len(bucketName) == 0 </span><span class="cov0" title="0">{
                log.Errorf("invalid input, bucket=%s\n", bucketName)
                WriteErrorResponse(response, request, ErrInvalidBucketName)
                return
        }</span>
        <span class="cov0" title="0">if len(objectName) == 0 </span><span class="cov0" title="0">{
                log.Errorf("invalid input, object=%s\n", objectName)
                WriteErrorResponse(response, request, ErrInvalidObjectName)
        }</span>

        <span class="cov0" title="0">input := s3.DeleteObjectInput{Bucket: bucketName, Key: objectName}
        if len(version) &gt; 0 </span><span class="cov0" title="0">{
                input.VersioId = version
        }</span>
        <span class="cov0" title="0">ctx := common.InitCtxWithAuthInfo(request)
        rsp, err := s.s3Client.DeleteObject(ctx, &amp;input)
        if HandleS3Error(response, request, err, rsp.GetErrorCode()) != nil </span><span class="cov0" title="0">{
                log.Errorf("delete object[%s] failed, err=%v, errCode=%d\n", objectName, err, rsp.GetErrorCode())
                return
        }</span>

        <span class="cov0" title="0">if rsp.DeleteMarker </span><span class="cov0" title="0">{
                response.Header().Set("x-amz-delete-marker", "true")
        }</span> else<span class="cov0" title="0"> {
                response.Header().Set("x-amz-delete-marker", "false")
        }</span>
        <span class="cov0" title="0">if rsp.VersionId != "" </span><span class="cov0" title="0">{
                response.Header().Set("x-amz-version-id", rsp.VersionId)
        }</span>

        <span class="cov0" title="0">log.Infof("delete object[%s] from bucket[%s] succeed.", objectName, bucketName)
        WriteSuccessNoContent(response)</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package s3

import (
        "io"
        "net/http"
        "net/url"
        "time"

        "github.com/emicklei/go-restful"
        "github.com/micro/go-micro/client"
        "github.com/soda/multi-cloud/api/pkg/common"
        . "github.com/soda/multi-cloud/api/pkg/s3/datatype"
        s3error "github.com/soda/multi-cloud/s3/error"
        pb "github.com/soda/multi-cloud/s3/proto"
        log "github.com/sirupsen/logrus"
)

var MiniSpeed int64 = 5 // 5KByte/Sec

// supportedGetReqParams - supported request parameters for GET presigned request.
var supportedGetReqParams = map[string]string{
        "response-expires":             "Expires",
        "response-content-type":        "Content-Type",
        "response-cache-control":       "Cache-Control",
        "response-content-disposition": "Content-Disposition",
        "response-content-language":    "Content-Language",
        "response-content-encoding":    "Content-Encoding",
}

// setGetRespHeaders - set any requested parameters as response headers.
func setGetRespHeaders(w http.ResponseWriter, reqParams url.Values) <span class="cov0" title="0">{
        for k, v := range reqParams </span><span class="cov0" title="0">{
                if header, ok := supportedGetReqParams[k]; ok </span><span class="cov0" title="0">{
                        w.Header()[header] = v
                }</span>
        }
}

// GetObjectHandler - GET Object
func (s *APIService) ObjectGet(request *restful.Request, response *restful.Response) <span class="cov0" title="0">{
        bucketName := request.PathParameter("bucketName")
        objectKey := request.PathParameter("objectKey")
        rangestr := request.HeaderParameter("Range")
        log.Infof("%v\n", rangestr)

        ctx := common.InitCtxWithAuthInfo(request)
        object, err := s.getObjectMeta(ctx, bucketName, objectKey, "")
        if err != nil </span><span class="cov0" title="0">{
                log.Errorln("get object meta failed. err:", err)
                WriteErrorResponse(response, request, err)
                return
        }</span>

        // Get request range.
        <span class="cov0" title="0">var hrange *HttpRange
        rangeHeader := request.HeaderParameter("Range")
        if rangeHeader != "" </span><span class="cov0" title="0">{
                if hrange, err = ParseRequestRange(rangeHeader, object.Size); err != nil </span><span class="cov0" title="0">{
                        // Handle only ErrorInvalidRange
                        // Ignore other parse error and treat it as regular Get request like Amazon S3.
                        if err == ErrorInvalidRange </span><span class="cov0" title="0">{
                                WriteErrorResponse(response, request, s3error.ErrInvalidRange)
                                return
                        }</span>
                        // log the error.
                        <span class="cov0" title="0">log.Errorln("invalid request range, err:", err)</span>
                }
        }

        // Validate pre-conditions if any.
        <span class="cov0" title="0">if err = checkPreconditions(request.Request.Header, object); err != nil </span><span class="cov0" title="0">{
                // set object-related metadata headers
                response.AddHeader("Last-Modified", time.Unix(object.LastModified, 0).UTC().Format(http.TimeFormat))

                if object.Etag != "" </span><span class="cov0" title="0">{
                        response.ResponseWriter.Header()["ETag"] = []string{"\"" + object.Etag + "\""}
                }</span>
                <span class="cov0" title="0">if err == s3error.ContentNotModified </span><span class="cov0" title="0">{ // write only header if is a 304
                        WriteErrorResponseHeaders(response, err)
                }</span> else<span class="cov0" title="0"> {
                        WriteErrorResponse(response, request, err)
                }</span>
                <span class="cov0" title="0">return</span>
        }

        // Get the object.
        <span class="cov0" title="0">startOffset := int64(0)
        length := object.Size
        if hrange != nil </span><span class="cov0" title="0">{
                startOffset = hrange.OffsetBegin
                length = hrange.GetLength()
        }</span>
        <span class="cov0" title="0">tmoutSec := object.Size / MiniSpeed
        opt := client.WithRequestTimeout(time.Duration(tmoutSec) * time.Second)
        stream, err := s.s3Client.GetObject(ctx, &amp;pb.GetObjectInput{Bucket: bucketName, Key: objectKey, Offset: startOffset, Length: length}, opt)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorln("get object failed, err:%v", err)
                WriteErrorResponse(response, request, err)
                return
        }</span>
        <span class="cov0" title="0">defer stream.Close()

        // Indicates if any data was written to the http.ResponseWriter
        dataWritten := false
        // io.Writer type which keeps track if any data was written.
        writer := func(p []byte) (int, error) </span><span class="cov0" title="0">{
                if !dataWritten </span><span class="cov0" title="0">{
                        // Set headers on the first write.
                        // Set standard object headers.
                        SetObjectHeaders(response, object, hrange)

                        // Set any additional requested response headers.
                        setGetRespHeaders(response.ResponseWriter, request.Request.URL.Query())
                        dataWritten = true
                }</span>
                <span class="cov0" title="0">n, err := response.Write(p)
                return n, err</span>
        }

        <span class="cov0" title="0">s3err := int32(s3error.ErrNoErr)
        eof := false
        left := length
        for !eof &amp;&amp; left &gt; 0 </span><span class="cov0" title="0">{
                rsp, err := stream.Recv()
                if err != nil &amp;&amp; err != io.EOF </span><span class="cov0" title="0">{
                        log.Errorln("recv err", err)
                        break</span>
                }
                // If err is equal to EOF, a non-zero number of bytes may be returned.
                // the err is set EOF, returned data is processed at the subsequent code.
                <span class="cov0" title="0">if err == io.EOF </span><span class="cov0" title="0">{
                        eof = true
                }</span>
                // It indicate that there is a error from grpc server.
                <span class="cov0" title="0">if rsp.GetErrorCode() != int32(s3error.ErrNoErr) </span><span class="cov0" title="0">{
                        s3err = rsp.GetErrorCode()
                        log.Errorf("received s3 service error, error code:%v", s3err)
                        break</span>
                }
                // If there is no data in rsp.Data, it show that there is no more data to receive
                <span class="cov0" title="0">if len(rsp.Data) == 0 </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">_, err = writer(rsp.Data)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorln("failed to write data to client. err:", err)
                        break</span>
                }
                <span class="cov0" title="0">left -= int64(len(rsp.Data))</span>
        }
        <span class="cov0" title="0">log.Debugf("left bytes=%d\n", left)

        if !dataWritten </span><span class="cov0" title="0">{
                if s3err == int32(s3error.ErrNoErr) </span><span class="cov0" title="0">{
                        writer(nil)
                }</span> else<span class="cov0" title="0"> {
                        WriteErrorResponse(response, request, s3error.S3ErrorCode(s3err))
                        return
                }</span>
        }

        <span class="cov0" title="0">log.Infof("Get object[%s] end.\n", objectKey)</span>
}

func (s *APIService) HeadObject(request *restful.Request, response *restful.Response) <span class="cov0" title="0">{
        bucketName := request.PathParameter("bucketName")
        objectKey := request.PathParameter("objectKey")
        versionId := request.Request.URL.Query().Get("versionId")
        log.Infof("Received request for head object: bucket=%s, objectkey=%s, version=%s\n", bucketName, objectKey, versionId)

        ctx := common.InitCtxWithAuthInfo(request)
        object, err := s.getObjectMeta(ctx, bucketName, objectKey, versionId)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("head object[bucketname=%s, key=%s] failed, err=%v\n", bucketName, objectKey, err)
                WriteErrorResponse(response, request, err)
                return
        }</span>

        <span class="cov0" title="0">if object.DeleteMarker </span><span class="cov0" title="0">{
                response.Header().Set("x-amz-delete-marker", "true")
                log.Errorf("object[bucketname=%s, key=%s] is marked as deleted\n", bucketName, objectKey)
                WriteErrorResponse(response, request, s3error.ErrNoSuchKey)
                return
        }</span>

        // Get request range.
        <span class="cov0" title="0">rangeHeader := request.Request.Header.Get("Range")
        if rangeHeader != "" </span><span class="cov0" title="0">{
                if _, err = ParseRequestRange(rangeHeader, object.Size); err != nil </span><span class="cov0" title="0">{
                        // Handle only ErrorInvalidRange
                        // Ignore other parse error and treat it as regular Get request like Amazon S3.
                        if err == ErrorInvalidRange </span><span class="cov0" title="0">{
                                WriteErrorResponse(response, request, s3error.ErrInvalidRange)
                                log.Errorf("invalid request range: %s\n", rangeHeader)
                                return
                        }</span>
                }
        }

        // Validate pre-conditions if any.
        <span class="cov0" title="0">if err = checkPreconditions(request.Request.Header, object); err != nil </span><span class="cov0" title="0">{
                // set object-related metadata headers
                response.Header().Set("Last-Modified", time.Unix(object.LastModified, 0).Format(http.TimeFormat))

                if object.Etag != "" </span><span class="cov0" title="0">{
                        response.Header()["ETag"] = []string{"\"" + object.Etag + "\""}
                }</span>
                <span class="cov0" title="0">if err == s3error.ContentNotModified </span><span class="cov0" title="0">{ // write only header if is a 304
                        log.Infof("content not modifed")
                        WriteErrorResponseHeaders(response, err)
                }</span> else<span class="cov0" title="0"> {
                        log.Errorln("head object failed, err:", err)
                        WriteErrorResponse(response, request, err)
                }</span>
                <span class="cov0" title="0">return</span>
        }

        // TODO: add sse header to response

        <span class="cov0" title="0">log.Debugf("object:%+v\n", object)
        // Set standard object headers.
        SetObjectHeaders(response, object, nil)

        // Successful response.
        response.WriteHeader(http.StatusOK)</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package s3

import (
        "net/url"
        "strconv"
        "strings"

        "github.com/emicklei/go-restful"
        "github.com/journeymidnight/yig/helper"
        "github.com/soda/multi-cloud/api/pkg/common"
        "github.com/soda/multi-cloud/api/pkg/s3/datatype"
        . "github.com/soda/multi-cloud/s3/error"

        pb "github.com/soda/multi-cloud/s3/proto"
        log "github.com/sirupsen/logrus"
)

// ObjectPartCopy copy object from http header x-amz-copy-source as a part for multipart
func (s *APIService) ObjectPartCopy(request *restful.Request, response *restful.Response) <span class="cov0" title="0">{
        targetBucketName := request.PathParameter(common.REQUEST_PATH_BUCKET_NAME)
        targetObjectName := request.PathParameter(common.REQUEST_PATH_OBJECT_KEY)

        log.Infof("received request: Copy object part, target bucket[%v], target object[%s]", targetBucketName, targetObjectName)

        if !isValidObjectName(targetObjectName) </span><span class="cov0" title="0">{
                log.Errorln("target object name is invalid. ")
                WriteErrorResponse(response, request, ErrInvalidObjectName)
                return
        }</span>

        <span class="cov0" title="0">uploadID := request.QueryParameter("uploadId")
        partIDString := request.QueryParameter("partNumber")
        partID, err := strconv.Atoi(partIDString)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to convert part id string[%s] to integer, err:%v", partIDString, err)
                WriteErrorResponse(response, request, ErrInvalidPart)
                return
        }</span>
        // check partID with maximum part ID for multipart objects
        <span class="cov0" title="0">if isMaxPartID(partID) </span><span class="cov0" title="0">{
                log.Errorln("part ID is greater than the maximum allowed ID.")
                WriteErrorResponse(response, request, ErrInvalidMaxParts)
                return
        }</span>

        // copy source is of form: /bucket-name/object-name?versionId=xxxxxx
        <span class="cov0" title="0">copySource := request.HeaderParameter(common.REQUEST_HEADER_COPY_SOURCE)

        // Skip the first element if it is '/', split the rest.
        if strings.HasPrefix(copySource, "/") </span><span class="cov0" title="0">{
                copySource = copySource[1:]
        }</span>
        <span class="cov0" title="0">splits := strings.SplitN(copySource, "/", 2)

        // Save sourceBucket and sourceObject extracted from url Path.
        var sourceBucketName, sourceObjectName string
        if len(splits) == 2 </span><span class="cov0" title="0">{
                sourceBucketName = splits[0]
                sourceObjectName = splits[1]
        }</span> else<span class="cov0" title="0"> {
                log.Infoln("copy source should be splited at least two parts.")
                WriteErrorResponse(response, request, ErrInvalidCopySource)
                return
        }</span>
        // If source object is empty, reply back error.
        <span class="cov0" title="0">if sourceBucketName == "" || sourceObjectName == "" </span><span class="cov0" title="0">{
                log.Errorln("there is no string for sourceBucketName or sourceObjectName.")
                WriteErrorResponse(response, request, ErrInvalidCopySource)
                return
        }</span>

        <span class="cov0" title="0">splits = strings.SplitN(sourceObjectName, "?", 2)
        if len(splits) &gt; 1 </span><span class="cov0" title="0">{
                // we dont support source object name that has "?"
                log.Errorln("we dont support source object name that has ?")
                WriteErrorResponse(response, request, ErrNotImplemented)
                return
        }</span>

        // X-Amz-Copy-Source should be URL-encoded
        <span class="cov0" title="0">sourceBucketName, err = url.QueryUnescape(sourceBucketName)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorln("failed to QueryUnescape. err:", err)
                WriteErrorResponse(response, request, ErrInvalidCopySource)
                return
        }</span>
        <span class="cov0" title="0">sourceObjectName, err = url.QueryUnescape(sourceObjectName)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorln("failed to QueryUnescape. err:", err)
                WriteErrorResponse(response, request, ErrInvalidCopySource)
                return
        }</span>

        <span class="cov0" title="0">ctx := common.InitCtxWithAuthInfo(request)
        getObjMetaRes, err := s.s3Client.GetObjectMeta(ctx, &amp;pb.Object{
                ObjectKey:  sourceObjectName,
                BucketName: sourceBucketName,
        })
        if HandleS3Error(response, request, err, getObjMetaRes.GetErrorCode()) != nil </span><span class="cov0" title="0">{
                log.Errorf("unable to fetch object meta. err:%v, errCode:%v", err, getObjMetaRes.ErrorCode)
                return
        }</span>

        // Verify before x-amz-copy-source preconditions before continuing with CopyObject.
        <span class="cov0" title="0">if err = checkObjectPreconditions(response.ResponseWriter, request.Request, getObjMetaRes.Object); err != nil </span><span class="cov0" title="0">{
                log.Infof("failed to check object preconditions. err:", err)
                WriteErrorResponse(response, request, err)
                return
        }</span>

        <span class="cov0" title="0">var readOffset, readLength int64
        copySourceRangeString := request.HeaderParameter(common.REQUEST_HEADER_COPY_SOURCE_RANGE)
        if copySourceRangeString == "" </span><span class="cov0" title="0">{
                readOffset = 0
                readLength = getObjMetaRes.Object.Size
        }</span> else<span class="cov0" title="0"> {
                copySourceRange, err := datatype.ParseRequestRange(copySourceRangeString, getObjMetaRes.Object.Size)
                if err != nil </span><span class="cov0" title="0">{
                        helper.ErrorIf(err, "Invalid request range, err:", err)
                        WriteErrorResponse(response, request, ErrInvalidRange)
                        return
                }</span>
                <span class="cov0" title="0">readOffset = copySourceRange.OffsetBegin
                readLength = copySourceRange.GetLength()</span>
        }
        <span class="cov0" title="0">if isMaxObjectSize(readLength) </span><span class="cov0" title="0">{
                log.Errorf("object size is too large. size:%v", readLength)
                WriteErrorResponseWithResource(response, request, ErrEntityTooLarge, copySource)
                return
        }</span>

        <span class="cov0" title="0">result, err := s.s3Client.CopyObjPart(ctx, &amp;pb.CopyObjPartRequest{
                TargetBucket: targetBucketName,
                TargetObject: targetObjectName,
                SourceObject: sourceObjectName,
                SourceBucket: sourceBucketName,
                UploadID:     uploadID,
                PartID:       int64(partID),
                ReadOffset:   readOffset,
                ReadLength:   readLength,
        })
        if HandleS3Error(response, request, err, result.ErrorCode) != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to copy object part s3. err:%v, errCode:%v", err, result.ErrorCode)
                return
        }</span>

        <span class="cov0" title="0">data := GenerateCopyObjectPartResponse(result.Etag, result.LastModified)
        encodedSuccessResponse := EncodeResponse(data)
        // write headers
        if result.Etag != "" </span><span class="cov0" title="0">{
                response.ResponseWriter.Header()["ETag"] = []string{"\"" + result.Etag + "\""}
        }</span>
        <span class="cov0" title="0">log.Infoln("copy object part successfully.")
        // write success response.
        WriteSuccessResponse(response, encodedSuccessResponse)</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package s3

import (
        "io"
        "net/http"
        "net/url"
        "strconv"

        "github.com/emicklei/go-restful"
        "github.com/soda/multi-cloud/api/pkg/common"
        "github.com/soda/multi-cloud/api/pkg/s3/datatype"
        "github.com/soda/multi-cloud/s3/error"
        "github.com/soda/multi-cloud/s3/pkg/helper"
        "github.com/soda/multi-cloud/s3/proto"
        pb "github.com/soda/multi-cloud/s3/proto"
        log "github.com/sirupsen/logrus"
)

// handle post object according to 'https://docs.aws.amazon.com/AmazonS3/latest/API/RESTObjectPOST.html'
var ValidSuccessActionStatus = []string{"200", "201", "204"}

func (s *APIService) ObjectPost(request *restful.Request, response *restful.Response) <span class="cov0" title="0">{
        var err error
        // Here the parameter is the size of the form data that should
        // be loaded in memory, the remaining being put in temporary files.
        reader, err := request.Request.MultipartReader()
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to get reader from post request, err: %v", err)
                WriteErrorResponse(response, request, s3error.ErrMalformedPOSTRequest)
                return
        }</span>

        <span class="cov0" title="0">fileBody, formValues, err := extractHTTPFormValues(reader)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to extract form values, err: %v", err)
                WriteErrorResponse(response, request, s3error.ErrMalformedPOSTRequest)
                return
        }</span>
        <span class="cov0" title="0">objectKey := formValues[common.REQUEST_FORM_KEY]
        if !isValidObjectName(objectKey) </span><span class="cov0" title="0">{
                log.Errorf("got invalid object key: %s", objectKey)
                WriteErrorResponse(response, request, s3error.ErrInvalidObjectName)
                return
        }</span>

        <span class="cov0" title="0">bucketName := request.PathParameter(common.REQUEST_PATH_BUCKET_NAME)
        backendName := request.HeaderParameter(common.REQUEST_HEADER_STORAGE_CLASS)
        formValues[common.REQUEST_FORM_BUCKET] = bucketName

        // check if specific bucket exist
        ctx := common.InitCtxWithAuthInfo(request)
        bucketMeta, err := s.getBucketMeta(ctx, bucketName)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to get bucket meta. err: %v", err)
                WriteErrorResponse(response, request, err)
                return
        }</span>
        <span class="cov0" title="0">location := bucketMeta.DefaultLocation
        if backendName != "" </span><span class="cov0" title="0">{
                // check if backend exist
                if s.isBackendExist(ctx, backendName) == false </span><span class="cov0" title="0">{
                        log.Errorf("backend %s for bucket %s doesn't exist", backendName, bucketName)
                        WriteErrorResponse(response, request, s3error.ErrGetBackendFailed)
                        return
                }</span>
                <span class="cov0" title="0">location = backendName</span>
        }

        <span class="cov0" title="0">metadata := extractMetadataFromHeader(request)

        acl, err := getAclFromFormValues(formValues)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to get acl from from values, err: %v", err)
                WriteErrorResponse(response, request, s3error.ErrInvalidCannedAcl)
                return
        }</span>

        <span class="cov0" title="0">buf := make([]byte, ChunkSize)
        eof := false
        stream, err := s.s3Client.PutObject(ctx)
        defer stream.Close()
        obj := pb.PutObjectRequest{
                BucketName: bucketName,
                ObjectKey:  objectKey,
                Acl:        &amp;pb.Acl{CannedAcl: acl.CannedAcl},
                Attrs:      metadata,
                Location:   location,
                Size:       -1,
        }
        err = stream.SendMsg(&amp;obj)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to call grpc PutObject(%v), err: %v", obj, err)
                WriteErrorResponse(response, request, s3error.ErrInternalError)
                return
        }</span>
        <span class="cov0" title="0">for !eof </span><span class="cov0" title="0">{
                n, err := fileBody.Read(buf)
                if err != nil &amp;&amp; err != io.EOF </span><span class="cov0" title="0">{
                        log.Errorf("read error:%v", err)
                        break</span>
                }
                <span class="cov0" title="0">if err == io.EOF </span><span class="cov0" title="0">{
                        log.Debugln("finished read")
                        eof = true
                }</span>
                <span class="cov0" title="0">err = stream.Send(&amp;s3.PutDataStream{Data: buf[:n]})
                if err != nil </span><span class="cov0" title="0">{
                        log.Infof("stream send error: %v", err)
                        break</span>
                }
                // make sure that the grpc server receives the EOF.
                <span class="cov0" title="0">if eof </span><span class="cov0" title="0">{
                        stream.Send(&amp;s3.PutDataStream{Data: buf[0:0]})
                }</span>
        }

        // if read or send data failed, then close stream and return error
        <span class="cov0" title="0">if !eof </span><span class="cov0" title="0">{
                log.Errorf("failed to send data to put object.")
                WriteErrorResponse(response, request, s3error.ErrInternalError)
                return
        }</span>

        <span class="cov0" title="0">result := &amp;s3.PutObjectResponse{}
        err = stream.RecvMsg(result)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("stream receive message failed:%v\n", err)
                WriteErrorResponse(response, request, s3error.ErrInternalError)
                return
        }</span>

        <span class="cov0" title="0">log.Info("succeed to put object data for post object request.")
        if result.Md5 != "" </span><span class="cov0" title="0">{
                response.Header().Set("ETag", "\""+result.Md5+"\"")
        }</span>

        <span class="cov0" title="0">var redirect string
        redirect, _ = formValues["Success_action_redirect"]
        if redirect == "" </span><span class="cov0" title="0">{
                redirect, _ = formValues["redirect"]
        }</span>
        <span class="cov0" title="0">if redirect != "" </span><span class="cov0" title="0">{
                redirectUrl, err := url.Parse(redirect)
                if err == nil </span><span class="cov0" title="0">{
                        redirectUrl.Query().Set("bucket", bucketName)
                        redirectUrl.Query().Set("key", objectKey)
                        redirectUrl.Query().Set("etag", result.Md5)
                        http.Redirect(response, request.Request, redirectUrl.String(), http.StatusSeeOther)
                        return
                }</span>
                // If URL is Invalid, ignore the redirect field
        }

        <span class="cov0" title="0">var status string
        status, _ = formValues["Success_action_status"]
        if !helper.StringInSlice(status, ValidSuccessActionStatus) </span><span class="cov0" title="0">{
                status = "204"
        }</span>

        <span class="cov0" title="0">statusCode, _ := strconv.Atoi(status)
        switch statusCode </span>{
        case 200, 204:<span class="cov0" title="0">
                response.WriteHeader(statusCode)</span>
        case 201:<span class="cov0" title="0">
                encodedSuccessResponse := EncodeResponse(datatype.PostResponse{
                        // TODO the full accessable url is needed.
                        Location: "/" + bucketName + "/" + objectKey,
                        Bucket:   bucketName,
                        Key:      objectKey,
                        ETag:     result.Md5,
                })
                response.WriteHeader(201)
                response.Write(encodedSuccessResponse)</span>
        }

}
</pre>
		
		<pre class="file" id="file37" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package s3

import (
        "encoding/hex"
        "errors"
        "fmt"
        "io"
        "strconv"
        "strings"

        "github.com/emicklei/go-restful"
        "github.com/soda/multi-cloud/api/pkg/common"
        "github.com/soda/multi-cloud/s3/error"
        "github.com/soda/multi-cloud/s3/proto"
        pb "github.com/soda/multi-cloud/s3/proto"
        log "github.com/sirupsen/logrus"
)

var ChunkSize int = 2048

//ObjectPut -
func (s *APIService) ObjectPut(request *restful.Request, response *restful.Response) <span class="cov0" title="0">{
        bucketName := request.PathParameter(common.REQUEST_PATH_BUCKET_NAME)
        objectKey := request.PathParameter(common.REQUEST_PATH_OBJECT_KEY)
        backendName := request.HeaderParameter(common.REQUEST_HEADER_STORAGE_CLASS)
        url := request.Request.URL
        if strings.HasSuffix(url.String(), "/") </span><span class="cov0" title="0">{
                objectKey = objectKey + "/"
        }</span>
        <span class="cov0" title="0">log.Infof("received request: PUT object, objectkey=%s, bucketName=%s\n:",
                objectKey, bucketName)

        //var authType = signature.GetRequestAuthType(r)
        var err error
        if !isValidObjectName(objectKey) </span><span class="cov0" title="0">{
                WriteErrorResponse(response, request, s3error.ErrInvalidObjectName)
                return
        }</span>

        // get size
        <span class="cov0" title="0">size, err := getSize(request, response)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if size == -1 </span><span class="cov0" title="0">{
                WriteErrorResponse(response, request, s3error.ErrMissingContentLength)
                return
        }</span>

        // maximum Upload size for objects in a single operation
        <span class="cov0" title="0">if isMaxObjectSize(size) </span><span class="cov0" title="0">{
                WriteErrorResponse(response, request, s3error.ErrEntityTooLarge)
                return
        }</span>

        // Save metadata.
        <span class="cov0" title="0">metadata := extractMetadataFromHeader(request)
        // Get Content-Md5 sent by client and verify if valid
        if _, ok := request.Request.Header["Content-Md5"]; !ok </span><span class="cov0" title="0">{
                metadata["md5Sum"] = ""
        }</span> else<span class="cov0" title="0"> {
                if len(request.Request.Header.Get("Content-Md5")) == 0 </span><span class="cov0" title="0">{
                        log.Infoln("Content Md5 is null!")
                        WriteErrorResponse(response, request, s3error.ErrInvalidDigest)
                        return
                }</span>
                <span class="cov0" title="0">md5Bytes, err := checkValidMD5(request.Request.Header.Get("Content-Md5"))
                if err != nil </span><span class="cov0" title="0">{
                        log.Infoln("Content Md5 is invalid!")
                        WriteErrorResponse(response, request, s3error.ErrInvalidDigest)
                        return
                }</span> else<span class="cov0" title="0"> {
                        metadata["md5Sum"] = hex.EncodeToString(md5Bytes)
                }</span>
        }

        <span class="cov0" title="0">acl, err := getAclFromHeader(request)
        if err != nil </span><span class="cov0" title="0">{
                WriteErrorResponse(response, request, err)
                return
        }</span>

        // check if specific bucket exist
        <span class="cov0" title="0">ctx := common.InitCtxWithAuthInfo(request)
        bucketMeta, err := s.getBucketMeta(ctx, bucketName)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorln("failed to get bucket meta. err:", err)
                WriteErrorResponse(response, request, err)
                return
        }</span>
        //log.Logf("bucket, acl:%f", bucketMeta.Acl.CannedAcl)
        <span class="cov0" title="0">location := bucketMeta.DefaultLocation
        if backendName != "" </span><span class="cov0" title="0">{
                // check if backend exist
                if s.isBackendExist(ctx, backendName) == false </span><span class="cov0" title="0">{
                        WriteErrorResponse(response, request, s3error.ErrGetBackendFailed)
                        return
                }</span>
                <span class="cov0" title="0">location = backendName</span>
        }

        <span class="cov0" title="0">var limitedDataReader io.Reader
        if size &gt; 0 </span><span class="cov0" title="0">{ // request.ContentLength is -1 if length is unknown
                limitedDataReader = io.LimitReader(request.Request.Body, size)
        }</span> else<span class="cov0" title="0"> {
                limitedDataReader = request.Request.Body
        }</span>

        <span class="cov0" title="0">buf := make([]byte, ChunkSize)
        eof := false
        stream, err := s.s3Client.PutObject(ctx)
        defer stream.Close()
        obj := pb.PutObjectRequest{
                BucketName: bucketName,
                ObjectKey:  objectKey,
                Acl:        &amp;pb.Acl{CannedAcl: acl.CannedAcl},
                Attrs:      metadata,
                Location:   location,
                Size:       size,
        }
        err = stream.SendMsg(&amp;obj)
        if err != nil </span><span class="cov0" title="0">{
                WriteErrorResponse(response, request, s3error.ErrInternalError)
                return
        }</span>
        <span class="cov0" title="0">for !eof </span><span class="cov0" title="0">{
                n, err := limitedDataReader.Read(buf)
                if err != nil &amp;&amp; err != io.EOF </span><span class="cov0" title="0">{
                        log.Errorf("read error:%v\n", err)
                        break</span>
                }
                <span class="cov0" title="0">if err == io.EOF </span><span class="cov0" title="0">{
                        log.Debugln("finished read")
                        eof = true
                }</span>
                <span class="cov0" title="0">err = stream.Send(&amp;s3.PutDataStream{Data: buf[:n]})

                if err != nil </span><span class="cov0" title="0">{
                        log.Infof("stream send error: %v\n", err)
                        break</span>
                }
        }

        // if read or send data failed, then close stream and return error
        <span class="cov0" title="0">if !eof </span><span class="cov0" title="0">{
                WriteErrorResponse(response, request, s3error.ErrInternalError)
                return
        }</span>

        // TODO: is this the right way to get response?
        <span class="cov0" title="0">rsp := &amp;s3.PutObjectResponse{}
        err = stream.RecvMsg(rsp)
        if err != nil </span><span class="cov0" title="0">{
                log.Infof("stream receive message failed:%v\n", err)
                WriteErrorResponse(response, request, s3error.ErrInternalError)
        }</span>

        <span class="cov0" title="0">log.Info("PUT object successfully.")
        WriteSuccessResponse(response, nil)</span>
}

func getSize(request *restful.Request, response *restful.Response) (int64, error) <span class="cov0" title="0">{
        // get content-length
        contentLenght := request.HeaderParameter(common.REQUEST_HEADER_CONTENT_LENGTH)
        size, err := strconv.ParseInt(contentLenght, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                log.Infof("parse contentLenght[%s] failed, err:%v\n", contentLenght, err)
                WriteErrorResponse(response, request, s3error.ErrMissingContentLength)
                return 0, err
        }</span>

        <span class="cov0" title="0">log.Infof("object size is %v\n", size)

        if size &gt; common.MaxObjectSize </span><span class="cov0" title="0">{
                log.Infof("invalid contentLenght:%s\n", contentLenght)
                errMsg := fmt.Sprintf("invalid contentLenght[%s], it should be less than %d and more than 0",
                        contentLenght, common.MaxObjectSize)
                err := errors.New(errMsg)
                WriteErrorResponse(response, request, err)
                return size, err
        }</span>

        <span class="cov0" title="0">return size, nil</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package s3

import (
        "github.com/emicklei/go-restful"
        "github.com/soda/multi-cloud/api/pkg/policy"
)

func (s *APIService) RouteBucketDelete(request *restful.Request, response *restful.Response) <span class="cov0" title="0">{
        if !policy.Authorize(request, response, "bucket:delete") </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if IsQuery(request, "acl") </span>{<span class="cov0" title="0">
                //TODO
        }</span> else<span class="cov0" title="0"> if IsQuery(request, "versioning") </span>{<span class="cov0" title="0">
                //TODO
        }</span> else<span class="cov0" title="0"> if IsQuery(request, "website") </span>{<span class="cov0" title="0">
                //TODO
        }</span> else<span class="cov0" title="0"> if IsQuery(request, "cors") </span>{<span class="cov0" title="0">
                //TODO

        }</span> else<span class="cov0" title="0"> if IsQuery(request, "replication") </span>{<span class="cov0" title="0">
                //TODO

        }</span> else<span class="cov0" title="0"> if IsQuery(request, "lifecycle") </span><span class="cov0" title="0">{
                s.BucketLifecycleDelete(request, response)

        }</span> else<span class="cov0" title="0"> {
                s.BucketDelete(request, response)
        }</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package s3

import (
        "github.com/emicklei/go-restful"
        "github.com/soda/multi-cloud/api/pkg/policy"
)

func (s *APIService) RouteBucketGet(request *restful.Request, response *restful.Response) <span class="cov0" title="0">{
        if !policy.Authorize(request, response, "bucket:get") </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if IsQuery(request, "acl") </span><span class="cov0" title="0">{
                s.BucketAclGet(request, response)
        }</span> else<span class="cov0" title="0"> if IsQuery(request, "uploads") </span><span class="cov0" title="0">{
                s.ListBucketUploadRecords(request, response)
        }</span> else<span class="cov0" title="0"> if IsQuery(request, "versioning") </span>{<span class="cov0" title="0">
                //TODO
        }</span> else<span class="cov0" title="0"> if IsQuery(request, "website") </span>{<span class="cov0" title="0">
                //TODO
        }</span> else<span class="cov0" title="0"> if IsQuery(request, "cors") </span>{<span class="cov0" title="0">
                //TODO

        }</span> else<span class="cov0" title="0"> if IsQuery(request, "replication") </span>{<span class="cov0" title="0">
                //TODO

        }</span> else<span class="cov0" title="0"> if IsQuery(request, "lifecycle") </span><span class="cov0" title="0">{
                s.BucketLifecycleGet(request, response)

        }</span> else<span class="cov0" title="0"> {
                s.BucketGet(request, response)
        }</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package s3

import (
        "github.com/emicklei/go-restful"
        "github.com/soda/multi-cloud/api/pkg/policy"
)

func (s *APIService) RouteBucketHead(request *restful.Request, response *restful.Response) <span class="cov0" title="0">{
        if !policy.Authorize(request, response, "bucket:get") </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">s.HeadBucket(request, response)</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package s3

import (
        "errors"

        "github.com/emicklei/go-restful"
        "github.com/soda/multi-cloud/api/pkg/policy"
        "net/http"
)

func (s *APIService) RouteBucketPut(request *restful.Request, response *restful.Response) <span class="cov0" title="0">{
        if !policy.Authorize(request, response, "bucket:put") </span><span class="cov0" title="0">{
                response.WriteError(http.StatusMethodNotAllowed, errors.New("authorize failed"))
                return
        }</span>

        <span class="cov0" title="0">if IsQuery(request, "acl") </span><span class="cov0" title="0">{
                s.BucketAclPut(request, response)
        }</span> else<span class="cov0" title="0"> if IsQuery(request, "versioning") </span><span class="cov0" title="0">{
                s.BucketVersioningPut(request, response)
        }</span> else<span class="cov0" title="0"> if IsQuery(request, "website") </span>{<span class="cov0" title="0">
                //TODO
        }</span> else<span class="cov0" title="0"> if IsQuery(request, "cors") </span>{<span class="cov0" title="0">
                //TODO

        }</span> else<span class="cov0" title="0"> if IsQuery(request, "replication") </span>{<span class="cov0" title="0">
                //TODO

        }</span> else<span class="cov0" title="0"> if IsQuery(request, "lifecycle") </span><span class="cov0" title="0">{
                s.BucketLifecyclePut(request, response)
        }</span>  else<span class="cov0" title="0"> if IsQuery(request, "DefaultEncryption") </span><span class="cov0" title="0">{
                s.BucketSSEPut(request, response)
        }</span> else<span class="cov0" title="0"> {
                s.BucketPut(request, response)
        }</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">package s3

import (
        "github.com/emicklei/go-restful"
        "github.com/soda/multi-cloud/api/pkg/policy"
)

func (s *APIService) RouteObjectDelete(request *restful.Request, response *restful.Response) <span class="cov0" title="0">{
        if !policy.Authorize(request, response, "object:delete") </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if IsQuery(request, "uploadId") </span><span class="cov0" title="0">{
                s.AbortMultipartUpload(request, response)
        }</span> else<span class="cov0" title="0"> {
                s.ObjectDelete(request, response)
        }</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package s3

import (
        "github.com/emicklei/go-restful"
        "github.com/soda/multi-cloud/api/pkg/policy"
)

func (s *APIService) RouteObjectGet(request *restful.Request, response *restful.Response) <span class="cov0" title="0">{
        if !policy.Authorize(request, response, "object:get") </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">if IsQuery(request, "acl") </span><span class="cov0" title="0">{
                s.ObjectAclGet(request, response)
        }</span> else<span class="cov0" title="0"> if IsQuery(request, "uploadId") </span><span class="cov0" title="0">{
                s.ListObjectParts(request, response)
        }</span> else<span class="cov0" title="0"> {
                s.ObjectGet(request, response)
        }</span>
}</pre>
		
		<pre class="file" id="file44" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package s3

import (
        "github.com/emicklei/go-restful"
        "github.com/soda/multi-cloud/api/pkg/policy"
)

func (s *APIService) RouteObjectHead(request *restful.Request, response *restful.Response) <span class="cov0" title="0">{
        if !policy.Authorize(request, response, "object:delete") </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">s.HeadObject(request, response)</span>
}
</pre>
		
		<pre class="file" id="file45" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package s3

import (
        "regexp"

        "github.com/emicklei/go-restful"
        "github.com/soda/multi-cloud/api/pkg/common"
        "github.com/soda/multi-cloud/api/pkg/policy"
)

func (s *APIService) RouteObjectPost(request *restful.Request, response *restful.Response) <span class="cov0" title="0">{
        if !policy.Authorize(request, response, "object:post") </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if IsQuery(request, "uploads") </span><span class="cov0" title="0">{
                s.MultiPartUploadInit(request, response)
        }</span> else<span class="cov0" title="0"> if IsQuery(request, "uploadId") </span><span class="cov0" title="0">{
                s.CompleteMultipartUpload(request, response)
        }</span> else<span class="cov0" title="0"> {
                // check whether it is the post object operation.
                contentType := request.HeaderParameter(common.REQUEST_HEADER_CONTENT_TYPE)
                objectPostValidate := regexp.MustCompile("multipart/form-data*")
                if contentType != "" &amp;&amp; objectPostValidate.MatchString(contentType) </span><span class="cov0" title="0">{
                        s.ObjectPost(request, response)
                        return
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file46" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package s3

import (
        "github.com/emicklei/go-restful"
        "github.com/soda/multi-cloud/api/pkg/policy"
)

func (s *APIService) RouteObjectPut(request *restful.Request, response *restful.Response) <span class="cov0" title="0">{
        if !policy.Authorize(request, response, "object:put") </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">if IsQuery(request, "acl") </span><span class="cov0" title="0">{
                s.ObjectAclPut(request, response)
        }</span> else<span class="cov0" title="0"> if IsQuery(request, "tagging") </span>{<span class="cov0" title="0">
                //TODO
        }</span> else<span class="cov0" title="0"> if IsQuery(request, "uploads") </span><span class="cov0" title="0">{
                s.MultiPartUploadInit(request, response)
        }</span> else<span class="cov0" title="0"> if IsQuery(request, "partNumber") &amp;&amp; IsQuery(request, "uploadId") &amp;&amp; HasHeader(request, "x-amz-copy-source") </span><span class="cov0" title="0">{
                s.ObjectPartCopy(request, response)
        }</span> else<span class="cov0" title="0"> if IsQuery(request, "partNumber") &amp;&amp; IsQuery(request, "uploadId") </span><span class="cov0" title="0">{
                s.UploadPart(request, response)
        }</span> else<span class="cov0" title="0"> if IsQuery(request, "uploadId") </span><span class="cov0" title="0">{
                s.CompleteMultipartUpload(request, response)
        }</span> else<span class="cov0" title="0"> if HasHeader(request, "x-amz-copy-source") </span><span class="cov0" title="0">{
                s.ObjectCopy(request, response)
        }</span> else<span class="cov0" title="0"> {
                s.ObjectPut(request, response)
        }</span>
}
</pre>
		
		<pre class="file" id="file47" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package s3

import (
        "github.com/emicklei/go-restful"
        "github.com/micro/go-micro/client"
)

//RegisterRouter - route request to appropriate method
func RegisterRouter(ws *restful.WebService) <span class="cov0" title="0">{
        handler := NewAPIService(client.DefaultClient)
        ws.Route(ws.GET("/").To(handler.ListBuckets)).Doc("Return list of buckets for the user")
        ws.Route(ws.GET("/storageClasses").To(handler.GetStorageClasses)).Doc("Return supported storage classes.")
        ws.Route(ws.PUT("/{bucketName}").To(handler.RouteBucketPut)).Doc("Create bucket for the user")
        //ws.Route(ws.HEAD("/s3/{bucketName}").To(handler.BucketHead)).Doc("Determine if bucket exists and if user has permission to access it")
        ws.Route(ws.GET("/{bucketName}").To(handler.RouteBucketGet)).Doc("Return list of objects in bucket")
        ws.Route(ws.DELETE("/{bucketName}").To(handler.RouteBucketDelete)).Doc("Delete bucket")
        ws.Route(ws.HEAD("/{bucketName}").To(handler.RouteBucketHead)).Doc("Head bucket")

        ws.Route(ws.PUT("/{bucketName}/{objectKey:*}").To(handler.RouteObjectPut)).Doc("Put object")
        ws.Route(ws.DELETE("/{bucketName}/{objectKey:*}").To(handler.RouteObjectDelete)).Doc("Delete object")
        ws.Route(ws.GET("/{bucketName}/{objectKey:*}").To(handler.RouteObjectGet)).Doc("Download object")
        ws.Route(ws.DELETE("/{bucketName}/{objectKey:*}").To(handler.RouteObjectDelete)).Doc("AbortMultipartUpload")
        ws.Route(ws.HEAD("/{bucketName}/{objectKey:*}").To(handler.RouteObjectHead)).Doc("Head object")
        ws.Route(ws.POST("/{bucketName}/{objectKey:*}").To(handler.RouteObjectPost)).Doc("Post object")
        ws.Route(ws.POST("/{bucketName}").To(handler.RouteObjectPost)).Doc("Post object")

        //Router for PUT and GET bucket lifecycle
        ws.Route(ws.PUT("/{bucketName}/?lifecycle").To(handler.RouteBucketPut)).Doc("Create lifecycle configuration for the bucket")
        ws.Route(ws.GET("/{bucketName}/?lifecycle").To(handler.RouteBucketGet)).Doc("Get lifecycle configuration from the bucket")
        ws.Route(ws.DELETE("/{bucketName}/?lifecycle").To(handler.RouteBucketDelete)).Doc("Delete lifecycle configuration from the bucket")

        ws.Route(ws.PUT("/{bucketName}/?versioning").To(handler.RouteBucketPut)).Doc("Create Versioning configuration for the bucket")

        // router for SSE
        ws.Route(ws.PUT("/{bucketName}/?DefaultEncryption").To(handler.RouteBucketPut)).Doc("Set default encryption on bucket")
}</span>
</pre>
		
		<pre class="file" id="file48" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package s3

import (
        "context"
        "io"
        "io/ioutil"
        "math"

        "github.com/emicklei/go-restful"
        "github.com/micro/go-micro/client"
        "github.com/soda/multi-cloud/backend/proto"
        backendpb "github.com/soda/multi-cloud/backend/proto"
        . "github.com/soda/multi-cloud/s3/error"
        "github.com/soda/multi-cloud/s3/proto"
        log "github.com/sirupsen/logrus"
)

const (
        s3Service      = "s3"
        backendService = "backend"
)

type APIService struct {
        s3Client      s3.S3Service
        backendClient backend.BackendService
}

func NewAPIService(c client.Client) *APIService <span class="cov0" title="0">{
        return &amp;APIService{
                s3Client:      s3.NewS3Service(s3Service, c),
                backendClient: backend.NewBackendService(backendService, c),
        }
}</span>

func IsQuery(request *restful.Request, name string) bool <span class="cov0" title="0">{
        params := request.Request.URL.Query()
        if params == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">if _, ok := params[name]; ok </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">return false</span>
}
func HasHeader(request *restful.Request, name string) bool <span class="cov0" title="0">{
        param := request.HeaderParameter(name)
        if param == "" </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return true</span>
}

func ReadBody(r *restful.Request) []byte <span class="cov0" title="0">{
        var reader io.Reader = r.Request.Body
        b, e := ioutil.ReadAll(reader)
        if e != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return b</span>
}

func (s *APIService) getBucketMeta(ctx context.Context, bucketName string) (*s3.Bucket, error) <span class="cov0" title="0">{
        rsp, err := s.s3Client.GetBucket(ctx, &amp;s3.Bucket{Name: bucketName})
        // according to gRPC framework work mechanism, if gRPC return error, then no response package can be received by
        // gRPC client, so in our codes, gRPC server will return nil and set error code to reponse package while business
        // error happens, and if gRPC client received error, that means some exception happened for gRPC itself.
        if err == nil </span><span class="cov0" title="0">{
                if rsp.GetErrorCode() != int32(ErrNoErr) </span><span class="cov0" title="0">{
                        err = S3ErrorCode(rsp.GetErrorCode())
                }</span>
        }
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                log.Infof("get bucket meta data[bucket=%s] failed, err=%v\n", bucketName, err)
                return nil, err
        }</span>

        <span class="cov0" title="0">return rsp.BucketMeta, nil</span>
}

func (s *APIService) getObjectMeta(ctx context.Context, bucketName, objectName, versiongId string) (*s3.Object, error) <span class="cov0" title="0">{
        rsp, err := s.s3Client.GetObjectMeta(ctx, &amp;s3.Object{BucketName: bucketName, ObjectKey: objectName, VersionId: versiongId})
        // according to gRPC framework work mechanism, if gRPC return error, then no response package can be received by
        // gRPC client, so in our codes, gRPC server will return nil and set error code to reponse package while business
        // error happens, and if gRPC client received error, that means some exception happened for gRPC itself.
        if err == nil </span><span class="cov0" title="0">{
                if rsp.GetErrorCode() != int32(ErrNoErr) </span><span class="cov0" title="0">{
                        err = S3ErrorCode(rsp.GetErrorCode())
                }</span>
        }
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                log.Infof("get object meta data[bucket=%s,key=%s] failed, err=%v\n", bucketName, objectName, err)
                return nil, err
        }</span>

        <span class="cov0" title="0">return rsp.Object, nil</span>
}

func (s *APIService) isBackendExist(ctx context.Context, backendName string) bool <span class="cov0" title="0">{
        flag := false

        backendRep, backendErr := s.backendClient.ListBackend(ctx, &amp;backendpb.ListBackendRequest{
                Offset: 0,
                Limit:  math.MaxInt32,
                Filter: map[string]string{"name": backendName}})
        log.Infof("backendErr is %v:", backendErr)
        if backendErr != nil </span><span class="cov0" title="0">{
                log.Infof("Get backend[name=%s] failed.", backendName)
        }</span> else<span class="cov0" title="0"> {
                log.Infof("backendRep=%+v\n", backendRep)
                if len(backendRep.Backends) &gt; 0 </span><span class="cov0" title="0">{
                        log.Infof("backend[name=%s] exist.", backendName)
                        flag = true
                }</span>
        }

        <span class="cov0" title="0">return flag</span>
}

func HandleS3Error(response *restful.Response, request *restful.Request, err error, errCode int32) error <span class="cov0" title="0">{
        if err != nil </span><span class="cov0" title="0">{
                WriteErrorResponse(response, request, err)
                return err
        }</span>
        <span class="cov0" title="0">if errCode != int32(ErrNoErr) </span><span class="cov0" title="0">{
                err := S3ErrorCode(errCode)
                WriteErrorResponse(response, request, err)
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file49" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package s3

import (
        "encoding/hex"
        "io"
        "strconv"

        "github.com/emicklei/go-restful"
        "github.com/soda/multi-cloud/api/pkg/common"
        . "github.com/soda/multi-cloud/s3/error"
        pb "github.com/soda/multi-cloud/s3/proto"
        log "github.com/sirupsen/logrus"
)

func (s *APIService) UploadPart(request *restful.Request, response *restful.Response) <span class="cov0" title="0">{
        bucketName := request.PathParameter("bucketName")
        objectKey := request.PathParameter("objectKey")

        var incomingMd5 string
        // get Content-Md5 sent by client and verify if valid
        md5Bytes, err := checkValidMD5(request.HeaderParameter(common.REQUEST_HEADER_CONTENT_MD5))
        if err != nil </span><span class="cov0" title="0">{
                incomingMd5 = ""
        }</span> else<span class="cov0" title="0"> {
                incomingMd5 = hex.EncodeToString(md5Bytes)
        }</span>

        <span class="cov0" title="0">size := request.Request.ContentLength
        /// maximum Upload size for multipart objects in a single operation
        if isMaxObjectSize(size) </span><span class="cov0" title="0">{
                log.Errorf("the size of object to upload is too large.")
                WriteErrorResponse(response, request, ErrEntityTooLarge)
                return
        }</span>
        <span class="cov0" title="0">log.Infoln("uploadpart size:", size)

        uploadID := request.QueryParameter("uploadId")
        partIDString := request.QueryParameter("partNumber")
        partID, err := strconv.Atoi(partIDString)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to convert part id string to integer")
                WriteErrorResponse(response, request, ErrInvalidPart)
                return
        }</span>
        // check partID with maximum part ID for multipart objects
        <span class="cov0" title="0">if isMaxPartID(partID) </span><span class="cov0" title="0">{
                log.Errorf("the part id is invalid.")
                WriteErrorResponse(response, request, ErrInvalidMaxParts)
                return
        }</span>

        <span class="cov0" title="0">ctx := common.InitCtxWithAuthInfo(request)
        stream, err := s.s3Client.UploadPart(ctx)
        defer stream.Close()

        uploadRequest := pb.UploadPartRequest{
                BucketName: bucketName,
                ObjectKey:  objectKey,
                UploadId:   uploadID,
                PartId:     int32(partID),
                Size:       size,
                Md5Hex:     incomingMd5,
        }
        err = stream.SendMsg(&amp;uploadRequest)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorln("failed send upload request msg. err:", err)
                WriteErrorResponse(response, request, err)
                return
        }</span>

        <span class="cov0" title="0">var limitedDataReader io.Reader
        if size &gt; 0 </span><span class="cov0" title="0">{ // request.ContentLength is -1 if length is unknown
                limitedDataReader = io.LimitReader(request.Request.Body, size)
        }</span> else<span class="cov0" title="0"> {
                limitedDataReader = request.Request.Body
        }</span>
        <span class="cov0" title="0">buf := make([]byte, ChunkSize)
        eof := false
        for !eof </span><span class="cov0" title="0">{
                n, err := limitedDataReader.Read(buf)
                if err != nil &amp;&amp; err != io.EOF </span><span class="cov0" title="0">{
                        log.Errorf("read error:%v\n", err)
                        break</span>
                }
                <span class="cov0" title="0">if err == io.EOF </span><span class="cov0" title="0">{
                        log.Debugln("finished read")
                        eof = true
                }</span>

                <span class="cov0" title="0">err = stream.Send(&amp;pb.PutDataStream{Data: buf[:n]})
                if err != nil </span><span class="cov0" title="0">{
                        log.Infof("stream send error: %v\n", err)
                        break</span>
                }
        }

        <span class="cov0" title="0">result := pb.UploadPartResponse{}
        err = stream.RecvMsg(&amp;result)
        if HandleS3Error(response, request, err, result.GetErrorCode()) != nil </span><span class="cov0" title="0">{
                log.Errorln("unable to recv message. err:%v, errcode:%v", err, result.ErrorCode)
                return
        }</span>

        <span class="cov0" title="0">if result.ETag != "" </span><span class="cov0" title="0">{
                response.Header()["ETag"] = []string{"\"" + result.ETag + "\""}
        }</span>

        <span class="cov0" title="0">WriteSuccessResponse(response, nil)
        log.Info("Uploadpart successfully.")</span>
}
</pre>
		
		<pre class="file" id="file50" style="display: none">/*
 * Minio Cloud Storage, (C) 2015 Minio, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package s3

import (
        "encoding/base64"
        "encoding/xml"
        "errors"
        "io"
        "net/http"
        "regexp"
        "strings"
)

// xmlDecoder provide decoded value in xml.
func xmlDecoder(body io.Reader, v interface{}) error <span class="cov0" title="0">{
        d := xml.NewDecoder(body)
        return d.Decode(v)
}</span>

// checkValidMD5 - verify if valid md5, returns md5 in bytes.
func checkValidMD5(md5 string) ([]byte, error) <span class="cov0" title="0">{
        return base64.StdEncoding.DecodeString(strings.TrimSpace(md5))
}</span>

/// http://docs.aws.amazon.com/AmazonS3/latest/dev/UploadingObjects.html
const (
        // maximum object size per PUT request is 5GiB
        maxObjectSize = 1024 * 1024 * 1024 * 5
        // minimum Part size for multipart upload is 5MB
        minPartSize = 1024 * 1024 * 5
        // maximum Part ID for multipart upload is 10000 (Acceptable values range from 1 to 10000 inclusive)
        maxPartID = 10000
)

// isMaxObjectSize - verify if max object size
func isMaxObjectSize(size int64) bool <span class="cov0" title="0">{
        return size &gt; maxObjectSize
}</span>

// Check if part size is more than or equal to minimum allowed size.
func isMinAllowedPartSize(size int64) bool <span class="cov0" title="0">{
        return size &gt;= minPartSize
}</span>

// isMaxPartNumber - Check if part ID is greater than the maximum allowed ID.
func isMaxPartID(partID int) bool <span class="cov0" title="0">{
        return partID &gt; maxPartID
}</span>

func contains(stringList []string, element string) bool <span class="cov0" title="0">{
        for _, e := range stringList </span><span class="cov0" title="0">{
                if e == element </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

/*
func requestIdFromContext(ctx context.Context) string {
        if result, ok := ctx.Value(RequestContextKey).(RequestContext); ok {
                return result.RequestId
        }
        return ""
}*/

// We support '.' with bucket names but we fallback to using path
// style requests instead for such buckets.
var (
        validBucketName       = regexp.MustCompile(`^[A-Za-z0-9][A-Za-z0-9\.\-\_\:]{1,61}[A-Za-z0-9]$`)
        validBucketNameStrict = regexp.MustCompile(`^[a-z0-9][a-z0-9\.\-]{1,61}[a-z0-9]$`)
        ipAddress             = regexp.MustCompile(`^(\d+\.){3}\d+$`)
)

// Common checker for both stricter and basic validation.
func checkBucketNameCommon(bucketName string, strict bool) (err error) <span class="cov8" title="1">{
        if strings.TrimSpace(bucketName) == "" </span><span class="cov0" title="0">{
                return errors.New("Bucket name cannot be empty")
        }</span>
        <span class="cov8" title="1">if len(bucketName) &lt; 3 </span><span class="cov0" title="0">{
                return errors.New("Bucket name cannot be smaller than 3 characters")
        }</span>
        <span class="cov8" title="1">if len(bucketName) &gt; 63 </span><span class="cov0" title="0">{
                return errors.New("Bucket name cannot be greater than 63 characters")
        }</span>
        <span class="cov8" title="1">if ipAddress.MatchString(bucketName) </span><span class="cov0" title="0">{
                return errors.New("Bucket name cannot be an ip address")
        }</span>
        <span class="cov8" title="1">if strings.Contains(bucketName, "..") </span><span class="cov0" title="0">{
                return errors.New("Bucket name contains invalid characters")
        }</span>
        <span class="cov8" title="1">if strict </span><span class="cov0" title="0">{
                if !validBucketNameStrict.MatchString(bucketName) </span><span class="cov0" title="0">{
                        err = errors.New("Bucket name contains invalid characters")
                }</span>
                <span class="cov0" title="0">return err</span>
        }
        <span class="cov8" title="1">if !validBucketName.MatchString(bucketName) </span><span class="cov0" title="0">{
                err = errors.New("Bucket name contains invalid characters")
        }</span>
        <span class="cov8" title="1">return err</span>
}

// CheckValidBucketName - checks if we have a valid input bucket name.
func CheckValidBucketName(bucketName string) (err error) <span class="cov8" title="1">{
        return checkBucketNameCommon(bucketName, false)
}</span>

func xmlFormat(data interface{}) ([]byte, error) <span class="cov0" title="0">{
        buffer, err := xml.Marshal(data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        // add XML header
        <span class="cov0" title="0">headerBytes := []byte(xml.Header)
        output := append(headerBytes, buffer...)
        return output, nil</span>
}

func setXmlHeader(w http.ResponseWriter, body []byte) <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/xml")
}</span>

// hasServerSideEncryptionHeader returns true if the given HTTP header
// contains server-side-encryption.
/*func hasServerSideEncryptionHeader(header http.Header) bool {
        return crypto.S3.IsRequested(header) || crypto.SSEC.IsRequested(header)
}*/
</pre>
		
		<pre class="file" id="file51" style="display: none">package obs

import (
        "fmt"
        "net/url"
        "sort"
        "strings"
        "time"

        log "github.com/sirupsen/logrus"
)

func (obsClient ObsClient) doAuthTemporary(method, bucketName, objectKey string, params map[string]string,
        headers map[string][]string, expires int64) (requestUrl string, err error) <span class="cov0" title="0">{

        requestUrl, canonicalizedUrl := obsClient.conf.formatUrls(bucketName, objectKey, params, true)
        parsedRequestUrl, err := url.Parse(requestUrl)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">encodeHeaders(headers)
        hostName := parsedRequestUrl.Host

        isV4 := obsClient.conf.signature == SignatureV4
        prepareHostAndDate(headers, hostName, isV4)

        if obsClient.conf.securityProvider == nil || obsClient.conf.securityProvider.ak == "" || obsClient.conf.securityProvider.sk == "" </span><span class="cov0" title="0">{
                log.Warn("No ak/sk provided, skip to construct authorization")
        }</span> else<span class="cov0" title="0"> {
                if obsClient.conf.securityProvider.securityToken != "" </span><span class="cov0" title="0">{
                        params[HEADER_STS_TOKEN_AMZ] = obsClient.conf.securityProvider.securityToken
                }</span>

                <span class="cov0" title="0">if isV4 </span><span class="cov0" title="0">{
                        date, _ := time.Parse(RFC1123_FORMAT, headers[HEADER_DATE_CAMEL][0])
                        delete(headers, HEADER_DATE_CAMEL)
                        shortDate := date.Format(SHORT_DATE_FORMAT)
                        longDate := date.Format(LONG_DATE_FORMAT)

                        signedHeaders, _headers := getSignedHeaders(headers)

                        credential, scope := getCredential(obsClient.conf.securityProvider.ak, obsClient.conf.region, shortDate)
                        params[PARAM_ALGORITHM_AMZ_CAMEL] = V4_HASH_PREFIX
                        params[PARAM_CREDENTIAL_AMZ_CAMEL] = credential
                        params[PARAM_DATE_AMZ_CAMEL] = longDate
                        params[PARAM_EXPIRES_AMZ_CAMEL] = Int64ToString(expires)
                        params[PARAM_SIGNEDHEADERS_AMZ_CAMEL] = strings.Join(signedHeaders, ";")

                        requestUrl, canonicalizedUrl = obsClient.conf.formatUrls(bucketName, objectKey, params, true)
                        parsedRequestUrl, _ = url.Parse(requestUrl)
                        stringToSign := getV4StringToSign(method, canonicalizedUrl, parsedRequestUrl.RawQuery, scope, longDate, UNSIGNED_PAYLOAD, signedHeaders, _headers)
                        signature := getSignature(stringToSign, obsClient.conf.securityProvider.sk, obsClient.conf.region, shortDate)

                        requestUrl += fmt.Sprintf("&amp;%s=%s", PARAM_SIGNATURE_AMZ_CAMEL, UrlEncode(signature, false))

                }</span> else<span class="cov0" title="0"> {
                        originDate := headers[HEADER_DATE_CAMEL][0]
                        date, _ := time.Parse(RFC1123_FORMAT, originDate)
                        expires += date.Unix()
                        headers[HEADER_DATE_CAMEL] = []string{Int64ToString(expires)}

                        stringToSign := getV2StringToSign(method, canonicalizedUrl, headers)
                        signature := UrlEncode(Base64Encode(HmacSha1([]byte(obsClient.conf.securityProvider.sk), []byte(stringToSign))), false)
                        if strings.Index(requestUrl, "?") &lt; 0 </span><span class="cov0" title="0">{
                                requestUrl += "?"
                        }</span> else<span class="cov0" title="0"> {
                                requestUrl += "&amp;"
                        }</span>
                        <span class="cov0" title="0">delete(headers, HEADER_DATE_CAMEL)
                        requestUrl += fmt.Sprintf("AWSAccessKeyId=%s&amp;Expires=%d&amp;Signature=%s", UrlEncode(obsClient.conf.securityProvider.ak, false),
                                expires, signature)</span>
                }
        }

        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) doAuth(method, bucketName, objectKey string, params map[string]string,
        headers map[string][]string, hostName string) (requestUrl string, err error) <span class="cov0" title="0">{

        requestUrl, canonicalizedUrl := obsClient.conf.formatUrls(bucketName, objectKey, params, true)
        parsedRequestUrl, err := url.Parse(requestUrl)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">encodeHeaders(headers)

        if hostName == "" </span><span class="cov0" title="0">{
                hostName = parsedRequestUrl.Host
        }</span>

        <span class="cov0" title="0">isV4 := obsClient.conf.signature == SignatureV4
        prepareHostAndDate(headers, hostName, isV4)

        if obsClient.conf.securityProvider == nil || obsClient.conf.securityProvider.ak == "" || obsClient.conf.securityProvider.sk == "" </span><span class="cov0" title="0">{
                log.Warn("No ak/sk provided, skip to construct authorization")
        }</span> else<span class="cov0" title="0"> {
                if obsClient.conf.securityProvider.securityToken != "" </span><span class="cov0" title="0">{
                        headers[HEADER_STS_TOKEN_AMZ] = []string{obsClient.conf.securityProvider.securityToken}
                }</span>
                <span class="cov0" title="0">ak := obsClient.conf.securityProvider.ak
                sk := obsClient.conf.securityProvider.sk
                var authorization string
                if isV4 </span><span class="cov0" title="0">{
                        headers[HEADER_CONTENT_SHA256_AMZ] = []string{EMPTY_CONTENT_SHA256}
                        ret := v4Auth(ak, sk, obsClient.conf.region, method, canonicalizedUrl, parsedRequestUrl.RawQuery, headers)
                        authorization = fmt.Sprintf("%s Credential=%s,SignedHeaders=%s,Signature=%s", V4_HASH_PREFIX, ret["Credential"], ret["SignedHeaders"], ret["Signature"])
                }</span> else<span class="cov0" title="0"> {
                        ret := v2Auth(ak, sk, method, canonicalizedUrl, headers)
                        authorization = fmt.Sprintf("%s %s:%s", V2_HASH_PREFIX, ak, ret["Signature"])
                }</span>
                <span class="cov0" title="0">headers[HEADER_AUTH_CAMEL] = []string{authorization}</span>
        }

        <span class="cov0" title="0">return</span>
}

func prepareHostAndDate(headers map[string][]string, hostName string, isV4 bool) <span class="cov0" title="0">{
        headers[HEADER_HOST_CAMEL] = []string{hostName}
        if date, ok := headers[HEADER_DATE_AMZ]; ok </span><span class="cov0" title="0">{
                flag := false
                if len(date) == 1 </span><span class="cov0" title="0">{
                        if isV4 </span><span class="cov0" title="0">{
                                if t, err := time.Parse(LONG_DATE_FORMAT, date[0]); err == nil </span><span class="cov0" title="0">{
                                        headers[HEADER_DATE_CAMEL] = []string{FormatUtcToRfc1123(t)}
                                        flag = true
                                }</span>
                        } else<span class="cov0" title="0"> {
                                if strings.HasSuffix(date[0], "GMT") </span><span class="cov0" title="0">{
                                        headers[HEADER_DATE_CAMEL] = []string{date[0]}
                                        flag = true
                                }</span>
                        }
                }
                <span class="cov0" title="0">if !flag </span><span class="cov0" title="0">{
                        delete(headers, HEADER_DATE_AMZ)
                }</span>
        }
        <span class="cov0" title="0">if _, ok := headers[HEADER_DATE_CAMEL]; !ok </span><span class="cov0" title="0">{
                headers[HEADER_DATE_CAMEL] = []string{FormatUtcToRfc1123(time.Now().UTC())}
        }</span>
}

func encodeHeaders(headers map[string][]string) <span class="cov0" title="0">{
        for key, values := range headers </span><span class="cov0" title="0">{
                for index, value := range values </span><span class="cov0" title="0">{
                        values[index] = UrlEncode(value, true)
                }</span>
                <span class="cov0" title="0">headers[key] = values</span>
        }
}

func attachHeaders(headers map[string][]string) string <span class="cov0" title="0">{
        length := len(headers)
        _headers := make(map[string][]string, length)
        keys := make([]string, 0, length)

        for key, value := range headers </span><span class="cov0" title="0">{
                _key := strings.ToLower(strings.TrimSpace(key))
                if _key != "" </span><span class="cov0" title="0">{
                        if _key == "content-md5" || _key == "content-type" || _key == "date" || strings.HasPrefix(_key, HEADER_PREFIX) </span><span class="cov0" title="0">{
                                keys = append(keys, _key)
                                _headers[_key] = value
                        }</span>
                } else<span class="cov0" title="0"> {
                        delete(headers, key)
                }</span>
        }

        <span class="cov0" title="0">for _, interestedHeader := range interested_headers </span><span class="cov0" title="0">{
                if _, ok := _headers[interestedHeader]; !ok </span><span class="cov0" title="0">{
                        _headers[interestedHeader] = []string{""}
                        keys = append(keys, interestedHeader)
                }</span>
        }

        <span class="cov0" title="0">if _, ok := _headers[HEADER_DATE_CAMEL]; ok </span><span class="cov0" title="0">{
                if _, ok := _headers[HEADER_DATE_AMZ]; ok </span><span class="cov0" title="0">{
                        _headers[HEADER_DATE_CAMEL] = []string{""}
                }</span> else<span class="cov0" title="0"> if _, ok := headers[PARAM_DATE_AMZ_CAMEL]; ok </span><span class="cov0" title="0">{
                        _headers[HEADER_DATE_CAMEL] = []string{""}
                }</span>
        } else<span class="cov0" title="0"> if _, ok := _headers[strings.ToLower(HEADER_DATE_CAMEL)]; ok </span><span class="cov0" title="0">{
                if _, ok := _headers[HEADER_DATE_AMZ]; ok </span><span class="cov0" title="0">{
                        _headers[HEADER_DATE_CAMEL] = []string{""}
                }</span> else<span class="cov0" title="0"> if _, ok := headers[PARAM_DATE_AMZ_CAMEL]; ok </span><span class="cov0" title="0">{
                        _headers[HEADER_DATE_CAMEL] = []string{""}
                }</span>
        }

        <span class="cov0" title="0">sort.Strings(keys)

        stringToSign := make([]string, 0, len(keys))
        for _, key := range keys </span><span class="cov0" title="0">{
                var value string
                if strings.HasPrefix(key, HEADER_PREFIX) </span><span class="cov0" title="0">{
                        if strings.HasPrefix(key, HEADER_PREFIX_META) </span><span class="cov0" title="0">{
                                for index, v := range _headers[key] </span><span class="cov0" title="0">{
                                        value += strings.TrimSpace(v)
                                        if index != len(_headers[key])-1 </span><span class="cov0" title="0">{
                                                value += ","
                                        }</span>
                                }
                        } else<span class="cov0" title="0"> {
                                value = strings.Join(_headers[key], ",")
                        }</span>
                        <span class="cov0" title="0">value = fmt.Sprintf("%s:%s", key, value)</span>
                } else<span class="cov0" title="0"> {
                        value = strings.Join(_headers[key], ",")
                }</span>
                <span class="cov0" title="0">stringToSign = append(stringToSign, value)</span>
        }
        <span class="cov0" title="0">return strings.Join(stringToSign, "\n")</span>
}

func getV2StringToSign(method, canonicalizedUrl string, headers map[string][]string) string <span class="cov0" title="0">{
        stringToSign := strings.Join([]string{method, "\n", attachHeaders(headers), "\n", canonicalizedUrl}, "")
        log.Debug("The v2 auth stringToSign:\n%s", stringToSign)
        return stringToSign
}</span>

func v2Auth(ak, sk, method, canonicalizedUrl string, headers map[string][]string) map[string]string <span class="cov0" title="0">{
        stringToSign := getV2StringToSign(method, canonicalizedUrl, headers)
        return map[string]string{"Signature": Base64Encode(HmacSha1([]byte(sk), []byte(stringToSign)))}
}</span>

func getScope(region, shortDate string) string <span class="cov0" title="0">{
        return fmt.Sprintf("%s/%s/%s/%s", shortDate, region, V4_SERVICE_NAME, V4_SERVICE_SUFFIX)
}</span>

func getCredential(ak, region, shortDate string) (string, string) <span class="cov0" title="0">{
        scope := getScope(region, shortDate)
        return fmt.Sprintf("%s/%s", ak, scope), scope
}</span>

func getV4StringToSign(method, canonicalizedUrl, queryUrl, scope, longDate, payload string, signedHeaders []string, headers map[string][]string) string <span class="cov0" title="0">{
        canonicalRequest := make([]string, 0, 10+len(signedHeaders)*4)
        canonicalRequest = append(canonicalRequest, method)
        canonicalRequest = append(canonicalRequest, "\n")
        canonicalRequest = append(canonicalRequest, canonicalizedUrl)
        canonicalRequest = append(canonicalRequest, "\n")
        canonicalRequest = append(canonicalRequest, queryUrl)
        canonicalRequest = append(canonicalRequest, "\n")

        for _, signedHeader := range signedHeaders </span><span class="cov0" title="0">{
                values, _ := headers[signedHeader]
                for _, value := range values </span><span class="cov0" title="0">{
                        canonicalRequest = append(canonicalRequest, signedHeader)
                        canonicalRequest = append(canonicalRequest, ":")
                        canonicalRequest = append(canonicalRequest, value)
                        canonicalRequest = append(canonicalRequest, "\n")
                }</span>
        }
        <span class="cov0" title="0">canonicalRequest = append(canonicalRequest, "\n")
        canonicalRequest = append(canonicalRequest, strings.Join(signedHeaders, ";"))
        canonicalRequest = append(canonicalRequest, "\n")
        canonicalRequest = append(canonicalRequest, payload)

        _canonicalRequest := strings.Join(canonicalRequest, "")
        log.Debug("The v4 auth canonicalRequest:\n%s", _canonicalRequest)

        stringToSign := make([]string, 0, 7)
        stringToSign = append(stringToSign, V4_HASH_PREFIX)
        stringToSign = append(stringToSign, "\n")
        stringToSign = append(stringToSign, longDate)
        stringToSign = append(stringToSign, "\n")
        stringToSign = append(stringToSign, scope)
        stringToSign = append(stringToSign, "\n")
        stringToSign = append(stringToSign, HexSha256([]byte(_canonicalRequest)))

        _stringToSign := strings.Join(stringToSign, "")

        log.Debug("The v4 auth stringToSign:\n%s", _stringToSign)
        return _stringToSign</span>
}

func getSignedHeaders(headers map[string][]string) ([]string, map[string][]string) <span class="cov0" title="0">{
        length := len(headers)
        _headers := make(map[string][]string, length)
        signedHeaders := make([]string, 0, length)
        for key, value := range headers </span><span class="cov0" title="0">{
                _key := strings.ToLower(strings.TrimSpace(key))
                if _key != "" </span><span class="cov0" title="0">{
                        signedHeaders = append(signedHeaders, _key)
                        _headers[_key] = value
                }</span> else<span class="cov0" title="0"> {
                        delete(headers, key)
                }</span>
        }
        <span class="cov0" title="0">sort.Strings(signedHeaders)
        return signedHeaders, _headers</span>
}

func getSignature(stringToSign, sk, region, shortDate string) string <span class="cov0" title="0">{
        key := HmacSha256([]byte(V4_HASH_PRE+sk), []byte(shortDate))
        key = HmacSha256(key, []byte(region))
        key = HmacSha256(key, []byte(V4_SERVICE_NAME))
        key = HmacSha256(key, []byte(V4_SERVICE_SUFFIX))
        return Hex(HmacSha256(key, []byte(stringToSign)))
}</span>

func V4Auth(ak, sk, region, method, canonicalizedUrl, queryUrl string, headers map[string][]string) map[string]string <span class="cov0" title="0">{
        return v4Auth(ak, sk, region, method, canonicalizedUrl, queryUrl, headers)
}</span>

func v4Auth(ak, sk, region, method, canonicalizedUrl, queryUrl string, headers map[string][]string) map[string]string <span class="cov0" title="0">{
        var t time.Time

        if val, ok := headers[HEADER_DATE_AMZ]; ok </span><span class="cov0" title="0">{
                var err error
                t, err = time.Parse(LONG_DATE_FORMAT, val[0])
                if err != nil </span><span class="cov0" title="0">{
                        t = time.Now().UTC()
                }</span>
        } else<span class="cov0" title="0"> if val, ok := headers[PARAM_DATE_AMZ_CAMEL]; ok </span><span class="cov0" title="0">{
                var err error
                t, err = time.Parse(LONG_DATE_FORMAT, val[0])
                if err != nil </span><span class="cov0" title="0">{
                        t = time.Now().UTC()
                }</span>
        } else<span class="cov0" title="0"> if val, ok := headers[HEADER_DATE_CAMEL]; ok </span><span class="cov0" title="0">{
                var err error
                t, err = time.Parse(RFC1123_FORMAT, val[0])
                if err != nil </span><span class="cov0" title="0">{
                        t = time.Now().UTC()
                }</span>
        } else<span class="cov0" title="0"> if val, ok := headers[strings.ToLower(HEADER_DATE_CAMEL)]; ok </span><span class="cov0" title="0">{
                var err error
                t, err = time.Parse(RFC1123_FORMAT, val[0])
                if err != nil </span><span class="cov0" title="0">{
                        t = time.Now().UTC()
                }</span>
        } else<span class="cov0" title="0"> {
                t = time.Now().UTC()
        }</span>
        <span class="cov0" title="0">shortDate := t.Format(SHORT_DATE_FORMAT)
        longDate := t.Format(LONG_DATE_FORMAT)

        signedHeaders, _headers := getSignedHeaders(headers)

        credential, scope := getCredential(ak, region, shortDate)

        stringToSign := getV4StringToSign(method, canonicalizedUrl, queryUrl, scope, longDate, EMPTY_CONTENT_SHA256, signedHeaders, _headers)

        signature := getSignature(stringToSign, sk, region, shortDate)

        ret := make(map[string]string, 3)
        ret["Credential"] = credential
        ret["SignedHeaders"] = strings.Join(signedHeaders, ";")
        ret["Signature"] = signature
        return ret</span>
}
</pre>
		
		<pre class="file" id="file52" style="display: none">package obs

import (
        "errors"
        "fmt"
        "io"
        "net/http"
        "os"
        "sort"
        "strings"

        log "github.com/sirupsen/logrus"
)

type ObsClient struct {
        conf       *config
        httpClient *http.Client
        transport  *http.Transport
}

func New(ak, sk, endpoint string, configurers ...configurer) (*ObsClient, error) <span class="cov0" title="0">{
        conf := &amp;config{securityProvider: &amp;securityProvider{ak: ak, sk: sk}, endpoint: endpoint}
        conf.maxRetryCount = -1
        for _, configurer := range configurers </span><span class="cov0" title="0">{
                configurer(conf)
        }</span>

        <span class="cov0" title="0">if err := conf.initConfigWithDefault(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">transport, err := conf.getTransport()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">info := make([]string, 3)
        info[0] = fmt.Sprintf("[OBS SDK Version=%s", obs_sdk_version)
        info[1] = fmt.Sprintf("Endpoint=%s", conf.endpoint)
        accessMode := "Virtual Hosting"
        if conf.pathStyle </span><span class="cov0" title="0">{
                accessMode = "Path"
        }</span>
        <span class="cov0" title="0">info[2] = fmt.Sprintf("Access Mode=%s]", accessMode)
        log.Warn(strings.Join(info, "];["))

        log.Debug("Create obsclient with config:\n%s\n", conf)
        obsClient := &amp;ObsClient{conf: conf, httpClient: &amp;http.Client{Transport: transport, CheckRedirect: checkRedirectFunc}, transport: transport}
        return obsClient, nil</span>
}

func (obsClient ObsClient) Refresh(ak, sk, securityToken string) <span class="cov0" title="0">{
        sp := &amp;securityProvider{ak: strings.TrimSpace(ak), sk: strings.TrimSpace(sk), securityToken: strings.TrimSpace(securityToken)}
        obsClient.conf.securityProvider = sp
}</span>

func (obsClient ObsClient) Close() <span class="cov0" title="0">{
        obsClient.transport.CloseIdleConnections()
        obsClient.transport = nil
        obsClient.httpClient = nil
        obsClient.conf = nil
}</span>

func (obsClient ObsClient) ListBuckets(input *ListBucketsInput) (output *ListBucketsOutput, err error) <span class="cov0" title="0">{
        if input == nil </span><span class="cov0" title="0">{
                input = &amp;ListBucketsInput{}
        }</span>
        <span class="cov0" title="0">output = &amp;ListBucketsOutput{}
        err = obsClient.doActionWithoutBucket("ListBuckets", HTTP_GET, input, output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) CreateBucket(input *CreateBucketInput) (output *BaseModel, err error) <span class="cov0" title="0">{
        if input == nil </span><span class="cov0" title="0">{
                return nil, errors.New("CreateBucketInput is nil")
        }</span>
        <span class="cov0" title="0">output = &amp;BaseModel{}
        err = obsClient.doActionWithBucket("CreateBucket", HTTP_PUT, input.Bucket, input, output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) DeleteBucket(bucketName string) (output *BaseModel, err error) <span class="cov0" title="0">{
        output = &amp;BaseModel{}
        err = obsClient.doActionWithBucket("DeleteBucket", HTTP_DELETE, bucketName, defaultSerializable, output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) SetBucketStoragePolicy(input *SetBucketStoragePolicyInput) (output *BaseModel, err error) <span class="cov0" title="0">{
        if input == nil </span><span class="cov0" title="0">{
                return nil, errors.New("SetBucketStoragePolicyInput is nil")
        }</span>
        <span class="cov0" title="0">output = &amp;BaseModel{}
        err = obsClient.doActionWithBucket("SetBucketStoragePolicy", HTTP_PUT, input.Bucket, input, output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) GetBucketStoragePolicy(bucketName string) (output *GetBucketStoragePolicyOutput, err error) <span class="cov0" title="0">{
        output = &amp;GetBucketStoragePolicyOutput{}
        err = obsClient.doActionWithBucket("GetBucketStoragePolicy", HTTP_GET, bucketName, newSubResourceSerial(SubResourceStoragePolicy), output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) ListObjects(input *ListObjectsInput) (output *ListObjectsOutput, err error) <span class="cov0" title="0">{
        if input == nil </span><span class="cov0" title="0">{
                return nil, errors.New("ListObjectsInput is nil")
        }</span>
        <span class="cov0" title="0">output = &amp;ListObjectsOutput{}
        err = obsClient.doActionWithBucket("ListObjects", HTTP_GET, input.Bucket, input, output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span> else<span class="cov0" title="0"> {
                if location, ok := output.ResponseHeaders[HEADER_BUCKET_REGION]; ok </span><span class="cov0" title="0">{
                        output.Location = location[0]
                }</span>
        }
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) ListVersions(input *ListVersionsInput) (output *ListVersionsOutput, err error) <span class="cov0" title="0">{
        if input == nil </span><span class="cov0" title="0">{
                return nil, errors.New("ListVersionsInput is nil")
        }</span>
        <span class="cov0" title="0">output = &amp;ListVersionsOutput{}
        err = obsClient.doActionWithBucket("ListVersions", HTTP_GET, input.Bucket, input, output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span> else<span class="cov0" title="0"> {
                if location, ok := output.ResponseHeaders[HEADER_BUCKET_REGION]; ok </span><span class="cov0" title="0">{
                        output.Location = location[0]
                }</span>
        }
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) ListMultipartUploads(input *ListMultipartUploadsInput) (output *ListMultipartUploadsOutput, err error) <span class="cov0" title="0">{
        if input == nil </span><span class="cov0" title="0">{
                return nil, errors.New("ListMultipartUploadsInput is nil")
        }</span>
        <span class="cov0" title="0">output = &amp;ListMultipartUploadsOutput{}
        err = obsClient.doActionWithBucket("ListMultipartUploads", HTTP_GET, input.Bucket, input, output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) SetBucketQuota(input *SetBucketQuotaInput) (output *BaseModel, err error) <span class="cov0" title="0">{
        if input == nil </span><span class="cov0" title="0">{
                return nil, errors.New("SetBucketQuotaInput is nil")
        }</span>
        <span class="cov0" title="0">output = &amp;BaseModel{}
        err = obsClient.doActionWithBucket("SetBucketQuota", HTTP_PUT, input.Bucket, input, output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) GetBucketQuota(bucketName string) (output *GetBucketQuotaOutput, err error) <span class="cov0" title="0">{
        output = &amp;GetBucketQuotaOutput{}
        err = obsClient.doActionWithBucket("GetBucketQuota", HTTP_GET, bucketName, newSubResourceSerial(SubResourceQuota), output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) HeadBucket(bucketName string) (output *BaseModel, err error) <span class="cov0" title="0">{
        output = &amp;BaseModel{}
        err = obsClient.doActionWithBucket("HeadBucket", HTTP_HEAD, bucketName, defaultSerializable, output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) GetBucketMetadata(input *GetBucketMetadataInput) (output *GetBucketMetadataOutput, err error) <span class="cov0" title="0">{
        output = &amp;GetBucketMetadataOutput{}
        err = obsClient.doActionWithBucket("GetBucketMetadata", HTTP_HEAD, input.Bucket, input, output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span> else<span class="cov0" title="0"> {
                ParseGetBucketMetadataOutput(output)
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) GetBucketStorageInfo(bucketName string) (output *GetBucketStorageInfoOutput, err error) <span class="cov0" title="0">{
        output = &amp;GetBucketStorageInfoOutput{}
        err = obsClient.doActionWithBucket("GetBucketStorageInfo", HTTP_GET, bucketName, newSubResourceSerial(SubResourceStorageInfo), output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) GetBucketLocation(bucketName string) (output *GetBucketLocationOutput, err error) <span class="cov0" title="0">{
        output = &amp;GetBucketLocationOutput{}
        err = obsClient.doActionWithBucket("GetBucketLocation", HTTP_GET, bucketName, newSubResourceSerial(SubResourceLocation), output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) SetBucketAcl(input *SetBucketAclInput) (output *BaseModel, err error) <span class="cov0" title="0">{
        if input == nil </span><span class="cov0" title="0">{
                return nil, errors.New("SetBucketAclInput is nil")
        }</span>
        <span class="cov0" title="0">output = &amp;BaseModel{}
        err = obsClient.doActionWithBucket("SetBucketAcl", HTTP_PUT, input.Bucket, input, output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) GetBucketAcl(bucketName string) (output *GetBucketAclOutput, err error) <span class="cov0" title="0">{
        output = &amp;GetBucketAclOutput{}
        err = obsClient.doActionWithBucket("GetBucketAcl", HTTP_GET, bucketName, newSubResourceSerial(SubResourceAcl), output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) SetBucketPolicy(input *SetBucketPolicyInput) (output *BaseModel, err error) <span class="cov0" title="0">{
        if input == nil </span><span class="cov0" title="0">{
                return nil, errors.New("SetBucketPolicy is nil")
        }</span>
        <span class="cov0" title="0">output = &amp;BaseModel{}
        err = obsClient.doActionWithBucket("SetBucketPolicy", HTTP_PUT, input.Bucket, input, output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) GetBucketPolicy(bucketName string) (output *GetBucketPolicyOutput, err error) <span class="cov0" title="0">{
        output = &amp;GetBucketPolicyOutput{}
        err = obsClient.doActionWithBucketV2("GetBucketPolicy", HTTP_GET, bucketName, newSubResourceSerial(SubResourcePolicy), output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) DeleteBucketPolicy(bucketName string) (output *BaseModel, err error) <span class="cov0" title="0">{
        output = &amp;BaseModel{}
        err = obsClient.doActionWithBucket("DeleteBucketPolicy", HTTP_DELETE, bucketName, newSubResourceSerial(SubResourcePolicy), output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) SetBucketCors(input *SetBucketCorsInput) (output *BaseModel, err error) <span class="cov0" title="0">{
        if input == nil </span><span class="cov0" title="0">{
                return nil, errors.New("SetBucketCorsInput is nil")
        }</span>
        <span class="cov0" title="0">output = &amp;BaseModel{}
        err = obsClient.doActionWithBucket("SetBucketCors", HTTP_PUT, input.Bucket, input, output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) GetBucketCors(bucketName string) (output *GetBucketCorsOutput, err error) <span class="cov0" title="0">{
        output = &amp;GetBucketCorsOutput{}
        err = obsClient.doActionWithBucket("GetBucketCors", HTTP_GET, bucketName, newSubResourceSerial(SubResourceCors), output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) DeleteBucketCors(bucketName string) (output *BaseModel, err error) <span class="cov0" title="0">{
        output = &amp;BaseModel{}
        err = obsClient.doActionWithBucket("DeleteBucketCors", HTTP_DELETE, bucketName, newSubResourceSerial(SubResourceCors), output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) SetBucketVersioning(input *SetBucketVersioningInput) (output *BaseModel, err error) <span class="cov0" title="0">{
        if input == nil </span><span class="cov0" title="0">{
                return nil, errors.New("SetBucketVersioningInput is nil")
        }</span>
        <span class="cov0" title="0">output = &amp;BaseModel{}
        err = obsClient.doActionWithBucket("SetBucketVersioning", HTTP_PUT, input.Bucket, input, output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) GetBucketVersioning(bucketName string) (output *GetBucketVersioningOutput, err error) <span class="cov0" title="0">{
        output = &amp;GetBucketVersioningOutput{}
        err = obsClient.doActionWithBucket("GetBucketVersioning", HTTP_GET, bucketName, newSubResourceSerial(SubResourceVersioning), output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) SetBucketWebsiteConfiguration(input *SetBucketWebsiteConfigurationInput) (output *BaseModel, err error) <span class="cov0" title="0">{
        if input == nil </span><span class="cov0" title="0">{
                return nil, errors.New("SetBucketWebsiteConfigurationInput is nil")
        }</span>
        <span class="cov0" title="0">output = &amp;BaseModel{}
        err = obsClient.doActionWithBucket("SetBucketWebsiteConfiguration", HTTP_PUT, input.Bucket, input, output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) GetBucketWebsiteConfiguration(bucketName string) (output *GetBucketWebsiteConfigurationOutput, err error) <span class="cov0" title="0">{
        output = &amp;GetBucketWebsiteConfigurationOutput{}
        err = obsClient.doActionWithBucket("GetBucketWebsiteConfiguration", HTTP_GET, bucketName, newSubResourceSerial(SubResourceWebsite), output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) DeleteBucketWebsiteConfiguration(bucketName string) (output *BaseModel, err error) <span class="cov0" title="0">{
        output = &amp;BaseModel{}
        err = obsClient.doActionWithBucket("DeleteBucketWebsiteConfiguration", HTTP_DELETE, bucketName, newSubResourceSerial(SubResourceWebsite), output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) SetBucketLoggingConfiguration(input *SetBucketLoggingConfigurationInput) (output *BaseModel, err error) <span class="cov0" title="0">{
        if input == nil </span><span class="cov0" title="0">{
                return nil, errors.New("SetBucketLoggingConfigurationInput is nil")
        }</span>
        <span class="cov0" title="0">output = &amp;BaseModel{}
        err = obsClient.doActionWithBucket("SetBucketLoggingConfiguration", HTTP_PUT, input.Bucket, input, output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) GetBucketLoggingConfiguration(bucketName string) (output *GetBucketLoggingConfigurationOutput, err error) <span class="cov0" title="0">{
        output = &amp;GetBucketLoggingConfigurationOutput{}
        err = obsClient.doActionWithBucket("GetBucketLoggingConfiguration", HTTP_GET, bucketName, newSubResourceSerial(SubResourceLogging), output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) SetBucketLifecycleConfiguration(input *SetBucketLifecycleConfigurationInput) (output *BaseModel, err error) <span class="cov0" title="0">{
        if input == nil </span><span class="cov0" title="0">{
                return nil, errors.New("SetBucketLifecycleConfigurationInput is nil")
        }</span>
        <span class="cov0" title="0">output = &amp;BaseModel{}
        err = obsClient.doActionWithBucket("SetBucketLifecycleConfiguration", HTTP_PUT, input.Bucket, input, output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) GetBucketLifecycleConfiguration(bucketName string) (output *GetBucketLifecycleConfigurationOutput, err error) <span class="cov0" title="0">{
        output = &amp;GetBucketLifecycleConfigurationOutput{}
        err = obsClient.doActionWithBucket("GetBucketLifecycleConfiguration", HTTP_GET, bucketName, newSubResourceSerial(SubResourceLifecycle), output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) DeleteBucketLifecycleConfiguration(bucketName string) (output *BaseModel, err error) <span class="cov0" title="0">{
        output = &amp;BaseModel{}
        err = obsClient.doActionWithBucket("DeleteBucketLifecycleConfiguration", HTTP_DELETE, bucketName, newSubResourceSerial(SubResourceLifecycle), output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) SetBucketTagging(input *SetBucketTaggingInput) (output *BaseModel, err error) <span class="cov0" title="0">{
        if input == nil </span><span class="cov0" title="0">{
                return nil, errors.New("SetBucketTaggingInput is nil")
        }</span>
        <span class="cov0" title="0">output = &amp;BaseModel{}
        err = obsClient.doActionWithBucket("SetBucketTagging", HTTP_PUT, input.Bucket, input, output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) GetBucketTagging(bucketName string) (output *GetBucketTaggingOutput, err error) <span class="cov0" title="0">{
        output = &amp;GetBucketTaggingOutput{}
        err = obsClient.doActionWithBucket("GetBucketTagging", HTTP_GET, bucketName, newSubResourceSerial(SubResourceTagging), output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) DeleteBucketTagging(bucketName string) (output *BaseModel, err error) <span class="cov0" title="0">{
        output = &amp;BaseModel{}
        err = obsClient.doActionWithBucket("DeleteBucketTagging", HTTP_DELETE, bucketName, newSubResourceSerial(SubResourceTagging), output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) SetBucketNotification(input *SetBucketNotificationInput) (output *BaseModel, err error) <span class="cov0" title="0">{
        if input == nil </span><span class="cov0" title="0">{
                return nil, errors.New("SetBucketNotificationInput is nil")
        }</span>
        <span class="cov0" title="0">output = &amp;BaseModel{}
        err = obsClient.doActionWithBucket("SetBucketNotification", HTTP_PUT, input.Bucket, input, output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) GetBucketNotification(bucketName string) (output *GetBucketNotificationOutput, err error) <span class="cov0" title="0">{
        output = &amp;GetBucketNotificationOutput{}
        err = obsClient.doActionWithBucket("GetBucketNotification", HTTP_GET, bucketName, newSubResourceSerial(SubResourceNotification), output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) DeleteObject(input *DeleteObjectInput) (output *DeleteObjectOutput, err error) <span class="cov0" title="0">{
        if input == nil </span><span class="cov0" title="0">{
                return nil, errors.New("DeleteObjectInput is nil")
        }</span>
        <span class="cov0" title="0">output = &amp;DeleteObjectOutput{}
        err = obsClient.doActionWithBucketAndKey("DeleteObject", HTTP_DELETE, input.Bucket, input.Key, input, output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span> else<span class="cov0" title="0"> {
                ParseDeleteObjectOutput(output)
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) DeleteObjects(input *DeleteObjectsInput) (output *DeleteObjectsOutput, err error) <span class="cov0" title="0">{
        if input == nil </span><span class="cov0" title="0">{
                return nil, errors.New("DeleteObjectsInput is nil")
        }</span>
        <span class="cov0" title="0">output = &amp;DeleteObjectsOutput{}
        err = obsClient.doActionWithBucket("DeleteObjects", HTTP_POST, input.Bucket, input, output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) SetObjectAcl(input *SetObjectAclInput) (output *BaseModel, err error) <span class="cov0" title="0">{
        if input == nil </span><span class="cov0" title="0">{
                return nil, errors.New("SetObjectAclInput is nil")
        }</span>
        <span class="cov0" title="0">output = &amp;BaseModel{}
        err = obsClient.doActionWithBucketAndKey("SetObjectAcl", HTTP_PUT, input.Bucket, input.Key, input, output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) GetObjectAcl(input *GetObjectAclInput) (output *GetObjectAclOutput, err error) <span class="cov0" title="0">{
        if input == nil </span><span class="cov0" title="0">{
                return nil, errors.New("GetObjectAclInput is nil")
        }</span>
        <span class="cov0" title="0">output = &amp;GetObjectAclOutput{}
        err = obsClient.doActionWithBucketAndKey("GetObjectAcl", HTTP_GET, input.Bucket, input.Key, input, output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span> else<span class="cov0" title="0"> {
                if versionId, ok := output.ResponseHeaders[HEADER_VERSION_ID]; ok </span><span class="cov0" title="0">{
                        output.VersionId = versionId[0]
                }</span>
        }
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) RestoreObject(input *RestoreObjectInput) (output *BaseModel, err error) <span class="cov0" title="0">{
        if input == nil </span><span class="cov0" title="0">{
                return nil, errors.New("RestoreObjectInput is nil")
        }</span>
        <span class="cov0" title="0">output = &amp;BaseModel{}
        err = obsClient.doActionWithBucketAndKey("RestoreObject", HTTP_POST, input.Bucket, input.Key, input, output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) GetObjectMetadata(input *GetObjectMetadataInput) (output *GetObjectMetadataOutput, err error) <span class="cov0" title="0">{
        if input == nil </span><span class="cov0" title="0">{
                return nil, errors.New("GetObjectMetadataInput is nil")
        }</span>
        <span class="cov0" title="0">output = &amp;GetObjectMetadataOutput{}
        err = obsClient.doActionWithBucketAndKey("GetObjectMetadata", HTTP_HEAD, input.Bucket, input.Key, input, output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span> else<span class="cov0" title="0"> {
                ParseGetObjectMetadataOutput(output)
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) GetObject(input *GetObjectInput) (output *GetObjectOutput, err error) <span class="cov0" title="0">{
        if input == nil </span><span class="cov0" title="0">{
                return nil, errors.New("GetObjectInput is nil")
        }</span>
        <span class="cov0" title="0">output = &amp;GetObjectOutput{}
        err = obsClient.doActionWithBucketAndKey("GetObject", HTTP_GET, input.Bucket, input.Key, input, output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span> else<span class="cov0" title="0"> {
                ParseGetObjectOutput(output)
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) PutObject(input *PutObjectInput) (output *PutObjectOutput, err error) <span class="cov0" title="0">{
        if input == nil </span><span class="cov0" title="0">{
                return nil, errors.New("PutObjectInput is nil")
        }</span>

        <span class="cov0" title="0">if input.ContentType == "" &amp;&amp; input.Key != "" </span><span class="cov0" title="0">{
                if contentType, ok := mime_types[input.Key[strings.LastIndex(input.Key, ".")+1:]]; ok </span><span class="cov0" title="0">{
                        input.ContentType = contentType
                }</span>
        }

        <span class="cov0" title="0">output = &amp;PutObjectOutput{}
        var repeatable bool
        if input.Body != nil </span><span class="cov0" title="0">{
                _, repeatable = input.Body.(*strings.Reader)
                if input.ContentLength &gt; 0 </span><span class="cov0" title="0">{
                        input.Body = &amp;readerWrapper{reader: input.Body, totalCount: input.ContentLength}
                }</span>
        }
        <span class="cov0" title="0">if repeatable </span><span class="cov0" title="0">{
                err = obsClient.doActionWithBucketAndKey("PutObject", HTTP_PUT, input.Bucket, input.Key, input, output)
        }</span> else<span class="cov0" title="0"> {
                err = obsClient.doActionWithBucketAndKeyUnRepeatable("PutObject", HTTP_PUT, input.Bucket, input.Key, input, output)
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span> else<span class="cov0" title="0"> {
                ParsePutObjectOutput(output)
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) PutFile(input *PutFileInput) (output *PutObjectOutput, err error) <span class="cov0" title="0">{
        if input == nil </span><span class="cov0" title="0">{
                return nil, errors.New("PutFileInput is nil")
        }</span>

        <span class="cov0" title="0">var body io.Reader
        sourceFile := strings.TrimSpace(input.SourceFile)
        if sourceFile != "" </span><span class="cov0" title="0">{
                fd, err := os.Open(sourceFile)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">defer fd.Close()

                stat, err := fd.Stat()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">fileReaderWrapper := &amp;fileReaderWrapper{filePath: sourceFile}
                fileReaderWrapper.reader = fd
                if input.ContentLength &gt; 0 </span><span class="cov0" title="0">{
                        if input.ContentLength &gt; stat.Size() </span><span class="cov0" title="0">{
                                input.ContentLength = stat.Size()
                        }</span>
                        <span class="cov0" title="0">fileReaderWrapper.totalCount = input.ContentLength</span>
                } else<span class="cov0" title="0"> {
                        fileReaderWrapper.totalCount = stat.Size()
                }</span>
                <span class="cov0" title="0">body = fileReaderWrapper</span>
        }

        <span class="cov0" title="0">_input := &amp;PutObjectInput{}
        _input.PutObjectBasicInput = input.PutObjectBasicInput
        _input.Body = body

        if _input.ContentType == "" &amp;&amp; _input.Key != "" </span><span class="cov0" title="0">{
                if contentType, ok := mime_types[_input.Key[strings.LastIndex(_input.Key, ".")+1:]]; ok </span><span class="cov0" title="0">{
                        _input.ContentType = contentType
                }</span> else<span class="cov0" title="0"> if contentType, ok := mime_types[sourceFile[strings.LastIndex(sourceFile, ".")+1:]]; ok </span><span class="cov0" title="0">{
                        _input.ContentType = contentType
                }</span>
        }

        <span class="cov0" title="0">output = &amp;PutObjectOutput{}
        err = obsClient.doActionWithBucketAndKey("PutFile", HTTP_PUT, _input.Bucket, _input.Key, _input, output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span> else<span class="cov0" title="0"> {
                ParsePutObjectOutput(output)
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) CopyObject(input *CopyObjectInput) (output *CopyObjectOutput, err error) <span class="cov0" title="0">{
        if input == nil </span><span class="cov0" title="0">{
                return nil, errors.New("CopyObjectInput is nil")
        }</span>

        <span class="cov0" title="0">if strings.TrimSpace(input.CopySourceBucket) == "" </span><span class="cov0" title="0">{
                return nil, errors.New("Source bucket is empty")
        }</span>
        <span class="cov0" title="0">if strings.TrimSpace(input.CopySourceKey) == "" </span><span class="cov0" title="0">{
                return nil, errors.New("Source key is empty")
        }</span>

        <span class="cov0" title="0">output = &amp;CopyObjectOutput{}
        err = obsClient.doActionWithBucketAndKey("CopyObject", HTTP_PUT, input.Bucket, input.Key, input, output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span> else<span class="cov0" title="0"> {
                ParseCopyObjectOutput(output)
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) AbortMultipartUpload(input *AbortMultipartUploadInput) (output *BaseModel, err error) <span class="cov0" title="0">{
        if input == nil </span><span class="cov0" title="0">{
                return nil, errors.New("AbortMultipartUploadInput is nil")
        }</span>
        <span class="cov0" title="0">if input.UploadId == "" </span><span class="cov0" title="0">{
                return nil, errors.New("UploadId is empty")
        }</span>
        <span class="cov0" title="0">output = &amp;BaseModel{}
        err = obsClient.doActionWithBucketAndKey("AbortMultipartUpload", HTTP_DELETE, input.Bucket, input.Key, input, output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) InitiateMultipartUpload(input *InitiateMultipartUploadInput) (output *InitiateMultipartUploadOutput, err error) <span class="cov0" title="0">{
        if input == nil </span><span class="cov0" title="0">{
                return nil, errors.New("InitiateMultipartUploadInput is nil")
        }</span>

        <span class="cov0" title="0">if input.ContentType == "" &amp;&amp; input.Key != "" </span><span class="cov0" title="0">{
                if contentType, ok := mime_types[input.Key[strings.LastIndex(input.Key, ".")+1:]]; ok </span><span class="cov0" title="0">{
                        input.ContentType = contentType
                }</span>
        }

        <span class="cov0" title="0">output = &amp;InitiateMultipartUploadOutput{}
        err = obsClient.doActionWithBucketAndKey("InitiateMultipartUpload", HTTP_POST, input.Bucket, input.Key, input, output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span> else<span class="cov0" title="0"> {
                ParseInitiateMultipartUploadOutput(output)
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) UploadPart(input *UploadPartInput) (output *UploadPartOutput, err error) <span class="cov0" title="0">{
        if input == nil </span><span class="cov0" title="0">{
                return nil, errors.New("UploadPartInput is nil")
        }</span>

        <span class="cov0" title="0">if input.UploadId == "" </span><span class="cov0" title="0">{
                return nil, errors.New("UploadId is empty")
        }</span>

        <span class="cov0" title="0">output = &amp;UploadPartOutput{}
        var repeatable bool
        if input.Body != nil </span><span class="cov0" title="0">{
                _, repeatable = input.Body.(*strings.Reader)
                if input.PartSize &gt; 0 </span><span class="cov0" title="0">{
                        input.Body = &amp;readerWrapper{reader: input.Body, totalCount: input.PartSize}
                }</span>
        } else<span class="cov0" title="0"> if sourceFile := strings.TrimSpace(input.SourceFile); sourceFile != "" </span><span class="cov0" title="0">{
                fd, err := os.Open(sourceFile)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">defer fd.Close()

                stat, err := fd.Stat()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">fileSize := stat.Size()
                fileReaderWrapper := &amp;fileReaderWrapper{filePath: sourceFile}
                fileReaderWrapper.reader = fd

                if input.Offset &lt; 0 || input.Offset &gt; fileSize </span><span class="cov0" title="0">{
                        input.Offset = 0
                }</span>

                <span class="cov0" title="0">if input.PartSize &lt;= 0 || input.PartSize &gt; (fileSize-input.Offset) </span><span class="cov0" title="0">{
                        input.PartSize = fileSize - input.Offset
                }</span>
                <span class="cov0" title="0">fileReaderWrapper.totalCount = input.PartSize
                fd.Seek(input.Offset, 0)
                input.Body = fileReaderWrapper
                repeatable = true</span>
        }
        <span class="cov0" title="0">if repeatable </span><span class="cov0" title="0">{
                err = obsClient.doActionWithBucketAndKey("UploadPart", HTTP_PUT, input.Bucket, input.Key, input, output)
        }</span> else<span class="cov0" title="0"> {
                err = obsClient.doActionWithBucketAndKeyUnRepeatable("UploadPart", HTTP_PUT, input.Bucket, input.Key, input, output)
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span> else<span class="cov0" title="0"> {
                ParseUploadPartOutput(output)
                output.PartNumber = input.PartNumber
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) CompleteMultipartUpload(input *CompleteMultipartUploadInput) (output *CompleteMultipartUploadOutput, err error) <span class="cov0" title="0">{
        if input == nil </span><span class="cov0" title="0">{
                return nil, errors.New("CompleteMultipartUploadInput is nil")
        }</span>

        <span class="cov0" title="0">if input.UploadId == "" </span><span class="cov0" title="0">{
                return nil, errors.New("UploadId is empty")
        }</span>

        <span class="cov0" title="0">var parts partSlice = input.Parts
        sort.Sort(parts)

        output = &amp;CompleteMultipartUploadOutput{}
        err = obsClient.doActionWithBucketAndKey("CompleteMultipartUpload", HTTP_POST, input.Bucket, input.Key, input, output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span> else<span class="cov0" title="0"> {
                ParseCompleteMultipartUploadOutput(output)
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) ListParts(input *ListPartsInput) (output *ListPartsOutput, err error) <span class="cov0" title="0">{
        if input == nil </span><span class="cov0" title="0">{
                return nil, errors.New("ListPartsInput is nil")
        }</span>
        <span class="cov0" title="0">if input.UploadId == "" </span><span class="cov0" title="0">{
                return nil, errors.New("UploadId is empty")
        }</span>
        <span class="cov0" title="0">output = &amp;ListPartsOutput{}
        err = obsClient.doActionWithBucketAndKey("ListParts", HTTP_GET, input.Bucket, input.Key, input, output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) CopyPart(input *CopyPartInput) (output *CopyPartOutput, err error) <span class="cov0" title="0">{
        if input == nil </span><span class="cov0" title="0">{
                return nil, errors.New("CopyPartInput is nil")
        }</span>
        <span class="cov0" title="0">if input.UploadId == "" </span><span class="cov0" title="0">{
                return nil, errors.New("UploadId is empty")
        }</span>
        <span class="cov0" title="0">if strings.TrimSpace(input.CopySourceBucket) == "" </span><span class="cov0" title="0">{
                return nil, errors.New("Source bucket is empty")
        }</span>
        <span class="cov0" title="0">if strings.TrimSpace(input.CopySourceKey) == "" </span><span class="cov0" title="0">{
                return nil, errors.New("Source key is empty")
        }</span>

        <span class="cov0" title="0">output = &amp;CopyPartOutput{}
        err = obsClient.doActionWithBucketAndKey("CopyPart", HTTP_PUT, input.Bucket, input.Key, input, output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span> else<span class="cov0" title="0"> {
                ParseCopyPartOutput(output)
                output.PartNumber = input.PartNumber
        }</span>
        <span class="cov0" title="0">return</span>
}
</pre>
		
		<pre class="file" id="file53" style="display: none">package obs

import (
        "crypto/tls"
        "crypto/x509"
        "errors"
        "fmt"
        "net"
        "net/http"
        "net/url"
        "sort"
        "strconv"
        "strings"
        "time"
)

type securityProvider struct {
        ak            string
        sk            string
        securityToken string
}

type urlHolder struct {
        scheme string
        host   string
        port   int
}

type config struct {
        securityProvider *securityProvider
        urlHolder        *urlHolder
        endpoint         string
        signature        SignatureType
        pathStyle        bool
        region           string
        connectTimeout   int
        socketTimeout    int
        headerTimeout    int
        idleConnTimeout  int
        finalTimeout     int
        maxRetryCount    int
        proxyUrl         string
        maxConnsPerHost  int
        sslVerify        bool
        pemCerts         []byte
}

func (conf config) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("[endpoint:%s, signature:%s, pathStyle:%v, region:%s"+
                "\nconnectTimeout:%d, socketTimeout:%dheaderTimeout:%d, idleConnTimeout:%d"+
                "\nmaxRetryCount:%d, maxConnsPerHost:%d, sslVerify:%v, proxyUrl:%s]",
                conf.endpoint, conf.signature, conf.pathStyle, conf.region,
                conf.connectTimeout, conf.socketTimeout, conf.headerTimeout, conf.idleConnTimeout,
                conf.maxRetryCount, conf.maxConnsPerHost, conf.sslVerify, conf.proxyUrl,
        )
}</span>

type configurer func(conf *config)

func WithSslVerify(sslVerify bool) configurer <span class="cov0" title="0">{
        return WithSslVerifyAndPemCerts(sslVerify, nil)
}</span>

func WithSslVerifyAndPemCerts(sslVerify bool, pemCerts []byte) configurer <span class="cov0" title="0">{
        return func(conf *config) </span><span class="cov0" title="0">{
                conf.sslVerify = sslVerify
                conf.pemCerts = pemCerts
        }</span>
}

func WithHeaderTimeout(headerTimeout int) configurer <span class="cov0" title="0">{
        return func(conf *config) </span><span class="cov0" title="0">{
                conf.headerTimeout = headerTimeout
        }</span>
}

func WithProxyUrl(proxyUrl string) configurer <span class="cov0" title="0">{
        return func(conf *config) </span><span class="cov0" title="0">{
                conf.proxyUrl = proxyUrl
        }</span>
}

func WithMaxConnections(maxConnsPerHost int) configurer <span class="cov0" title="0">{
        return func(conf *config) </span><span class="cov0" title="0">{
                conf.maxConnsPerHost = maxConnsPerHost
        }</span>
}

func WithPathStyle(pathStyle bool) configurer <span class="cov0" title="0">{
        return func(conf *config) </span><span class="cov0" title="0">{
                conf.pathStyle = pathStyle
        }</span>
}

func WithSignature(signature SignatureType) configurer <span class="cov0" title="0">{
        return func(conf *config) </span><span class="cov0" title="0">{
                conf.signature = signature
        }</span>
}

func WithRegion(region string) configurer <span class="cov0" title="0">{
        return func(conf *config) </span><span class="cov0" title="0">{
                conf.region = region
        }</span>
}

func WithConnectTimeout(connectTimeout int) configurer <span class="cov0" title="0">{
        return func(conf *config) </span><span class="cov0" title="0">{
                conf.connectTimeout = connectTimeout
        }</span>
}

func WithSocketTimeout(socketTimeout int) configurer <span class="cov0" title="0">{
        return func(conf *config) </span><span class="cov0" title="0">{
                conf.socketTimeout = socketTimeout
        }</span>
}

func WithIdleConnTimeout(idleConnTimeout int) configurer <span class="cov0" title="0">{
        return func(conf *config) </span><span class="cov0" title="0">{
                conf.idleConnTimeout = idleConnTimeout
        }</span>
}

func WithMaxRetryCount(maxRetryCount int) configurer <span class="cov0" title="0">{
        return func(conf *config) </span><span class="cov0" title="0">{
                conf.maxRetryCount = maxRetryCount
        }</span>
}

func WithSecurityToken(securityToken string) configurer <span class="cov0" title="0">{
        return func(conf *config) </span><span class="cov0" title="0">{
                conf.securityProvider.securityToken = securityToken
        }</span>
}

func (conf *config) initConfigWithDefault() error <span class="cov0" title="0">{
        conf.securityProvider.ak = strings.TrimSpace(conf.securityProvider.ak)
        conf.securityProvider.sk = strings.TrimSpace(conf.securityProvider.sk)
        conf.securityProvider.securityToken = strings.TrimSpace(conf.securityProvider.securityToken)
        conf.endpoint = strings.TrimSpace(conf.endpoint)
        if conf.endpoint == "" </span><span class="cov0" title="0">{
                return errors.New("endpoint is not set")
        }</span>

        <span class="cov0" title="0">if index := strings.Index(conf.endpoint, "?"); index &gt; 0 </span><span class="cov0" title="0">{
                conf.endpoint = conf.endpoint[:index]
        }</span>

        <span class="cov0" title="0">for strings.LastIndex(conf.endpoint, "/") == len(conf.endpoint)-1 </span><span class="cov0" title="0">{
                conf.endpoint = conf.endpoint[:len(conf.endpoint)-1]
        }</span>

        <span class="cov0" title="0">if conf.signature == "" </span><span class="cov0" title="0">{
                conf.signature = DEFAULT_SIGNATURE
        }</span>

        <span class="cov0" title="0">urlHolder := &amp;urlHolder{}
        var address string
        if strings.HasPrefix(conf.endpoint, "https://") </span><span class="cov0" title="0">{
                urlHolder.scheme = "https"
                address = conf.endpoint[len("https://"):]
        }</span> else<span class="cov0" title="0"> if strings.HasPrefix(conf.endpoint, "http://") </span><span class="cov0" title="0">{
                urlHolder.scheme = "http"
                address = conf.endpoint[len("http://"):]
        }</span> else<span class="cov0" title="0"> {
                urlHolder.scheme = "http"
                address = conf.endpoint
        }</span>

        <span class="cov0" title="0">addr := strings.Split(address, ":")
        if len(addr) == 2 </span><span class="cov0" title="0">{
                if port, err := strconv.Atoi(addr[1]); err == nil </span><span class="cov0" title="0">{
                        urlHolder.port = port
                }</span>
        }
        <span class="cov0" title="0">urlHolder.host = addr[0]
        if urlHolder.port == 0 </span><span class="cov0" title="0">{
                if urlHolder.scheme == "https" </span><span class="cov0" title="0">{
                        urlHolder.port = 443
                }</span> else<span class="cov0" title="0"> {
                        urlHolder.port = 80
                }</span>
        }

        <span class="cov0" title="0">if IsIP(urlHolder.host) </span><span class="cov0" title="0">{
                conf.pathStyle = true
        }</span>

        <span class="cov0" title="0">conf.urlHolder = urlHolder

        conf.region = strings.TrimSpace(conf.region)
        if conf.region == "" </span><span class="cov0" title="0">{
                conf.region = DEFAULT_REGION
        }</span>

        <span class="cov0" title="0">if conf.connectTimeout &lt;= 0 </span><span class="cov0" title="0">{
                conf.connectTimeout = DEFAULT_CONNECT_TIMEOUT
        }</span>

        <span class="cov0" title="0">if conf.socketTimeout &lt;= 0 </span><span class="cov0" title="0">{
                conf.socketTimeout = DEFAULT_SOCKET_TIMEOUT
        }</span>

        <span class="cov0" title="0">conf.finalTimeout = conf.socketTimeout * 10

        if conf.headerTimeout &lt;= 0 </span><span class="cov0" title="0">{
                conf.headerTimeout = DEFAULT_HEADER_TIMEOUT
        }</span>

        <span class="cov0" title="0">if conf.idleConnTimeout &lt; 0 </span><span class="cov0" title="0">{
                conf.idleConnTimeout = DEFAULT_IDLE_CONN_TIMEOUT
        }</span>

        <span class="cov0" title="0">if conf.maxRetryCount &lt; 0 </span><span class="cov0" title="0">{
                conf.maxRetryCount = DEFAULT_MAX_RETRY_COUNT
        }</span>

        <span class="cov0" title="0">if conf.maxConnsPerHost &lt;= 0 </span><span class="cov0" title="0">{
                conf.maxConnsPerHost = DEFAULT_MAX_CONN_PER_HOST
        }</span>

        <span class="cov0" title="0">conf.proxyUrl = strings.TrimSpace(conf.proxyUrl)
        return nil</span>
}

func (conf *config) getTransport() (*http.Transport, error) <span class="cov0" title="0">{
        transport := &amp;http.Transport{
                Dial: func(network, addr string) (net.Conn, error) </span><span class="cov0" title="0">{
                        conn, err := net.DialTimeout(network, addr, time.Second*time.Duration(conf.connectTimeout))
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">return getConnDelegate(conn, conf.socketTimeout, conf.finalTimeout), nil</span>
                },
                MaxIdleConns:          conf.maxConnsPerHost,
                MaxIdleConnsPerHost:   conf.maxConnsPerHost,
                ResponseHeaderTimeout: time.Second * time.Duration(conf.headerTimeout),
                IdleConnTimeout:       time.Second * time.Duration(conf.idleConnTimeout),
        }

        <span class="cov0" title="0">if conf.proxyUrl != "" </span><span class="cov0" title="0">{
                proxyUrl, err := url.Parse(conf.proxyUrl)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">transport.Proxy = http.ProxyURL(proxyUrl)</span>
        }

        <span class="cov0" title="0">tlsConfig := &amp;tls.Config{InsecureSkipVerify: !conf.sslVerify}
        if conf.sslVerify &amp;&amp; conf.pemCerts != nil </span><span class="cov0" title="0">{
                pool := x509.NewCertPool()
                pool.AppendCertsFromPEM(conf.pemCerts)
                tlsConfig.RootCAs = pool
        }</span>
        <span class="cov0" title="0">transport.TLSClientConfig = tlsConfig

        return transport, nil</span>
}

func checkRedirectFunc(req *http.Request, via []*http.Request) error <span class="cov0" title="0">{
        return http.ErrUseLastResponse
}</span>

func DummyQueryEscape(s string) string <span class="cov0" title="0">{
        return s
}</span>

func (conf *config) formatUrls(bucketName, objectKey string, params map[string]string, escape bool) (requestUrl string, canonicalizedUrl string) <span class="cov0" title="0">{

        urlHolder := conf.urlHolder

        if bucketName == "" </span><span class="cov0" title="0">{
                requestUrl = fmt.Sprintf("%s://%s:%d", urlHolder.scheme, urlHolder.host, urlHolder.port)
                canonicalizedUrl = "/"
        }</span> else<span class="cov0" title="0"> {
                if conf.pathStyle </span><span class="cov0" title="0">{
                        requestUrl = fmt.Sprintf("%s://%s:%d/%s", urlHolder.scheme, urlHolder.host, urlHolder.port, bucketName)
                        canonicalizedUrl = "/" + bucketName
                }</span> else<span class="cov0" title="0"> {
                        requestUrl = fmt.Sprintf("%s://%s.%s:%d", urlHolder.scheme, bucketName, urlHolder.host, urlHolder.port)
                        if conf.signature == "v2" </span><span class="cov0" title="0">{
                                canonicalizedUrl = "/" + bucketName + "/"
                        }</span> else<span class="cov0" title="0"> {
                                canonicalizedUrl = "/"
                        }</span>
                }
        }
        <span class="cov0" title="0">var escapeFunc func(s string) string
        if escape </span><span class="cov0" title="0">{
                escapeFunc = url.QueryEscape
        }</span> else<span class="cov0" title="0"> {
                escapeFunc = DummyQueryEscape
        }</span>

        <span class="cov0" title="0">if objectKey != "" </span><span class="cov0" title="0">{
                encodeObjectKey := escapeFunc(objectKey)
                requestUrl += "/" + encodeObjectKey
                if !strings.HasSuffix(canonicalizedUrl, "/") </span><span class="cov0" title="0">{
                        canonicalizedUrl += "/"
                }</span>
                <span class="cov0" title="0">canonicalizedUrl += encodeObjectKey</span>
        }

        <span class="cov0" title="0">keys := make([]string, 0, len(params))
        for key, _ := range params </span><span class="cov0" title="0">{
                keys = append(keys, strings.TrimSpace(key))
        }</span>
        <span class="cov0" title="0">sort.Strings(keys)
        i := 0

        for index, key := range keys </span><span class="cov0" title="0">{
                if index == 0 </span><span class="cov0" title="0">{
                        requestUrl += "?"
                }</span> else<span class="cov0" title="0"> {
                        requestUrl += "&amp;"
                }</span>
                <span class="cov0" title="0">_key := url.QueryEscape(key)
                requestUrl += _key

                _value := params[key]

                if conf.signature == "v4" </span><span class="cov0" title="0">{
                        requestUrl += "=" + url.QueryEscape(_value)
                }</span> else<span class="cov0" title="0"> {
                        if _value != "" </span><span class="cov0" title="0">{
                                requestUrl += "=" + url.QueryEscape(_value)
                                _value = "=" + _value
                        }</span> else<span class="cov0" title="0"> {
                                _value = ""
                        }</span>
                        <span class="cov0" title="0">lowerKey := strings.ToLower(key)
                        _, ok := allowed_resource_parameter_names[lowerKey]
                        ok = ok || strings.HasPrefix(lowerKey, HEADER_PREFIX)
                        if ok </span><span class="cov0" title="0">{
                                if i == 0 </span><span class="cov0" title="0">{
                                        canonicalizedUrl += "?"
                                }</span> else<span class="cov0" title="0"> {
                                        canonicalizedUrl += "&amp;"
                                }</span>
                                <span class="cov0" title="0">canonicalizedUrl += getQueryUrl(_key, _value)
                                i++</span>
                        }
                }
        }
        <span class="cov0" title="0">return</span>
}

func getQueryUrl(key, value string) string <span class="cov0" title="0">{
        queryUrl := ""
        queryUrl += key
        queryUrl += value
        return queryUrl
}</span>
</pre>
		
		<pre class="file" id="file54" style="display: none">package obs

import (
        "bytes"
        "fmt"
        "io"
        "io/ioutil"
        "net/http"
        "reflect"
        "strings"
        "time"

        log "github.com/sirupsen/logrus"
)

func cleanHeaderPrefix(header http.Header) map[string][]string <span class="cov0" title="0">{
        responseHeaders := make(map[string][]string)
        for key, value := range header </span><span class="cov0" title="0">{
                if len(value) &gt; 0 </span><span class="cov0" title="0">{
                        key = strings.ToLower(key)
                        if strings.HasPrefix(key, HEADER_PREFIX) </span><span class="cov0" title="0">{
                                key = key[len(HEADER_PREFIX):]
                        }</span>
                        <span class="cov0" title="0">responseHeaders[key] = value</span>
                }
        }
        <span class="cov0" title="0">return responseHeaders</span>
}

func ParseStringToStorageClassType(value string) (ret StorageClassType) <span class="cov0" title="0">{
        switch value </span>{
        case "STANDARD":<span class="cov0" title="0">
                ret = StorageClassStandard</span>
        case "STANDARD_IA":<span class="cov0" title="0">
                ret = StorageClassWarm</span>
        case "GLACIER":<span class="cov0" title="0">
                ret = StorageClassCold</span>
        default:<span class="cov0" title="0">
                ret = ""</span>
        }
        <span class="cov0" title="0">return</span>
}

func convertGrantToXml(grant Grant) string <span class="cov0" title="0">{
        xml := make([]string, 0, 4)
        xml = append(xml, fmt.Sprintf("&lt;Grant&gt;&lt;Grantee xsi:type=\"%s\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"&gt;", grant.Grantee.Type))
        if grant.Grantee.Type == GranteeUser </span><span class="cov0" title="0">{
                xml = append(xml, fmt.Sprintf("&lt;ID&gt;%s&lt;/ID&gt;", grant.Grantee.ID))
                if grant.Grantee.DisplayName != "" </span><span class="cov0" title="0">{
                        xml = append(xml, fmt.Sprintf("&lt;DisplayName&gt;%s&lt;/DisplayName&gt;", grant.Grantee.DisplayName))
                }</span>
        } else<span class="cov0" title="0"> {
                xml = append(xml, fmt.Sprintf("&lt;URI&gt;%s&lt;/URI&gt;", grant.Grantee.URI))
        }</span>
        <span class="cov0" title="0">xml = append(xml, fmt.Sprintf("&lt;/Grantee&gt;&lt;Permission&gt;%s&lt;/Permission&gt;&lt;/Grant&gt;", grant.Permission))
        return strings.Join(xml, "")</span>
}

func ConvertLoggingStatusToXml(input BucketLoggingStatus, returnMd5 bool) (data string, md5 string) <span class="cov0" title="0">{
        grantsLength := len(input.TargetGrants)
        xml := make([]string, 0, 8+grantsLength)

        xml = append(xml, "&lt;BucketLoggingStatus&gt;")
        if input.TargetBucket != "" || input.TargetPrefix != "" </span><span class="cov0" title="0">{
                xml = append(xml, "&lt;LoggingEnabled&gt;")
                xml = append(xml, fmt.Sprintf("&lt;TargetBucket&gt;%s&lt;/TargetBucket&gt;", input.TargetBucket))
                xml = append(xml, fmt.Sprintf("&lt;TargetPrefix&gt;%s&lt;/TargetPrefix&gt;", input.TargetPrefix))

                if grantsLength &gt; 0 </span><span class="cov0" title="0">{
                        xml = append(xml, "&lt;TargetGrants&gt;")
                        for _, grant := range input.TargetGrants </span><span class="cov0" title="0">{
                                xml = append(xml, convertGrantToXml(grant))
                        }</span>
                        <span class="cov0" title="0">xml = append(xml, "&lt;/TargetGrants&gt;")</span>
                }

                <span class="cov0" title="0">xml = append(xml, "&lt;/LoggingEnabled&gt;")</span>
        }
        <span class="cov0" title="0">xml = append(xml, "&lt;/BucketLoggingStatus&gt;")
        data = strings.Join(xml, "")
        if returnMd5 </span><span class="cov0" title="0">{
                md5 = Base64Md5([]byte(data))
        }</span>
        <span class="cov0" title="0">return</span>
}

func ConvertAclToXml(input AccessControlPolicy, returnMd5 bool) (data string, md5 string) <span class="cov0" title="0">{
        xml := make([]string, 0, 4+len(input.Grants))
        xml = append(xml, fmt.Sprintf("&lt;AccessControlPolicy&gt;&lt;Owner&gt;&lt;ID&gt;%s&lt;/ID&gt;", input.Owner.ID))
        if input.Owner.DisplayName != "" </span><span class="cov0" title="0">{
                xml = append(xml, fmt.Sprintf("&lt;DisplayName&gt;%s&lt;/DisplayName&gt;", input.Owner.DisplayName))
        }</span>
        <span class="cov0" title="0">xml = append(xml, "&lt;/Owner&gt;&lt;AccessControlList&gt;")
        for _, grant := range input.Grants </span><span class="cov0" title="0">{
                xml = append(xml, convertGrantToXml(grant))
        }</span>
        <span class="cov0" title="0">xml = append(xml, "&lt;/AccessControlList&gt;&lt;/AccessControlPolicy&gt;")
        data = strings.Join(xml, "")
        if returnMd5 </span><span class="cov0" title="0">{
                md5 = Base64Md5([]byte(data))
        }</span>
        <span class="cov0" title="0">return</span>
}

func convertConditionToXml(condition Condition) string <span class="cov0" title="0">{
        xml := make([]string, 0, 2)
        if condition.KeyPrefixEquals != "" </span><span class="cov0" title="0">{
                xml = append(xml, fmt.Sprintf("&lt;KeyPrefixEquals&gt;%s&lt;/KeyPrefixEquals&gt;", condition.KeyPrefixEquals))
        }</span>
        <span class="cov0" title="0">if condition.HttpErrorCodeReturnedEquals != "" </span><span class="cov0" title="0">{
                xml = append(xml, fmt.Sprintf("&lt;HttpErrorCodeReturnedEquals&gt;%s&lt;/HttpErrorCodeReturnedEquals&gt;", condition.HttpErrorCodeReturnedEquals))
        }</span>
        <span class="cov0" title="0">if len(xml) &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Sprintf("&lt;Condition&gt;%s&lt;/Condition&gt;", strings.Join(xml, ""))
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func ConvertWebsiteConfigurationToXml(input BucketWebsiteConfiguration, returnMd5 bool) (data string, md5 string) <span class="cov0" title="0">{
        routingRuleLength := len(input.RoutingRules)
        xml := make([]string, 0, 6+routingRuleLength*10)
        xml = append(xml, "&lt;WebsiteConfiguration&gt;")

        if input.RedirectAllRequestsTo.HostName != "" </span><span class="cov0" title="0">{
                xml = append(xml, fmt.Sprintf("&lt;RedirectAllRequestsTo&gt;&lt;HostName&gt;%s&lt;/HostName&gt;", input.RedirectAllRequestsTo.HostName))
                if input.RedirectAllRequestsTo.Protocol != "" </span><span class="cov0" title="0">{
                        xml = append(xml, fmt.Sprintf("&lt;Protocol&gt;%s&lt;/Protocol&gt;", input.RedirectAllRequestsTo.Protocol))
                }</span>
                <span class="cov0" title="0">xml = append(xml, "&lt;/RedirectAllRequestsTo&gt;")</span>
        } else<span class="cov0" title="0"> {
                xml = append(xml, fmt.Sprintf("&lt;IndexDocument&gt;&lt;Suffix&gt;%s&lt;/Suffix&gt;&lt;/IndexDocument&gt;", input.IndexDocument.Suffix))
                if input.ErrorDocument.Key != "" </span><span class="cov0" title="0">{
                        xml = append(xml, fmt.Sprintf("&lt;ErrorDocument&gt;&lt;Key&gt;%s&lt;/Key&gt;&lt;/ErrorDocument&gt;", input.ErrorDocument.Key))
                }</span>
                <span class="cov0" title="0">if routingRuleLength &gt; 0 </span><span class="cov0" title="0">{
                        xml = append(xml, "&lt;RoutingRules&gt;")
                        for _, routingRule := range input.RoutingRules </span><span class="cov0" title="0">{
                                xml = append(xml, "&lt;RoutingRule&gt;")
                                xml = append(xml, "&lt;Redirect&gt;")
                                if routingRule.Redirect.Protocol != "" </span><span class="cov0" title="0">{
                                        xml = append(xml, fmt.Sprintf("&lt;Protocol&gt;%s&lt;/Protocol&gt;", routingRule.Redirect.Protocol))
                                }</span>
                                <span class="cov0" title="0">if routingRule.Redirect.HostName != "" </span><span class="cov0" title="0">{
                                        xml = append(xml, fmt.Sprintf("&lt;HostName&gt;%s&lt;/HostName&gt;", routingRule.Redirect.HostName))
                                }</span>
                                <span class="cov0" title="0">if routingRule.Redirect.ReplaceKeyPrefixWith != "" </span><span class="cov0" title="0">{
                                        xml = append(xml, fmt.Sprintf("&lt;ReplaceKeyPrefixWith&gt;%s&lt;/ReplaceKeyPrefixWith&gt;", routingRule.Redirect.ReplaceKeyPrefixWith))
                                }</span>

                                <span class="cov0" title="0">if routingRule.Redirect.ReplaceKeyWith != "" </span><span class="cov0" title="0">{
                                        xml = append(xml, fmt.Sprintf("&lt;ReplaceKeyWith&gt;%s&lt;/ReplaceKeyWith&gt;", routingRule.Redirect.ReplaceKeyWith))
                                }</span>
                                <span class="cov0" title="0">if routingRule.Redirect.HttpRedirectCode != "" </span><span class="cov0" title="0">{
                                        xml = append(xml, fmt.Sprintf("&lt;HttpRedirectCode&gt;%s&lt;/HttpRedirectCode&gt;", routingRule.Redirect.HttpRedirectCode))
                                }</span>
                                <span class="cov0" title="0">xml = append(xml, "&lt;/Redirect&gt;")

                                if ret := convertConditionToXml(routingRule.Condition); ret != "" </span><span class="cov0" title="0">{
                                        xml = append(xml, ret)
                                }</span>
                                <span class="cov0" title="0">xml = append(xml, "&lt;/RoutingRule&gt;")</span>
                        }
                        <span class="cov0" title="0">xml = append(xml, "&lt;/RoutingRules&gt;")</span>
                }
        }

        <span class="cov0" title="0">xml = append(xml, "&lt;/WebsiteConfiguration&gt;")
        data = strings.Join(xml, "")
        if returnMd5 </span><span class="cov0" title="0">{
                md5 = Base64Md5([]byte(data))
        }</span>
        <span class="cov0" title="0">return</span>
}

func convertTransitionsToXml(transitions []Transition) string <span class="cov0" title="0">{
        if length := len(transitions); length &gt; 0 </span><span class="cov0" title="0">{
                xml := make([]string, 0, length)
                for _, transition := range transitions </span><span class="cov0" title="0">{
                        var temp string
                        if transition.Days &gt; 0 </span><span class="cov0" title="0">{
                                temp = fmt.Sprintf("&lt;Days&gt;%d&lt;/Days&gt;", transition.Days)
                        }</span> else<span class="cov0" title="0"> if !transition.Date.IsZero() </span><span class="cov0" title="0">{
                                temp = fmt.Sprintf("&lt;Date&gt;%s&lt;/Date&gt;", transition.Date.UTC().Format(ISO8601_MIDNIGHT_DATE_FORMAT))
                        }</span>
                        <span class="cov0" title="0">if temp != "" </span><span class="cov0" title="0">{
                                xml = append(xml, fmt.Sprintf("&lt;Transition&gt;%s&lt;StorageClass&gt;%s&lt;/StorageClass&gt;&lt;/Transition&gt;", temp, transition.StorageClass))
                        }</span>
                }
                <span class="cov0" title="0">return strings.Join(xml, "")</span>
        }
        <span class="cov0" title="0">return ""</span>
}

func convertExpirationToXml(expiration Expiration) string <span class="cov0" title="0">{
        if expiration.Days &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Sprintf("&lt;Expiration&gt;&lt;Days&gt;%d&lt;/Days&gt;&lt;/Expiration&gt;", expiration.Days)
        }</span> else<span class="cov0" title="0"> if !expiration.Date.IsZero() </span><span class="cov0" title="0">{
                return fmt.Sprintf("&lt;Expiration&gt;&lt;Date&gt;%s&lt;/Date&gt;&lt;/Expiration&gt;", expiration.Date.UTC().Format(ISO8601_MIDNIGHT_DATE_FORMAT))
        }</span>
        <span class="cov0" title="0">return ""</span>
}
func convertNoncurrentVersionTransitionsToXml(noncurrentVersionTransitions []NoncurrentVersionTransition) string <span class="cov0" title="0">{
        if length := len(noncurrentVersionTransitions); length &gt; 0 </span><span class="cov0" title="0">{
                xml := make([]string, 0, length)
                for _, noncurrentVersionTransition := range noncurrentVersionTransitions </span><span class="cov0" title="0">{
                        if noncurrentVersionTransition.NoncurrentDays &gt; 0 </span><span class="cov0" title="0">{
                                xml = append(xml, fmt.Sprintf("&lt;NoncurrentVersionTransition&gt;&lt;NoncurrentDays&gt;%d&lt;/NoncurrentDays&gt;"+
                                        "&lt;StorageClass&gt;%s&lt;/StorageClass&gt;&lt;/NoncurrentVersionTransition&gt;",
                                        noncurrentVersionTransition.NoncurrentDays, noncurrentVersionTransition.StorageClass))
                        }</span>
                }
                <span class="cov0" title="0">return strings.Join(xml, "")</span>
        }
        <span class="cov0" title="0">return ""</span>
}
func convertNoncurrentVersionExpirationToXml(noncurrentVersionExpiration NoncurrentVersionExpiration) string <span class="cov0" title="0">{
        if noncurrentVersionExpiration.NoncurrentDays &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Sprintf("&lt;NoncurrentVersionExpiration&gt;&lt;NoncurrentDays&gt;%d&lt;/NoncurrentDays&gt;&lt;/NoncurrentVersionExpiration&gt;", noncurrentVersionExpiration.NoncurrentDays)
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func ConvertLifecyleConfigurationToXml(input BucketLifecyleConfiguration, returnMd5 bool) (data string, md5 string) <span class="cov0" title="0">{
        xml := make([]string, 0, 2+len(input.LifecycleRules)*9)
        xml = append(xml, "&lt;LifecycleConfiguration&gt;")
        for _, lifecyleRule := range input.LifecycleRules </span><span class="cov0" title="0">{
                xml = append(xml, "&lt;Rule&gt;")
                if lifecyleRule.ID != "" </span><span class="cov0" title="0">{
                        xml = append(xml, fmt.Sprintf("&lt;ID&gt;%s&lt;/ID&gt;", lifecyleRule.ID))
                }</span>
                <span class="cov0" title="0">xml = append(xml, fmt.Sprintf("&lt;Prefix&gt;%s&lt;/Prefix&gt;", lifecyleRule.Prefix))
                xml = append(xml, fmt.Sprintf("&lt;Status&gt;%s&lt;/Status&gt;", lifecyleRule.Status))
                if ret := convertTransitionsToXml(lifecyleRule.Transitions); ret != "" </span><span class="cov0" title="0">{
                        xml = append(xml, ret)
                }</span>
                <span class="cov0" title="0">if ret := convertExpirationToXml(lifecyleRule.Expiration); ret != "" </span><span class="cov0" title="0">{
                        xml = append(xml, ret)
                }</span>
                <span class="cov0" title="0">if ret := convertNoncurrentVersionTransitionsToXml(lifecyleRule.NoncurrentVersionTransitions); ret != "" </span><span class="cov0" title="0">{
                        xml = append(xml, ret)
                }</span>
                <span class="cov0" title="0">if ret := convertNoncurrentVersionExpirationToXml(lifecyleRule.NoncurrentVersionExpiration); ret != "" </span><span class="cov0" title="0">{
                        xml = append(xml, ret)
                }</span>
                <span class="cov0" title="0">xml = append(xml, "&lt;/Rule&gt;")</span>
        }
        <span class="cov0" title="0">xml = append(xml, "&lt;/LifecycleConfiguration&gt;")
        data = strings.Join(xml, "")
        if returnMd5 </span><span class="cov0" title="0">{
                md5 = Base64Md5([]byte(data))
        }</span>
        <span class="cov0" title="0">return</span>
}

func converntFilterRulesToXml(filterRules []FilterRule) string <span class="cov0" title="0">{
        if length := len(filterRules); length &gt; 0 </span><span class="cov0" title="0">{
                xml := make([]string, 0, length*4)
                for _, filterRule := range filterRules </span><span class="cov0" title="0">{
                        xml = append(xml, "&lt;FilterRule&gt;")
                        if filterRule.Name != "" </span><span class="cov0" title="0">{
                                xml = append(xml, fmt.Sprintf("&lt;Name&gt;%s&lt;/Name&gt;", filterRule.Name))
                        }</span>
                        <span class="cov0" title="0">if filterRule.Value != "" </span><span class="cov0" title="0">{
                                xml = append(xml, fmt.Sprintf("&lt;Value&gt;%s&lt;/Value&gt;", filterRule.Value))
                        }</span>
                        <span class="cov0" title="0">xml = append(xml, "&lt;/FilterRule&gt;")</span>
                }
                <span class="cov0" title="0">return fmt.Sprintf("&lt;Filter&gt;&lt;S3Key&gt;%s&lt;/S3Key&gt;&lt;/Filter&gt;", strings.Join(xml, ""))</span>
        }
        <span class="cov0" title="0">return ""</span>
}

func converntEventsToXml(events []string) string <span class="cov0" title="0">{
        if length := len(events); length &gt; 0 </span><span class="cov0" title="0">{
                xml := make([]string, 0, length)
                for _, event := range events </span><span class="cov0" title="0">{
                        xml = append(xml, fmt.Sprintf("&lt;Event&gt;%s&lt;/Event&gt;", event))
                }</span>
                <span class="cov0" title="0">return strings.Join(xml, "")</span>
        }
        <span class="cov0" title="0">return ""</span>
}

func ConvertNotificationToXml(input BucketNotification, returnMd5 bool) (data string, md5 string) <span class="cov0" title="0">{
        xml := make([]string, 0, 2+len(input.TopicConfigurations)*6)
        xml = append(xml, "&lt;NotificationConfiguration&gt;")
        for _, topicConfiguration := range input.TopicConfigurations </span><span class="cov0" title="0">{
                xml = append(xml, "&lt;TopicConfiguration&gt;")
                if topicConfiguration.ID != "" </span><span class="cov0" title="0">{
                        xml = append(xml, fmt.Sprintf("&lt;Id&gt;%s&lt;/Id&gt;", topicConfiguration.ID))
                }</span>
                <span class="cov0" title="0">xml = append(xml, fmt.Sprintf("&lt;Topic&gt;%s&lt;/Topic&gt;", topicConfiguration.Topic))

                if ret := converntEventsToXml(topicConfiguration.Events); ret != "" </span><span class="cov0" title="0">{
                        xml = append(xml, ret)
                }</span>
                <span class="cov0" title="0">if ret := converntFilterRulesToXml(topicConfiguration.FilterRules); ret != "" </span><span class="cov0" title="0">{
                        xml = append(xml, ret)
                }</span>
                <span class="cov0" title="0">xml = append(xml, "&lt;/TopicConfiguration&gt;")</span>
        }
        <span class="cov0" title="0">xml = append(xml, "&lt;/NotificationConfiguration&gt;")
        data = strings.Join(xml, "")
        if returnMd5 </span><span class="cov0" title="0">{
                md5 = Base64Md5([]byte(data))
        }</span>
        <span class="cov0" title="0">return</span>
}

func ConvertCompleteMultipartUploadInputToXml(input CompleteMultipartUploadInput, returnMd5 bool) (data string, md5 string) <span class="cov0" title="0">{
        xml := make([]string, 0, 2+len(input.Parts)*4)
        xml = append(xml, "&lt;CompleteMultipartUpload&gt;")
        for _, part := range input.Parts </span><span class="cov0" title="0">{
                xml = append(xml, "&lt;Part&gt;")
                xml = append(xml, fmt.Sprintf("&lt;PartNumber&gt;%d&lt;/PartNumber&gt;", part.PartNumber))
                xml = append(xml, fmt.Sprintf("&lt;ETag&gt;%s&lt;/ETag&gt;", part.ETag))
                xml = append(xml, "&lt;/Part&gt;")
        }</span>
        <span class="cov0" title="0">xml = append(xml, "&lt;/CompleteMultipartUpload&gt;")
        data = strings.Join(xml, "")
        if returnMd5 </span><span class="cov0" title="0">{
                md5 = Base64Md5([]byte(data))
        }</span>
        <span class="cov0" title="0">return</span>
}

func parseSseHeader(responseHeaders map[string][]string) (sseHeader ISseHeader) <span class="cov0" title="0">{
        if ret, ok := responseHeaders[HEADER_SSEC_ENCRYPTION]; ok </span><span class="cov0" title="0">{
                sseCHeader := SseCHeader{Encryption: ret[0]}
                if ret, ok = responseHeaders[HEADER_SSEC_KEY_MD5]; ok </span><span class="cov0" title="0">{
                        sseCHeader.KeyMD5 = ret[0]
                }</span>
                <span class="cov0" title="0">sseHeader = sseCHeader</span>
        } else<span class="cov0" title="0"> if ret, ok := responseHeaders[HEADER_SSEKMS_ENCRYPTION]; ok </span><span class="cov0" title="0">{
                sseKmsHeader := SseKmsHeader{Encryption: ret[0]}
                if ret, ok = responseHeaders[HEADER_SSEKMS_KEY]; ok </span><span class="cov0" title="0">{
                        sseKmsHeader.Key = ret[0]
                }</span>
                <span class="cov0" title="0">sseHeader = sseKmsHeader</span>
        }
        <span class="cov0" title="0">return</span>
}

func ParseGetObjectMetadataOutput(output *GetObjectMetadataOutput) <span class="cov0" title="0">{
        if ret, ok := output.ResponseHeaders[HEADER_VERSION_ID]; ok </span><span class="cov0" title="0">{
                output.VersionId = ret[0]
        }</span>
        <span class="cov0" title="0">if ret, ok := output.ResponseHeaders[HEADER_WEBSITE_REDIRECT_LOCATION]; ok </span><span class="cov0" title="0">{
                output.WebsiteRedirectLocation = ret[0]
        }</span>
        <span class="cov0" title="0">if ret, ok := output.ResponseHeaders[HEADER_EXPIRATION]; ok </span><span class="cov0" title="0">{
                output.Expiration = ret[0]
        }</span>
        <span class="cov0" title="0">if ret, ok := output.ResponseHeaders[HEADER_RESTORE]; ok </span><span class="cov0" title="0">{
                output.Restore = ret[0]
        }</span>

        <span class="cov0" title="0">if ret, ok := output.ResponseHeaders[HEADER_STORAGE_CLASS2]; ok </span><span class="cov0" title="0">{
                output.StorageClass = ParseStringToStorageClassType(ret[0])
        }</span>
        <span class="cov0" title="0">if ret, ok := output.ResponseHeaders[HEADER_ETAG]; ok </span><span class="cov0" title="0">{
                output.ETag = ret[0]
        }</span>
        <span class="cov0" title="0">if ret, ok := output.ResponseHeaders[HEADER_CONTENT_TYPE]; ok </span><span class="cov0" title="0">{
                output.ContentType = ret[0]
        }</span>
        <span class="cov0" title="0">if ret, ok := output.ResponseHeaders[HEADER_ACCESS_CONRTOL_ALLOW_ORIGIN]; ok </span><span class="cov0" title="0">{
                output.AllowOrigin = ret[0]
        }</span>
        <span class="cov0" title="0">if ret, ok := output.ResponseHeaders[HEADER_ACCESS_CONRTOL_ALLOW_HEADERS]; ok </span><span class="cov0" title="0">{
                output.AllowHeader = ret[0]
        }</span>
        <span class="cov0" title="0">if ret, ok := output.ResponseHeaders[HEADER_ACCESS_CONRTOL_MAX_AGE]; ok </span><span class="cov0" title="0">{
                output.MaxAgeSeconds = StringToInt(ret[0], 0)
        }</span>
        <span class="cov0" title="0">if ret, ok := output.ResponseHeaders[HEADER_ACCESS_CONRTOL_ALLOW_METHODS]; ok </span><span class="cov0" title="0">{
                output.AllowMethod = ret[0]
        }</span>
        <span class="cov0" title="0">if ret, ok := output.ResponseHeaders[HEADER_ACCESS_CONRTOL_EXPOSE_HEADERS]; ok </span><span class="cov0" title="0">{
                output.ExposeHeader = ret[0]
        }</span>

        <span class="cov0" title="0">output.SseHeader = parseSseHeader(output.ResponseHeaders)
        if ret, ok := output.ResponseHeaders[HEADER_LASTMODIFIED]; ok </span><span class="cov0" title="0">{
                ret, err := time.Parse(time.RFC1123, ret[0])
                if err == nil </span><span class="cov0" title="0">{
                        output.LastModified = ret
                }</span>
        }
        <span class="cov0" title="0">if ret, ok := output.ResponseHeaders[HEADER_CONTENT_LENGTH]; ok </span><span class="cov0" title="0">{
                output.ContentLength = StringToInt64(ret[0], 0)
        }</span>

        <span class="cov0" title="0">output.Metadata = make(map[string]string)

        for key, value := range output.ResponseHeaders </span><span class="cov0" title="0">{
                if strings.HasPrefix(key, PREFIX_META) </span><span class="cov0" title="0">{
                        _key := key[len(PREFIX_META):]
                        output.ResponseHeaders[_key] = value
                        output.Metadata[_key] = value[0]
                        delete(output.ResponseHeaders, key)
                }</span>
        }

}

func ParseCopyObjectOutput(output *CopyObjectOutput) <span class="cov0" title="0">{
        if ret, ok := output.ResponseHeaders[HEADER_VERSION_ID]; ok </span><span class="cov0" title="0">{
                output.VersionId = ret[0]
        }</span>
        <span class="cov0" title="0">output.SseHeader = parseSseHeader(output.ResponseHeaders)
        if ret, ok := output.ResponseHeaders[HEADER_COPY_SOURCE_VERSION_ID]; ok </span><span class="cov0" title="0">{
                output.CopySourceVersionId = ret[0]
        }</span>
}

func ParsePutObjectOutput(output *PutObjectOutput) <span class="cov0" title="0">{
        if ret, ok := output.ResponseHeaders[HEADER_VERSION_ID]; ok </span><span class="cov0" title="0">{
                output.VersionId = ret[0]
        }</span>
        <span class="cov0" title="0">output.SseHeader = parseSseHeader(output.ResponseHeaders)
        if ret, ok := output.ResponseHeaders[HEADER_STORAGE_CLASS2]; ok </span><span class="cov0" title="0">{
                output.StorageClass = ParseStringToStorageClassType(ret[0])
        }</span>

        <span class="cov0" title="0">if ret, ok := output.ResponseHeaders[HEADER_ETAG]; ok </span><span class="cov0" title="0">{
                output.ETag = ret[0]
        }</span>
}

func ParseInitiateMultipartUploadOutput(output *InitiateMultipartUploadOutput) <span class="cov0" title="0">{
        output.SseHeader = parseSseHeader(output.ResponseHeaders)
}</span>

func ParseUploadPartOutput(output *UploadPartOutput) <span class="cov0" title="0">{
        output.SseHeader = parseSseHeader(output.ResponseHeaders)
        if ret, ok := output.ResponseHeaders[HEADER_ETAG]; ok </span><span class="cov0" title="0">{
                output.ETag = ret[0]
        }</span>
}

func ParseCompleteMultipartUploadOutput(output *CompleteMultipartUploadOutput) <span class="cov0" title="0">{
        output.SseHeader = parseSseHeader(output.ResponseHeaders)
        if ret, ok := output.ResponseHeaders[HEADER_VERSION_ID]; ok </span><span class="cov0" title="0">{
                output.VersionId = ret[0]
        }</span>
}

func ParseCopyPartOutput(output *CopyPartOutput) <span class="cov0" title="0">{
        output.SseHeader = parseSseHeader(output.ResponseHeaders)
}</span>

func ParseGetBucketMetadataOutput(output *GetBucketMetadataOutput) <span class="cov0" title="0">{
        if ret, ok := output.ResponseHeaders[HEADER_STORAGE_CLASS]; ok </span><span class="cov0" title="0">{
                output.StorageClass = ParseStringToStorageClassType(ret[0])
        }</span>
        <span class="cov0" title="0">if ret, ok := output.ResponseHeaders[HEADER_BUCKET_REGION]; ok </span><span class="cov0" title="0">{
                output.Location = ret[0]
        }</span>
        <span class="cov0" title="0">if ret, ok := output.ResponseHeaders[HEADER_ACCESS_CONRTOL_ALLOW_ORIGIN]; ok </span><span class="cov0" title="0">{
                output.AllowOrigin = ret[0]
        }</span>
        <span class="cov0" title="0">if ret, ok := output.ResponseHeaders[HEADER_ACCESS_CONRTOL_ALLOW_HEADERS]; ok </span><span class="cov0" title="0">{
                output.AllowHeader = ret[0]
        }</span>
        <span class="cov0" title="0">if ret, ok := output.ResponseHeaders[HEADER_ACCESS_CONRTOL_MAX_AGE]; ok </span><span class="cov0" title="0">{
                output.MaxAgeSeconds = StringToInt(ret[0], 0)
        }</span>
        <span class="cov0" title="0">if ret, ok := output.ResponseHeaders[HEADER_ACCESS_CONRTOL_ALLOW_METHODS]; ok </span><span class="cov0" title="0">{
                output.AllowMethod = ret[0]
        }</span>
        <span class="cov0" title="0">if ret, ok := output.ResponseHeaders[HEADER_ACCESS_CONRTOL_EXPOSE_HEADERS]; ok </span><span class="cov0" title="0">{
                output.ExposeHeader = ret[0]
        }</span>
}

func ParseDeleteObjectOutput(output *DeleteObjectOutput) <span class="cov0" title="0">{
        if versionId, ok := output.ResponseHeaders[HEADER_VERSION_ID]; ok </span><span class="cov0" title="0">{
                output.VersionId = versionId[0]
        }</span>

        <span class="cov0" title="0">if deleteMarker, ok := output.ResponseHeaders[HEADER_DELETE_MARKER]; ok </span><span class="cov0" title="0">{
                output.DeleteMarker = deleteMarker[0] == "true"
        }</span>
}

func ParseGetObjectOutput(output *GetObjectOutput) <span class="cov0" title="0">{
        ParseGetObjectMetadataOutput(&amp;output.GetObjectMetadataOutput)
        if ret, ok := output.ResponseHeaders[HEADER_DELETE_MARKER]; ok </span><span class="cov0" title="0">{
                output.DeleteMarker = ret[0] == "true"
        }</span>
        <span class="cov0" title="0">if ret, ok := output.ResponseHeaders[HEADER_CACHE_CONTROL]; ok </span><span class="cov0" title="0">{
                output.CacheControl = ret[0]
        }</span>
        <span class="cov0" title="0">if ret, ok := output.ResponseHeaders[HEADER_CONTENT_DISPOSITION]; ok </span><span class="cov0" title="0">{
                output.ContentDisposition = ret[0]
        }</span>
        <span class="cov0" title="0">if ret, ok := output.ResponseHeaders[HEADER_CONTENT_ENCODING]; ok </span><span class="cov0" title="0">{
                output.ContentEncoding = ret[0]
        }</span>
        <span class="cov0" title="0">if ret, ok := output.ResponseHeaders[HEADER_CONTENT_LANGUAGE]; ok </span><span class="cov0" title="0">{
                output.ContentLanguage = ret[0]
        }</span>
        <span class="cov0" title="0">if ret, ok := output.ResponseHeaders[HEADER_EXPIRES]; ok </span><span class="cov0" title="0">{
                output.Expires = ret[0]
        }</span>
}

func ConvertRequestToIoReaderV2(req interface{}) (io.Reader, string, error) <span class="cov0" title="0">{
        data, err := TransToXml(req)
        if err == nil </span><span class="cov0" title="0">{
                log.Debug("Do http request with data: %s", string(data))
                return bytes.NewReader(data), Base64Md5(data), nil
        }</span>
        <span class="cov0" title="0">return nil, "", err</span>
}

func ConvertRequestToIoReader(req interface{}) (io.Reader, error) <span class="cov0" title="0">{
        body, err := TransToXml(req)
        if err == nil </span><span class="cov0" title="0">{
                log.Debug("Do http request with data: %s", string(body))
                return bytes.NewReader(body), nil
        }</span>
        <span class="cov0" title="0">return nil, err</span>
}

func ParseResponseToBaseModel(resp *http.Response, baseModel IBaseModel, xmlResult bool) (err error) <span class="cov0" title="0">{
        readCloser, ok := baseModel.(IReadCloser)
        if !ok </span><span class="cov0" title="0">{
                defer resp.Body.Close()
                body, err := ioutil.ReadAll(resp.Body)
                if err == nil &amp;&amp; len(body) &gt; 0 </span><span class="cov0" title="0">{
                        if xmlResult </span><span class="cov0" title="0">{
                                err = ParseXml(body, baseModel)
                                if err != nil </span><span class="cov0" title="0">{
                                        log.Error("Unmarshal error: %v", err)
                                }</span>
                        } else<span class="cov0" title="0"> {
                                s := reflect.TypeOf(baseModel).Elem()
                                for i := 0; i &lt; s.NumField(); i++ </span><span class="cov0" title="0">{
                                        if s.Field(i).Tag == "body" </span><span class="cov0" title="0">{
                                                reflect.ValueOf(baseModel).Elem().FieldByName(s.Field(i).Name).SetString(string(body))
                                                break</span>
                                        }
                                }
                        }
                }
        } else<span class="cov0" title="0"> {
                readCloser.setReadCloser(resp.Body)
        }</span>

        <span class="cov0" title="0">baseModel.setStatusCode(resp.StatusCode)
        responseHeaders := cleanHeaderPrefix(resp.Header)
        baseModel.setResponseHeaders(responseHeaders)
        if values, ok := responseHeaders[HEADER_REQUEST_ID]; ok </span><span class="cov0" title="0">{
                baseModel.setRequestId(values[0])
        }</span>
        <span class="cov0" title="0">return</span>
}

func ParseResponseToObsError(resp *http.Response) error <span class="cov0" title="0">{
        obsError := ObsError{}
        ParseResponseToBaseModel(resp, &amp;obsError, true)
        obsError.Status = resp.Status
        return obsError
}</span>
</pre>
		
		<pre class="file" id="file55" style="display: none">package obs

import (
        "encoding/xml"
        "fmt"
)

type ObsError struct {
        BaseModel
        Status   string
        XMLName  xml.Name `xml:"Error"`
        Code     string   `xml:"Code"`
        Message  string   `xml:"Message"`
        Resource string   `xml:"Resource"`
        HostId   string   `xml:"HostId"`
}

func (err ObsError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("obs: service returned error: Status=%s, Code=%s, Message=%s, RequestId=%s",
                err.Status, err.Code, err.Message, err.RequestId)
}</span>
</pre>
		
		<pre class="file" id="file56" style="display: none">package obs

import (
        "bytes"
        "errors"
        "io"
        "math/rand"
        "net"
        "net/http"
        "net/url"
        "os"
        "strings"
        "time"

        log "github.com/sirupsen/logrus"
)

func prepareHeaders(headers map[string][]string, meta bool) map[string][]string <span class="cov0" title="0">{
        _headers := make(map[string][]string, len(headers))
        if headers != nil </span><span class="cov0" title="0">{
                for key, value := range headers </span><span class="cov0" title="0">{
                        key = strings.TrimSpace(key)
                        if key == "" </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">_key := strings.ToLower(key)
                        if _, ok := allowed_request_http_header_metadata_names[_key]; !ok &amp;&amp; !strings.HasPrefix(key, HEADER_PREFIX) </span><span class="cov0" title="0">{
                                if !meta </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov0" title="0">_key = HEADER_PREFIX_META + _key</span>
                        } else<span class="cov0" title="0"> {
                                _key = key
                        }</span>
                        <span class="cov0" title="0">_headers[_key] = value</span>
                }
        }
        <span class="cov0" title="0">return _headers</span>
}

func (obsClient ObsClient) doActionWithoutBucket(action, method string, input ISerializable, output IBaseModel) error <span class="cov0" title="0">{
        return obsClient.doAction(action, method, "", "", input, output, true, true)
}</span>

func (obsClient ObsClient) doActionWithBucketV2(action, method, bucketName string, input ISerializable, output IBaseModel) error <span class="cov0" title="0">{
        if strings.TrimSpace(bucketName) == "" </span><span class="cov0" title="0">{
                return errors.New("Bucket is empty")
        }</span>
        <span class="cov0" title="0">return obsClient.doAction(action, method, bucketName, "", input, output, false, true)</span>
}

func (obsClient ObsClient) doActionWithBucket(action, method, bucketName string, input ISerializable, output IBaseModel) error <span class="cov0" title="0">{
        if strings.TrimSpace(bucketName) == "" </span><span class="cov0" title="0">{
                return errors.New("Bucket is empty")
        }</span>
        <span class="cov0" title="0">return obsClient.doAction(action, method, bucketName, "", input, output, true, true)</span>
}

func (obsClient ObsClient) doActionWithBucketAndKey(action, method, bucketName, objectKey string, input ISerializable, output IBaseModel) error <span class="cov0" title="0">{
        return obsClient._doActionWithBucketAndKey(action, method, bucketName, objectKey, input, output, true)
}</span>

func (obsClient ObsClient) doActionWithBucketAndKeyUnRepeatable(action, method, bucketName, objectKey string, input ISerializable, output IBaseModel) error <span class="cov0" title="0">{
        return obsClient._doActionWithBucketAndKey(action, method, bucketName, objectKey, input, output, false)
}</span>

func (obsClient ObsClient) _doActionWithBucketAndKey(action, method, bucketName, objectKey string, input ISerializable, output IBaseModel, repeatable bool) error <span class="cov0" title="0">{
        if strings.TrimSpace(bucketName) == "" </span><span class="cov0" title="0">{
                return errors.New("Key is empty")
        }</span>
        <span class="cov0" title="0">if strings.TrimSpace(objectKey) == "" </span><span class="cov0" title="0">{
                return errors.New("Key is empty")
        }</span>
        <span class="cov0" title="0">return obsClient.doAction(action, method, bucketName, objectKey, input, output, true, repeatable)</span>
}

func (obsClient ObsClient) doAction(action, method, bucketName, objectKey string, input ISerializable, output IBaseModel, xmlResult bool, repeatable bool) error <span class="cov0" title="0">{

        var resp *http.Response
        var respError error
        log.Info("Enter method %s...", action)
        start := GetCurrentTimestamp()

        params, headers, data := input.trans()

        if params == nil </span><span class="cov0" title="0">{
                params = make(map[string]string)
        }</span>

        <span class="cov0" title="0">if headers == nil </span><span class="cov0" title="0">{
                headers = make(map[string][]string)
        }</span>

        <span class="cov0" title="0">switch method </span>{
        case HTTP_GET:<span class="cov0" title="0">
                resp, respError = obsClient.doHttpGet(bucketName, objectKey, params, headers, data, repeatable)</span>
        case HTTP_POST:<span class="cov0" title="0">
                resp, respError = obsClient.doHttpPost(bucketName, objectKey, params, headers, data, repeatable)</span>
        case HTTP_PUT:<span class="cov0" title="0">
                resp, respError = obsClient.doHttpPut(bucketName, objectKey, params, headers, data, repeatable)</span>
        case HTTP_DELETE:<span class="cov0" title="0">
                resp, respError = obsClient.doHttpDelete(bucketName, objectKey, params, headers, data, repeatable)</span>
        case HTTP_HEAD:<span class="cov0" title="0">
                resp, respError = obsClient.doHttpHead(bucketName, objectKey, params, headers, data, repeatable)</span>
        case HTTP_OPTIONS:<span class="cov0" title="0">
                resp, respError = obsClient.doHttpOptions(bucketName, objectKey, params, headers, data, repeatable)</span>
        default:<span class="cov0" title="0">
                respError = errors.New("Unexpect http method error")</span>
        }
        <span class="cov0" title="0">if respError == nil &amp;&amp; output != nil </span><span class="cov0" title="0">{
                respError = ParseResponseToBaseModel(resp, output, xmlResult)
                if respError != nil </span><span class="cov0" title="0">{
                        log.Warn("Parse response to BaseModel with error: %v", respError)
                }</span>
        } else<span class="cov0" title="0"> {
                log.Warn("Do http request with error: %v", respError)
        }</span>

        <span class="cov0" title="0">log.Debug("End method %s, obsclient cost %d ms", action, (GetCurrentTimestamp() - start))

        return respError</span>
}

func (obsClient ObsClient) doHttpGet(bucketName, objectKey string, params map[string]string,
        headers map[string][]string, data interface{}, repeatable bool) (*http.Response, error) <span class="cov0" title="0">{
        return obsClient.doHttp(HTTP_GET, bucketName, objectKey, params, prepareHeaders(headers, false), data, repeatable)
}</span>

func (obsClient ObsClient) doHttpHead(bucketName, objectKey string, params map[string]string,
        headers map[string][]string, data interface{}, repeatable bool) (*http.Response, error) <span class="cov0" title="0">{
        return obsClient.doHttp(HTTP_HEAD, bucketName, objectKey, params, prepareHeaders(headers, false), data, repeatable)
}</span>

func (obsClient ObsClient) doHttpOptions(bucketName, objectKey string, params map[string]string,
        headers map[string][]string, data interface{}, repeatable bool) (*http.Response, error) <span class="cov0" title="0">{
        return obsClient.doHttp(HTTP_OPTIONS, bucketName, objectKey, params, prepareHeaders(headers, false), data, repeatable)
}</span>

func (obsClient ObsClient) doHttpDelete(bucketName, objectKey string, params map[string]string,
        headers map[string][]string, data interface{}, repeatable bool) (*http.Response, error) <span class="cov0" title="0">{
        return obsClient.doHttp(HTTP_DELETE, bucketName, objectKey, params, prepareHeaders(headers, false), data, repeatable)
}</span>

func (obsClient ObsClient) doHttpPut(bucketName, objectKey string, params map[string]string,
        headers map[string][]string, data interface{}, repeatable bool) (*http.Response, error) <span class="cov0" title="0">{
        return obsClient.doHttp(HTTP_PUT, bucketName, objectKey, params, prepareHeaders(headers, true), data, repeatable)
}</span>

func (obsClient ObsClient) doHttpPost(bucketName, objectKey string, params map[string]string,
        headers map[string][]string, data interface{}, repeatable bool) (*http.Response, error) <span class="cov0" title="0">{
        return obsClient.doHttp(HTTP_POST, bucketName, objectKey, params, prepareHeaders(headers, true), data, repeatable)
}</span>

func (obsClient ObsClient) doHttpWithSignedUrl(action, method string, signedUrl string, actualSignedRequestHeaders http.Header, data io.Reader, output IBaseModel, xmlResult bool) (respError error) <span class="cov0" title="0">{
        req, err := http.NewRequest(method, signedUrl, data)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var resp *http.Response

        log.Info("Do %s with signedUrl %s...", action, signedUrl)

        req.Header = actualSignedRequestHeaders
        if value, ok := req.Header[HEADER_HOST_CAMEL]; ok </span><span class="cov0" title="0">{
                req.Host = value[0]
                delete(req.Header, HEADER_HOST_CAMEL)
        }</span> else<span class="cov0" title="0"> if value, ok := req.Header[HEADER_HOST]; ok </span><span class="cov0" title="0">{
                req.Host = value[0]
                delete(req.Header, HEADER_HOST)
        }</span>

        <span class="cov0" title="0">if value, ok := req.Header[HEADER_CONTENT_LENGTH_CAMEL]; ok </span><span class="cov0" title="0">{
                req.ContentLength = StringToInt64(value[0], -1)
                delete(req.Header, HEADER_CONTENT_LENGTH_CAMEL)
        }</span> else<span class="cov0" title="0"> if value, ok := req.Header[HEADER_CONTENT_LENGTH]; ok </span><span class="cov0" title="0">{
                req.ContentLength = StringToInt64(value[0], -1)
                delete(req.Header, HEADER_CONTENT_LENGTH)
        }</span>

        <span class="cov0" title="0">req.Header[HEADER_USER_AGENT_CAMEL] = []string{USER_AGENT}
        start := GetCurrentTimestamp()
        resp, err = obsClient.httpClient.Do(req)
        log.Info("Do http request cost %d ms", (GetCurrentTimestamp() - start))


        var msg interface{}
        if err != nil </span><span class="cov0" title="0">{
                respError = err
                resp = nil
        }</span> else<span class="cov0" title="0"> {
                log.Debug("Response headers: %v", resp.Header)
                if resp.StatusCode &gt;= 300 </span><span class="cov0" title="0">{
                        respError = ParseResponseToObsError(resp)
                        msg = resp.Status
                        resp = nil
                }</span> else<span class="cov0" title="0"> {
                        if output != nil </span><span class="cov0" title="0">{
                                respError = ParseResponseToBaseModel(resp, output, xmlResult)
                        }</span>
                        <span class="cov0" title="0">if respError != nil </span><span class="cov0" title="0">{
                                log.Warn("Parse response to BaseModel with error: %v", respError)
                        }</span>
                }
        }

        <span class="cov0" title="0">if msg != nil </span><span class="cov0" title="0">{
                log.Error("Failed to send request with reason:%v", msg)
        }</span>

        <span class="cov0" title="0">log.Debug("End method %s, obsclient cost %d ms", action, (GetCurrentTimestamp() - start))

        return</span>
}

func (obsClient ObsClient) doHttp(method, bucketName, objectKey string, params map[string]string,
        headers map[string][]string, data interface{}, repeatable bool) (resp *http.Response, respError error) <span class="cov0" title="0">{

        bucketName = strings.TrimSpace(bucketName)

        objectKey = strings.TrimSpace(objectKey)

        method = strings.ToUpper(method)

        var redirectUrl string
        var requestUrl string
        maxRetryCount := obsClient.conf.maxRetryCount

        var _data io.Reader
        if data != nil </span><span class="cov0" title="0">{
                if dataStr, ok := data.(string); ok </span><span class="cov0" title="0">{
                        log.Debug("Do http request with string: %s", dataStr)
                        headers["Content-Length"] = []string{IntToString(len(dataStr))}
                        _data = strings.NewReader(dataStr)
                }</span> else<span class="cov0" title="0"> if dataByte, ok := data.([]byte); ok </span><span class="cov0" title="0">{
                        log.Debug("Do http request with byte array")
                        headers["Content-Length"] = []string{IntToString(len(dataByte))}
                        _data = bytes.NewReader(dataByte)
                }</span> else<span class="cov0" title="0"> if dataReader, ok := data.(io.Reader); ok </span><span class="cov0" title="0">{
                        _data = dataReader
                }</span> else<span class="cov0" title="0"> {
                        log.Warn("Data is not a valid io.Reader")
                        return nil, errors.New("Data is not a valid io.Reader")
                }</span>
        }

        <span class="cov0" title="0">for i := 0; i &lt;= maxRetryCount; i++ </span><span class="cov0" title="0">{
                if redirectUrl != "" </span><span class="cov0" title="0">{
                        parsedRedirectUrl, err := url.Parse(redirectUrl)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">requestUrl, _ = obsClient.doAuth(method, bucketName, objectKey, params, headers, parsedRedirectUrl.Host)
                        if parsedRequestUrl, _ := url.Parse(requestUrl); parsedRequestUrl.RawQuery != "" &amp;&amp; parsedRedirectUrl.RawQuery == "" </span><span class="cov0" title="0">{
                                redirectUrl += "?" + parsedRequestUrl.RawQuery
                        }</span>
                        <span class="cov0" title="0">requestUrl = redirectUrl</span>
                } else<span class="cov0" title="0"> {
                        var err error
                        requestUrl, err = obsClient.doAuth(method, bucketName, objectKey, params, headers, "")
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                }

                <span class="cov0" title="0">req, err := http.NewRequest(method, requestUrl, _data)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">log.Debug("Do request with url [%s] and method [%s]", requestUrl, method)

                auth := headers[HEADER_AUTH_CAMEL]
                delete(headers, HEADER_AUTH_CAMEL)
                log.Debug("Request headers: %v", headers)
                headers[HEADER_AUTH_CAMEL] = auth

                for key, value := range headers </span><span class="cov0" title="0">{
                        if key == HEADER_HOST_CAMEL </span><span class="cov0" title="0">{
                                req.Host = value[0]
                                delete(headers, key)
                        }</span> else<span class="cov0" title="0"> if key == HEADER_CONTENT_LENGTH_CAMEL </span><span class="cov0" title="0">{
                                req.ContentLength = StringToInt64(value[0], -1)
                                delete(headers, key)
                        }</span> else<span class="cov0" title="0"> {
                                req.Header[key] = value
                        }</span>
                }

                <span class="cov0" title="0">req.Header[HEADER_USER_AGENT_CAMEL] = []string{USER_AGENT}

                start := GetCurrentTimestamp()
                resp, err = obsClient.httpClient.Do(req)
                log.Info("Do http request cost %d ms", (GetCurrentTimestamp() - start))

                var msg interface{}
                if err != nil </span><span class="cov0" title="0">{
                        msg = err
                        respError = err
                        resp = nil
                }</span> else<span class="cov0" title="0"> {
                        log.Debug("Response headers: %v", resp.Header)
                        if resp.StatusCode &lt; 300 </span><span class="cov0" title="0">{
                                break</span>
                        } else<span class="cov0" title="0"> if !repeatable || (resp.StatusCode &gt;= 400 &amp;&amp; resp.StatusCode &lt; 500) || resp.StatusCode == 304 </span><span class="cov0" title="0">{
                                respError = ParseResponseToObsError(resp)
                                resp = nil
                                break</span>
                        } else<span class="cov0" title="0"> if resp.StatusCode &gt;= 300 &amp;&amp; resp.StatusCode &lt; 400 </span><span class="cov0" title="0">{
                                if location := resp.Header.Get(HEADER_LOCATION_CAMEL); location != "" </span><span class="cov0" title="0">{
                                        redirectUrl = location
                                        log.Warn("Redirect request to %s", redirectUrl)
                                        msg = resp.Status
                                        maxRetryCount++
                                }</span> else<span class="cov0" title="0"> {
                                        respError = ParseResponseToObsError(resp)
                                        resp = nil
                                        break</span>
                                }
                        } else<span class="cov0" title="0"> {
                                msg = resp.Status
                        }</span>
                }
                <span class="cov0" title="0">if i != maxRetryCount </span><span class="cov0" title="0">{
                        if resp != nil </span><span class="cov0" title="0">{
                                resp.Body.Close()
                                resp = nil
                        }</span>
                        <span class="cov0" title="0">if _, ok := headers[HEADER_AUTH_CAMEL]; ok </span><span class="cov0" title="0">{
                                delete(headers, HEADER_AUTH_CAMEL)
                        }</span>
                        <span class="cov0" title="0">log.Warn("Failed to send request with reason:%v, will try again", msg)
                        if r, ok := _data.(*strings.Reader); ok </span><span class="cov0" title="0">{
                                r.Seek(0, 0)
                        }</span> else<span class="cov0" title="0"> if r, ok := _data.(*bytes.Reader); ok </span><span class="cov0" title="0">{
                                r.Seek(0, 0)
                        }</span> else<span class="cov0" title="0"> if r, ok := _data.(*fileReaderWrapper); ok </span><span class="cov0" title="0">{
                                fd, err := os.Open(r.filePath)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                                <span class="cov0" title="0">defer fd.Close()
                                fileReaderWrapper := &amp;fileReaderWrapper{filePath: r.filePath}
                                fileReaderWrapper.mark = r.mark
                                fileReaderWrapper.reader = fd
                                fileReaderWrapper.totalCount = r.totalCount
                                _data = fileReaderWrapper
                                fd.Seek(r.mark, 0)</span>
                        } else<span class="cov0" title="0"> if r, ok := _data.(*readerWrapper); ok </span><span class="cov0" title="0">{
                                r.seek(0, 0)
                        }</span>
                        <span class="cov0" title="0">time.Sleep(time.Duration(float64(i+2) * rand.Float64() * float64(time.Second)))</span>
                } else<span class="cov0" title="0"> {
                        log.Error("Failed to send request with reason:%v", msg)
                        if resp != nil </span><span class="cov0" title="0">{
                                respError = ParseResponseToObsError(resp)
                                resp = nil
                        }</span>
                }
        }
        <span class="cov0" title="0">return</span>
}

type connDelegate struct {
        conn          net.Conn
        socketTimeout time.Duration
        finalTimeout  time.Duration
}

func getConnDelegate(conn net.Conn, socketTimeout int, finalTimeout int) *connDelegate <span class="cov0" title="0">{
        return &amp;connDelegate{
                conn:          conn,
                socketTimeout: time.Second * time.Duration(socketTimeout),
                finalTimeout:  time.Second * time.Duration(finalTimeout),
        }
}</span>

func (delegate *connDelegate) Read(b []byte) (n int, err error) <span class="cov0" title="0">{
        delegate.SetReadDeadline(time.Now().Add(delegate.socketTimeout))
        n, err = delegate.conn.Read(b)
        delegate.SetReadDeadline(time.Now().Add(delegate.finalTimeout))
        return n, err
}</span>

func (delegate *connDelegate) Write(b []byte) (n int, err error) <span class="cov0" title="0">{
        delegate.SetWriteDeadline(time.Now().Add(delegate.socketTimeout))
        n, err = delegate.conn.Write(b)
        finalTimeout := time.Now().Add(delegate.finalTimeout)
        delegate.SetWriteDeadline(finalTimeout)
        delegate.SetReadDeadline(finalTimeout)
        return n, err
}</span>

func (delegate *connDelegate) Close() error <span class="cov0" title="0">{
        return delegate.conn.Close()
}</span>

func (delegate *connDelegate) LocalAddr() net.Addr <span class="cov0" title="0">{
        return delegate.conn.LocalAddr()
}</span>

func (delegate *connDelegate) RemoteAddr() net.Addr <span class="cov0" title="0">{
        return delegate.conn.RemoteAddr()
}</span>

func (delegate *connDelegate) SetDeadline(t time.Time) error <span class="cov0" title="0">{
        return delegate.conn.SetDeadline(t)
}</span>

func (delegate *connDelegate) SetReadDeadline(t time.Time) error <span class="cov0" title="0">{
        return delegate.conn.SetReadDeadline(t)
}</span>

func (delegate *connDelegate) SetWriteDeadline(t time.Time) error <span class="cov0" title="0">{
        return delegate.conn.SetWriteDeadline(t)
}</span>
</pre>
		
		<pre class="file" id="file57" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package obs

import (
        "fmt"
        "io"
        "log"
        "os"
        "os/user"
        "path/filepath"
        "strconv"
        "strings"
        "time"

        "github.com/go-ini/ini"
        "github.com/sirupsen/logrus"
        "gopkg.in/natefinch/lumberjack.v2"
)

type LogFormatter struct {
        TimestampFormat string
        LogFormat       string
}

const (
        debugLevel             = "debug"
        infoLevel              = "info"
        warnLevel              = "warn"
        errorLevel             = "error"
        path                   = "path"
        level                  = "level"
        format                 = "format"
        defaultLogPath         = "/var/log/multi-cloud"
        defaultLogLevel        = "info"
        unknownHost            = "unknownhost"
        unknownUser            = "unknownuser"
        configFileName         = "/etc/multi-cloud/multi-cloud.conf"
        defaultLogFormat       = "[%time%] [%level%] [%filename%] [%funcName%():%lineNo%] [PID:%process%] %message%"
        defaultTimestampFormat = time.RFC3339
        logSection             = "log"
        tenMb                  = 10
        threeMonth             = 100
)

func InitLogs() <span class="cov8" title="1">{
        path, level, format := readConfigurationFile()
        configureLogModule(path, level, format)
}</span>

func configureLogModule(path, level, format string) <span class="cov8" title="1">{
        configureWriter(path, format)
        configureLevel(level)
}</span>

func configureWriter(path, format string) <span class="cov8" title="1">{
        logrus.SetFormatter(&amp;LogFormatter{
                TimestampFormat: defaultTimestampFormat,
                LogFormat:       format + "\n",
        })
        fileWriter := &amp;lumberjack.Logger{
                Filename: filepath.Join(path, logName()),
                MaxSize:  tenMb,
                MaxAge:   threeMonth,
                Compress: true,
        }
        multiWriter := io.MultiWriter(os.Stdout, fileWriter)
        logrus.SetOutput(multiWriter)
}</span>

func configureLevel(level string) <span class="cov8" title="1">{
        switch level </span>{
        case debugLevel:<span class="cov8" title="1">
                logrus.SetLevel(logrus.DebugLevel)</span>
        case infoLevel:<span class="cov0" title="0">
                logrus.SetLevel(logrus.InfoLevel)</span>
        case warnLevel:<span class="cov0" title="0">
                logrus.SetLevel(logrus.WarnLevel)</span>
        case errorLevel:<span class="cov0" title="0">
                logrus.SetLevel(logrus.ErrorLevel)</span>
        }
        <span class="cov8" title="1">logrus.SetReportCaller(true)</span>
}

func logName() (name string) <span class="cov8" title="1">{
        name = fmt.Sprintf("%s.%s.%s.log",
                filepath.Base(os.Args[0]),
                hostName(),
                userName())
        return name
}</span>

func shortHostname(hostname string) string <span class="cov8" title="1">{
        if i := strings.Index(hostname, "."); i &gt;= 0 </span><span class="cov0" title="0">{
                return hostname[:i]
        }</span>
        <span class="cov8" title="1">return hostname</span>
}

func hostName() string <span class="cov8" title="1">{
        host := unknownHost
        h, err := os.Hostname()
        if err == nil </span><span class="cov8" title="1">{
                host = shortHostname(h)
        }</span>
        <span class="cov8" title="1">return host</span>
}

func userName() string <span class="cov8" title="1">{
        userName := unknownUser
        current, err := user.Current()
        if err == nil </span><span class="cov8" title="1">{
                userName = current.Username
        }</span>
        // Sanitize userName since it may contain filepath separators on Windows.
        <span class="cov8" title="1">userName = strings.Replace(userName, `\`, "_", -1)
        return userName</span>
}

func readConfigurationFile() (cfgPath, cfgLevel, cfgFormat string) <span class="cov8" title="1">{
        cfgPath = defaultLogPath
        cfgLevel = defaultLogLevel
        cfgFormat = defaultLogFormat
        cfg, err := ini.Load(configFileName)
        if err != nil </span><span class="cov0" title="0">{
                log.Println("Failed to open config file")
                return cfgPath, cfgLevel, cfgFormat
        }</span>
        <span class="cov8" title="1">if cfg.Section(logSection).HasKey(path) </span><span class="cov8" title="1">{
                cfgPath = cfg.Section(logSection).Key(path).String()
        }</span>
        <span class="cov8" title="1">if cfg.Section(logSection).HasKey(level) </span><span class="cov8" title="1">{
                cfgLevel = strings.ToLower(cfg.Section(logSection).Key(level).String())
        }</span>
        <span class="cov8" title="1">if cfg.Section(logSection).HasKey(format) </span><span class="cov8" title="1">{
                cfgFormat = cfg.Section(logSection).Key(format).String()
        }</span>

        <span class="cov8" title="1">return cfgPath, cfgLevel, cfgFormat</span>
}

func (f *LogFormatter) Format(entry *logrus.Entry) ([]byte, error) <span class="cov8" title="1">{
        output := f.LogFormat
        if output == "" </span><span class="cov0" title="0">{
                output = defaultLogFormat
        }</span>

        <span class="cov8" title="1">timestampFormat := f.TimestampFormat
        if timestampFormat == "" </span><span class="cov0" title="0">{
                timestampFormat = defaultTimestampFormat
        }</span>

        <span class="cov8" title="1">output = strings.Replace(output, "%time%", entry.Time.Format(timestampFormat), 1)

        output = strings.Replace(output, "%message%", entry.Message, 1)

        level := strings.ToUpper(entry.Level.String())
        output = strings.Replace(output, "%level%", level, 1)

        output = strings.Replace(output, "%process%", strconv.Itoa(os.Getpid()), 1)

        output = strings.Replace(output, "%filename%", entry.Caller.File, 1)
        output = strings.Replace(output, "%lineNo%", strconv.Itoa(entry.Caller.Line), 1)
        funcName := entry.Caller.Function
        if strings.Contains(funcName, "/") </span><span class="cov8" title="1">{
                funcName = string([]byte(funcName)[strings.LastIndex(funcName, "/")+1:])
        }</span>
        <span class="cov8" title="1">output = strings.Replace(output, "%funcName%", funcName, 1)

        return []byte(output), nil</span>
}
</pre>
		
		<pre class="file" id="file58" style="display: none">package obs

import (
        "errors"
        "fmt"
        "io"
        "net/http"
        "os"
        "strings"
        "time"
)

func (obsClient ObsClient) CreateSignedUrl(input *CreateSignedUrlInput) (output *CreateSignedUrlOutput, err error) <span class="cov0" title="0">{
        if input == nil </span><span class="cov0" title="0">{
                return nil, errors.New("CreateSignedUrlInput is nil")
        }</span>

        <span class="cov0" title="0">params := make(map[string]string, len(input.QueryParams))
        for key, value := range input.QueryParams </span><span class="cov0" title="0">{
                params[key] = value
        }</span>

        <span class="cov0" title="0">if input.SubResource != "" </span><span class="cov0" title="0">{
                params[string(input.SubResource)] = ""
        }</span>

        <span class="cov0" title="0">headers := make(map[string][]string, len(input.Headers))
        for key, value := range input.Headers </span><span class="cov0" title="0">{
                headers[key] = []string{value}
        }</span>

        <span class="cov0" title="0">if input.Expires &lt;= 0 </span><span class="cov0" title="0">{
                input.Expires = 300
        }</span>

        <span class="cov0" title="0">requestUrl, err := obsClient.doAuthTemporary(string(input.Method), input.Bucket, input.Key, params, headers, int64(input.Expires))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">output = &amp;CreateSignedUrlOutput{
                SignedUrl:                  requestUrl,
                ActualSignedRequestHeaders: headers,
        }
        return</span>
}

func (obsClient ObsClient) CreateBrowserBasedSignature(input *CreateBrowserBasedSignatureInput) (output *CreateBrowserBasedSignatureOutput, err error) <span class="cov0" title="0">{
        if input == nil </span><span class="cov0" title="0">{
                return nil, errors.New("CreateBrowserBasedSignatureInput is nil")
        }</span>

        <span class="cov0" title="0">params := make(map[string]string, len(input.FormParams))
        for key, value := range input.FormParams </span><span class="cov0" title="0">{
                params[key] = value
        }</span>

        <span class="cov0" title="0">date := time.Now().UTC()
        shortDate := date.Format(SHORT_DATE_FORMAT)
        longDate := date.Format(LONG_DATE_FORMAT)

        credential, _ := getCredential(obsClient.conf.securityProvider.ak, obsClient.conf.region, shortDate)

        if input.Expires &lt;= 0 </span><span class="cov0" title="0">{
                input.Expires = 300
        }</span>

        <span class="cov0" title="0">expiration := date.Add(time.Second * time.Duration(input.Expires)).Format(ISO8601_DATE_FORMAT)
        params[PARAM_ALGORITHM_AMZ_CAMEL] = V4_HASH_PREFIX
        params[PARAM_CREDENTIAL_AMZ_CAMEL] = credential
        params[PARAM_DATE_AMZ_CAMEL] = longDate

        if obsClient.conf.securityProvider.securityToken != "" </span><span class="cov0" title="0">{
                params[HEADER_STS_TOKEN_AMZ] = obsClient.conf.securityProvider.securityToken
        }</span>

        <span class="cov0" title="0">matchAnyBucket := true
        matchAnyKey := true
        count := 5
        if bucket := strings.TrimSpace(input.Bucket); bucket != "" </span><span class="cov0" title="0">{
                params["bucket"] = bucket
                matchAnyBucket = false
                count--
        }</span>

        <span class="cov0" title="0">if key := strings.TrimSpace(input.Key); key != "" </span><span class="cov0" title="0">{
                params["key"] = key
                matchAnyKey = false
                count--
        }</span>

        <span class="cov0" title="0">originPolicySlice := make([]string, 0, len(params)+count)
        originPolicySlice = append(originPolicySlice, fmt.Sprintf("{\"expiration\":\"%s\",", expiration))
        originPolicySlice = append(originPolicySlice, "\"conditions\":[")
        for key, value := range params </span><span class="cov0" title="0">{
                if _key := strings.TrimSpace(strings.ToLower(key)); _key != "" </span><span class="cov0" title="0">{
                        originPolicySlice = append(originPolicySlice, fmt.Sprintf("{\"%s\":\"%s\"},", _key, value))
                }</span>
        }

        <span class="cov0" title="0">if matchAnyBucket </span><span class="cov0" title="0">{
                originPolicySlice = append(originPolicySlice, "[\"starts-with\", \"$bucket\", \"\"],")
        }</span>

        <span class="cov0" title="0">if matchAnyKey </span><span class="cov0" title="0">{
                originPolicySlice = append(originPolicySlice, "[\"starts-with\", \"$key\", \"\"],")
        }</span>

        <span class="cov0" title="0">originPolicySlice = append(originPolicySlice, "]}")

        originPolicy := strings.Join(originPolicySlice, "")
        policy := Base64Encode([]byte(originPolicy))
        signature := getSignature(policy, obsClient.conf.securityProvider.sk, obsClient.conf.region, shortDate)

        output = &amp;CreateBrowserBasedSignatureOutput{
                OriginPolicy: originPolicy,
                Policy:       policy,
                Algorithm:    params[PARAM_ALGORITHM_AMZ_CAMEL],
                Credential:   params[PARAM_CREDENTIAL_AMZ_CAMEL],
                Date:         params[PARAM_DATE_AMZ_CAMEL],
                Signature:    signature,
        }
        return</span>
}

func (obsClient ObsClient) ListBucketsWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header) (output *ListBucketsOutput, err error) <span class="cov0" title="0">{
        output = &amp;ListBucketsOutput{}
        err = obsClient.doHttpWithSignedUrl("ListBuckets", HTTP_GET, signedUrl, actualSignedRequestHeaders, nil, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) CreateBucketWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header, data io.Reader) (output *BaseModel, err error) <span class="cov0" title="0">{
        output = &amp;BaseModel{}
        err = obsClient.doHttpWithSignedUrl("CreateBucket", HTTP_PUT, signedUrl, actualSignedRequestHeaders, data, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) DeleteBucketWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header) (output *BaseModel, err error) <span class="cov0" title="0">{
        output = &amp;BaseModel{}
        err = obsClient.doHttpWithSignedUrl("DeleteBucket", HTTP_DELETE, signedUrl, actualSignedRequestHeaders, nil, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) SetBucketStoragePolicyWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header, data io.Reader) (output *BaseModel, err error) <span class="cov0" title="0">{
        output = &amp;BaseModel{}
        err = obsClient.doHttpWithSignedUrl("SetBucketStoragePolicy", HTTP_PUT, signedUrl, actualSignedRequestHeaders, data, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) GetBucketStoragePolicyWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header) (output *GetBucketStoragePolicyOutput, err error) <span class="cov0" title="0">{
        output = &amp;GetBucketStoragePolicyOutput{}
        err = obsClient.doHttpWithSignedUrl("GetBucketStoragePolicy", HTTP_GET, signedUrl, actualSignedRequestHeaders, nil, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) ListObjectsWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header) (output *ListObjectsOutput, err error) <span class="cov0" title="0">{
        output = &amp;ListObjectsOutput{}
        err = obsClient.doHttpWithSignedUrl("ListObjects", HTTP_GET, signedUrl, actualSignedRequestHeaders, nil, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span> else<span class="cov0" title="0"> {
                if location, ok := output.ResponseHeaders[HEADER_BUCKET_REGION]; ok </span><span class="cov0" title="0">{
                        output.Location = location[0]
                }</span>
        }
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) ListVersionsWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header) (output *ListVersionsOutput, err error) <span class="cov0" title="0">{
        output = &amp;ListVersionsOutput{}
        err = obsClient.doHttpWithSignedUrl("ListVersions", HTTP_GET, signedUrl, actualSignedRequestHeaders, nil, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span> else<span class="cov0" title="0"> {
                if location, ok := output.ResponseHeaders[HEADER_BUCKET_REGION]; ok </span><span class="cov0" title="0">{
                        output.Location = location[0]
                }</span>
        }
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) ListMultipartUploadsWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header) (output *ListMultipartUploadsOutput, err error) <span class="cov0" title="0">{
        output = &amp;ListMultipartUploadsOutput{}
        err = obsClient.doHttpWithSignedUrl("ListMultipartUploads", HTTP_GET, signedUrl, actualSignedRequestHeaders, nil, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) SetBucketQuotaWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header, data io.Reader) (output *BaseModel, err error) <span class="cov0" title="0">{
        output = &amp;BaseModel{}
        err = obsClient.doHttpWithSignedUrl("SetBucketQuota", HTTP_PUT, signedUrl, actualSignedRequestHeaders, data, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) GetBucketQuotaWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header) (output *GetBucketQuotaOutput, err error) <span class="cov0" title="0">{
        output = &amp;GetBucketQuotaOutput{}
        err = obsClient.doHttpWithSignedUrl("GetBucketQuota", HTTP_GET, signedUrl, actualSignedRequestHeaders, nil, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) HeadBucketWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header) (output *BaseModel, err error) <span class="cov0" title="0">{
        output = &amp;BaseModel{}
        err = obsClient.doHttpWithSignedUrl("HeadBucket", HTTP_HEAD, signedUrl, actualSignedRequestHeaders, nil, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) GetBucketMetadataWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header) (output *GetBucketMetadataOutput, err error) <span class="cov0" title="0">{
        output = &amp;GetBucketMetadataOutput{}
        err = obsClient.doHttpWithSignedUrl("GetBucketMetadata", HTTP_HEAD, signedUrl, actualSignedRequestHeaders, nil, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span> else<span class="cov0" title="0"> {
                ParseGetBucketMetadataOutput(output)
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) GetBucketStorageInfoWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header) (output *GetBucketStorageInfoOutput, err error) <span class="cov0" title="0">{
        output = &amp;GetBucketStorageInfoOutput{}
        err = obsClient.doHttpWithSignedUrl("GetBucketStorageInfo", HTTP_GET, signedUrl, actualSignedRequestHeaders, nil, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) GetBucketLocationWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header) (output *GetBucketLocationOutput, err error) <span class="cov0" title="0">{
        output = &amp;GetBucketLocationOutput{}
        err = obsClient.doHttpWithSignedUrl("GetBucketLocation", HTTP_GET, signedUrl, actualSignedRequestHeaders, nil, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) SetBucketAclWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header, data io.Reader) (output *BaseModel, err error) <span class="cov0" title="0">{
        output = &amp;BaseModel{}
        err = obsClient.doHttpWithSignedUrl("SetBucketAcl", HTTP_PUT, signedUrl, actualSignedRequestHeaders, data, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) GetBucketAclWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header) (output *GetBucketAclOutput, err error) <span class="cov0" title="0">{
        output = &amp;GetBucketAclOutput{}
        err = obsClient.doHttpWithSignedUrl("GetBucketAcl", HTTP_GET, signedUrl, actualSignedRequestHeaders, nil, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) SetBucketPolicyWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header, data io.Reader) (output *BaseModel, err error) <span class="cov0" title="0">{
        output = &amp;BaseModel{}
        err = obsClient.doHttpWithSignedUrl("SetBucketPolicy", HTTP_PUT, signedUrl, actualSignedRequestHeaders, data, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) GetBucketPolicyWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header) (output *GetBucketPolicyOutput, err error) <span class="cov0" title="0">{
        output = &amp;GetBucketPolicyOutput{}
        err = obsClient.doHttpWithSignedUrl("GetBucketPolicy", HTTP_GET, signedUrl, actualSignedRequestHeaders, nil, output, false)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) DeleteBucketPolicyWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header) (output *BaseModel, err error) <span class="cov0" title="0">{
        output = &amp;BaseModel{}
        err = obsClient.doHttpWithSignedUrl("DeleteBucketPolicy", HTTP_DELETE, signedUrl, actualSignedRequestHeaders, nil, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) SetBucketCorsWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header, data io.Reader) (output *BaseModel, err error) <span class="cov0" title="0">{
        output = &amp;BaseModel{}
        err = obsClient.doHttpWithSignedUrl("SetBucketCors", HTTP_PUT, signedUrl, actualSignedRequestHeaders, data, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) GetBucketCorsWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header) (output *GetBucketCorsOutput, err error) <span class="cov0" title="0">{
        output = &amp;GetBucketCorsOutput{}
        err = obsClient.doHttpWithSignedUrl("GetBucketCors", HTTP_GET, signedUrl, actualSignedRequestHeaders, nil, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) DeleteBucketCorsWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header) (output *BaseModel, err error) <span class="cov0" title="0">{
        output = &amp;BaseModel{}
        err = obsClient.doHttpWithSignedUrl("DeleteBucketCors", HTTP_DELETE, signedUrl, actualSignedRequestHeaders, nil, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) SetBucketVersioningWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header, data io.Reader) (output *BaseModel, err error) <span class="cov0" title="0">{
        output = &amp;BaseModel{}
        err = obsClient.doHttpWithSignedUrl("SetBucketVersioning", HTTP_PUT, signedUrl, actualSignedRequestHeaders, data, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) GetBucketVersioningWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header) (output *GetBucketVersioningOutput, err error) <span class="cov0" title="0">{
        output = &amp;GetBucketVersioningOutput{}
        err = obsClient.doHttpWithSignedUrl("GetBucketVersioning", HTTP_GET, signedUrl, actualSignedRequestHeaders, nil, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) SetBucketWebsiteConfigurationWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header, data io.Reader) (output *BaseModel, err error) <span class="cov0" title="0">{
        output = &amp;BaseModel{}
        err = obsClient.doHttpWithSignedUrl("SetBucketWebsiteConfiguration", HTTP_PUT, signedUrl, actualSignedRequestHeaders, data, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) GetBucketWebsiteConfigurationWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header) (output *GetBucketWebsiteConfigurationOutput, err error) <span class="cov0" title="0">{
        output = &amp;GetBucketWebsiteConfigurationOutput{}
        err = obsClient.doHttpWithSignedUrl("GetBucketWebsiteConfiguration", HTTP_GET, signedUrl, actualSignedRequestHeaders, nil, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) DeleteBucketWebsiteConfigurationWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header) (output *BaseModel, err error) <span class="cov0" title="0">{
        output = &amp;BaseModel{}
        err = obsClient.doHttpWithSignedUrl("DeleteBucketWebsiteConfiguration", HTTP_DELETE, signedUrl, actualSignedRequestHeaders, nil, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) SetBucketLoggingConfigurationWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header, data io.Reader) (output *BaseModel, err error) <span class="cov0" title="0">{
        output = &amp;BaseModel{}
        err = obsClient.doHttpWithSignedUrl("SetBucketLoggingConfiguration", HTTP_PUT, signedUrl, actualSignedRequestHeaders, data, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) GetBucketLoggingConfigurationWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header) (output *GetBucketLoggingConfigurationOutput, err error) <span class="cov0" title="0">{
        output = &amp;GetBucketLoggingConfigurationOutput{}
        err = obsClient.doHttpWithSignedUrl("GetBucketLoggingConfiguration", HTTP_GET, signedUrl, actualSignedRequestHeaders, nil, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) SetBucketLifecycleConfigurationWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header, data io.Reader) (output *BaseModel, err error) <span class="cov0" title="0">{
        output = &amp;BaseModel{}
        err = obsClient.doHttpWithSignedUrl("SetBucketLifecycleConfiguration", HTTP_PUT, signedUrl, actualSignedRequestHeaders, data, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) GetBucketLifecycleConfigurationWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header) (output *GetBucketLifecycleConfigurationOutput, err error) <span class="cov0" title="0">{
        output = &amp;GetBucketLifecycleConfigurationOutput{}
        err = obsClient.doHttpWithSignedUrl("GetBucketLifecycleConfiguration", HTTP_GET, signedUrl, actualSignedRequestHeaders, nil, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) DeleteBucketLifecycleConfigurationWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header) (output *BaseModel, err error) <span class="cov0" title="0">{
        output = &amp;BaseModel{}
        err = obsClient.doHttpWithSignedUrl("DeleteBucketLifecycleConfiguration", HTTP_DELETE, signedUrl, actualSignedRequestHeaders, nil, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) SetBucketTaggingWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header, data io.Reader) (output *BaseModel, err error) <span class="cov0" title="0">{
        output = &amp;BaseModel{}
        err = obsClient.doHttpWithSignedUrl("SetBucketTagging", HTTP_PUT, signedUrl, actualSignedRequestHeaders, data, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) GetBucketTaggingWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header) (output *GetBucketTaggingOutput, err error) <span class="cov0" title="0">{
        output = &amp;GetBucketTaggingOutput{}
        err = obsClient.doHttpWithSignedUrl("GetBucketTagging", HTTP_GET, signedUrl, actualSignedRequestHeaders, nil, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) DeleteBucketTaggingWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header) (output *BaseModel, err error) <span class="cov0" title="0">{
        output = &amp;BaseModel{}
        err = obsClient.doHttpWithSignedUrl("DeleteBucketTagging", HTTP_DELETE, signedUrl, actualSignedRequestHeaders, nil, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) SetBucketNotificationWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header, data io.Reader) (output *BaseModel, err error) <span class="cov0" title="0">{
        output = &amp;BaseModel{}
        err = obsClient.doHttpWithSignedUrl("SetBucketNotification", HTTP_PUT, signedUrl, actualSignedRequestHeaders, data, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) GetBucketNotificationWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header) (output *GetBucketNotificationOutput, err error) <span class="cov0" title="0">{
        output = &amp;GetBucketNotificationOutput{}
        err = obsClient.doHttpWithSignedUrl("GetBucketNotification", HTTP_GET, signedUrl, actualSignedRequestHeaders, nil, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) DeleteObjectWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header) (output *DeleteObjectOutput, err error) <span class="cov0" title="0">{
        output = &amp;DeleteObjectOutput{}
        err = obsClient.doHttpWithSignedUrl("DeleteObject", HTTP_DELETE, signedUrl, actualSignedRequestHeaders, nil, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span> else<span class="cov0" title="0"> {
                ParseDeleteObjectOutput(output)
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) DeleteObjectsWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header, data io.Reader) (output *DeleteObjectsOutput, err error) <span class="cov0" title="0">{
        output = &amp;DeleteObjectsOutput{}
        err = obsClient.doHttpWithSignedUrl("DeleteObjects", HTTP_POST, signedUrl, actualSignedRequestHeaders, data, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) SetObjectAclWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header, data io.Reader) (output *BaseModel, err error) <span class="cov0" title="0">{
        output = &amp;BaseModel{}
        err = obsClient.doHttpWithSignedUrl("SetObjectAcl", HTTP_PUT, signedUrl, actualSignedRequestHeaders, data, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) GetObjectAclWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header) (output *GetObjectAclOutput, err error) <span class="cov0" title="0">{
        output = &amp;GetObjectAclOutput{}
        err = obsClient.doHttpWithSignedUrl("GetObjectAcl", HTTP_GET, signedUrl, actualSignedRequestHeaders, nil, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span> else<span class="cov0" title="0"> {
                if versionId, ok := output.ResponseHeaders[HEADER_VERSION_ID]; ok </span><span class="cov0" title="0">{
                        output.VersionId = versionId[0]
                }</span>
        }
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) RestoreObjectWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header, data io.Reader) (output *BaseModel, err error) <span class="cov0" title="0">{
        output = &amp;BaseModel{}
        err = obsClient.doHttpWithSignedUrl("RestoreObject", HTTP_POST, signedUrl, actualSignedRequestHeaders, data, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) GetObjectMetadataWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header) (output *GetObjectMetadataOutput, err error) <span class="cov0" title="0">{
        output = &amp;GetObjectMetadataOutput{}
        err = obsClient.doHttpWithSignedUrl("GetObjectMetadata", HTTP_HEAD, signedUrl, actualSignedRequestHeaders, nil, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span> else<span class="cov0" title="0"> {
                ParseGetObjectMetadataOutput(output)
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) GetObjectWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header) (output *GetObjectOutput, err error) <span class="cov0" title="0">{
        output = &amp;GetObjectOutput{}
        err = obsClient.doHttpWithSignedUrl("GetObject", HTTP_GET, signedUrl, actualSignedRequestHeaders, nil, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span> else<span class="cov0" title="0"> {
                ParseGetObjectOutput(output)
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) PutObjectWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header, data io.Reader) (output *PutObjectOutput, err error) <span class="cov0" title="0">{
        output = &amp;PutObjectOutput{}
        err = obsClient.doHttpWithSignedUrl("PutObject", HTTP_PUT, signedUrl, actualSignedRequestHeaders, data, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span> else<span class="cov0" title="0"> {
                ParsePutObjectOutput(output)
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) PutFileWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header, sourceFile string) (output *PutObjectOutput, err error) <span class="cov0" title="0">{
        var data io.Reader
        sourceFile = strings.TrimSpace(sourceFile)
        if sourceFile != "" </span><span class="cov0" title="0">{
                fd, err := os.Open(sourceFile)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">defer fd.Close()

                stat, err := fd.Stat()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">fileReaderWrapper := &amp;fileReaderWrapper{filePath: sourceFile}
                fileReaderWrapper.reader = fd

                var contentLength int64
                if value, ok := actualSignedRequestHeaders[HEADER_CONTENT_LENGTH_CAMEL]; ok </span><span class="cov0" title="0">{
                        contentLength = StringToInt64(value[0], -1)
                }</span> else<span class="cov0" title="0"> if value, ok := actualSignedRequestHeaders[HEADER_CONTENT_LENGTH]; ok </span><span class="cov0" title="0">{
                        contentLength = StringToInt64(value[0], -1)
                }</span> else<span class="cov0" title="0"> {
                        contentLength = stat.Size()
                }</span>
                <span class="cov0" title="0">if contentLength &gt; stat.Size() </span><span class="cov0" title="0">{
                        return nil, errors.New("ContentLength is larger than fileSize")
                }</span>
                <span class="cov0" title="0">fileReaderWrapper.totalCount = contentLength
                data = fileReaderWrapper</span>
        }

        <span class="cov0" title="0">output = &amp;PutObjectOutput{}
        err = obsClient.doHttpWithSignedUrl("PutObject", HTTP_PUT, signedUrl, actualSignedRequestHeaders, data, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span> else<span class="cov0" title="0"> {
                ParsePutObjectOutput(output)
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) CopyObjectWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header) (output *CopyObjectOutput, err error) <span class="cov0" title="0">{
        output = &amp;CopyObjectOutput{}
        err = obsClient.doHttpWithSignedUrl("CopyObject", HTTP_PUT, signedUrl, actualSignedRequestHeaders, nil, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span> else<span class="cov0" title="0"> {
                ParseCopyObjectOutput(output)
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) AbortMultipartUploadWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header) (output *BaseModel, err error) <span class="cov0" title="0">{
        output = &amp;BaseModel{}
        err = obsClient.doHttpWithSignedUrl("AbortMultipartUpload", HTTP_DELETE, signedUrl, actualSignedRequestHeaders, nil, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) InitiateMultipartUploadWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header) (output *InitiateMultipartUploadOutput, err error) <span class="cov0" title="0">{
        output = &amp;InitiateMultipartUploadOutput{}
        err = obsClient.doHttpWithSignedUrl("InitiateMultipartUpload", HTTP_POST, signedUrl, actualSignedRequestHeaders, nil, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span> else<span class="cov0" title="0"> {
                ParseInitiateMultipartUploadOutput(output)
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) UploadPartWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header, data io.Reader) (output *UploadPartOutput, err error) <span class="cov0" title="0">{
        output = &amp;UploadPartOutput{}
        err = obsClient.doHttpWithSignedUrl("UploadPart", HTTP_PUT, signedUrl, actualSignedRequestHeaders, data, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span> else<span class="cov0" title="0"> {
                ParseUploadPartOutput(output)
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) CompleteMultipartUploadWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header, data io.Reader) (output *CompleteMultipartUploadOutput, err error) <span class="cov0" title="0">{
        output = &amp;CompleteMultipartUploadOutput{}
        err = obsClient.doHttpWithSignedUrl("CompleteMultipartUpload", HTTP_POST, signedUrl, actualSignedRequestHeaders, data, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span> else<span class="cov0" title="0"> {
                ParseCompleteMultipartUploadOutput(output)
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) ListPartsWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header) (output *ListPartsOutput, err error) <span class="cov0" title="0">{
        output = &amp;ListPartsOutput{}
        err = obsClient.doHttpWithSignedUrl("ListParts", HTTP_GET, signedUrl, actualSignedRequestHeaders, nil, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) CopyPartWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header) (output *CopyPartOutput, err error) <span class="cov0" title="0">{
        output = &amp;CopyPartOutput{}
        err = obsClient.doHttpWithSignedUrl("CopyPart", HTTP_PUT, signedUrl, actualSignedRequestHeaders, nil, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span> else<span class="cov0" title="0"> {
                ParseCopyPartOutput(output)
        }</span>
        <span class="cov0" title="0">return</span>
}
</pre>
		
		<pre class="file" id="file59" style="display: none">package obs

import (
        "bytes"
        "fmt"
        "io"
        "os"
        "strings"
)

type IReadCloser interface {
        setReadCloser(body io.ReadCloser)
}

func (output *GetObjectOutput) setReadCloser(body io.ReadCloser) <span class="cov0" title="0">{
        output.Body = body
}</span>

type IBaseModel interface {
        setStatusCode(statusCode int)

        setRequestId(requestId string)

        setResponseHeaders(responseHeaders map[string][]string)
}

type ISerializable interface {
        trans() (map[string]string, map[string][]string, interface{})
}

type DefaultSerializable struct {
        params  map[string]string
        headers map[string][]string
        data    interface{}
}

func (input DefaultSerializable) trans() (map[string]string, map[string][]string, interface{}) <span class="cov0" title="0">{
        return input.params, input.headers, input.data
}</span>

var defaultSerializable = &amp;DefaultSerializable{}

func newSubResourceSerial(subResource SubResourceType) *DefaultSerializable <span class="cov0" title="0">{
        return &amp;DefaultSerializable{map[string]string{string(subResource): ""}, nil, nil}
}</span>

func trans(subResource SubResourceType, input interface{}) (params map[string]string, headers map[string][]string, data interface{}) <span class="cov0" title="0">{
        params = map[string]string{string(subResource): ""}
        data, _ = ConvertRequestToIoReader(input)
        return
}</span>

func (baseModel *BaseModel) setStatusCode(statusCode int) <span class="cov0" title="0">{
        baseModel.StatusCode = statusCode
}</span>

func (baseModel *BaseModel) setRequestId(requestId string) <span class="cov0" title="0">{
        baseModel.RequestId = requestId
}</span>

func (baseModel *BaseModel) setResponseHeaders(responseHeaders map[string][]string) <span class="cov0" title="0">{
        baseModel.ResponseHeaders = responseHeaders
}</span>

func (input ListBucketsInput) trans() (params map[string]string, headers map[string][]string, data interface{}) <span class="cov0" title="0">{
        headers = make(map[string][]string)
        if input.QueryLocation </span><span class="cov0" title="0">{
                headers[HEADER_LOCATION_AMZ] = []string{"true"}
        }</span>
        <span class="cov0" title="0">return</span>
}

func (input CreateBucketInput) trans() (params map[string]string, headers map[string][]string, data interface{}) <span class="cov0" title="0">{
        headers = make(map[string][]string)
        if acl := string(input.ACL); acl != "" </span><span class="cov0" title="0">{
                headers[HEADER_ACL_AMZ] = []string{acl}
        }</span>

        <span class="cov0" title="0">if storageClass := string(input.StorageClass); storageClass != "" </span><span class="cov0" title="0">{
                headers[HEADER_STORAGE_CLASS] = []string{storageClass}
        }</span>

        <span class="cov0" title="0">if location := strings.TrimSpace(input.Location); location != "" </span><span class="cov0" title="0">{
                input.Location = location
                data, _ = ConvertRequestToIoReader(input)
        }</span>
        <span class="cov0" title="0">return</span>
}

func (input SetBucketStoragePolicyInput) trans() (params map[string]string, headers map[string][]string, data interface{}) <span class="cov0" title="0">{
        return trans(SubResourceStoragePolicy, input)
}</span>

func (input ListObjsInput) trans() (params map[string]string, headers map[string][]string, data interface{}) <span class="cov0" title="0">{
        params = make(map[string]string)
        if input.Prefix != "" </span><span class="cov0" title="0">{
                params["prefix"] = input.Prefix
        }</span>
        <span class="cov0" title="0">if input.Delimiter != "" </span><span class="cov0" title="0">{
                params["delimiter"] = input.Delimiter
        }</span>
        <span class="cov0" title="0">if input.MaxKeys &gt; 0 </span><span class="cov0" title="0">{
                params["max-keys"] = IntToString(input.MaxKeys)
        }</span>
        <span class="cov0" title="0">headers = make(map[string][]string)
        if origin := strings.TrimSpace(input.Origin); origin != "" </span><span class="cov0" title="0">{
                headers[HEADER_ORIGIN_CAMEL] = []string{origin}
        }</span>
        <span class="cov0" title="0">if requestHeader := strings.TrimSpace(input.RequestHeader); requestHeader != "" </span><span class="cov0" title="0">{
                headers[HEADER_ACCESS_CONTROL_REQUEST_HEADER_CAMEL] = []string{requestHeader}
        }</span>
        <span class="cov0" title="0">return</span>
}

func (input ListObjectsInput) trans() (params map[string]string, headers map[string][]string, data interface{}) <span class="cov0" title="0">{
        params, headers, data = input.ListObjsInput.trans()
        if input.Marker != "" </span><span class="cov0" title="0">{
                params["marker"] = input.Marker
        }</span>
        <span class="cov0" title="0">return</span>
}

func (input ListVersionsInput) trans() (params map[string]string, headers map[string][]string, data interface{}) <span class="cov0" title="0">{
        params, headers, data = input.ListObjsInput.trans()
        params[string(SubResourceVersions)] = ""
        if input.KeyMarker != "" </span><span class="cov0" title="0">{
                params["key-marker"] = input.KeyMarker
        }</span>
        <span class="cov0" title="0">if input.VersionIdMarker != "" </span><span class="cov0" title="0">{
                params["version-id-marker"] = input.VersionIdMarker
        }</span>
        <span class="cov0" title="0">return</span>
}

func (input ListMultipartUploadsInput) trans() (params map[string]string, headers map[string][]string, data interface{}) <span class="cov0" title="0">{
        params = map[string]string{string(SubResourceUploads): ""}
        if input.Prefix != "" </span><span class="cov0" title="0">{
                params["prefix"] = input.Prefix
        }</span>
        <span class="cov0" title="0">if input.Delimiter != "" </span><span class="cov0" title="0">{
                params["delimiter"] = input.Delimiter
        }</span>
        <span class="cov0" title="0">if input.MaxUploads &gt; 0 </span><span class="cov0" title="0">{
                params["max-uploads"] = IntToString(input.MaxUploads)
        }</span>
        <span class="cov0" title="0">if input.KeyMarker != "" </span><span class="cov0" title="0">{
                params["key-marker"] = input.KeyMarker
        }</span>
        <span class="cov0" title="0">if input.UploadIdMarker != "" </span><span class="cov0" title="0">{
                params["upload-id-marker"] = input.UploadIdMarker
        }</span>
        <span class="cov0" title="0">return</span>
}

func (input SetBucketQuotaInput) trans() (params map[string]string, headers map[string][]string, data interface{}) <span class="cov0" title="0">{
        return trans(SubResourceQuota, input)
}</span>

func (input SetBucketAclInput) trans() (params map[string]string, headers map[string][]string, data interface{}) <span class="cov0" title="0">{
        params = map[string]string{string(SubResourceAcl): ""}
        headers = make(map[string][]string)

        if acl := string(input.ACL); acl != "" </span><span class="cov0" title="0">{
                headers[HEADER_ACL_AMZ] = []string{acl}
        }</span> else<span class="cov0" title="0"> {
                data, _ = ConvertAclToXml(input.AccessControlPolicy, false)
        }</span>
        <span class="cov0" title="0">return</span>
}

func (input SetBucketPolicyInput) trans() (params map[string]string, headers map[string][]string, data interface{}) <span class="cov0" title="0">{
        params = map[string]string{string(SubResourcePolicy): ""}
        data = strings.NewReader(input.Policy)
        return
}</span>

func (input SetBucketCorsInput) trans() (params map[string]string, headers map[string][]string, data interface{}) <span class="cov0" title="0">{
        params = map[string]string{string(SubResourceCors): ""}
        data, md5, _ := ConvertRequestToIoReaderV2(input)
        headers = map[string][]string{HEADER_MD5_CAMEL: []string{md5}}
        return
}</span>

func (input SetBucketVersioningInput) trans() (params map[string]string, headers map[string][]string, data interface{}) <span class="cov0" title="0">{
        return trans(SubResourceVersioning, input)
}</span>

func (input SetBucketWebsiteConfigurationInput) trans() (params map[string]string, headers map[string][]string, data interface{}) <span class="cov0" title="0">{
        params = map[string]string{string(SubResourceWebsite): ""}
        data, _ = ConvertWebsiteConfigurationToXml(input.BucketWebsiteConfiguration, false)
        return
}</span>

func (input GetBucketMetadataInput) trans() (params map[string]string, headers map[string][]string, data interface{}) <span class="cov0" title="0">{
        headers = make(map[string][]string)
        if origin := strings.TrimSpace(input.Origin); origin != "" </span><span class="cov0" title="0">{
                headers[HEADER_ORIGIN_CAMEL] = []string{origin}
        }</span>
        <span class="cov0" title="0">if requestHeader := strings.TrimSpace(input.RequestHeader); requestHeader != "" </span><span class="cov0" title="0">{
                headers[HEADER_ACCESS_CONTROL_REQUEST_HEADER_CAMEL] = []string{requestHeader}
        }</span>
        <span class="cov0" title="0">return</span>
}

func (input SetBucketLoggingConfigurationInput) trans() (params map[string]string, headers map[string][]string, data interface{}) <span class="cov0" title="0">{
        params = map[string]string{string(SubResourceLogging): ""}
        data, _ = ConvertLoggingStatusToXml(input.BucketLoggingStatus, false)
        return
}</span>

func (input SetBucketLifecycleConfigurationInput) trans() (params map[string]string, headers map[string][]string, data interface{}) <span class="cov0" title="0">{
        params = map[string]string{string(SubResourceLifecycle): ""}
        data, md5 := ConvertLifecyleConfigurationToXml(input.BucketLifecyleConfiguration, true)
        headers = map[string][]string{HEADER_MD5_CAMEL: []string{md5}}
        return
}</span>

func (input SetBucketTaggingInput) trans() (params map[string]string, headers map[string][]string, data interface{}) <span class="cov0" title="0">{
        params = map[string]string{string(SubResourceTagging): ""}
        data, md5, _ := ConvertRequestToIoReaderV2(input)
        headers = map[string][]string{HEADER_MD5_CAMEL: []string{md5}}
        return
}</span>

func (input SetBucketNotificationInput) trans() (params map[string]string, headers map[string][]string, data interface{}) <span class="cov0" title="0">{
        params = map[string]string{string(SubResourceNotification): ""}
        data, _ = ConvertNotificationToXml(input.BucketNotification, false)
        return
}</span>

func (input DeleteObjectInput) trans() (params map[string]string, headers map[string][]string, data interface{}) <span class="cov0" title="0">{
        params = make(map[string]string)
        if input.VersionId != "" </span><span class="cov0" title="0">{
                params[PARAM_VERSION_ID] = input.VersionId
        }</span>
        <span class="cov0" title="0">return</span>
}

func (input DeleteObjectsInput) trans() (params map[string]string, headers map[string][]string, data interface{}) <span class="cov0" title="0">{
        params = map[string]string{string(SubResourceDelete): ""}
        data, md5, _ := ConvertRequestToIoReaderV2(input)
        headers = map[string][]string{HEADER_MD5_CAMEL: []string{md5}}
        return
}</span>

func (input SetObjectAclInput) trans() (params map[string]string, headers map[string][]string, data interface{}) <span class="cov0" title="0">{
        params = map[string]string{string(SubResourceAcl): ""}
        if input.VersionId != "" </span><span class="cov0" title="0">{
                params[PARAM_VERSION_ID] = input.VersionId
        }</span>
        <span class="cov0" title="0">headers = make(map[string][]string)
        if acl := string(input.ACL); acl != "" </span><span class="cov0" title="0">{
                headers[HEADER_ACL_AMZ] = []string{acl}
        }</span> else<span class="cov0" title="0"> {
                data, _ = ConvertAclToXml(input.AccessControlPolicy, false)
        }</span>
        <span class="cov0" title="0">return</span>
}

func (input GetObjectAclInput) trans() (params map[string]string, headers map[string][]string, data interface{}) <span class="cov0" title="0">{
        params = map[string]string{string(SubResourceAcl): ""}
        if input.VersionId != "" </span><span class="cov0" title="0">{
                params[PARAM_VERSION_ID] = input.VersionId
        }</span>
        <span class="cov0" title="0">return</span>
}

func (input RestoreObjectInput) trans() (params map[string]string, headers map[string][]string, data interface{}) <span class="cov0" title="0">{
        params = map[string]string{string(SubResourceRestore): ""}
        if input.VersionId != "" </span><span class="cov0" title="0">{
                params[PARAM_VERSION_ID] = input.VersionId
        }</span>
        <span class="cov0" title="0">data, _ = ConvertRequestToIoReader(input)
        return</span>
}

func (header SseKmsHeader) GetEncryption() string <span class="cov0" title="0">{
        if header.Encryption != "" </span><span class="cov0" title="0">{
                return header.Encryption
        }</span>
        <span class="cov0" title="0">return DEFAULT_SSE_KMS_ENCRYPTION</span>
}

func (header SseKmsHeader) GetKey() string <span class="cov0" title="0">{
        return header.Key
}</span>

func (header SseCHeader) GetEncryption() string <span class="cov0" title="0">{
        if header.Encryption != "" </span><span class="cov0" title="0">{
                return header.Encryption
        }</span>
        <span class="cov0" title="0">return DEFAULT_SSE_C_ENCRYPTION</span>
}

func (header SseCHeader) GetKey() string <span class="cov0" title="0">{
        return header.Key
}</span>

func (header SseCHeader) GetKeyMD5() string <span class="cov0" title="0">{
        if header.KeyMD5 != "" </span><span class="cov0" title="0">{
                return header.KeyMD5
        }</span>

        <span class="cov0" title="0">if ret, err := Base64Decode(header.GetKey()); err == nil </span><span class="cov0" title="0">{
                return Base64Md5(ret)
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func setSseHeader(headers map[string][]string, sseHeader ISseHeader, sseCOnly bool) <span class="cov0" title="0">{
        if sseHeader != nil </span><span class="cov0" title="0">{
                if sseCHeader, ok := sseHeader.(SseCHeader); ok </span><span class="cov0" title="0">{
                        headers[HEADER_SSEC_ENCRYPTION_AMZ] = []string{sseCHeader.GetEncryption()}
                        headers[HEADER_SSEC_KEY_AMZ] = []string{sseCHeader.GetKey()}
                        headers[HEADER_SSEC_KEY_MD5_AMZ] = []string{sseCHeader.GetKeyMD5()}
                }</span> else<span class="cov0" title="0"> if sseKmsHeader, ok := sseHeader.(SseKmsHeader); !sseCOnly &amp;&amp; ok </span><span class="cov0" title="0">{
                        headers[HEADER_SSEKMS_ENCRYPTION_AMZ] = []string{sseKmsHeader.GetEncryption()}
                        headers[HEADER_SSEKMS_KEY_AMZ] = []string{sseKmsHeader.GetKey()}
                }</span>
        }
}

func (input GetObjectMetadataInput) trans() (params map[string]string, headers map[string][]string, data interface{}) <span class="cov0" title="0">{
        params = make(map[string]string)
        if input.VersionId != "" </span><span class="cov0" title="0">{
                params[PARAM_VERSION_ID] = input.VersionId
        }</span>
        <span class="cov0" title="0">headers = make(map[string][]string)

        if input.Origin != "" </span><span class="cov0" title="0">{
                headers[HEADER_ORIGIN_CAMEL] = []string{input.Origin}
        }</span>

        <span class="cov0" title="0">if input.RequestHeader != "" </span><span class="cov0" title="0">{
                headers[HEADER_ACCESS_CONTROL_REQUEST_HEADER_CAMEL] = []string{input.RequestHeader}
        }</span>
        <span class="cov0" title="0">setSseHeader(headers, input.SseHeader, true)
        return</span>
}

func (input GetObjectInput) trans() (params map[string]string, headers map[string][]string, data interface{}) <span class="cov0" title="0">{
        params, headers, data = input.GetObjectMetadataInput.trans()
        if input.ResponseCacheControl != "" </span><span class="cov0" title="0">{
                params[PARAM_RESPONSE_CACHE_CONTROL] = input.ResponseCacheControl
        }</span>
        <span class="cov0" title="0">if input.ResponseContentDisposition != "" </span><span class="cov0" title="0">{
                params[PARAM_RESPONSE_CONTENT_DISPOSITION] = input.ResponseContentDisposition
        }</span>
        <span class="cov0" title="0">if input.ResponseContentEncoding != "" </span><span class="cov0" title="0">{
                params[PARAM_RESPONSE_CONTENT_ENCODING] = input.ResponseContentEncoding
        }</span>
        <span class="cov0" title="0">if input.ResponseContentLanguage != "" </span><span class="cov0" title="0">{
                params[PARAM_RESPONSE_CONTENT_LANGUAGE] = input.ResponseContentLanguage
        }</span>
        <span class="cov0" title="0">if input.ResponseContentType != "" </span><span class="cov0" title="0">{
                params[PARAM_RESPONSE_CONTENT_TYPE] = input.ResponseContentType
        }</span>
        <span class="cov0" title="0">if input.ResponseExpires != "" </span><span class="cov0" title="0">{
                params[PARAM_RESPONSE_EXPIRES] = input.ResponseExpires
        }</span>
        <span class="cov0" title="0">if input.ImageProcess != "" </span><span class="cov0" title="0">{
                params[PARAM_IMAGE_PROCESS] = input.ImageProcess
        }</span>
        <span class="cov0" title="0">if input.RangeStart &gt;= 0 &amp;&amp; input.RangeEnd &gt; input.RangeStart </span><span class="cov0" title="0">{
                headers[HEADER_RANGE] = []string{fmt.Sprintf("bytes=%d-%d", input.RangeStart, input.RangeEnd)}
        }</span>

        <span class="cov0" title="0">if input.IfMatch != "" </span><span class="cov0" title="0">{
                headers[HEADER_IF_MATCH] = []string{input.IfMatch}
        }</span>
        <span class="cov0" title="0">if input.IfNoneMatch != "" </span><span class="cov0" title="0">{
                headers[HEADER_IF_NONE_MATCH] = []string{input.IfNoneMatch}
        }</span>
        <span class="cov0" title="0">if !input.IfModifiedSince.IsZero() </span><span class="cov0" title="0">{
                headers[HEADER_IF_MODIFIED_SINCE] = []string{FormatUtcToRfc1123(input.IfModifiedSince)}
        }</span>
        <span class="cov0" title="0">if !input.IfUnmodifiedSince.IsZero() </span><span class="cov0" title="0">{
                headers[HEADER_IF_UNMODIFIED_SINCE] = []string{FormatUtcToRfc1123(input.IfUnmodifiedSince)}
        }</span>
        <span class="cov0" title="0">return</span>
}

func (input ObjectOperationInput) trans() (params map[string]string, headers map[string][]string, data interface{}) <span class="cov0" title="0">{
        headers = make(map[string][]string)
        params = make(map[string]string)
        if acl := string(input.ACL); acl != "" </span><span class="cov0" title="0">{
                headers[HEADER_ACL_AMZ] = []string{acl}
        }</span>
        <span class="cov0" title="0">if storageClass := string(input.StorageClass); storageClass != "" </span><span class="cov0" title="0">{
                headers[HEADER_STORAGE_CLASS2_AMZ] = []string{storageClass}
        }</span>
        <span class="cov0" title="0">if input.WebsiteRedirectLocation != "" </span><span class="cov0" title="0">{
                headers[HEADER_WEBSITE_REDIRECT_LOCATION_AMZ] = []string{input.WebsiteRedirectLocation}
        }</span>
        <span class="cov0" title="0">setSseHeader(headers, input.SseHeader, false)
        if input.Metadata != nil </span><span class="cov0" title="0">{
                for key, value := range input.Metadata </span><span class="cov0" title="0">{
                        key = strings.TrimSpace(key)
                        if !strings.HasPrefix(key, HEADER_PREFIX_META) </span><span class="cov0" title="0">{
                                key = HEADER_PREFIX_META + key
                        }</span>
                        <span class="cov0" title="0">headers[key] = []string{value}</span>
                }
        }
        <span class="cov0" title="0">return</span>
}

func (input PutObjectBasicInput) trans() (params map[string]string, headers map[string][]string, data interface{}) <span class="cov0" title="0">{
        params, headers, data = input.ObjectOperationInput.trans()

        if input.ContentMD5 != "" </span><span class="cov0" title="0">{
                headers[HEADER_MD5_CAMEL] = []string{input.ContentMD5}
        }</span>

        <span class="cov0" title="0">if input.ContentLength &gt; 0 </span><span class="cov0" title="0">{
                headers[HEADER_CONTENT_LENGTH_CAMEL] = []string{Int64ToString(input.ContentLength)}
        }</span>
        <span class="cov0" title="0">if input.ContentType != "" </span><span class="cov0" title="0">{
                headers[HEADER_CONTENT_TYPE_CAML] = []string{input.ContentType}
        }</span>

        <span class="cov0" title="0">return</span>
}

func (input PutObjectInput) trans() (params map[string]string, headers map[string][]string, data interface{}) <span class="cov0" title="0">{
        params, headers, data = input.PutObjectBasicInput.trans()
        if input.Body != nil </span><span class="cov0" title="0">{
                data = input.Body
        }</span>
        <span class="cov0" title="0">return</span>
}

func (input CopyObjectInput) trans() (params map[string]string, headers map[string][]string, data interface{}) <span class="cov0" title="0">{
        params, headers, data = input.ObjectOperationInput.trans()

        var copySource string
        if input.CopySourceVersionId != "" </span><span class="cov0" title="0">{
                copySource = fmt.Sprintf("%s/%s?versionId=%s", input.CopySourceBucket, UrlEncode(input.CopySourceKey, false), input.CopySourceVersionId)
        }</span> else<span class="cov0" title="0"> {
                copySource = fmt.Sprintf("%s/%s", input.CopySourceBucket, UrlEncode(input.CopySourceKey, false))
        }</span>
        <span class="cov0" title="0">headers[HEADER_COPY_SOURCE_AMZ] = []string{copySource}

        if directive := string(input.MetadataDirective); directive != "" </span><span class="cov0" title="0">{
                headers[HEADER_METADATA_DIRECTIVE_AMZ] = []string{directive}
        }</span>

        <span class="cov0" title="0">if input.MetadataDirective == ReplaceMetadata </span><span class="cov0" title="0">{
                if input.CacheControl != "" </span><span class="cov0" title="0">{
                        headers[HEADER_CACHE_CONTROL] = []string{input.CacheControl}
                }</span>
                <span class="cov0" title="0">if input.ContentDisposition != "" </span><span class="cov0" title="0">{
                        headers[HEADER_CONTENT_DISPOSITION] = []string{input.ContentDisposition}
                }</span>
                <span class="cov0" title="0">if input.ContentEncoding != "" </span><span class="cov0" title="0">{
                        headers[HEADER_CONTENT_ENCODING] = []string{input.ContentEncoding}
                }</span>
                <span class="cov0" title="0">if input.ContentLanguage != "" </span><span class="cov0" title="0">{
                        headers[HEADER_CONTENT_LANGUAGE] = []string{input.ContentLanguage}
                }</span>
                <span class="cov0" title="0">if input.ContentType != "" </span><span class="cov0" title="0">{
                        headers[HEADER_CONTENT_TYPE] = []string{input.ContentType}
                }</span>
                <span class="cov0" title="0">if input.Expires != "" </span><span class="cov0" title="0">{
                        headers[HEADER_EXPIRES] = []string{input.Expires}
                }</span>
        }

        <span class="cov0" title="0">if input.CopySourceIfMatch != "" </span><span class="cov0" title="0">{
                headers[HEADER_COPY_SOURCE_IF_MATCH_AMZ] = []string{input.CopySourceIfMatch}
        }</span>
        <span class="cov0" title="0">if input.CopySourceIfNoneMatch != "" </span><span class="cov0" title="0">{
                headers[HEADER_COPY_SOURCE_IF_NONE_MATCH_AMZ] = []string{input.CopySourceIfNoneMatch}
        }</span>
        <span class="cov0" title="0">if !input.CopySourceIfModifiedSince.IsZero() </span><span class="cov0" title="0">{
                headers[HEADER_COPY_SOURCE_IF_MODIFIED_SINCE_AMZ] = []string{FormatUtcToRfc1123(input.CopySourceIfModifiedSince)}
        }</span>
        <span class="cov0" title="0">if !input.CopySourceIfUnmodifiedSince.IsZero() </span><span class="cov0" title="0">{
                headers[HEADER_COPY_SOURCE_IF_UNMODIFIED_SINCE_AMZ] = []string{FormatUtcToRfc1123(input.CopySourceIfUnmodifiedSince)}
        }</span>
        <span class="cov0" title="0">if input.SourceSseHeader != nil </span><span class="cov0" title="0">{
                if sseCHeader, ok := input.SourceSseHeader.(SseCHeader); ok </span><span class="cov0" title="0">{
                        headers[HEADER_SSEC_COPY_SOURCE_ENCRYPTION_AMZ] = []string{sseCHeader.GetEncryption()}
                        headers[HEADER_SSEC_COPY_SOURCE_KEY_AMZ] = []string{sseCHeader.GetKey()}
                        headers[HEADER_SSEC_COPY_SOURCE_KEY_MD5_AMZ] = []string{sseCHeader.GetKeyMD5()}
                }</span>
        }
        <span class="cov0" title="0">return</span>
}

func (input AbortMultipartUploadInput) trans() (params map[string]string, headers map[string][]string, data interface{}) <span class="cov0" title="0">{
        params = map[string]string{"uploadId": input.UploadId}
        return
}</span>

func (input InitiateMultipartUploadInput) trans() (params map[string]string, headers map[string][]string, data interface{}) <span class="cov0" title="0">{
        params, headers, data = input.ObjectOperationInput.trans()
        params[string(SubResourceUploads)] = ""
        return
}</span>

func (input UploadPartInput) trans() (params map[string]string, headers map[string][]string, data interface{}) <span class="cov0" title="0">{
        params = map[string]string{"uploadId": input.UploadId, "partNumber": IntToString(input.PartNumber)}
        headers = make(map[string][]string)
        setSseHeader(headers, input.SseHeader, true)
        if input.Body != nil </span><span class="cov0" title="0">{
                data = input.Body
        }</span>
        <span class="cov0" title="0">return</span>
}

func (input CompleteMultipartUploadInput) trans() (params map[string]string, headers map[string][]string, data interface{}) <span class="cov0" title="0">{
        params = map[string]string{"uploadId": input.UploadId}
        data, _ = ConvertCompleteMultipartUploadInputToXml(input, false)
        return
}</span>

func (input ListPartsInput) trans() (params map[string]string, headers map[string][]string, data interface{}) <span class="cov0" title="0">{
        params = map[string]string{"uploadId": input.UploadId}
        if input.MaxParts &gt; 0 </span><span class="cov0" title="0">{
                params["max-parts"] = IntToString(input.MaxParts)
        }</span>
        <span class="cov0" title="0">if input.PartNumberMarker &gt; 0 </span><span class="cov0" title="0">{
                params["part-number-marker"] = IntToString(input.PartNumberMarker)
        }</span>
        <span class="cov0" title="0">return</span>
}

func (input CopyPartInput) trans() (params map[string]string, headers map[string][]string, data interface{}) <span class="cov0" title="0">{
        params = map[string]string{"uploadId": input.UploadId, "partNumber": IntToString(input.PartNumber)}
        headers = make(map[string][]string, 1)
        var copySource string
        if input.CopySourceVersionId != "" </span><span class="cov0" title="0">{
                copySource = fmt.Sprintf("%s/%s?versionId=%s", input.CopySourceBucket, UrlEncode(input.CopySourceKey, false), input.CopySourceVersionId)
        }</span> else<span class="cov0" title="0"> {
                copySource = fmt.Sprintf("%s/%s", input.CopySourceBucket, UrlEncode(input.CopySourceKey, false))
        }</span>
        <span class="cov0" title="0">headers[HEADER_COPY_SOURCE_AMZ] = []string{copySource}

        if input.CopySourceRangeStart &gt;= 0 &amp;&amp; input.CopySourceRangeEnd &gt; input.CopySourceRangeStart </span><span class="cov0" title="0">{
                headers[HEADER_COPY_SOURCE_RANGE_AMZ] = []string{fmt.Sprintf("bytes=%d-%d", input.CopySourceRangeStart, input.CopySourceRangeEnd)}
        }</span>

        <span class="cov0" title="0">setSseHeader(headers, input.SseHeader, true)
        if input.SourceSseHeader != nil </span><span class="cov0" title="0">{
                if sseCHeader, ok := input.SourceSseHeader.(SseCHeader); ok </span><span class="cov0" title="0">{
                        headers[HEADER_SSEC_COPY_SOURCE_ENCRYPTION_AMZ] = []string{sseCHeader.GetEncryption()}
                        headers[HEADER_SSEC_COPY_SOURCE_KEY_AMZ] = []string{sseCHeader.GetKey()}
                        headers[HEADER_SSEC_COPY_SOURCE_KEY_MD5_AMZ] = []string{sseCHeader.GetKeyMD5()}
                }</span>
        }
        <span class="cov0" title="0">return</span>
}

type partSlice []Part

func (parts partSlice) Len() int <span class="cov0" title="0">{
        return len(parts)
}</span>

func (parts partSlice) Less(i, j int) bool <span class="cov0" title="0">{
        return parts[i].PartNumber &lt; parts[j].PartNumber
}</span>

func (parts partSlice) Swap(i, j int) <span class="cov0" title="0">{
        parts[i], parts[j] = parts[j], parts[i]
}</span>

type readerWrapper struct {
        reader      io.Reader
        mark        int64
        totalCount  int64
        readedCount int64
}

func (rw *readerWrapper) seek(offset int64, whence int) (int64, error) <span class="cov0" title="0">{
        if r, ok := rw.reader.(*strings.Reader); ok </span><span class="cov0" title="0">{
                return r.Seek(offset, whence)
        }</span> else<span class="cov0" title="0"> if r, ok := rw.reader.(*bytes.Reader); ok </span><span class="cov0" title="0">{
                return r.Seek(offset, whence)
        }</span> else<span class="cov0" title="0"> if r, ok := rw.reader.(*os.File); ok </span><span class="cov0" title="0">{
                return r.Seek(offset, whence)
        }</span>
        <span class="cov0" title="0">return offset, nil</span>
}

func (rw *readerWrapper) Read(p []byte) (n int, err error) <span class="cov0" title="0">{
        if rw.totalCount == 0 </span><span class="cov0" title="0">{
                return 0, io.EOF
        }</span>
        <span class="cov0" title="0">if rw.totalCount &gt; 0 </span><span class="cov0" title="0">{
                n, err = rw.reader.Read(p)
                readedOnce := int64(n)
                if remainCount := rw.totalCount - rw.readedCount; remainCount &gt; readedOnce </span><span class="cov0" title="0">{
                        rw.readedCount += readedOnce
                        return n, err
                }</span> else<span class="cov0" title="0"> {
                        rw.readedCount += remainCount
                        return int(remainCount), io.EOF
                }</span>
        }
        <span class="cov0" title="0">return rw.reader.Read(p)</span>
}

type fileReaderWrapper struct {
        readerWrapper
        filePath string
}
</pre>
		
		<pre class="file" id="file60" style="display: none">package obs

import (
        "crypto/hmac"
        "crypto/md5"
        "crypto/sha1"
        "crypto/sha256"
        "encoding/base64"
        "encoding/hex"
        "encoding/xml"
        "fmt"
        "net/url"
        "regexp"
        "strconv"
        "strings"
        "time"
)

var regex = regexp.MustCompile("^[\u4e00-\u9fa5]$")
var ipRegex = regexp.MustCompile("^((2[0-4]\\d|25[0-5]|[01]?\\d\\d?)\\.){3}(2[0-4]\\d|25[0-5]|[01]?\\d\\d?)$")
var v4AuthRegex = regexp.MustCompile("Credential=(.+?),SignedHeaders=(.+?),Signature=.+")
var regionRegex = regexp.MustCompile(".+/\\d+/(.+?)/.+")

func StringToInt(value string, def int) int <span class="cov0" title="0">{
        ret, err := strconv.Atoi(value)
        if err != nil </span><span class="cov0" title="0">{
                ret = def
        }</span>
        <span class="cov0" title="0">return ret</span>
}

func StringToInt64(value string, def int64) int64 <span class="cov0" title="0">{
        ret, err := strconv.ParseInt(value, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                ret = def
        }</span>
        <span class="cov0" title="0">return ret</span>
}

func IntToString(value int) string <span class="cov0" title="0">{
        return strconv.Itoa(value)
}</span>

func Int64ToString(value int64) string <span class="cov0" title="0">{
        return strconv.FormatInt(value, 10)
}</span>

func GetCurrentTimestamp() int64 <span class="cov0" title="0">{
        return time.Now().UnixNano() / 1000000
}</span>

func FormatUtcNow(format string) string <span class="cov0" title="0">{
        return time.Now().UTC().Format(format)
}</span>

func FormatUtcToRfc1123(t time.Time) string <span class="cov0" title="0">{
        ret := t.UTC().Format(time.RFC1123)
        return ret[:strings.LastIndex(ret, "UTC")] + "GMT"
}</span>

func Md5(value []byte) []byte <span class="cov0" title="0">{
        m := md5.New()
        m.Write(value)
        return m.Sum(nil)
}</span>

func HmacSha1(key, value []byte) []byte <span class="cov0" title="0">{
        mac := hmac.New(sha1.New, key)
        mac.Write(value)
        return mac.Sum(nil)
}</span>

func HmacSha256(key, value []byte) []byte <span class="cov0" title="0">{
        mac := hmac.New(sha256.New, key)
        mac.Write(value)
        return mac.Sum(nil)
}</span>

func Base64Encode(value []byte) string <span class="cov0" title="0">{
        return base64.StdEncoding.EncodeToString(value)
}</span>

func Base64Decode(value string) ([]byte, error) <span class="cov0" title="0">{
        return base64.StdEncoding.DecodeString(value)
}</span>

func HexMd5(value []byte) string <span class="cov0" title="0">{
        return Hex(Md5(value))
}</span>

func Base64Md5(value []byte) string <span class="cov0" title="0">{
        return Base64Encode(Md5(value))
}</span>

func Sha256Hash(value []byte) []byte <span class="cov0" title="0">{
        hash := sha256.New()
        hash.Write(value)
        return hash.Sum(nil)
}</span>

func ParseXml(value []byte, result interface{}) error <span class="cov0" title="0">{
        if len(value) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return xml.Unmarshal(value, result)</span>
}

func TransToXml(value interface{}) ([]byte, error) <span class="cov0" title="0">{
        if value == nil </span><span class="cov0" title="0">{
                return []byte{}, nil
        }</span>
        <span class="cov0" title="0">return xml.Marshal(value)</span>
}

func Hex(value []byte) string <span class="cov0" title="0">{
        return hex.EncodeToString(value)
}</span>

func HexSha256(value []byte) string <span class="cov0" title="0">{
        return Hex(Sha256Hash(value))
}</span>

func UrlDecode(value string) (string, error) <span class="cov0" title="0">{
        ret, err := url.QueryUnescape(value)
        if err == nil </span><span class="cov0" title="0">{
                return ret, nil
        }</span>
        <span class="cov0" title="0">return "", err</span>
}

func IsIP(value string) bool <span class="cov0" title="0">{
        return ipRegex.MatchString(value)
}</span>

func UrlEncode(value string, chineseOnly bool) string <span class="cov0" title="0">{
        if chineseOnly </span><span class="cov0" title="0">{
                values := make([]string, 0, len(value))
                for _, val := range value </span><span class="cov0" title="0">{
                        _value := string(val)
                        if regex.MatchString(_value) </span><span class="cov0" title="0">{
                                _value = url.QueryEscape(_value)
                        }</span>
                        <span class="cov0" title="0">values = append(values, _value)</span>
                }
                <span class="cov0" title="0">return strings.Join(values, "")</span>
        }
        <span class="cov0" title="0">return url.QueryEscape(value)</span>
}

func copyHeaders(m map[string][]string) (ret map[string][]string) <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                ret = make(map[string][]string, len(m))
                for key, values := range m </span><span class="cov0" title="0">{
                        _values := make([]string, 0, len(values))
                        for _, value := range values </span><span class="cov0" title="0">{
                                _values = append(_values, value)
                        }</span>
                        <span class="cov0" title="0">ret[strings.ToLower(key)] = _values</span>
                }
        } else<span class="cov0" title="0"> {
                ret = make(map[string][]string)
        }</span>

        <span class="cov0" title="0">return</span>
}

func parseHeaders(headers map[string][]string) (signature string, region string, signedHeaders string) <span class="cov0" title="0">{
        signature = "v2"
        if receviedAuthorization, ok := headers[strings.ToLower(HEADER_AUTH_CAMEL)]; ok &amp;&amp; len(receviedAuthorization) &gt; 0 </span><span class="cov0" title="0">{
                if strings.HasPrefix(receviedAuthorization[0], V4_HASH_PREFIX) </span><span class="cov0" title="0">{
                        signature = "v4"
                        matches := v4AuthRegex.FindStringSubmatch(receviedAuthorization[0])
                        if len(matches) &gt;= 3 </span><span class="cov0" title="0">{
                                region = matches[1]
                                regions := regionRegex.FindStringSubmatch(region)
                                if len(regions) &gt;= 2 </span><span class="cov0" title="0">{
                                        region = regions[1]
                                }</span>
                                <span class="cov0" title="0">signedHeaders = matches[2]</span>
                        }

                } else<span class="cov0" title="0"> if strings.HasPrefix(receviedAuthorization[0], V2_HASH_PREFIX) </span><span class="cov0" title="0">{
                        signature = "v2"
                }</span>
        }
        <span class="cov0" title="0">return</span>
}

func getTemporaryKeys() []string <span class="cov0" title="0">{
        return []string{
                "Signature",
                "signature",
                "X-Amz-Signature",
                "x-amz-signature",
        }
}</span>

func GetAuthorization(ak, sk, method, bucketName, objectKey, queryUrl string, headers map[string][]string) (ret map[string]string) <span class="cov0" title="0">{

        if strings.HasPrefix(queryUrl, "?") </span><span class="cov0" title="0">{
                queryUrl = queryUrl[1:]
        }</span>

        <span class="cov0" title="0">method = strings.ToUpper(method)

        querys := strings.Split(queryUrl, "&amp;")

        params := make(map[string]string)

        for _, value := range querys </span><span class="cov0" title="0">{
                kv := strings.Split(value, "=")
                length := len(kv)
                if length == 1 </span><span class="cov0" title="0">{
                        key, _ := UrlDecode(kv[0])
                        params[key] = ""
                }</span> else<span class="cov0" title="0"> if length &gt;= 2 </span><span class="cov0" title="0">{
                        key, _ := UrlDecode(kv[0])
                        vals := make([]string, 0, length-1)
                        for i := 1; i &lt; length; i++ </span><span class="cov0" title="0">{
                                val, _ := UrlDecode(kv[i])
                                vals = append(vals, val)
                        }</span>
                        <span class="cov0" title="0">params[key] = strings.Join(vals, "=")</span>
                }
        }

        <span class="cov0" title="0">isTemporary := false
        signature := "v2"
        temporaryKeys := getTemporaryKeys()
        for _, key := range temporaryKeys </span><span class="cov0" title="0">{
                if _, ok := params[key]; ok </span><span class="cov0" title="0">{
                        isTemporary = true
                        if strings.ToLower(key) == "signature" </span><span class="cov0" title="0">{
                                signature = "v2"
                        }</span> else<span class="cov0" title="0"> if strings.ToLower(key) == "x-amz-signature" </span><span class="cov0" title="0">{
                                signature = "v4"
                        }</span>
                        <span class="cov0" title="0">break</span>
                }
        }
        <span class="cov0" title="0">headers = copyHeaders(headers)
        pathStyle := false
        if receviedHost, ok := headers[HEADER_HOST]; ok &amp;&amp; len(receviedHost) &gt; 0 &amp;&amp; !strings.HasPrefix(receviedHost[0], bucketName+".") </span><span class="cov0" title="0">{
                pathStyle = true
        }</span>
        <span class="cov0" title="0">conf := &amp;config{securityProvider: &amp;securityProvider{ak: ak, sk: sk},
                urlHolder: &amp;urlHolder{scheme: "https", host: "dummy", port: 443},
                pathStyle: pathStyle}

        if isTemporary </span><span class="cov0" title="0">{
                return getTemporaryAuthorization(ak, sk, method, bucketName, objectKey, signature, conf, params, headers)
        }</span> else<span class="cov0" title="0"> {
                signature, region, signedHeaders := parseHeaders(headers)
                if signature == "v4" </span><span class="cov0" title="0">{
                        conf.signature = SignatureV4
                        requestUrl, canonicalizedUrl := conf.formatUrls(bucketName, objectKey, params, false)
                        parsedRequestUrl, _ := url.Parse(requestUrl)
                        headerKeys := strings.Split(signedHeaders, ";")
                        _headers := make(map[string][]string, len(headerKeys))
                        for _, headerKey := range headerKeys </span><span class="cov0" title="0">{
                                _headers[headerKey] = headers[headerKey]
                        }</span>
                        <span class="cov0" title="0">ret = v4Auth(ak, sk, region, method, canonicalizedUrl, parsedRequestUrl.RawQuery, _headers)
                        ret[HEADER_AUTH_CAMEL] = fmt.Sprintf("%s Credential=%s,SignedHeaders=%s,Signature=%s", V4_HASH_PREFIX, ret["Credential"], ret["SignedHeaders"], ret["Signature"])</span>
                } else<span class="cov0" title="0"> if signature == "v2" </span><span class="cov0" title="0">{
                        conf.signature = SignatureV2
                        _, canonicalizedUrl := conf.formatUrls(bucketName, objectKey, params, false)
                        ret = v2Auth(ak, sk, method, canonicalizedUrl, headers)
                        ret[HEADER_AUTH_CAMEL] = fmt.Sprintf("%s %s:%s", V2_HASH_PREFIX, ak, ret["Signature"])
                }</span>
                <span class="cov0" title="0">return</span>
        }

}

func getTemporaryAuthorization(ak, sk, method, bucketName, objectKey, signature string, conf *config, params map[string]string,
        headers map[string][]string) (ret map[string]string) <span class="cov0" title="0">{

        if signature == "v4" </span><span class="cov0" title="0">{
                conf.signature = SignatureV4

                longDate, ok := params[PARAM_DATE_AMZ_CAMEL]
                if !ok </span><span class="cov0" title="0">{
                        longDate = params[HEADER_DATE_AMZ]
                }</span>
                <span class="cov0" title="0">shortDate := longDate[:8]

                credential, ok := params[PARAM_CREDENTIAL_AMZ_CAMEL]
                if !ok </span><span class="cov0" title="0">{
                        credential = params[strings.ToLower(PARAM_CREDENTIAL_AMZ_CAMEL)]
                }</span>

                <span class="cov0" title="0">_credential, _ := UrlDecode(credential)

                regions := regionRegex.FindStringSubmatch(_credential)
                var region string
                if len(regions) &gt;= 2 </span><span class="cov0" title="0">{
                        region = regions[1]
                }</span>

                <span class="cov0" title="0">_, scope := getCredential(ak, region, shortDate)

                expires, ok := params[PARAM_EXPIRES_AMZ_CAMEL]
                if !ok </span><span class="cov0" title="0">{
                        expires = params[strings.ToLower(PARAM_EXPIRES_AMZ_CAMEL)]
                }</span>

                <span class="cov0" title="0">signedHeaders, ok := params[PARAM_SIGNEDHEADERS_AMZ_CAMEL]
                if !ok </span><span class="cov0" title="0">{
                        signedHeaders = params[strings.ToLower(PARAM_SIGNEDHEADERS_AMZ_CAMEL)]
                }</span>

                <span class="cov0" title="0">algorithm, ok := params[PARAM_ALGORITHM_AMZ_CAMEL]
                if !ok </span><span class="cov0" title="0">{
                        algorithm = params[strings.ToLower(PARAM_ALGORITHM_AMZ_CAMEL)]
                }</span>

                <span class="cov0" title="0">if _, ok := params[PARAM_SIGNATURE_AMZ_CAMEL]; ok </span><span class="cov0" title="0">{
                        delete(params, PARAM_SIGNATURE_AMZ_CAMEL)
                }</span> else<span class="cov0" title="0"> if _, ok := params[strings.ToLower(PARAM_SIGNATURE_AMZ_CAMEL)]; ok </span><span class="cov0" title="0">{
                        delete(params, strings.ToLower(PARAM_SIGNATURE_AMZ_CAMEL))
                }</span>

                <span class="cov0" title="0">ret = make(map[string]string, 6)
                ret[PARAM_ALGORITHM_AMZ_CAMEL] = algorithm
                ret[PARAM_CREDENTIAL_AMZ_CAMEL] = credential
                ret[PARAM_DATE_AMZ_CAMEL] = longDate
                ret[PARAM_EXPIRES_AMZ_CAMEL] = expires
                ret[PARAM_SIGNEDHEADERS_AMZ_CAMEL] = signedHeaders

                requestUrl, canonicalizedUrl := conf.formatUrls(bucketName, objectKey, params, false)
                parsedRequestUrl, _ := url.Parse(requestUrl)
                stringToSign := getV4StringToSign(method, canonicalizedUrl, parsedRequestUrl.RawQuery, scope, longDate, UNSIGNED_PAYLOAD, strings.Split(signedHeaders, ";"), headers)
                ret[PARAM_SIGNATURE_AMZ_CAMEL] = UrlEncode(getSignature(stringToSign, sk, region, shortDate), false)</span>
        } else<span class="cov0" title="0"> if signature == "v2" </span><span class="cov0" title="0">{
                conf.signature = SignatureV2
                _, canonicalizedUrl := conf.formatUrls(bucketName, objectKey, params, false)
                expires, ok := params["Expires"]
                if !ok </span><span class="cov0" title="0">{
                        expires = params["expires"]
                }</span>
                <span class="cov0" title="0">headers[HEADER_DATE_CAMEL] = []string{expires}
                stringToSign := getV2StringToSign(method, canonicalizedUrl, headers)
                ret = make(map[string]string, 3)
                ret["Signature"] = UrlEncode(Base64Encode(HmacSha1([]byte(sk), []byte(stringToSign))), false)
                ret["AWSAccessKeyId"] = UrlEncode(ak, false)
                ret["Expires"] = UrlEncode(expires, false)</span>
        }

        <span class="cov0" title="0">return</span>
}
</pre>
		
		<pre class="file" id="file61" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package utils

import (
        "encoding/json"
        "errors"
        "math/rand"
        "os"
        "reflect"

        log "github.com/sirupsen/logrus"
)

//remove redundant elements
func RvRepElement(arr []string) []string <span class="cov0" title="0">{
        result := []string{}
        for i := 0; i &lt; len(arr); i++ </span><span class="cov0" title="0">{
                flag := true
                for j := range result </span><span class="cov0" title="0">{
                        if arr[i] == result[j] </span><span class="cov0" title="0">{
                                flag = false
                                break</span>
                        }
                }
                <span class="cov0" title="0">if flag == true </span><span class="cov0" title="0">{
                        result = append(result, arr[i])
                }</span>
        }
        <span class="cov0" title="0">return result</span>
}

func Contained(obj, target interface{}) bool <span class="cov8" title="1">{
        targetValue := reflect.ValueOf(target)
        switch reflect.TypeOf(target).Kind() </span>{
        case reflect.Slice, reflect.Array:<span class="cov8" title="1">
                for i := 0; i &lt; targetValue.Len(); i++ </span><span class="cov8" title="1">{
                        if targetValue.Index(i).Interface() == obj </span><span class="cov8" title="1">{
                                return true
                        }</span>
                }
        case reflect.Map:<span class="cov0" title="0">
                if targetValue.MapIndex(reflect.ValueOf(obj)).IsValid() </span><span class="cov0" title="0">{
                        return true
                }</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
        <span class="cov8" title="1">return false</span>
}

func MergeGeneralMaps(maps ...map[string]interface{}) map[string]interface{} <span class="cov0" title="0">{
        var out = make(map[string]interface{})
        for _, m := range maps </span><span class="cov0" title="0">{
                for k, v := range m </span><span class="cov0" title="0">{
                        out[k] = v
                }</span>
        }
        <span class="cov0" title="0">return out</span>
}

func MergeStringMaps(maps ...map[string]string) map[string]string <span class="cov0" title="0">{
        var out = make(map[string]string)
        for _, m := range maps </span><span class="cov0" title="0">{
                for k, v := range m </span><span class="cov0" title="0">{
                        out[k] = v
                }</span>
        }
        <span class="cov0" title="0">return out</span>
}

func PathExists(path string) (bool, error) <span class="cov0" title="0">{
        _, err := os.Stat(path)
        if err == nil </span><span class="cov0" title="0">{
                return true, nil
        }</span>
        <span class="cov0" title="0">if os.IsNotExist(err) </span><span class="cov0" title="0">{
                return false, nil
        }</span>
        <span class="cov0" title="0">return false, err</span>
}

func Retry(retryNum int, desc string, silent bool, fn func(retryIdx int, lastErr error) error) error <span class="cov0" title="0">{
        var err error
        for i := 0; i &lt; retryNum; i++ </span><span class="cov0" title="0">{
                if err = fn(i, err); err != nil </span><span class="cov0" title="0">{
                        if !silent </span><span class="cov0" title="0">{
                                log.Errorf("%s:%s, retry %d time(s)", desc, err, i+1)
                        }</span>
                } else<span class="cov0" title="0"> {
                        return nil
                }</span>
        }
        <span class="cov0" title="0">if !silent </span><span class="cov0" title="0">{
                log.Errorf("%s retry exceed the max retry times(%d).", desc, retryNum)
        }</span>
        <span class="cov0" title="0">return err</span>
}

// StructToMap ...
func StructToMap(structObj interface{}) (map[string]interface{}, error) <span class="cov0" title="0">{
        jsonStr, err := json.Marshal(structObj)
        if nil != err </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var result map[string]interface{}
        err = json.Unmarshal(jsonStr, &amp;result)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

// Epsilon ...
const Epsilon float64 = 0.00000001

// IsFloatEqual ...
func IsFloatEqual(a, b float64) bool <span class="cov0" title="0">{
        if (a-b) &lt; Epsilon &amp;&amp; (b-a) &lt; Epsilon </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">return false</span>
}

// IsEqual ...
func IsEqual(key string, value interface{}, reqValue interface{}) (bool, error) <span class="cov0" title="0">{
        switch value.(type) </span>{
        case bool:<span class="cov0" title="0">
                v, ok1 := value.(bool)
                r, ok2 := reqValue.(bool)

                if ok1 &amp;&amp; ok2 </span><span class="cov0" title="0">{
                        if v == r </span><span class="cov0" title="0">{
                                return true, nil
                        }</span>

                        <span class="cov0" title="0">return false, nil</span>
                }

                <span class="cov0" title="0">return false, errors.New("the type of " + key + " must be bool")</span>
        case float64:<span class="cov0" title="0">
                v, ok1 := value.(float64)
                r, ok2 := reqValue.(float64)

                if ok1 &amp;&amp; ok2 </span><span class="cov0" title="0">{
                        if IsFloatEqual(v, r) </span><span class="cov0" title="0">{
                                return true, nil
                        }</span>

                        <span class="cov0" title="0">return false, nil</span>
                }

                <span class="cov0" title="0">return false, errors.New("the type of " + key + " must be float64")</span>
        case string:<span class="cov0" title="0">
                v, ok1 := value.(string)
                r, ok2 := reqValue.(string)
                if ok1 &amp;&amp; ok2 </span><span class="cov0" title="0">{
                        if v == r </span><span class="cov0" title="0">{
                                return true, nil
                        }</span>

                        <span class="cov0" title="0">return false, nil</span>
                }

                <span class="cov0" title="0">return false, errors.New("the type of " + key + " must be string")</span>
        default:<span class="cov0" title="0">
                return false, errors.New("the type of " + key + " must be bool or float64 or string")</span>
        }
}

func RandSeqWithAlnum(n int) string <span class="cov0" title="0">{
        alnum := []rune("1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ")
        return RandSeq(n, alnum)
}</span>

func RandSeq(n int, chs []rune) string <span class="cov0" title="0">{
        b := make([]rune, n)
        for i := range b </span><span class="cov0" title="0">{
                b[i] = chs[rand.Intn(len(chs))]
        }</span>
        <span class="cov0" title="0">return string(b)</span>
}
</pre>
		
		<pre class="file" id="file62" style="display: none">// Code generated by protoc-gen-micro. DO NOT EDIT.
// source: backend.proto

/*
Package backend is a generated protocol buffer package.

It is generated from these files:
        backend.proto

It has these top-level messages:
        CreateBackendRequest
        CreateBackendResponse
        GetBackendRequest
        GetBackendResponse
        ListBackendRequest
        ListBackendResponse
        UpdateBackendRequest
        UpdateBackendResponse
        DeleteBackendRequest
        DeleteBackendResponse
        BackendDetail
        ListTypeRequest
        ListTypeResponse
        TypeDetail
*/
package backend

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
        context "context"

        client "github.com/micro/go-micro/client"
        server "github.com/micro/go-micro/server"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ client.Option
var _ server.Option

// Client API for Backend service

type BackendService interface {
        CreateBackend(ctx context.Context, in *CreateBackendRequest, opts ...client.CallOption) (*CreateBackendResponse, error)
        GetBackend(ctx context.Context, in *GetBackendRequest, opts ...client.CallOption) (*GetBackendResponse, error)
        ListBackend(ctx context.Context, in *ListBackendRequest, opts ...client.CallOption) (*ListBackendResponse, error)
        UpdateBackend(ctx context.Context, in *UpdateBackendRequest, opts ...client.CallOption) (*UpdateBackendResponse, error)
        DeleteBackend(ctx context.Context, in *DeleteBackendRequest, opts ...client.CallOption) (*DeleteBackendResponse, error)
        ListType(ctx context.Context, in *ListTypeRequest, opts ...client.CallOption) (*ListTypeResponse, error)
}

type backendService struct {
        c    client.Client
        name string
}

func NewBackendService(name string, c client.Client) BackendService <span class="cov8" title="1">{
        if c == nil </span><span class="cov0" title="0">{
                c = client.NewClient()
        }</span>
        <span class="cov8" title="1">if len(name) == 0 </span><span class="cov0" title="0">{
                name = "backend"
        }</span>
        <span class="cov8" title="1">return &amp;backendService{
                c:    c,
                name: name,
        }</span>
}

func (c *backendService) CreateBackend(ctx context.Context, in *CreateBackendRequest, opts ...client.CallOption) (*CreateBackendResponse, error) <span class="cov0" title="0">{
        req := c.c.NewRequest(c.name, "Backend.CreateBackend", in)
        out := new(CreateBackendResponse)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *backendService) GetBackend(ctx context.Context, in *GetBackendRequest, opts ...client.CallOption) (*GetBackendResponse, error) <span class="cov0" title="0">{
        req := c.c.NewRequest(c.name, "Backend.GetBackend", in)
        out := new(GetBackendResponse)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *backendService) ListBackend(ctx context.Context, in *ListBackendRequest, opts ...client.CallOption) (*ListBackendResponse, error) <span class="cov8" title="1">{
        req := c.c.NewRequest(c.name, "Backend.ListBackend", in)
        out := new(ListBackendResponse)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (c *backendService) UpdateBackend(ctx context.Context, in *UpdateBackendRequest, opts ...client.CallOption) (*UpdateBackendResponse, error) <span class="cov0" title="0">{
        req := c.c.NewRequest(c.name, "Backend.UpdateBackend", in)
        out := new(UpdateBackendResponse)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *backendService) DeleteBackend(ctx context.Context, in *DeleteBackendRequest, opts ...client.CallOption) (*DeleteBackendResponse, error) <span class="cov0" title="0">{
        req := c.c.NewRequest(c.name, "Backend.DeleteBackend", in)
        out := new(DeleteBackendResponse)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *backendService) ListType(ctx context.Context, in *ListTypeRequest, opts ...client.CallOption) (*ListTypeResponse, error) <span class="cov0" title="0">{
        req := c.c.NewRequest(c.name, "Backend.ListType", in)
        out := new(ListTypeResponse)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// Server API for Backend service

type BackendHandler interface {
        CreateBackend(context.Context, *CreateBackendRequest, *CreateBackendResponse) error
        GetBackend(context.Context, *GetBackendRequest, *GetBackendResponse) error
        ListBackend(context.Context, *ListBackendRequest, *ListBackendResponse) error
        UpdateBackend(context.Context, *UpdateBackendRequest, *UpdateBackendResponse) error
        DeleteBackend(context.Context, *DeleteBackendRequest, *DeleteBackendResponse) error
        ListType(context.Context, *ListTypeRequest, *ListTypeResponse) error
}

func RegisterBackendHandler(s server.Server, hdlr BackendHandler, opts ...server.HandlerOption) error <span class="cov0" title="0">{
        type backend interface {
                CreateBackend(ctx context.Context, in *CreateBackendRequest, out *CreateBackendResponse) error
                GetBackend(ctx context.Context, in *GetBackendRequest, out *GetBackendResponse) error
                ListBackend(ctx context.Context, in *ListBackendRequest, out *ListBackendResponse) error
                UpdateBackend(ctx context.Context, in *UpdateBackendRequest, out *UpdateBackendResponse) error
                DeleteBackend(ctx context.Context, in *DeleteBackendRequest, out *DeleteBackendResponse) error
                ListType(ctx context.Context, in *ListTypeRequest, out *ListTypeResponse) error
        }
        type Backend struct {
                backend
        }
        h := &amp;backendHandler{hdlr}
        return s.Handle(s.NewHandler(&amp;Backend{h}, opts...))
}</span>

type backendHandler struct {
        BackendHandler
}

func (h *backendHandler) CreateBackend(ctx context.Context, in *CreateBackendRequest, out *CreateBackendResponse) error <span class="cov0" title="0">{
        return h.BackendHandler.CreateBackend(ctx, in, out)
}</span>

func (h *backendHandler) GetBackend(ctx context.Context, in *GetBackendRequest, out *GetBackendResponse) error <span class="cov0" title="0">{
        return h.BackendHandler.GetBackend(ctx, in, out)
}</span>

func (h *backendHandler) ListBackend(ctx context.Context, in *ListBackendRequest, out *ListBackendResponse) error <span class="cov0" title="0">{
        return h.BackendHandler.ListBackend(ctx, in, out)
}</span>

func (h *backendHandler) UpdateBackend(ctx context.Context, in *UpdateBackendRequest, out *UpdateBackendResponse) error <span class="cov0" title="0">{
        return h.BackendHandler.UpdateBackend(ctx, in, out)
}</span>

func (h *backendHandler) DeleteBackend(ctx context.Context, in *DeleteBackendRequest, out *DeleteBackendResponse) error <span class="cov0" title="0">{
        return h.BackendHandler.DeleteBackend(ctx, in, out)
}</span>

func (h *backendHandler) ListType(ctx context.Context, in *ListTypeRequest, out *ListTypeResponse) error <span class="cov0" title="0">{
        return h.BackendHandler.ListType(ctx, in, out)
}</span>
</pre>
		
		<pre class="file" id="file63" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// source: backend.proto

/*
Package backend is a generated protocol buffer package.

It is generated from these files:
        backend.proto

It has these top-level messages:
        CreateBackendRequest
        CreateBackendResponse
        GetBackendRequest
        GetBackendResponse
        ListBackendRequest
        ListBackendResponse
        UpdateBackendRequest
        UpdateBackendResponse
        DeleteBackendRequest
        DeleteBackendResponse
        BackendDetail
        ListTypeRequest
        ListTypeResponse
        TypeDetail
*/
package backend

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type CreateBackendRequest struct {
        Backend *BackendDetail `protobuf:"bytes,1,opt,name=backend" json:"backend,omitempty"`
}

func (m *CreateBackendRequest) Reset()                    <span class="cov0" title="0">{ *m = CreateBackendRequest{} }</span>
func (m *CreateBackendRequest) String() string            <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*CreateBackendRequest) ProtoMessage()               {<span class="cov0" title="0">}</span>
func (*CreateBackendRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{ return fileDescriptor0, []int{0} }</span>

func (m *CreateBackendRequest) GetBackend() *BackendDetail <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Backend
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type CreateBackendResponse struct {
        Backend *BackendDetail `protobuf:"bytes,1,opt,name=backend" json:"backend,omitempty"`
}

func (m *CreateBackendResponse) Reset()                    <span class="cov0" title="0">{ *m = CreateBackendResponse{} }</span>
func (m *CreateBackendResponse) String() string            <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*CreateBackendResponse) ProtoMessage()               {<span class="cov0" title="0">}</span>
func (*CreateBackendResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{ return fileDescriptor0, []int{1} }</span>

func (m *CreateBackendResponse) GetBackend() *BackendDetail <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Backend
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type GetBackendRequest struct {
        Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
}

func (m *GetBackendRequest) Reset()                    <span class="cov0" title="0">{ *m = GetBackendRequest{} }</span>
func (m *GetBackendRequest) String() string            <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*GetBackendRequest) ProtoMessage()               {<span class="cov0" title="0">}</span>
func (*GetBackendRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{ return fileDescriptor0, []int{2} }</span>

func (m *GetBackendRequest) GetId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type GetBackendResponse struct {
        Backend *BackendDetail `protobuf:"bytes,1,opt,name=backend" json:"backend,omitempty"`
}

func (m *GetBackendResponse) Reset()                    <span class="cov0" title="0">{ *m = GetBackendResponse{} }</span>
func (m *GetBackendResponse) String() string            <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*GetBackendResponse) ProtoMessage()               {<span class="cov0" title="0">}</span>
func (*GetBackendResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{ return fileDescriptor0, []int{3} }</span>

func (m *GetBackendResponse) GetBackend() *BackendDetail <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Backend
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type ListBackendRequest struct {
        Limit    int32             `protobuf:"varint,1,opt,name=limit" json:"limit,omitempty"`
        Offset   int32             `protobuf:"varint,2,opt,name=offset" json:"offset,omitempty"`
        SortKeys []string          `protobuf:"bytes,3,rep,name=sortKeys" json:"sortKeys,omitempty"`
        SortDirs []string          `protobuf:"bytes,4,rep,name=sortDirs" json:"sortDirs,omitempty"`
        Filter   map[string]string `protobuf:"bytes,5,rep,name=Filter" json:"Filter,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *ListBackendRequest) Reset()                    <span class="cov0" title="0">{ *m = ListBackendRequest{} }</span>
func (m *ListBackendRequest) String() string            <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*ListBackendRequest) ProtoMessage()               {<span class="cov0" title="0">}</span>
func (*ListBackendRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{ return fileDescriptor0, []int{4} }</span>

func (m *ListBackendRequest) GetLimit() int32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Limit
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *ListBackendRequest) GetOffset() int32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Offset
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *ListBackendRequest) GetSortKeys() []string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.SortKeys
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *ListBackendRequest) GetSortDirs() []string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.SortDirs
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *ListBackendRequest) GetFilter() map[string]string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Filter
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type ListBackendResponse struct {
        Backends []*BackendDetail `protobuf:"bytes,1,rep,name=backends" json:"backends,omitempty"`
        Next     int32            `protobuf:"varint,2,opt,name=next" json:"next,omitempty"`
}

func (m *ListBackendResponse) Reset()                    <span class="cov8" title="1">{ *m = ListBackendResponse{} }</span>
func (m *ListBackendResponse) String() string            <span class="cov8" title="1">{ return proto.CompactTextString(m) }</span>
func (*ListBackendResponse) ProtoMessage()               {<span class="cov0" title="0">}</span>
func (*ListBackendResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{ return fileDescriptor0, []int{5} }</span>

func (m *ListBackendResponse) GetBackends() []*BackendDetail <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Backends
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *ListBackendResponse) GetNext() int32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Next
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type UpdateBackendRequest struct {
        Id       string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
        Access   string `protobuf:"bytes,2,opt,name=access" json:"access,omitempty"`
        Security string `protobuf:"bytes,3,opt,name=security" json:"security,omitempty"`
}

func (m *UpdateBackendRequest) Reset()                    <span class="cov0" title="0">{ *m = UpdateBackendRequest{} }</span>
func (m *UpdateBackendRequest) String() string            <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*UpdateBackendRequest) ProtoMessage()               {<span class="cov0" title="0">}</span>
func (*UpdateBackendRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{ return fileDescriptor0, []int{6} }</span>

func (m *UpdateBackendRequest) GetId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *UpdateBackendRequest) GetAccess() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Access
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *UpdateBackendRequest) GetSecurity() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Security
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type UpdateBackendResponse struct {
        Backend *BackendDetail `protobuf:"bytes,1,opt,name=backend" json:"backend,omitempty"`
}

func (m *UpdateBackendResponse) Reset()                    <span class="cov0" title="0">{ *m = UpdateBackendResponse{} }</span>
func (m *UpdateBackendResponse) String() string            <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*UpdateBackendResponse) ProtoMessage()               {<span class="cov0" title="0">}</span>
func (*UpdateBackendResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{ return fileDescriptor0, []int{7} }</span>

func (m *UpdateBackendResponse) GetBackend() *BackendDetail <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Backend
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type DeleteBackendRequest struct {
        Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
}

func (m *DeleteBackendRequest) Reset()                    <span class="cov0" title="0">{ *m = DeleteBackendRequest{} }</span>
func (m *DeleteBackendRequest) String() string            <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*DeleteBackendRequest) ProtoMessage()               {<span class="cov0" title="0">}</span>
func (*DeleteBackendRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{ return fileDescriptor0, []int{8} }</span>

func (m *DeleteBackendRequest) GetId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type DeleteBackendResponse struct {
}

func (m *DeleteBackendResponse) Reset()                    <span class="cov0" title="0">{ *m = DeleteBackendResponse{} }</span>
func (m *DeleteBackendResponse) String() string            <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*DeleteBackendResponse) ProtoMessage()               {<span class="cov0" title="0">}</span>
func (*DeleteBackendResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{ return fileDescriptor0, []int{9} }</span>

type BackendDetail struct {
        Id         string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
        TenantId   string `protobuf:"bytes,2,opt,name=tenantId" json:"tenantId,omitempty"`
        UserId     string `protobuf:"bytes,3,opt,name=userId" json:"userId,omitempty"`
        Name       string `protobuf:"bytes,4,opt,name=name" json:"name,omitempty"`
        Type       string `protobuf:"bytes,5,opt,name=type" json:"type,omitempty"`
        Region     string `protobuf:"bytes,6,opt,name=region" json:"region,omitempty"`
        Endpoint   string `protobuf:"bytes,7,opt,name=endpoint" json:"endpoint,omitempty"`
        BucketName string `protobuf:"bytes,8,opt,name=bucketName" json:"bucketName,omitempty"`
        Access     string `protobuf:"bytes,9,opt,name=access" json:"access,omitempty"`
        Security   string `protobuf:"bytes,10,opt,name=security" json:"security,omitempty"`
}

func (m *BackendDetail) Reset()                    <span class="cov0" title="0">{ *m = BackendDetail{} }</span>
func (m *BackendDetail) String() string            <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*BackendDetail) ProtoMessage()               {<span class="cov0" title="0">}</span>
func (*BackendDetail) Descriptor() ([]byte, []int) <span class="cov0" title="0">{ return fileDescriptor0, []int{10} }</span>

func (m *BackendDetail) GetId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *BackendDetail) GetTenantId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.TenantId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *BackendDetail) GetUserId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.UserId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *BackendDetail) GetName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *BackendDetail) GetType() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Type
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *BackendDetail) GetRegion() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Region
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *BackendDetail) GetEndpoint() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Endpoint
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *BackendDetail) GetBucketName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.BucketName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *BackendDetail) GetAccess() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Access
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *BackendDetail) GetSecurity() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Security
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type ListTypeRequest struct {
        Limit    int32             `protobuf:"varint,1,opt,name=limit" json:"limit,omitempty"`
        Offset   int32             `protobuf:"varint,2,opt,name=offset" json:"offset,omitempty"`
        SortKeys []string          `protobuf:"bytes,3,rep,name=sortKeys" json:"sortKeys,omitempty"`
        SortDirs []string          `protobuf:"bytes,4,rep,name=sortDirs" json:"sortDirs,omitempty"`
        Filter   map[string]string `protobuf:"bytes,5,rep,name=Filter" json:"Filter,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *ListTypeRequest) Reset()                    <span class="cov0" title="0">{ *m = ListTypeRequest{} }</span>
func (m *ListTypeRequest) String() string            <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*ListTypeRequest) ProtoMessage()               {<span class="cov0" title="0">}</span>
func (*ListTypeRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{ return fileDescriptor0, []int{11} }</span>

func (m *ListTypeRequest) GetLimit() int32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Limit
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *ListTypeRequest) GetOffset() int32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Offset
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *ListTypeRequest) GetSortKeys() []string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.SortKeys
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *ListTypeRequest) GetSortDirs() []string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.SortDirs
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *ListTypeRequest) GetFilter() map[string]string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Filter
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type ListTypeResponse struct {
        Types []*TypeDetail `protobuf:"bytes,1,rep,name=types" json:"types,omitempty"`
        Next  int32         `protobuf:"varint,2,opt,name=next" json:"next,omitempty"`
}

func (m *ListTypeResponse) Reset()                    <span class="cov0" title="0">{ *m = ListTypeResponse{} }</span>
func (m *ListTypeResponse) String() string            <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*ListTypeResponse) ProtoMessage()               {<span class="cov0" title="0">}</span>
func (*ListTypeResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{ return fileDescriptor0, []int{12} }</span>

func (m *ListTypeResponse) GetTypes() []*TypeDetail <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Types
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *ListTypeResponse) GetNext() int32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Next
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type TypeDetail struct {
        Name        string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
        Description string `protobuf:"bytes,2,opt,name=description" json:"description,omitempty"`
}

func (m *TypeDetail) Reset()                    <span class="cov0" title="0">{ *m = TypeDetail{} }</span>
func (m *TypeDetail) String() string            <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*TypeDetail) ProtoMessage()               {<span class="cov0" title="0">}</span>
func (*TypeDetail) Descriptor() ([]byte, []int) <span class="cov0" title="0">{ return fileDescriptor0, []int{13} }</span>

func (m *TypeDetail) GetName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *TypeDetail) GetDescription() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Description
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func init() <span class="cov8" title="1">{
        proto.RegisterType((*CreateBackendRequest)(nil), "CreateBackendRequest")
        proto.RegisterType((*CreateBackendResponse)(nil), "CreateBackendResponse")
        proto.RegisterType((*GetBackendRequest)(nil), "GetBackendRequest")
        proto.RegisterType((*GetBackendResponse)(nil), "GetBackendResponse")
        proto.RegisterType((*ListBackendRequest)(nil), "ListBackendRequest")
        proto.RegisterType((*ListBackendResponse)(nil), "ListBackendResponse")
        proto.RegisterType((*UpdateBackendRequest)(nil), "UpdateBackendRequest")
        proto.RegisterType((*UpdateBackendResponse)(nil), "UpdateBackendResponse")
        proto.RegisterType((*DeleteBackendRequest)(nil), "DeleteBackendRequest")
        proto.RegisterType((*DeleteBackendResponse)(nil), "DeleteBackendResponse")
        proto.RegisterType((*BackendDetail)(nil), "BackendDetail")
        proto.RegisterType((*ListTypeRequest)(nil), "ListTypeRequest")
        proto.RegisterType((*ListTypeResponse)(nil), "ListTypeResponse")
        proto.RegisterType((*TypeDetail)(nil), "TypeDetail")
}</span>

func init() <span class="cov8" title="1">{ proto.RegisterFile("backend.proto", fileDescriptor0) }</span>

var fileDescriptor0 = []byte{
        // 630 bytes of a gzipped FileDescriptorProto
        0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x55, 0x4d, 0x6f, 0xd3, 0x40,
        0x10, 0x8d, 0x93, 0x26, 0x4d, 0xc6, 0x6a, 0x69, 0xb7, 0x49, 0xb0, 0x2c, 0x04, 0xc1, 0x48, 0x28,
        0xe2, 0xb0, 0x12, 0x05, 0xa9, 0xd0, 0x03, 0x2a, 0xa5, 0x80, 0x2a, 0x10, 0x07, 0x8b, 0x5e, 0xb8,
        0xb9, 0xf6, 0x14, 0xad, 0x9a, 0xda, 0xc6, 0xbb, 0x41, 0xf8, 0xcc, 0x9f, 0xe5, 0xc4, 0x95, 0x2b,
        0xda, 0x0f, 0x27, 0xce, 0xc6, 0x08, 0x45, 0x42, 0xdc, 0xfc, 0x66, 0x66, 0x77, 0x66, 0xe7, 0xcd,
        0x3c, 0xc3, 0xce, 0x65, 0x14, 0x5f, 0x63, 0x9a, 0xd0, 0xbc, 0xc8, 0x44, 0x16, 0x9c, 0xc0, 0xf0,
        0x55, 0x81, 0x91, 0xc0, 0x53, 0x6d, 0x0e, 0xf1, 0xcb, 0x1c, 0xb9, 0x20, 0x53, 0xd8, 0x36, 0x81,
        0x9e, 0x33, 0x71, 0xa6, 0xee, 0xe1, 0x2e, 0x35, 0x11, 0x67, 0x28, 0x22, 0x36, 0x0b, 0x2b, 0x77,
        0xf0, 0x12, 0x46, 0xd6, 0x0d, 0x3c, 0xcf, 0x52, 0x8e, 0x1b, 0x5c, 0xf1, 0x00, 0xf6, 0xdf, 0xa2,
        0xb0, 0x2a, 0xd8, 0x85, 0x36, 0xd3, 0x27, 0x07, 0x61, 0x9b, 0x25, 0xc1, 0x0b, 0x20, 0xf5, 0xa0,
        0x8d, 0x93, 0xfc, 0x74, 0x80, 0xbc, 0x67, 0xdc, 0x4e, 0x33, 0x84, 0xee, 0x8c, 0xdd, 0x30, 0xa1,
        0x8e, 0x77, 0x43, 0x0d, 0xc8, 0x18, 0x7a, 0xd9, 0xd5, 0x15, 0x47, 0xe1, 0xb5, 0x95, 0xd9, 0x20,
        0xe2, 0x43, 0x9f, 0x67, 0x85, 0x78, 0x87, 0x25, 0xf7, 0x3a, 0x93, 0xce, 0x74, 0x10, 0x2e, 0x70,
        0xe5, 0x3b, 0x63, 0x05, 0xf7, 0xb6, 0x96, 0x3e, 0x89, 0xc9, 0x11, 0xf4, 0xde, 0xb0, 0x99, 0xc0,
        0xc2, 0xeb, 0x4e, 0x3a, 0x53, 0xf7, 0xf0, 0x1e, 0x5d, 0x2f, 0x85, 0xea, 0x88, 0xd7, 0xa9, 0x28,
        0xca, 0xd0, 0x84, 0xfb, 0xcf, 0xc1, 0xad, 0x99, 0xc9, 0x1e, 0x74, 0xae, 0xb1, 0x34, 0x5d, 0x91,
        0x9f, 0xb2, 0xfe, 0xaf, 0xd1, 0x6c, 0x8e, 0xaa, 0xd0, 0x41, 0xa8, 0xc1, 0x71, 0xfb, 0x99, 0x13,
        0x5c, 0xc0, 0xc1, 0x4a, 0x12, 0xd3, 0xb1, 0x47, 0xd0, 0x37, 0x2d, 0xe1, 0x9e, 0xa3, 0x8a, 0xb1,
        0x5b, 0xb6, 0xf0, 0x13, 0x02, 0x5b, 0x29, 0x7e, 0xab, 0x9a, 0xa0, 0xbe, 0x83, 0x4f, 0x30, 0xbc,
        0xc8, 0x93, 0xf5, 0x89, 0xb1, 0xf8, 0x92, 0x2d, 0x8c, 0xe2, 0x18, 0x39, 0x37, 0x95, 0x19, 0xa4,
        0xda, 0x84, 0xf1, 0xbc, 0x60, 0xa2, 0xf4, 0x3a, 0xca, 0xb3, 0xc0, 0x72, 0x96, 0xac, 0xbb, 0x37,
        0xa6, 0xf9, 0x21, 0x0c, 0xcf, 0x70, 0x86, 0x7f, 0x2b, 0x2f, 0xb8, 0x0d, 0x23, 0x2b, 0x4e, 0xa7,
        0x0a, 0xbe, 0xb7, 0x61, 0x67, 0xe5, 0xee, 0xb5, 0x97, 0xf9, 0xd0, 0x17, 0x98, 0x46, 0xa9, 0x38,
        0x4f, 0xcc, 0xdb, 0x16, 0x58, 0xbe, 0x7a, 0xce, 0xb1, 0x38, 0x4f, 0xcc, 0xdb, 0x0c, 0x52, 0x9d,
        0x8c, 0x6e, 0xd0, 0xdb, 0x52, 0x56, 0xf5, 0x2d, 0x6d, 0xa2, 0xcc, 0xd1, 0xeb, 0x6a, 0x9b, 0xfc,
        0x96, 0xe7, 0x0b, 0xfc, 0xcc, 0xb2, 0xd4, 0xeb, 0xe9, 0xf3, 0x1a, 0xc9, 0x9c, 0x98, 0x26, 0x79,
        0xc6, 0x52, 0xe1, 0x6d, 0xeb, 0x9c, 0x15, 0x26, 0x77, 0x01, 0x2e, 0xe7, 0xf1, 0x35, 0x8a, 0x0f,
        0x32, 0x43, 0x5f, 0x79, 0x6b, 0x96, 0x1a, 0x13, 0x83, 0x3f, 0x32, 0x01, 0x16, 0x13, 0x3f, 0x1c,
        0xb8, 0x25, 0xa7, 0xe7, 0x63, 0x99, 0xe3, 0xff, 0x5d, 0x95, 0xa7, 0xd6, 0xaa, 0xdc, 0xa1, 0x56,
        0x1d, 0xff, 0x7a, 0x4f, 0xce, 0x61, 0x6f, 0x99, 0xc1, 0xcc, 0xdb, 0x7d, 0xe8, 0x4a, 0x3a, 0xaa,
        0x0d, 0x71, 0xa9, 0xf4, 0x9a, 0x51, 0xd3, 0x9e, 0xc6, 0xdd, 0x38, 0x05, 0x58, 0x06, 0x2e, 0x38,
        0x77, 0x6a, 0x9c, 0x4f, 0xc0, 0x4d, 0x90, 0xc7, 0x05, 0xcb, 0x85, 0x24, 0x59, 0x17, 0x53, 0x37,
        0x1d, 0xfe, 0x6a, 0xc3, 0xb6, 0x99, 0x3f, 0x72, 0x02, 0x3b, 0x2b, 0xda, 0x4a, 0x46, 0xb4, 0x49,
        0xad, 0xfd, 0x31, 0x6d, 0x94, 0xe0, 0xa0, 0x45, 0x8e, 0x00, 0x96, 0xaa, 0x49, 0x08, 0x5d, 0xd3,
        0x59, 0xff, 0x80, 0xae, 0xcb, 0x6a, 0xd0, 0x22, 0xc7, 0xe0, 0xd6, 0xd4, 0x83, 0x1c, 0x34, 0x08,
        0x96, 0x3f, 0xa4, 0x0d, 0x02, 0x13, 0xb4, 0x64, 0xd9, 0x2b, 0x6b, 0x4c, 0x46, 0xb4, 0x49, 0x32,
        0xfc, 0x31, 0x6d, 0xdc, 0x76, 0x7d, 0xc3, 0xca, 0x76, 0x92, 0x11, 0x6d, 0xda, 0x6a, 0x7f, 0x4c,
        0x9b, 0x97, 0xb8, 0x45, 0x1e, 0x43, 0xbf, 0x62, 0x95, 0xec, 0xd9, 0x23, 0xe4, 0xef, 0x53, 0x9b,
        0xf2, 0xa0, 0x75, 0xd9, 0x53, 0xbf, 0xc4, 0x27, 0xbf, 0x03, 0x00, 0x00, 0xff, 0xff, 0x50, 0xb6,
        0xe0, 0x3d, 0x23, 0x07, 0x00, 0x00,
}
</pre>
		
		<pre class="file" id="file64" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package main

import (
        "fmt"

        "github.com/micro/go-micro"
        "github.com/soda/multi-cloud/api/pkg/utils/obs"
        _ "github.com/soda/multi-cloud/s3/pkg/datastore"
        "github.com/soda/multi-cloud/s3/pkg/datastore/driver"
        "github.com/soda/multi-cloud/s3/pkg/datastore/yig/config"
        gc "github.com/soda/multi-cloud/s3/pkg/gc"
        "github.com/soda/multi-cloud/s3/pkg/helper"
        "github.com/soda/multi-cloud/s3/pkg/meta/redis"
        handler "github.com/soda/multi-cloud/s3/pkg/service"
        pb "github.com/soda/multi-cloud/s3/proto"
        log "github.com/sirupsen/logrus"
        _ "go.uber.org/automaxprocs"
)

func main() <span class="cov8" title="1">{
        service := micro.NewService(
                micro.Name("s3"),
        )

        obs.InitLogs()
        service.Init(micro.AfterStop(func() error </span><span class="cov8" title="1">{
                driver.FreeCloser()
                gc.Stop()
                return nil
        }</span>))

        <span class="cov8" title="1">helper.SetupConfig()

        log.Infof("YIG conf: %+v \n", helper.CONFIG)
        log.Infof("YIG instance ID: %+v \n", helper.CONFIG.InstanceId)

        if helper.CONFIG.MetaCacheType &gt; 0 || helper.CONFIG.EnableDataCache </span><span class="cov0" title="0">{
                cfg := config.CacheConfig{
                        Mode:    helper.CONFIG.RedisMode,
                        Address: helper.CONFIG.RedisAddress,
                }
                redis.Initialize(&amp;cfg)
        }</span>

        <span class="cov8" title="1">pb.RegisterS3Handler(service.Server(), handler.NewS3Service())
        if err := service.Run(); err != nil </span><span class="cov0" title="0">{
                fmt.Println(err)
        }</span>
}
</pre>
		
		<pre class="file" id="file65" style="display: none">/*
 * Minio Cloud Storage, (C) 2015 Minio, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package s3error

import (
        "net/http"
)

type S3Error interface {
        error
        AwsErrorCode() string
        Description() string
        HttpStatusCode() int
}

type S3ErrorStruct struct {
        AwsErrorCode   string
        Description    string
        HttpStatusCode int
}

// APIErrorCode type of error status.
type S3ErrorCode int

// Error codes, non exhaustive list - http://docs.aws.amazon.com/AmazonS3/latest/API/ErrorResponses.html
const (
        ErrNoErr S3ErrorCode = iota
        ErrAccessDenied
        ErrBadDigest
        ErrBucketAlreadyExists
        ErrEmptyEntity
        ErrEntityTooLarge
        ErrIncompleteBody
        ErrInternalError
        ErrInvalidAccessKeyID
        ErrInvalidBucketName
        ErrInvalidObjectName
        ErrInvalidDigest
        ErrInvalidRange
        ErrInvalidEncodingType
        ErrInvalidContinuationToken
        ErrInvalidMaxKeys
        ErrInvalidMaxUploads
        ErrInvalidMaxParts
        ErrInvalidPartNumberMarker
        ErrInvalidRequestBody
        ErrInvalidCopySource
        ErrInvalidCopySourceStorageClass
        ErrInvalidCopyDest
        ErrInvalidPrecondition
        ErrInvalidPolicyDocument
        ErrInvalidCorsDocument
        ErrInvalidVersioning
        ErrMalformedXML
        ErrMissingContentLength
        ErrMissingContentMD5
        ErrMissingRequestBodyError
        ErrNoSuchBucket
        ErrNoSuchBucketPolicy
        ErrNoSuchKey
        ErrNoSuchUpload
        ErrNoSuchVersion
        ErrNotImplemented
        ErrPreconditionFailed
        ErrRequestTimeTooSkewed
        ErrSignatureDoesNotMatch
        ErrMethodNotAllowed
        ErrInvalidPart
        ErrInvalidPartOrder
        ErrAuthorizationHeaderMalformed
        ErrMalformedPOSTRequest
        ErrSignatureVersionNotSupported
        ErrBucketNotEmpty
        ErrBucketAccessForbidden
        ErrMalformedPolicy
        ErrMissingFields
        ErrMissingCredTag
        ErrCredMalformed
        ErrInvalidRegion
        ErrInvalidService
        ErrInvalidRequestVersion
        ErrMissingSignTag
        ErrMissingSignHeadersTag
        ErrMissingRequiredSignedHeader
        ErrSignedHeadersNotSorted
        ErrPolicyAlreadyExpired
        ErrPolicyViolation
        ErrMalformedDate
        ErrMalformedExpires
        ErrAuthHeaderEmpty
        ErrExpiredPresignRequest
        ErrMissingDateHeader
        ErrInvalidQuerySignatureAlgo
        ErrInvalidQueryParams
        ErrBucketAlreadyOwnedByYou
        ErrInvalidCannedAcl
        ErrInvalidSseHeader
        ErrTooManyBuckets
        ErrInvalidPosition
        ErrObjectNotAppendable
        ErrPositionNotEqualToLength
        // Add new error codes here.

        // SSE-S3 related API errors
        ErrInvalidEncryptionMethod

        // Server-Side-Encryption (with Customer provided key) related API errors.
        ErrInsecureSSECustomerRequest
        ErrSSEMultipartEncrypted
        ErrSSEEncryptedObject
        ErrInvalidEncryptionParameters
        ErrInvalidSSECustomerAlgorithm
        ErrInvalidSSECustomerKey
        ErrMissingSSECustomerKey
        ErrMissingSSECustomerKeyMD5
        ErrSSECustomerKeyMD5Mismatch
        ErrInvalidSSECustomerParameters
        ErrIncompatibleEncryptionMethod
        ErrKMSNotConfigured
        ErrKMSAuthFailure

        // S3 extended errors.
        ErrContentSHA256Mismatch
        // Add new extended error codes here.

        // Add new extended error codes here.
        ContentNotModified // actually not an error
        ErrInvalidHeader   // supplementary error for golang http lib
        ErrNoSuchBucketCors
        ErrPolicyMissingFields
        ErrInvalidAcl
        ErrUnsupportedAcl
        ErrNonUTF8Encode
        ErrInvalidLc
        ErrNoSuchBucketLc
        ErrInvalidStorageClass
        ErrPutToBackendFailed
        ErrGetFromBackendFailed
        ErrDeleteFromBackendFailed
        ErrBackendInitMultipartFailed
        ErrBackendCompleteMultipartFailed
        ErrBackendAbortMultipartFailed
        ErrGetBackendFailed
        ErrUnmarshalFailed
        ErrGetBucketFailed
        ErrDBError
)

// error code to APIError structure, these fields carry respective
// descriptions for all the error responses.
var ErrorCodeResponse = map[S3ErrorCode]S3ErrorStruct{
        ErrNoErr: {
                AwsErrorCode:   "OK",
                Description:    "OK",
                HttpStatusCode: http.StatusOK,
        },
        ErrInvalidCopyDest: {
                AwsErrorCode:   "InvalidRequest",
                Description:    "This copy request is illegal because it is trying to copy an object to itself.",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrInvalidCopySource: {
                AwsErrorCode:   "InvalidArgument",
                Description:    "Copy Source must mention the source bucket and key: sourcebucket/sourcekey.",
                HttpStatusCode: http.StatusBadRequest,
        },

        ErrInvalidCopySourceStorageClass: {
                AwsErrorCode:   "InvalidCopySourceStorageClass",
                Description:    "Storage class of copy source cannot be GLACIER or DEEP_ARCHIVE.",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrInvalidPrecondition: {
                AwsErrorCode:   "InvalidArgument",
                Description:    "The provided preconditions are not valid(bad time format, rule combination, etc)",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrInvalidRequestBody: {
                AwsErrorCode:   "InvalidArgument",
                Description:    "Body shouldn't be set for this request.",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrInvalidEncodingType: {
                AwsErrorCode:   "InvalidEncodingType",
                Description:    "The encoding type you provided is not allowed.",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrInvalidContinuationToken: {
                AwsErrorCode:   "ErrInvalidContinuationToken",
                Description:    "The continuation token you provided is invalid.",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrInvalidMaxUploads: {
                AwsErrorCode:   "InvalidArgument",
                Description:    "Argument max-uploads must be an integer between 1 and 1000",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrInvalidMaxKeys: {
                AwsErrorCode:   "InvalidArgument",
                Description:    "Argument maxKeys must be an integer between 1 and 1000",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrInvalidMaxParts: {
                AwsErrorCode:   "InvalidArgument",
                Description:    "Argument max-parts must be an integer between 1 and 1000",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrInvalidPartNumberMarker: {
                AwsErrorCode:   "InvalidArgument",
                Description:    "Argument partNumberMarker must be an integer.",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrInvalidPolicyDocument: {
                AwsErrorCode:   "InvalidPolicyDocument",
                Description:    "The content of the form does not meet the conditions specified in the policy document.",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrInvalidCorsDocument: {
                AwsErrorCode:   "InvalidCorsDocument",
                Description:    "The CORS XML you provided is invalid",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrInvalidVersioning: {
                AwsErrorCode:   "IllegalVersioningConfigurationException",
                Description:    "The versioning configuration specified in the request is invalid.",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrAccessDenied: {
                AwsErrorCode:   "AccessDenied",
                Description:    "Access Denied.",
                HttpStatusCode: http.StatusForbidden,
        },
        ErrBadDigest: {
                AwsErrorCode:   "BadDigest",
                Description:    "The Content-Md5 you specified did not match what we received.",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrBucketAlreadyExists: {
                AwsErrorCode:   "BucketAlreadyExists",
                Description:    "The requested bucket name is not available.",
                HttpStatusCode: http.StatusConflict,
        },
        ErrEmptyEntity: {
                AwsErrorCode:   "EmptyEntity",
                Description:    "Your upload does not include a valid object",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrEntityTooLarge: {
                AwsErrorCode:   "EntityTooLarge",
                Description:    "Your proposed upload exceeds the maximum allowed object size.",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrIncompleteBody: {
                AwsErrorCode:   "IncompleteBody",
                Description:    "You did not provide the number of bytes specified by the Content-Length HTTP header.",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrInternalError: {
                AwsErrorCode:   "InternalError",
                Description:    "We encountered an internal error, please try again.",
                HttpStatusCode: http.StatusInternalServerError,
        },
        ErrInvalidAccessKeyID: {
                AwsErrorCode:   "InvalidAccessKeyId",
                Description:    "The access key ID you provided does not exist in our records.",
                HttpStatusCode: http.StatusForbidden,
        },
        ErrInvalidBucketName: {
                AwsErrorCode:   "InvalidBucketName",
                Description:    "The specified bucket name is not valid.",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrInvalidObjectName: {
                AwsErrorCode:   "InvalidObjectName",
                Description:    "The specified object name is not valid",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrInvalidDigest: {
                AwsErrorCode:   "InvalidDigest",
                Description:    "The Content-Md5 you specified is not valid.",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrInvalidRange: {
                AwsErrorCode:   "InvalidRange",
                Description:    "The requested range is not satisfiable",
                HttpStatusCode: http.StatusRequestedRangeNotSatisfiable,
        },
        ErrMalformedXML: {
                AwsErrorCode:   "MalformedXML",
                Description:    "The XML you provided was not well-formed or did not validate against our published schema.",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrMissingContentLength: {
                AwsErrorCode:   "MissingContentLength",
                Description:    "You must provide the Content-Length HTTP header.",
                HttpStatusCode: http.StatusLengthRequired,
        },
        ErrMissingContentMD5: {
                AwsErrorCode:   "MissingContentMD5",
                Description:    "Missing required header for this request: Content-Md5.",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrMissingRequestBodyError: {
                AwsErrorCode:   "MissingRequestBodyError",
                Description:    "Request body is empty.",
                HttpStatusCode: http.StatusLengthRequired,
        },
        ErrNoSuchBucket: {
                AwsErrorCode:   "NoSuchBucket",
                Description:    "The specified bucket does not exist",
                HttpStatusCode: http.StatusNotFound,
        },
        ErrNoSuchBucketPolicy: {
                AwsErrorCode:   "NoSuchBucketPolicy",
                Description:    "The specified bucket does not have a bucket policy.",
                HttpStatusCode: http.StatusNotFound,
        },
        ErrNoSuchKey: {
                AwsErrorCode:   "NoSuchKey",
                Description:    "The specified key does not exist.",
                HttpStatusCode: http.StatusNotFound,
        },
        ErrNoSuchUpload: {
                AwsErrorCode:   "NoSuchUpload",
                Description:    "The specified multipart upload does not exist.",
                HttpStatusCode: http.StatusNotFound,
        },
        ErrNoSuchVersion: {
                AwsErrorCode:   "NoSuchVersion",
                Description:    "The version ID specified in the request does not match an existing version.",
                HttpStatusCode: http.StatusNotFound,
        },
        ErrNotImplemented: {
                AwsErrorCode:   "NotImplemented",
                Description:    "A header you provided implies functionality that is not implemented",
                HttpStatusCode: http.StatusNotImplemented,
        },
        ErrPreconditionFailed: {
                AwsErrorCode:   "PreconditionFailed",
                Description:    "At least one of the pre-conditions you specified did not hold",
                HttpStatusCode: http.StatusPreconditionFailed,
        },
        ErrRequestTimeTooSkewed: {
                AwsErrorCode:   "RequestTimeTooSkewed",
                Description:    "The difference between the request time and the server's time is too large.",
                HttpStatusCode: http.StatusForbidden,
        },
        ErrSignatureDoesNotMatch: {
                AwsErrorCode:   "SignatureDoesNotMatch",
                Description:    "The request signature we calculated does not match the signature you provided. Check your key and signing method.",
                HttpStatusCode: http.StatusForbidden,
        },
        ErrMethodNotAllowed: {
                AwsErrorCode:   "MethodNotAllowed",
                Description:    "The specified method is not allowed against this resource.",
                HttpStatusCode: http.StatusMethodNotAllowed,
        },
        ErrInvalidPart: {
                AwsErrorCode:   "InvalidPart",
                Description:    "One or more of the specified parts could not be found. The part might not have been uploaded, or the specified entity tag might not have matched the part's entity tag.",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrInvalidPartOrder: {
                AwsErrorCode:   "InvalidPartOrder",
                Description:    "The list of parts was not in ascending order. The parts list must be specified in order by part number.",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrAuthorizationHeaderMalformed: {
                AwsErrorCode:   "AuthorizationHeaderMalformed",
                Description:    "The authorization header is malformed.",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrMalformedPOSTRequest: {
                AwsErrorCode:   "MalformedPOSTRequest",
                Description:    "The body of your POST request is not well-formed multipart/form-data.",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrSignatureVersionNotSupported: {
                AwsErrorCode:   "AccessDenied",
                Description:    "The authorization mechanism you have provided is not supported. Please use AWS4-HMAC-SHA256.",
                HttpStatusCode: http.StatusForbidden,
        },
        ErrBucketNotEmpty: {
                AwsErrorCode:   "BucketNotEmpty",
                Description:    "The bucket you tried to delete is not empty.",
                HttpStatusCode: http.StatusConflict,
        },
        ErrBucketAccessForbidden: {
                AwsErrorCode:   "AccessDenied",
                Description:    "You have no access to this bucket.",
                HttpStatusCode: http.StatusForbidden,
        },
        ErrMalformedPolicy: {
                AwsErrorCode:   "MalformedPolicy",
                Description:    "Policy has invalid resource.",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrMissingFields: {
                AwsErrorCode:   "MissingFields",
                Description:    "Missing fields in request.",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrMissingCredTag: {
                AwsErrorCode:   "InvalidRequest",
                Description:    "Missing Credential field for this request.",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrCredMalformed: {
                AwsErrorCode:   "CredentialMalformed",
                Description:    "Credential field does not follow accessKeyID/credentialScope.",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrMalformedDate: {
                AwsErrorCode:   "MalformedDate",
                Description:    "Invalid date format header, expected to be in ISO8601, RFC1123 or RFC1123Z time format.",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrInvalidRegion: {
                AwsErrorCode:   "InvalidRegion",
                Description:    "Region does not match.",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrInvalidService: {
                AwsErrorCode:   "AccessDenied",
                Description:    "Service scope should be of value 's3'.",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrInvalidRequestVersion: {
                AwsErrorCode:   "AccessDenied",
                Description:    "Request scope should be of value 'aws4_request'.",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrMissingSignTag: {
                AwsErrorCode:   "AccessDenied",
                Description:    "Signature header missing Signature field.",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrMissingSignHeadersTag: {
                AwsErrorCode:   "InvalidArgument",
                Description:    "Signature header missing SignedHeaders field.",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrMissingRequiredSignedHeader: {
                AwsErrorCode:   "InvalidArgument",
                Description:    "Missing one or more required signed header",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrSignedHeadersNotSorted: {
                AwsErrorCode:   "InvalidArgument",
                Description:    "Signed headers are not ordered",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrPolicyAlreadyExpired: {
                AwsErrorCode:   "AccessDenied",
                Description:    "Invalid according to Policy: Policy expired.",
                HttpStatusCode: http.StatusForbidden,
        },
        ErrPolicyViolation: {
                AwsErrorCode:   "AccessDenied",
                Description:    "File uploading policy violated.",
                HttpStatusCode: http.StatusForbidden,
        },
        ErrMalformedExpires: {
                AwsErrorCode:   "MalformedExpires",
                Description:    "Malformed expires value, should be between 1 and 604800(seven days)",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrAuthHeaderEmpty: {
                AwsErrorCode:   "InvalidArgument",
                Description:    "Authorization header is invalid -- one and only one ' ' (space) required.",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrMissingDateHeader: {
                AwsErrorCode:   "AccessDenied",
                Description:    "AWS authentication requires a valid Date or x-amz-date header",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrInvalidQuerySignatureAlgo: {
                AwsErrorCode:   "AuthorizationQueryParametersError",
                Description:    "X-Amz-Algorithm only supports \"AWS4-HMAC-SHA256\".",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrExpiredPresignRequest: {
                AwsErrorCode:   "ExpiredToken",
                Description:    "Request has expired.",
                HttpStatusCode: http.StatusForbidden,
        },
        ErrInvalidQueryParams: {
                AwsErrorCode:   "AuthorizationQueryParametersError",
                Description:    "Query-string authentication version 4 requires the X-Amz-Algorithm, X-Amz-Credential, X-Amz-Signature, X-Amz-Date, X-Amz-SignedHeaders, and X-Amz-Expires parameters.",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrBucketAlreadyOwnedByYou: {
                AwsErrorCode:   "BucketAlreadyOwnedByYou",
                Description:    "Your previous request to create the named bucket succeeded and you already own it.",
                HttpStatusCode: http.StatusConflict,
        },
        ErrTooManyBuckets: {
                AwsErrorCode:   "TooManyBuckets",
                Description:    "You have attempted to create more buckets than allowed.",
                HttpStatusCode: http.StatusBadRequest,
        },

        // SSE-S3 related API errors
        ErrInvalidEncryptionMethod: {
                AwsErrorCode:   "InvalidRequest",
                Description:    "The encryption method specified is not supported",
                HttpStatusCode: http.StatusBadRequest,
        },

        // Server-Side-Encryption (with Customer provided key) related API errors.
        ErrInsecureSSECustomerRequest: {
                AwsErrorCode:   "InvalidRequest",
                Description:    "Requests specifying Server Side Encryption with Customer provided keys must be made over a secure connection.",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrSSEMultipartEncrypted: {
                AwsErrorCode:   "InvalidRequest",
                Description:    "The multipart upload initiate requested encryption. Subsequent part requests must include the appropriate encryption parameters.",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrSSEEncryptedObject: {
                AwsErrorCode:   "InvalidRequest",
                Description:    "The object was stored using a form of Server Side Encryption. The correct parameters must be provided to retrieve the object.",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrInvalidEncryptionParameters: {
                AwsErrorCode:   "InvalidRequest",
                Description:    "The encryption parameters are not applicable to this object.",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrInvalidSSECustomerAlgorithm: {
                AwsErrorCode:   "InvalidArgument",
                Description:    "Requests specifying Server Side Encryption with Customer provided keys must provide a valid encryption algorithm.",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrInvalidSSECustomerKey: {
                AwsErrorCode:   "InvalidArgument",
                Description:    "The secret key was invalid for the specified algorithm.",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrMissingSSECustomerKey: {
                AwsErrorCode:   "InvalidArgument",
                Description:    "Requests specifying Server Side Encryption with Customer provided keys must provide an appropriate secret key.",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrMissingSSECustomerKeyMD5: {
                AwsErrorCode:   "InvalidArgument",
                Description:    "Requests specifying Server Side Encryption with Customer provided keys must provide the client calculated MD5 of the secret key.",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrSSECustomerKeyMD5Mismatch: {
                AwsErrorCode:   "InvalidArgument",
                Description:    "The calculated MD5 hash of the key did not match the hash that was provided.",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrInvalidSSECustomerParameters: {
                AwsErrorCode:   "InvalidArgument",
                Description:    "The provided encryption parameters did not match the ones used originally.",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrIncompatibleEncryptionMethod: {
                AwsErrorCode:   "InvalidArgument",
                Description:    "Server side encryption specified with both SSE-C and SSE-S3 headers",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrKMSNotConfigured: {
                AwsErrorCode:   "InvalidArgument",
                Description:    "Server side encryption specified but KMS is not configured",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrKMSAuthFailure: {
                AwsErrorCode:   "InvalidArgument",
                Description:    "Server side encryption specified but KMS authorization failed",
                HttpStatusCode: http.StatusBadRequest,
        },
        /// S3 extensions.
        ErrContentSHA256Mismatch: {
                AwsErrorCode:   "XAmzContentSHA256Mismatch",
                Description:    "The provided 'x-amz-content-sha256' header does not match what was computed.",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrInvalidCannedAcl: {
                AwsErrorCode:   "InvalidAcl",
                Description:    "The canned ACL you provided is not valid",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrInvalidSseHeader: {
                AwsErrorCode:   "InvalidSseHeader",
                Description:    "The Server-side Encryption configuration is corrupted or invalid",
                HttpStatusCode: http.StatusBadRequest,
        },

        ContentNotModified: { // FIXME: This is actually not an error
                AwsErrorCode:   "",
                Description:    "",
                HttpStatusCode: http.StatusNotModified,
        },
        ErrInvalidHeader: {
                AwsErrorCode:   "InvalidRequest",
                Description:    "This request is illegal because some header is malformed.",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrNoSuchBucketCors: {
                AwsErrorCode:   "NoSuchBucketCors",
                Description:    "The specified bucket does not have CORS configured.",
                HttpStatusCode: http.StatusNotFound,
        },
        ErrPolicyMissingFields: {
                AwsErrorCode:   "AccessDenied",
                Description:    "Missing policy condition",
                HttpStatusCode: http.StatusForbidden,
        },
        ErrInvalidAcl: {
                AwsErrorCode:   "IllegalAclConfigurationException",
                Description:    "The ACL configuration specified in the request is invalid.",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrUnsupportedAcl: {
                AwsErrorCode:   "UnsupportedAclConfigurationException",
                Description:    "The ACL configuration specified in the request is unsupported.",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrNonUTF8Encode: {
                AwsErrorCode:   "InvalidArgument",
                Description:    "URL Argument must be UTF8 encoded.",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrNoSuchBucketLc: {
                AwsErrorCode:   "NoSuchBucketLc",
                Description:    "The specified bucket does not have LifeCycle configured.",
                HttpStatusCode: http.StatusNotFound,
        },
        ErrInvalidLc: {
                AwsErrorCode:   "IllegalLcConfigurationException",
                Description:    "The LC configuration specified in the request is invalid.",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrInvalidPosition: {
                AwsErrorCode:   "InvalidPosition",
                Description:    "The argument position specified in the request must be non-negative integer.",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrObjectNotAppendable: {
                AwsErrorCode:   "ObjectNotAppendable",
                Description:    "Cannot perform an AppendObject operation on a non-Appendable Object.",
                HttpStatusCode: http.StatusConflict,
        },
        ErrPositionNotEqualToLength: {
                AwsErrorCode:   "PositionNotEqualToLength",
                Description:    "The value of position does not match the length of the current Object.",
                HttpStatusCode: http.StatusConflict,
        },
        ErrInvalidStorageClass: {
                AwsErrorCode:   "InvalidStorageClass",
                Description:    "The storage class you specified in header is invalid.",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrPutToBackendFailed: {
                AwsErrorCode:   "PutToBackendFailed",
                Description:    "Put object to backend failed.",
                HttpStatusCode: http.StatusInternalServerError,
        },
        ErrGetFromBackendFailed: {
                AwsErrorCode:   "GetFromBackendFailed",
                Description:    "Get object from backend failed.",
                HttpStatusCode: http.StatusInternalServerError,
        },
        ErrDeleteFromBackendFailed: {
                AwsErrorCode:   "DeleteFromBackendFailed",
                Description:    "Delete object from backend failed.",
                HttpStatusCode: http.StatusInternalServerError,
        },
        ErrBackendInitMultipartFailed: {
                AwsErrorCode:   "BackendInitMultipartFailed",
                Description:    "Backend init multipart upload failed.",
                HttpStatusCode: http.StatusInternalServerError,
        },
        ErrBackendCompleteMultipartFailed: {
                AwsErrorCode:   "BackendCompleteMultipartFailed",
                Description:    "Backend complete multipart upload failed.",
                HttpStatusCode: http.StatusInternalServerError,
        },
        ErrBackendAbortMultipartFailed: {
                AwsErrorCode:   "BackendAbortMultipartFailed",
                Description:    "Backend abort multipart upload failed.",
                HttpStatusCode: http.StatusInternalServerError,
        },
        ErrGetBackendFailed: {
                AwsErrorCode:   "GetBackendFailed",
                Description:    "Backend is not exist, or get it failed.",
                HttpStatusCode: http.StatusInternalServerError,
        },
        ErrUnmarshalFailed: {
                AwsErrorCode:   "UnmarshalFailed",
                Description:    "Unmarshal failed.",
                HttpStatusCode: http.StatusInternalServerError,
        },
        ErrGetBucketFailed: {
                AwsErrorCode:   "GetBucketFailed",
                Description:    "Bucket is not exist, or get it failed.",
                HttpStatusCode: http.StatusInternalServerError,
        },
        ErrDBError: {
                AwsErrorCode:   "InternalError",
                Description:    "DB error.",
                HttpStatusCode: http.StatusInternalServerError,
        },
}

func (e S3ErrorCode) AwsErrorCode() string <span class="cov0" title="0">{
        awsError, ok := ErrorCodeResponse[e]
        if !ok </span><span class="cov0" title="0">{
                return "InternalError"
        }</span>
        <span class="cov0" title="0">return awsError.AwsErrorCode</span>
}

func (e S3ErrorCode) Description() string <span class="cov8" title="1">{
        awsError, ok := ErrorCodeResponse[e]
        if !ok </span><span class="cov0" title="0">{
                return "We encountered an internal error, please try again."
        }</span>
        <span class="cov8" title="1">return awsError.Description</span>
}

func (e S3ErrorCode) Error() string <span class="cov8" title="1">{
        return e.Description()
}</span>

func (e S3ErrorCode) HttpStatusCode() int <span class="cov0" title="0">{
        awsError, ok := ErrorCodeResponse[e]
        if !ok </span><span class="cov0" title="0">{
                return http.StatusInternalServerError
        }</span>
        <span class="cov0" title="0">return awsError.HttpStatusCode</span>
}
</pre>
		
		<pre class="file" id="file66" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package aws

import (
        "bytes"
        "context"
        "errors"
        "io"
        "io/ioutil"
        "strconv"
        "time"

        "crypto/md5"
        "encoding/base64"
        "encoding/hex"
        "github.com/aws/aws-sdk-go/aws"
        "github.com/aws/aws-sdk-go/aws/credentials"
        "github.com/aws/aws-sdk-go/aws/session"
        awss3 "github.com/aws/aws-sdk-go/service/s3"
        "github.com/aws/aws-sdk-go/service/s3/s3manager"
        backendpb "github.com/soda/multi-cloud/backend/proto"
        . "github.com/soda/multi-cloud/s3/error"
        dscommon "github.com/soda/multi-cloud/s3/pkg/datastore/common"
        "github.com/soda/multi-cloud/s3/pkg/model"
        osdss3 "github.com/soda/multi-cloud/s3/pkg/service"
        "github.com/soda/multi-cloud/s3/pkg/utils"
        pb "github.com/soda/multi-cloud/s3/proto"
        log "github.com/sirupsen/logrus"
)

type AwsAdapter struct {
        backend *backendpb.BackendDetail
        session *session.Session
}

type s3Cred struct {
        ak string
        sk string
}

func (myc *s3Cred) Retrieve() (credentials.Value, error) <span class="cov8" title="1">{
        cred := credentials.Value{AccessKeyID: myc.ak, SecretAccessKey: myc.sk}
        return cred, nil
}</span>

func (myc *s3Cred) IsExpired() bool <span class="cov0" title="0">{
        return false
}</span>

func (ad *AwsAdapter) Put(ctx context.Context, stream io.Reader, object *pb.Object) (dscommon.PutResult, error) <span class="cov8" title="1">{
        bucket := ad.backend.BucketName
        objectId := object.BucketName + "/" + object.ObjectKey
        result := dscommon.PutResult{}
        userMd5 := dscommon.GetMd5FromCtx(ctx)
        size := object.Size
        log.Infof("put object[OBS], objectId:%s, bucket:%s, size=%d, userMd5=%s\n", objectId, bucket, size, userMd5)

        // Limit the reader to its provided size if specified.
        var limitedDataReader io.Reader
        if size &gt; 0 </span><span class="cov0" title="0">{ // request.ContentLength is -1 if length is unknown
                limitedDataReader = io.LimitReader(stream, size)
        }</span> else<span class="cov8" title="1"> {
                limitedDataReader = stream
        }</span>
        <span class="cov8" title="1">md5Writer := md5.New()
        dataReader := io.TeeReader(limitedDataReader, md5Writer)

        if object.Tier == 0 </span><span class="cov8" title="1">{
                // default
                object.Tier = utils.Tier1
        }</span>
        <span class="cov8" title="1">storClass, err := osdss3.GetNameFromTier(object.Tier, utils.OSTYPE_AWS)
        if err != nil </span><span class="cov0" title="0">{
                log.Infof("translate tier[%d] to aws storage class failed\n", object.Tier)
                return result, ErrInternalError
        }</span>

        <span class="cov8" title="1">uploader := s3manager.NewUploader(ad.session)
        input := &amp;s3manager.UploadInput{
                Body:         dataReader,
                Bucket:       aws.String(bucket),
                Key:          aws.String(objectId),
                StorageClass: aws.String(storClass),
        }
        if userMd5 != "" </span><span class="cov0" title="0">{
                md5Bytes, err := hex.DecodeString(userMd5)
                if err != nil </span><span class="cov0" title="0">{
                        log.Warnf("user input md5 is abandoned, cause decode md5 failed, err:%v\n", err)
                }</span> else<span class="cov0" title="0"> {
                        input.ContentMD5 = aws.String(base64.StdEncoding.EncodeToString(md5Bytes))
                        log.Debugf("input.ContentMD5=%s\n", *input.ContentMD5)
                }</span>
        }
        <span class="cov8" title="1">log.Infof("upload object[AWS S3] start, objectId:%s\n", objectId)
        ret, err := uploader.Upload(input)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("put object[AWS S3] failed, objectId:%s, err:%v\n", objectId, err)
                return result, ErrPutToBackendFailed
        }</span>
        <span class="cov8" title="1">log.Infof("put object[AWS S3] end, objectId:%s\n", objectId)

        calculatedMd5 := hex.EncodeToString(md5Writer.Sum(nil))
        log.Debug("calculatedMd5:", calculatedMd5, ", userMd5:", userMd5)
        if userMd5 != "" &amp;&amp; userMd5 != calculatedMd5 </span><span class="cov0" title="0">{
                log.Error("### MD5 not match, calculatedMd5:", calculatedMd5, ", userMd5:", userMd5)
                return result, ErrBadDigest
        }</span>

        <span class="cov8" title="1">if ret.VersionID != nil </span><span class="cov0" title="0">{
                result.Meta = *ret.VersionID
        }</span>
        <span class="cov8" title="1">result.UpdateTime = time.Now().Unix()
        result.ObjectId = objectId
        result.Etag = calculatedMd5
        result.Written = size
        log.Infof("put object[AWS S3] successfully, objectId:%s, UpdateTime is:%v\n", objectId, result.UpdateTime)

        return result, nil</span>
}

func (ad *AwsAdapter) Get(ctx context.Context, object *pb.Object, start int64, end int64) (io.ReadCloser, error) <span class="cov8" title="1">{
        bucket := ad.backend.BucketName
        objectId := object.ObjectId
        getObjectInput := awss3.GetObjectInput{
                Bucket: &amp;bucket,
                Key:    &amp;objectId,
        }
        log.Infof("get object[AWS S3], objectId:%s, start = %d, end = %d\n", objectId, start, end)
        if start != 0 || end != 0 </span><span class="cov8" title="1">{
                strStart := strconv.FormatInt(start, 10)
                strEnd := strconv.FormatInt(end, 10)
                rangestr := "bytes=" + strStart + "-" + strEnd
                getObjectInput.SetRange(rangestr)
        }</span>

        <span class="cov8" title="1">svc := awss3.New(ad.session)
        result, err := svc.GetObject(&amp;getObjectInput)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("get object[AWS S3] failed, objectId:%s, err:%v", objectId, err)
                return nil, ErrGetFromBackendFailed
        }</span>

        <span class="cov8" title="1">log.Infof("get object[AWS S3] succeed, objectId:%s, ContentLength:%d\n", objectId, *result.ContentLength)
        return result.Body, nil</span>
}

func (ad *AwsAdapter) Delete(ctx context.Context, input *pb.DeleteObjectInput) error <span class="cov0" title="0">{
        bucket := ad.backend.BucketName
        objectId := input.Bucket + "/" + input.Key
        deleteInput := awss3.DeleteObjectInput{Bucket: &amp;bucket, Key: &amp;objectId}

        log.Infof("delete object[AWS S3], objectId:%s.\n", objectId)
        svc := awss3.New(ad.session)
        _, err := svc.DeleteObject(&amp;deleteInput)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("delete object[AWS S3] failed, objectId:%s, err:%v.\n", objectId, err)
                return ErrDeleteFromBackendFailed
        }</span>

        <span class="cov0" title="0">log.Infof("delete object[AWS S3] succeed, objectId:%s.\n", objectId)

        return nil</span>
}

func (ad *AwsAdapter) Copy(ctx context.Context, stream io.Reader, target *pb.Object) (result dscommon.PutResult, err error) <span class="cov0" title="0">{
        log.Errorf("copy[AWS S3] is not supported.")
        err = ErrInternalError
        return
}</span>

func (ad *AwsAdapter) ChangeStorageClass(ctx context.Context, object *pb.Object, newClass *string) error <span class="cov0" title="0">{
        objectId := object.ObjectId
        log.Infof("change storage class[AWS S3] of object[%s] to %s .\n", objectId, *newClass)

        svc := awss3.New(ad.session)
        input := &amp;awss3.CopyObjectInput{
                Bucket:     aws.String(ad.backend.BucketName),
                Key:        aws.String(objectId),
                CopySource: aws.String(ad.backend.BucketName + "/" + objectId),
        }
        input.StorageClass = aws.String(*newClass)
        _, err := svc.CopyObject(input)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("change storage class[AWS S3] of object[%s] to %s failed: %v.\n", objectId, *newClass, err)
                return ErrPutToBackendFailed
        }</span>

        <span class="cov0" title="0">log.Infof("change storage class[AWS S3] of object[%s] to %s succeed.\n", objectId, *newClass)
        return nil</span>
}

func (ad *AwsAdapter) InitMultipartUpload(ctx context.Context, object *pb.Object) (*pb.MultipartUpload, error) <span class="cov0" title="0">{
        bucket := ad.backend.BucketName
        objectId := object.BucketName + "/" + object.ObjectKey
        log.Infof("init multipart upload[AWS S3], bucket = %v,objectId = %v\n", bucket, objectId)

        storClass, err := osdss3.GetNameFromTier(object.Tier, utils.OSTYPE_AWS)
        if err != nil </span><span class="cov0" title="0">{
                log.Warnf("translate tier[%d] to aws storage class failed, use default value.\n", object.Tier)
                return nil, ErrInternalError
        }</span>

        <span class="cov0" title="0">multipartUpload := &amp;pb.MultipartUpload{}
        multiUpInput := &amp;awss3.CreateMultipartUploadInput{
                Bucket:       &amp;bucket,
                Key:          &amp;objectId,
                StorageClass: aws.String(storClass),
        }

        svc := awss3.New(ad.session)
        res, err := svc.CreateMultipartUpload(multiUpInput)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("init multipart upload[AWS S3] failed, err:%v\n", err)
                return nil, ErrBackendInitMultipartFailed
        }</span> else<span class="cov0" title="0"> {
                log.Infof("init multipart upload[AWS S3] succeed, UploadId:%s\n", *res.UploadId)
                multipartUpload.Bucket = object.BucketName
                multipartUpload.Key = object.ObjectKey
                multipartUpload.UploadId = *res.UploadId
                multipartUpload.ObjectId = objectId
                return multipartUpload, nil
        }</span>
}

func (ad *AwsAdapter) UploadPart(ctx context.Context, stream io.Reader, multipartUpload *pb.MultipartUpload,
        partNumber int64, upBytes int64) (*model.UploadPartResult, error) <span class="cov0" title="0">{
        bucket := ad.backend.BucketName
        bytess, err := ioutil.ReadAll(stream)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("read data failed, err:%v\n", err)
                return nil, ErrInternalError
        }</span>
        <span class="cov0" title="0">upPartInput := &amp;awss3.UploadPartInput{
                Body:          bytes.NewReader(bytess),
                Bucket:        &amp;bucket,
                Key:           &amp;multipartUpload.ObjectId,
                PartNumber:    aws.Int64(partNumber),
                UploadId:      &amp;multipartUpload.UploadId,
                ContentLength: aws.Int64(upBytes),
        }
        log.Infof("upload part[AWS S3], input:%v\n", *upPartInput)

        svc := awss3.New(ad.session)
        upRes, err := svc.UploadPart(upPartInput)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("upload part[AWS S3] failed. err:%v\n", err)
                return nil, ErrPutToBackendFailed
        }</span> else<span class="cov0" title="0"> {
                log.Infof("upload object[AWS S3], objectId:%s, part #%d succeed, ETag:%s\n", multipartUpload.ObjectId,
                        partNumber, *upRes.ETag)
                result := &amp;model.UploadPartResult{
                        Xmlns:      model.Xmlns,
                        ETag:       *upRes.ETag,
                        PartNumber: partNumber}
                return result, nil
        }</span>

        <span class="cov0" title="0">log.Error("upload part[AWS S3]: should not be here.")
        return nil, ErrInternalError</span>
}

func (ad *AwsAdapter) CompleteMultipartUpload(ctx context.Context, multipartUpload *pb.MultipartUpload,
        completeUpload *model.CompleteMultipartUpload) (*model.CompleteMultipartUploadResult, error) <span class="cov0" title="0">{
        bucket := ad.backend.BucketName
        log.Infof("complete multipart upload[AWS S3], bucket:%s, objectId:%s.\n", bucket, multipartUpload.ObjectId)

        var completeParts []*awss3.CompletedPart
        for _, p := range completeUpload.Parts </span><span class="cov0" title="0">{
                completePart := &amp;awss3.CompletedPart{
                        ETag:       aws.String(p.ETag),
                        PartNumber: aws.Int64(p.PartNumber),
                }
                completeParts = append(completeParts, completePart)
        }</span>
        <span class="cov0" title="0">completeInput := &amp;awss3.CompleteMultipartUploadInput{
                Bucket:   &amp;bucket,
                Key:      &amp;multipartUpload.ObjectId,
                UploadId: &amp;multipartUpload.UploadId,
                MultipartUpload: &amp;awss3.CompletedMultipartUpload{
                        Parts: completeParts,
                },
        }

        log.Infof("completeInput %v\n", *completeInput)
        svc := awss3.New(ad.session)
        resp, err := svc.CompleteMultipartUpload(completeInput)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("complete multipart upload[AWS S3] failed, err:%v\n", err)
                return nil, ErrBackendCompleteMultipartFailed
        }</span>
        <span class="cov0" title="0">result := &amp;model.CompleteMultipartUploadResult{
                Xmlns:    model.Xmlns,
                Location: *resp.Location,
                Bucket:   multipartUpload.Bucket,
                Key:      multipartUpload.Key,
                ETag:     *resp.ETag,
        }

        log.Infof("complete multipart upload[AWS S3] successfully, resp:%v\n", resp)
        return result, nil</span>
}

func (ad *AwsAdapter) AbortMultipartUpload(ctx context.Context, multipartUpload *pb.MultipartUpload) error <span class="cov0" title="0">{
        bucket := ad.backend.BucketName
        log.Infof("abort multipart upload[AWS S3], bucket:%s, objectId:%s.\n", bucket, multipartUpload.ObjectId)

        abortInput := &amp;awss3.AbortMultipartUploadInput{
                Bucket:   &amp;bucket,
                Key:      &amp;multipartUpload.ObjectId,
                UploadId: &amp;multipartUpload.UploadId,
        }

        svc := awss3.New(ad.session)
        rsp, err := svc.AbortMultipartUpload(abortInput)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("abort multipart upload[AWS S3] failed, err:%v\n", err)
                return ErrBackendAbortMultipartFailed
        }</span>

        <span class="cov0" title="0">log.Infof("complete multipart upload[AWS S3] successfully, rsp:%v\n", rsp)
        return nil</span>
}

func (ad *AwsAdapter) ListParts(ctx context.Context, multipartUpload *pb.ListParts) (*model.ListPartsOutput, error) <span class="cov0" title="0">{
        return nil, errors.New("not implemented yet.")
}</span>

func (ad *AwsAdapter) Close() error <span class="cov0" title="0">{
        // TODO:
        return nil
}</span>
</pre>
		
		<pre class="file" id="file67" style="display: none">package aws

import (
        "github.com/aws/aws-sdk-go/aws"
        "github.com/aws/aws-sdk-go/aws/credentials"
        "github.com/aws/aws-sdk-go/aws/session"
        "github.com/soda/multi-cloud/backend/pkg/utils/constants"
        backendpb "github.com/soda/multi-cloud/backend/proto"
        "github.com/soda/multi-cloud/s3/pkg/datastore/driver"
)

type AwsS3DriverFactory struct {
}

func (factory *AwsS3DriverFactory) CreateDriver(backend *backendpb.BackendDetail) (driver.StorageDriver, error) <span class="cov8" title="1">{
        endpoint := backend.Endpoint
        AccessKeyID := backend.Access
        AccessKeySecret := backend.Security
        region := backend.Region

        s3aksk := s3Cred{ak: AccessKeyID, sk: AccessKeySecret}
        creds := credentials.NewCredentials(&amp;s3aksk)

        disableSSL := true
        sess, err := session.NewSession(&amp;aws.Config{
                Region:      &amp;region,
                Endpoint:    &amp;endpoint,
                Credentials: creds,
                DisableSSL:  &amp;disableSSL,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">adap := &amp;AwsAdapter{backend: backend, session: sess}

        return adap, nil</span>
}

func init() <span class="cov8" title="1">{
        driver.RegisterDriverFactory(constants.BackendTypeAws, &amp;AwsS3DriverFactory{})
}</span>
</pre>
		
		<pre class="file" id="file68" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package azure

import (
        "bytes"
        "context"
        "encoding/base64"
        "encoding/binary"
        "io"
        "io/ioutil"
        "net/http"
        "net/url"
        "time"

        "encoding/hex"
        "github.com/Azure/azure-storage-blob-go/azblob"
        backendpb "github.com/soda/multi-cloud/backend/proto"
        . "github.com/soda/multi-cloud/s3/error"
        dscommon "github.com/soda/multi-cloud/s3/pkg/datastore/common"
        "github.com/soda/multi-cloud/s3/pkg/model"
        osdss3 "github.com/soda/multi-cloud/s3/pkg/service"
        "github.com/soda/multi-cloud/s3/pkg/utils"
        pb "github.com/soda/multi-cloud/s3/proto"
        log "github.com/sirupsen/logrus"
        "strconv"
)

// TryTimeout indicates the maximum time allowed for any single try of an HTTP request.
var MaxTimeForSingleHttpRequest = 50 * time.Minute

type AzureAdapter struct {
        backend      *backendpb.BackendDetail
        containerURL azblob.ContainerURL
}

/*func Init(backend *backendpb.BackendDetail) *AzureAdapter {
        endpoint := backend.Endpoint
        AccessKeyID := backend.Access
        AccessKeySecret := backend.Security
        ad := AzureAdapter{}
        containerURL, err := ad.createContainerURL(endpoint, AccessKeyID, AccessKeySecret)
        if err != nil {
                log.Infof("AzureAdapter Init container URL faild:%v\n", err)
                return nil
        }
        adap := &amp;AzureAdapter{backend: backend, containerURL: containerURL}
        log.Log("AzureAdapter Init succeed, container URL:", containerURL.String())
        return adap
}*/

func (ad *AzureAdapter) createContainerURL(endpoint string, acountName string, accountKey string) (azblob.ContainerURL,
        error) <span class="cov0" title="0">{
        credential, err := azblob.NewSharedKeyCredential(acountName, accountKey)

        if err != nil </span><span class="cov0" title="0">{
                log.Infof("create credential[Azure Blob] failed, err:%v\n", err)
                return azblob.ContainerURL{}, err
        }</span>

        //create containerURL
        <span class="cov0" title="0">p := azblob.NewPipeline(credential, azblob.PipelineOptions{
                Retry: azblob.RetryOptions{
                        TryTimeout: MaxTimeForSingleHttpRequest,
                },
        })
        URL, _ := url.Parse(endpoint)

        return azblob.NewContainerURL(*URL, p), nil</span>
}

func (ad *AzureAdapter) Put(ctx context.Context, stream io.Reader, object *pb.Object) (dscommon.PutResult, error) <span class="cov0" title="0">{
        objectId := object.BucketName + "/" + object.ObjectKey
        blobURL := ad.containerURL.NewBlockBlobURL(objectId)
        result := dscommon.PutResult{}
        userMd5 := dscommon.GetMd5FromCtx(ctx)
        log.Infof("put object[Azure Blob], objectId:%s, blobURL:%v, userMd5:%s, size:%d\n", objectId, blobURL, userMd5, object.Size)

        log.Infof("put object[Azure Blob] begin, objectId:%s\n", objectId)
        options := azblob.UploadStreamToBlockBlobOptions{BufferSize: 2 * 1024 * 1024, MaxBuffers: 2}

        uploadResp, err := azblob.UploadStreamToBlockBlob(ctx, stream, blobURL, options)
        log.Infof("put object[Azure Blob] end, objectId:%s\n", objectId)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("put object[Azure Blob], objectId:%s, err:%v\n", objectId, err)
                return result, ErrPutToBackendFailed
        }</span>
        <span class="cov0" title="0">if uploadResp.Response().StatusCode != http.StatusCreated </span><span class="cov0" title="0">{
                log.Errorf("put object[Azure Blob], objectId:%s, StatusCode:%d\n", objectId, uploadResp.Response().StatusCode)
                return result, ErrPutToBackendFailed
        }</span>

        <span class="cov0" title="0">if object.Tier == 0 </span><span class="cov0" title="0">{
                // default
                object.Tier = utils.Tier1
        }</span>
        <span class="cov0" title="0">storClass, err := osdss3.GetNameFromTier(object.Tier, utils.OSTYPE_Azure)
        if err != nil </span><span class="cov0" title="0">{
                log.Infof("translate tier[%d] to aws storage class failed\n", object.Tier)
                return result, ErrInternalError
        }</span>

        <span class="cov0" title="0">resultMd5 := uploadResp.Response().Header.Get("Content-MD5")
        resultMd5Bytes, err := base64.StdEncoding.DecodeString(resultMd5)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("decode Content-MD5 failed, err:%v\n", err)
                return result, ErrBadDigest
        }</span>
        <span class="cov0" title="0">decodedMd5 := hex.EncodeToString(resultMd5Bytes)
        if userMd5 != "" &amp;&amp; userMd5 != decodedMd5 </span><span class="cov0" title="0">{
                log.Error("### MD5 not match, resultMd5:", resultMd5, ", decodedMd5:", decodedMd5, ", userMd5:", userMd5)
                return result, ErrBadDigest
        }</span>

        // Currently, only support Hot
        <span class="cov0" title="0">_, err = blobURL.SetTier(ctx, azblob.AccessTierType(storClass), azblob.LeaseAccessConditions{})
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("set azure blob tier[%s] failed:%v\n", object.Tier, err)
                return result, ErrPutToBackendFailed
        }</span>

        <span class="cov0" title="0">result.UpdateTime = time.Now().Unix()
        result.ObjectId = objectId
        result.Etag = decodedMd5
        result.Meta = uploadResp.Version()
        result.Written = object.Size
        log.Infof("upload object[Azure Blob] succeed, objectId:%s, UpdateTime is:%v\n", objectId, result.UpdateTime)

        return result, nil</span>
}

func (ad *AzureAdapter) Get(ctx context.Context, object *pb.Object, start int64, end int64) (io.ReadCloser, error) <span class="cov0" title="0">{
        bucket := ad.backend.BucketName
        log.Infof("get object[Azure Blob], bucket:%s, objectId:%s\n", bucket, object.ObjectId)

        blobURL := ad.containerURL.NewBlobURL(object.ObjectId)
        log.Infof("blobURL:%v, size:%d\n", blobURL, object.Size)

        var buf []byte
        if end &lt; object.Size - 1 </span><span class="cov0" title="0">{
                count := end - start + 1
                buf = make([]byte, count)
                log.Debugf("start=%d, end=%d, count=%d\n", start, end, count)
                err := azblob.DownloadBlobToBuffer(ctx, blobURL, start, count, buf, azblob.DownloadFromBlobOptions{})
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("get object[Azure Blob] failed, objectId:%s, err:%v\n", object.ObjectId, err)
                        return nil, ErrGetFromBackendFailed
                }</span>
                <span class="cov0" title="0">body := bytes.NewReader(buf)
                ioReaderClose := ioutil.NopCloser(body)
                return ioReaderClose, nil</span>
        } else<span class="cov0" title="0"> {
                downloadResp, err := blobURL.Download(ctx, 0, azblob.CountToEnd, azblob.BlobAccessConditions{},
                        false)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("get object[Azure Blob] failed, objectId:%s, err:%v\n", object.ObjectId, err)
                        return nil, ErrGetFromBackendFailed
                }</span>
                <span class="cov0" title="0">log.Infof("get object[Azure Blob] successfully, objectId:%s\n", object.ObjectId)
                return downloadResp.Response().Body, nil</span>
        }

        <span class="cov0" title="0">log.Error("get object[Azure Blob]: should not be here")
        return nil, ErrInternalError</span>
}

func (ad *AzureAdapter) Delete(ctx context.Context, input *pb.DeleteObjectInput) error <span class="cov0" title="0">{
        bucket := ad.backend.BucketName
        objectId := input.Bucket + "/" + input.Key
        log.Infof("delete object[Azure Blob], objectId:%s, bucket:%s\n", objectId, bucket)

        blobURL := ad.containerURL.NewBlockBlobURL(objectId)
        log.Infof("blobURL is %v\n", blobURL)
        delRsp, err := blobURL.Delete(ctx, azblob.DeleteSnapshotsOptionInclude, azblob.BlobAccessConditions{})
        if err != nil </span><span class="cov0" title="0">{
                if serr, ok := err.(azblob.StorageError); ok </span><span class="cov0" title="0">{ // This error is a Service-specific
                        log.Infof("delete service code:%s\n", serr.ServiceCode())
                        if string(serr.ServiceCode()) == string(azblob.StorageErrorCodeBlobNotFound) </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                }

                <span class="cov0" title="0">log.Errorf("delete object[Azure Blob] failed, objectId:%s, err:%v\n", objectId, err)
                return ErrDeleteFromBackendFailed</span>
        }

        <span class="cov0" title="0">if delRsp.StatusCode() != http.StatusOK &amp;&amp; delRsp.StatusCode() != http.StatusAccepted </span><span class="cov0" title="0">{
                log.Errorf("delete object[Azure Blob] failed, objectId:%s, status code:%d\n", objectId, delRsp.StatusCode())
                return ErrDeleteFromBackendFailed
        }</span>

        <span class="cov0" title="0">log.Infof("delete object[Azure Blob] succeed, objectId:%s\n", objectId)
        return nil</span>
}

func (ad *AzureAdapter) Copy(ctx context.Context, stream io.Reader, target *pb.Object) (result dscommon.PutResult, err error) <span class="cov0" title="0">{
        log.Errorf("copy[Azure Blob] is not supported.")
        err = ErrInternalError
        return
}</span>

func (ad *AzureAdapter) ChangeStorageClass(ctx context.Context, object *pb.Object, newClass *string) error <span class="cov0" title="0">{
        objectId := object.ObjectId
        blobURL := ad.containerURL.NewBlockBlobURL(objectId)
        log.Infof("change storage class[Azure Blob], objectId:%s, blobURL is %v\n", objectId, blobURL)

        var res *azblob.BlobSetTierResponse
        var err error
        switch *newClass </span>{
        case string(azblob.AccessTierHot):<span class="cov0" title="0">
                res, err = blobURL.SetTier(ctx, azblob.AccessTierHot, azblob.LeaseAccessConditions{})</span>
        case string(azblob.AccessTierCool):<span class="cov0" title="0">
                res, err = blobURL.SetTier(ctx, azblob.AccessTierCool, azblob.LeaseAccessConditions{})</span>
        case string(azblob.AccessTierArchive):<span class="cov0" title="0">
                res, err = blobURL.SetTier(ctx, azblob.AccessTierArchive, azblob.LeaseAccessConditions{})</span>
        default:<span class="cov0" title="0">
                log.Errorf("change storage class[Azure Blob] of object[%s] to %s failed, err: invalid storage class.\n",
                        object.ObjectKey, newClass)
                return ErrInvalidStorageClass</span>
        }
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                log.Errorf("change storage class[Azure Blob] of object[%s] to %s failed, err:%v\n", object.ObjectKey,
                        newClass, err)
                return ErrInternalError
        }</span> else<span class="cov0" title="0"> {
                log.Errorf("change storage class[Azure Blob] of object[%s] to %s succeed, res:%v\n", object.ObjectKey,
                        newClass, res.Response())
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (ad *AzureAdapter) GetObjectInfo(bucketName string, key string, context context.Context) (*pb.Object, error) <span class="cov0" title="0">{
        object := pb.Object{}
        object.BucketName = bucketName
        object.ObjectKey = key
        return &amp;object, nil
}</span>

func (ad *AzureAdapter) InitMultipartUpload(ctx context.Context, object *pb.Object) (*pb.MultipartUpload, error) <span class="cov0" title="0">{
        bucket := ad.backend.BucketName
        log.Infof("bucket is %v\n", bucket)
        multipartUpload := &amp;pb.MultipartUpload{}
        multipartUpload.Key = object.ObjectKey

        multipartUpload.Bucket = object.BucketName
        multipartUpload.UploadId = object.ObjectKey + "_" + strconv.FormatInt(time.Now().UnixNano(), 10)
        multipartUpload.ObjectId = object.BucketName + "/" + object.ObjectKey
        return multipartUpload, nil
}</span>

func (ad *AzureAdapter) Int64ToBase64(blockID int64) string <span class="cov0" title="0">{
        buf := (&amp;[8]byte{})[:]
        binary.LittleEndian.PutUint64(buf, uint64(blockID))
        return ad.BinaryToBase64(buf)
}</span>

func (ad *AzureAdapter) BinaryToBase64(binaryID []byte) string <span class="cov0" title="0">{
        return base64.StdEncoding.EncodeToString(binaryID)
}</span>

func (ad *AzureAdapter) Base64ToInt64(base64ID string) int64 <span class="cov0" title="0">{
        bin, _ := base64.StdEncoding.DecodeString(base64ID)
        return int64(binary.LittleEndian.Uint64(bin))
}</span>

func (ad *AzureAdapter) UploadPart(ctx context.Context, stream io.Reader, multipartUpload *pb.MultipartUpload,
        partNumber int64, upBytes int64) (*model.UploadPartResult, error) <span class="cov0" title="0">{
        bucket := ad.backend.BucketName
        log.Infof("upload part[Azure Blob], bucket:%s, objectId:%s\n", bucket, multipartUpload.ObjectId)

        blobURL := ad.containerURL.NewBlockBlobURL(multipartUpload.ObjectId)
        base64ID := ad.Int64ToBase64(partNumber)
        bytess, _ := ioutil.ReadAll(stream)
        log.Debugf("blobURL=%+v\n", blobURL)
        rsp, err := blobURL.StageBlock(ctx, base64ID, bytes.NewReader(bytess), azblob.LeaseAccessConditions{}, nil)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("stage block[#%d,base64ID:%s] failed:%v\n", partNumber, base64ID, err)
                return nil, ErrPutToBackendFailed
        }</span>

        <span class="cov0" title="0">etag := hex.EncodeToString(rsp.ContentMD5())
        log.Infof("stage block[#%d,base64ID:%s] succeed, etag:%s.\n", partNumber, base64ID, etag)
        result := &amp;model.UploadPartResult{PartNumber: partNumber, ETag: etag}

        return result, nil</span>
}

func (ad *AzureAdapter) CompleteMultipartUpload(ctx context.Context, multipartUpload *pb.MultipartUpload,
        completeUpload *model.CompleteMultipartUpload) (*model.CompleteMultipartUploadResult, error) <span class="cov0" title="0">{
        bucket := ad.backend.BucketName
        result := model.CompleteMultipartUploadResult{}
        result.Bucket = multipartUpload.Bucket
        result.Key = multipartUpload.Key
        result.Location = ad.backend.Name
        log.Infof("complete multipart upload[Azure Blob], bucket:%s, objectId:%s\n", bucket, multipartUpload.ObjectId)

        blobURL := ad.containerURL.NewBlockBlobURL(multipartUpload.ObjectId)
        var completeParts []string
        for _, p := range completeUpload.Parts </span><span class="cov0" title="0">{
                base64ID := ad.Int64ToBase64(p.PartNumber)
                completeParts = append(completeParts, base64ID)
        }</span>
        <span class="cov0" title="0">log.Debugf("commit block list, blobURL:%+v, completeParts:%+v\n", blobURL, completeParts)
        _, err := blobURL.CommitBlockList(ctx, completeParts, azblob.BlobHTTPHeaders{}, azblob.Metadata{}, azblob.BlobAccessConditions{})
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("commit blocks[bucket:%s, objectId:%s] failed:%v\n", bucket, multipartUpload.ObjectId, err)
                return nil, ErrBackendCompleteMultipartFailed
        }</span> else<span class="cov0" title="0"> {
                storClass, err := osdss3.GetNameFromTier(multipartUpload.Tier, utils.OSTYPE_Azure)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("translate tier[%d] to aws storage class failed\n", multipartUpload.Tier)
                        return nil, ErrInternalError
                }</span>

                // set tier
                <span class="cov0" title="0">_, err = blobURL.SetTier(ctx, azblob.AccessTierType(storClass), azblob.LeaseAccessConditions{})
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("set blob[objectId:%s] tier failed:%v\n", multipartUpload.ObjectId, err)
                        return nil, ErrBackendCompleteMultipartFailed
                }</span>
        }

        <span class="cov0" title="0">log.Infof("complete multipart upload[Azure Blob], bucket:%s, objectId:%s succeed\n",
                bucket, multipartUpload.ObjectId)
        return &amp;result, nil</span>
}

func (ad *AzureAdapter) AbortMultipartUpload(ctx context.Context, multipartUpload *pb.MultipartUpload) error <span class="cov0" title="0">{
        bucket := ad.backend.BucketName
        log.Infof("no need to abort multipart upload[objkey:%s].\n", bucket)
        return nil
}</span>

func (ad *AzureAdapter) ListParts(ctx context.Context, multipartUpload *pb.ListParts) (*model.ListPartsOutput, error) <span class="cov0" title="0">{
        return nil, ErrNotImplemented
}</span>

func (ad *AzureAdapter) Close() error <span class="cov0" title="0">{
        // TODO:
        return nil
}</span>
</pre>
		
		<pre class="file" id="file69" style="display: none">package azure

import (
        "github.com/soda/multi-cloud/backend/pkg/utils/constants"
        "github.com/soda/multi-cloud/s3/pkg/datastore/driver"
        backendpb "github.com/soda/multi-cloud/backend/proto"
)

type AzureBlobDriverFactory struct {
}

func (factory *AzureBlobDriverFactory) CreateDriver(backend *backendpb.BackendDetail) (driver.StorageDriver, error) <span class="cov0" title="0">{
        endpoint := backend.Endpoint
        AccessKeyID := backend.Access
        AccessKeySecret := backend.Security
        ad := AzureAdapter{}
        containerURL, err := ad.createContainerURL(endpoint, AccessKeyID, AccessKeySecret)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">adap := &amp;AzureAdapter{backend: backend, containerURL: containerURL}

        return adap, nil</span>
}

func init() <span class="cov8" title="1">{
        driver.RegisterDriverFactory(constants.BackendTypeAzure, &amp;AzureBlobDriverFactory{})
}</span>
</pre>
		
		<pre class="file" id="file70" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package ceph

import (
        "bytes"
        "context"
        "fmt"
        "io"
        "io/ioutil"
        "time"

        "crypto/md5"
        "encoding/hex"
        backendpb "github.com/soda/multi-cloud/backend/proto"
        . "github.com/soda/multi-cloud/s3/error"
        dscommon "github.com/soda/multi-cloud/s3/pkg/datastore/common"
        "github.com/soda/multi-cloud/s3/pkg/model"
        "github.com/soda/multi-cloud/s3/pkg/utils"
        pb "github.com/soda/multi-cloud/s3/proto"
        log "github.com/sirupsen/logrus"
        "github.com/webrtcn/s3client"
        . "github.com/webrtcn/s3client"
        "github.com/webrtcn/s3client/models"
)

type CephAdapter struct {
        backend *backendpb.BackendDetail
        session *s3client.Client
}

func (ad *CephAdapter) Put(ctx context.Context, stream io.Reader, object *pb.Object) (result dscommon.PutResult, err error) <span class="cov0" title="0">{
        bucketName := ad.backend.BucketName
        objectId := object.BucketName + "/" + object.ObjectKey
        log.Infof("put object[Ceph S3], bucket:%s, objectId:%s\n", bucketName, objectId)

        userMd5 := dscommon.GetMd5FromCtx(ctx)
        size := object.Size

        // Limit the reader to its provided size if specified.
        var limitedDataReader io.Reader
        if size &gt; 0 </span><span class="cov0" title="0">{ // request.ContentLength is -1 if length is unknown
                limitedDataReader = io.LimitReader(stream, size)
        }</span> else<span class="cov0" title="0"> {
                limitedDataReader = stream
        }</span>
        <span class="cov0" title="0">md5Writer := md5.New()
        dataReader := io.TeeReader(limitedDataReader, md5Writer)

        bucket := ad.session.NewBucket()
        cephObject := bucket.NewObject(bucketName)
        body := ioutil.NopCloser(dataReader)
        log.Infof("put object[Ceph S3] begin, objectId:%s\n", objectId)
        err = cephObject.Create(objectId, userMd5, "", object.Size, body, models.Private)
        log.Infof("put object[Ceph S3] end, objectId:%s\n", objectId)
        if err != nil </span><span class="cov0" title="0">{
                log.Infof("upload object[Ceph S3] failed, objectId:%s, err:%v", objectId, err)
                return result, ErrPutToBackendFailed
        }</span>

        <span class="cov0" title="0">calculatedMd5 := "\"" + hex.EncodeToString(md5Writer.Sum(nil)) + "\""
        if userMd5 != "" &amp;&amp; userMd5 != calculatedMd5 </span><span class="cov0" title="0">{
                log.Error("### MD5 not match, calculatedMd5:", calculatedMd5, "userMd5:", userMd5)
                return result, ErrBadDigest
        }</span>

        <span class="cov0" title="0">result.UpdateTime = time.Now().Unix()
        result.ObjectId = objectId
        result.Etag = calculatedMd5
        result.Written = size
        log.Infof("upload object[Ceph S3] succeed, objectId:%s, UpdateTime is:%v, etag:\n", objectId,
                result.UpdateTime, result.Etag)

        return result, nil</span>
}

func (ad *CephAdapter) Get(ctx context.Context, object *pb.Object, start int64, end int64) (io.ReadCloser, error) <span class="cov0" title="0">{
        log.Infof("get object[Ceph S3], bucket:%s, objectId:%s\n", object.BucketName, object.ObjectId)

        getObjectOption := GetObjectOption{}
        if start != 0 || end != 0 </span><span class="cov0" title="0">{
                rangeObj := Range{
                        Begin: start,
                        End:   end,
                }
                getObjectOption = GetObjectOption{
                        Range: &amp;rangeObj,
                }
        }</span>

        <span class="cov0" title="0">bucket := ad.session.NewBucket()
        cephObject := bucket.NewObject(ad.backend.BucketName)
        getObject, err := cephObject.Get(object.ObjectId, &amp;getObjectOption)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println(err)
                log.Infof("get object[Ceph S3], objectId:%s failed:%v", object.ObjectId, err)
                return nil, ErrGetFromBackendFailed
        }</span>

        <span class="cov0" title="0">log.Infof("get object[Ceph S3] succeed, objectId:%s, bytes:%d\n", object.ObjectId, getObject.ContentLength)
        return getObject.Body, nil</span>
}

func (ad *CephAdapter) Delete(ctx context.Context, object *pb.DeleteObjectInput) error <span class="cov0" title="0">{
        bucket := ad.session.NewBucket()
        objectId := object.Bucket + "/" + object.Key
        log.Infof("delete object[Ceph S3], objectId:%s, bucket:%s\n", objectId, bucket)

        cephObject := bucket.NewObject(ad.backend.BucketName)
        err := cephObject.Remove(objectId)
        if err != nil </span><span class="cov0" title="0">{
                log.Infof("delete object[Ceph S3] failed, objectId:%s, err:%v\n", objectId, err)
                return ErrDeleteFromBackendFailed
        }</span>

        <span class="cov0" title="0">log.Infof("delete object[Ceph S3] succeed, objectId:%s.\n", objectId)
        return nil</span>
}

func (ad *CephAdapter) Copy(ctx context.Context, stream io.Reader, target *pb.Object) (result dscommon.PutResult, err error) <span class="cov0" title="0">{
        log.Errorf("copy[Ceph S3] is not supported.")
        err = ErrInternalError
        return
}</span>

func (ad *CephAdapter) ChangeStorageClass(ctx context.Context, object *pb.Object, newClass *string) error <span class="cov0" title="0">{
        log.Errorf("change storage class[Ceph S3] is not supported.")
        return ErrInternalError
}</span>

/*func (ad *CephAdapter) GetObjectInfo(context context.Context, bucketName string, key string) (*pb.Object, error) {
        bucket := ad.backend.BucketName
        newKey := bucketName + "/" + key

        bucketO := ad.session.NewBucket()
        bucketResp, err := bucketO.Get(bucket, newKey, "", "", 1000)
        if err != nil {
                log.Infof("error occured during get Object Info, err:%v\n", err)
                return nil, err
        }

        for _, content := range bucketResp.Contents {
                realKey := bucketName + "/" + key
                if realKey != content.Key {
                        break
                }
                obj := &amp;pb.Object{
                        BucketName: bucketName,
                        ObjectKey:  key,
                        Size:       content.Size,
                }

                return obj, nil
        }

        log.Infof("can not find specified object(%s).\n", key)
        return nil, NoSuchObject.Error()
}*/

func (ad *CephAdapter) InitMultipartUpload(ctx context.Context, object *pb.Object) (*pb.MultipartUpload, error) <span class="cov0" title="0">{
        bucket := ad.session.NewBucket()
        objectId := object.BucketName + "/" + object.ObjectKey
        log.Infof("init multipart upload[Ceph S3], bucket = %v,objectId = %v\n", bucket, objectId)
        cephObject := bucket.NewObject(ad.backend.BucketName)
        uploader := cephObject.NewUploads(objectId)
        multipartUpload := &amp;pb.MultipartUpload{}

        res, err := uploader.Initiate(nil)

        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("init multipart upload[Ceph S3] failed, objectId:%s, err:%v\n", objectId, err)
                return nil, err
        }</span> else<span class="cov0" title="0"> {
                log.Infof("init multipart upload[Ceph S3] succeed, objectId:%s, UploadId:%s\n", objectId, res.UploadID)
                multipartUpload.Bucket = object.BucketName
                multipartUpload.Key = object.ObjectKey
                multipartUpload.UploadId = res.UploadID
                multipartUpload.ObjectId = objectId
                return multipartUpload, nil
        }</span>
}

func (ad *CephAdapter) UploadPart(ctx context.Context, stream io.Reader, multipartUpload *pb.MultipartUpload,
        partNumber int64, upBytes int64) (*model.UploadPartResult, error) <span class="cov0" title="0">{
        bucket := ad.session.NewBucket()
        log.Infof("upload part[Ceph S3], objectId:%s, bucket:%s\n", multipartUpload.ObjectId, bucket)

        cephObject := bucket.NewObject(ad.backend.BucketName)
        uploader := cephObject.NewUploads(multipartUpload.ObjectId)

        d, err := ioutil.ReadAll(stream)
        data := []byte(d)
        body := ioutil.NopCloser(bytes.NewReader(data))
        contentMD5 := utils.Md5Content(data)
        part, err := uploader.UploadPart(int(partNumber), multipartUpload.UploadId, contentMD5, "", upBytes, body)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("upload part[Ceph S3] failed, err:%v\n", err)
                return nil, ErrPutToBackendFailed
        }</span> else<span class="cov0" title="0"> {
                log.Infof("uploaded part[Ceph S3] #%d successfully, ETag:%s\n", partNumber, part.Etag)
                result := &amp;model.UploadPartResult{
                        Xmlns:      model.Xmlns,
                        ETag:       part.Etag,
                        PartNumber: partNumber}
                return result, nil
        }</span>

        <span class="cov0" title="0">log.Error("upload part[Ceph S3]: should not be here.")
        return nil, ErrInternalError</span>
}

func (ad *CephAdapter) CompleteMultipartUpload(ctx context.Context, multipartUpload *pb.MultipartUpload,
        completeUpload *model.CompleteMultipartUpload) (*model.CompleteMultipartUploadResult, error) <span class="cov0" title="0">{
        bucket := ad.session.NewBucket()
        log.Infof("complete multipart upload[Ceph S3], objectId:%s, bucket:%s\n", multipartUpload.ObjectId, bucket)

        cephObject := bucket.NewObject(ad.backend.BucketName)
        uploader := cephObject.NewUploads(multipartUpload.ObjectId)
        var completeParts []CompletePart
        for _, p := range completeUpload.Parts </span><span class="cov0" title="0">{
                completePart := CompletePart{
                        Etag:       p.ETag,
                        PartNumber: int(p.PartNumber),
                }
                completeParts = append(completeParts, completePart)
        }</span>
        <span class="cov0" title="0">resp, err := uploader.Complete(multipartUpload.UploadId, completeParts)
        if err != nil </span><span class="cov0" title="0">{
                log.Infof("complete multipart upload[Ceph S3] failed, objectId:%s, err:%v\n", multipartUpload.ObjectId, err)
                return nil, ErrBackendCompleteMultipartFailed
        }</span>
        <span class="cov0" title="0">result := &amp;model.CompleteMultipartUploadResult{
                Xmlns:    model.Xmlns,
                Location: ad.backend.Endpoint,
                Bucket:   multipartUpload.Bucket,
                Key:      multipartUpload.Key,
                ETag:     resp.Etag,
        }

        log.Infof("complete multipart upload[Ceph S3] succeed, objectId:%s, resp:%v\n", multipartUpload.ObjectId, resp)
        return result, nil</span>
}

func (ad *CephAdapter) AbortMultipartUpload(ctx context.Context, multipartUpload *pb.MultipartUpload) error <span class="cov0" title="0">{
        bucket := ad.session.NewBucket()
        cephObject := bucket.NewObject(ad.backend.BucketName)
        uploader := cephObject.NewUploads(multipartUpload.ObjectId)
        log.Infof("abort multipart upload[Ceph S3], objectId:%s, bucket:%s\n", multipartUpload.ObjectId, bucket)

        err := uploader.RemoveUploads(multipartUpload.UploadId)
        if err != nil </span><span class="cov0" title="0">{
                log.Infof("abort multipart upload[Ceph S3] failed, objectId:%s, err:%v\n", multipartUpload.ObjectId, err)
                return ErrBackendAbortMultipartFailed
        }</span> else<span class="cov0" title="0"> {
                log.Infof("abort multipart upload[Ceph S3] succeed, objectId:%s, err:%v\n", multipartUpload.ObjectId, err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

/*func (ad *CephAdapter) ListParts(context context.Context, listParts *pb.ListParts) (*model.ListPartsOutput, error) {
        newObjectKey := listParts.Bucket + "/" + listParts.Key
        bucket := ad.session.NewBucket()
        cephObject := bucket.NewObject(ad.backend.BucketName)
        uploader := cephObject.NewUploads(newObjectKey)

        listPartsResult, err := uploader.ListPart(listParts.UploadId)
        if err != nil {
                log.Infof("list parts failed, err:%v\n", err)
                return nil, S3Error{Code: 500, Description: err.Error()}.Error()
        } else {
                log.Infof("List parts successful\n")
                var parts []model.Part
                for _, p := range listPartsResult.Parts {
                        part := model.Part{
                                ETag:       p.Etag,
                                PartNumber: int64(p.PartNumber),
                        }
                        parts = append(parts, part)
                }
                listPartsOutput := &amp;model.ListPartsOutput{
                        Xmlns:       model.Xmlns,
                        Key:         listPartsResult.Key,
                        Bucket:      listParts.Bucket,
                        IsTruncated: listPartsResult.IsTruncated,
                        MaxParts:    listPartsResult.MaxParts,
                        Owner: model.Owner{
                                ID:          listPartsResult.Owner.OwnerID,
                                DisplayName: listPartsResult.Owner.DisplayName,
                        },
                        UploadId: listPartsResult.UploadID,
                        Parts:    parts,
                }

                return listPartsOutput, nil
        }
}*/

func (ad *CephAdapter) ListParts(ctx context.Context, multipartUpload *pb.ListParts) (*model.ListPartsOutput, error) <span class="cov0" title="0">{
        return nil, ErrNotImplemented
}</span>

func (ad *CephAdapter) Close() error <span class="cov0" title="0">{
        // TODO
        return nil
}</span>
</pre>
		
		<pre class="file" id="file71" style="display: none">package ceph

import (
        backendpb "github.com/soda/multi-cloud/backend/proto"
        "github.com/soda/multi-cloud/s3/pkg/datastore/driver"
        "github.com/webrtcn/s3client"
        "github.com/soda/multi-cloud/backend/pkg/utils/constants"
)

type CephS3DriverFactory struct {
}

func (cdf *CephS3DriverFactory) CreateDriver(backend *backendpb.BackendDetail) (driver.StorageDriver, error) <span class="cov0" title="0">{
        endpoint := backend.Endpoint
        AccessKeyID := backend.Access
        AccessKeySecret := backend.Security
        sess := s3client.NewClient(endpoint, AccessKeyID, AccessKeySecret)
        adap := &amp;CephAdapter{backend: backend, session: sess}

        return adap, nil
}</span>

func init() <span class="cov8" title="1">{
        driver.RegisterDriverFactory(constants.BackendTypeCeph, &amp;CephS3DriverFactory{})
}</span>
</pre>
		
		<pre class="file" id="file72" style="display: none">package common

import (
        "context"
)

func GetMd5FromCtx(ctx context.Context) (md5val string) <span class="cov8" title="1">{
        // md5 provided by user for uploading object.
        if val := ctx.Value(CONTEXT_KEY_MD5); val != nil </span><span class="cov8" title="1">{
                md5val = val.(string)
        }</span>

        <span class="cov8" title="1">return</span>
}

func TrimQuot(in string) string <span class="cov0" title="0">{
        s := in
        l := len(s)
        if l &lt;= 0 </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">if s[l-1] == '"' </span><span class="cov0" title="0">{
                s = s[:l-1]
        }</span>
        <span class="cov0" title="0">if s[0] == '"' </span><span class="cov0" title="0">{
                s = s[1:]
        }</span>

        <span class="cov0" title="0">return s</span>
}
</pre>
		
		<pre class="file" id="file73" style="display: none">package driver

type Closer interface {
        Close()
}

var closers []Closer

func AddCloser(closer Closer) <span class="cov8" title="1">{
        closers = append(closers, closer)
}</span>

func FreeCloser() <span class="cov8" title="1">{
        for _, c := range closers </span><span class="cov8" title="1">{
                c.Close()
        }</span>
}
</pre>
		
		<pre class="file" id="file74" style="display: none">package driver

import (
        backendpb "github.com/soda/multi-cloud/backend/proto"
        exp "github.com/soda/multi-cloud/s3/pkg/exception"
)

type DriverFactory interface {
        CreateDriver(detail *backendpb.BackendDetail) (StorageDriver, error)
}

var driverFactoryMgr = make(map[string]DriverFactory)

func RegisterDriverFactory(driverType string, factory DriverFactory) <span class="cov8" title="1">{
        driverFactoryMgr[driverType] = factory
}</span>

func CreateStorageDriver(driverType string, detail *backendpb.BackendDetail) (StorageDriver, error) <span class="cov8" title="1">{
        if factory, ok := driverFactoryMgr[driverType]; ok </span><span class="cov8" title="1">{
                return factory.CreateDriver(detail)
        }</span>
        <span class="cov0" title="0">return nil, exp.NoSuchType.Error()</span>
}
</pre>
		
		<pre class="file" id="file75" style="display: none">package hws

import (
        "github.com/soda/multi-cloud/s3/pkg/datastore/driver"
        "github.com/soda/multi-cloud/api/pkg/utils/obs"
        backendpb "github.com/soda/multi-cloud/backend/proto"
        "github.com/soda/multi-cloud/backend/pkg/utils/constants"
)

type HWObsDriverFactory struct {

}

func (cdf *HWObsDriverFactory) CreateDriver(backend *backendpb.BackendDetail) (driver.StorageDriver, error) <span class="cov0" title="0">{
        endpoint := backend.Endpoint
        AccessKeyID := backend.Access
        AccessKeySecret := backend.Security

        client, err := obs.New(AccessKeyID, AccessKeySecret, endpoint)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">adap := &amp;OBSAdapter{backend: backend, client: client}

        return adap, nil</span>
}

func init() <span class="cov8" title="1">{
        driver.RegisterDriverFactory(constants.BackendTypeObs, &amp;HWObsDriverFactory{})
}</span>
</pre>
		
		<pre class="file" id="file76" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package hws

import (
        "context"
        "io"
        "time"

        "encoding/base64"
        "encoding/hex"
        "github.com/soda/multi-cloud/api/pkg/utils/obs"
        backendpb "github.com/soda/multi-cloud/backend/proto"
        . "github.com/soda/multi-cloud/s3/error"
        dscommon "github.com/soda/multi-cloud/s3/pkg/datastore/common"
        "github.com/soda/multi-cloud/s3/pkg/model"
        osdss3 "github.com/soda/multi-cloud/s3/pkg/service"
        "github.com/soda/multi-cloud/s3/pkg/utils"
        pb "github.com/soda/multi-cloud/s3/proto"
        log "github.com/sirupsen/logrus"
)

type OBSAdapter struct {
        backend *backendpb.BackendDetail
        client  *obs.ObsClient
}

func (ad *OBSAdapter) Put(ctx context.Context, stream io.Reader, object *pb.Object) (dscommon.PutResult, error) <span class="cov0" title="0">{
        bucket := ad.backend.BucketName
        objectId := object.BucketName + "/" + object.ObjectKey
        result := dscommon.PutResult{}
        userMd5 := dscommon.GetMd5FromCtx(ctx)
        size := object.Size
        log.Infof("put object[OBS], objectId:%s, bucket:%s, size=%d, userMd5=%s\n", objectId, bucket, size, userMd5)

        if object.Tier == 0 </span><span class="cov0" title="0">{
                // default
                object.Tier = utils.Tier1
        }</span>
        <span class="cov0" title="0">storClass, err := osdss3.GetNameFromTier(object.Tier, utils.OSTYPE_OBS)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("translate tier[%d] to aws storage class failed\n", object.Tier)
                return result, ErrInternalError
        }</span>

        <span class="cov0" title="0">input := &amp;obs.PutObjectInput{}
        input.Bucket = bucket
        input.Key = objectId
        input.Body = stream
        input.ContentLength = size
        input.StorageClass = obs.StorageClassType(storClass)
        if userMd5 != "" </span><span class="cov0" title="0">{
                md5Bytes, err := hex.DecodeString(userMd5)
                if err != nil </span><span class="cov0" title="0">{
                        log.Warnf("user input md5 is abandoned, cause decode md5 failed, err:%v\n", err)
                }</span> else<span class="cov0" title="0"> {
                        input.ContentMD5 = base64.StdEncoding.EncodeToString(md5Bytes)
                        log.Debugf("input.ContentMD5=%s\n", input.ContentMD5)
                }</span>
        }

        <span class="cov0" title="0">log.Infof("upload object[OBS] begin, objectId:%s\n", objectId)
        out, err := ad.client.PutObject(input)
        log.Infof("upload object[OBS] end, objectId:%s\n", objectId)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("upload object[OBS] failed, objectId:%s, err:%v", objectId, err)
                return result, ErrPutToBackendFailed
        }</span>

        <span class="cov0" title="0">result.Etag = dscommon.TrimQuot(out.ETag)
        if userMd5 != "" &amp;&amp; userMd5 != result.Etag </span><span class="cov0" title="0">{
                log.Error("### MD5 not match, result.Etag:", result.Etag, ", userMd5:", userMd5)
                return result, ErrBadDigest
        }</span>

        <span class="cov0" title="0">result.ObjectId = objectId
        result.UpdateTime = time.Now().Unix()
        result.Meta = out.VersionId
        result.Written = size
        log.Infof("upload object[OBS] succeed, objectId:%s, UpdateTime is:%v\n", objectId, result.UpdateTime)

        return result, nil</span>
}

func (ad *OBSAdapter) Get(ctx context.Context, object *pb.Object, start int64, end int64) (io.ReadCloser, error) <span class="cov0" title="0">{
        bucket := ad.backend.BucketName
        objectId := object.ObjectId
        log.Infof("get object[OBS], objectId:%s, bucket:%s\n", objectId, bucket)

        input := &amp;obs.GetObjectInput{}
        input.Bucket = bucket
        input.Key = objectId
        if start != 0 || end != 0 </span><span class="cov0" title="0">{
                input.RangeStart = start
                input.RangeEnd = end
        }</span>

        <span class="cov0" title="0">out, err := ad.client.GetObject(input)
        if err != nil </span><span class="cov0" title="0">{
                log.Infof("get object[OBS] failed, objectId:%,s err:%v", objectId, err)
                return nil, ErrGetFromBackendFailed
        }</span>

        <span class="cov0" title="0">log.Infof("get object[OBS] succeed, objectId:%s\n", objectId)
        return out.Body, nil</span>
}

func (ad *OBSAdapter) Delete(ctx context.Context, object *pb.DeleteObjectInput) error <span class="cov0" title="0">{
        objectId := object.Bucket + "/" + object.Key
        log.Infof("delete object[OBS], objectId:%s\n", objectId)

        deleteObjectInput := obs.DeleteObjectInput{Bucket: ad.backend.BucketName, Key: objectId}
        _, err := ad.client.DeleteObject(&amp;deleteObjectInput)
        if err != nil </span><span class="cov0" title="0">{
                log.Infof("delete object[OBS] failed, objectId:%s, :%v", objectId, err)
                return ErrDeleteFromBackendFailed
        }</span>

        <span class="cov0" title="0">log.Infof("delete object[OBS] succeed, objectId:%s.\n", objectId)
        return nil</span>
}

func (ad *OBSAdapter) ChangeStorageClass(ctx context.Context, object *pb.Object, newClass *string) error <span class="cov0" title="0">{
        log.Infof("change storage class[OBS] of object[%s] to %s .\n", object.ObjectId, newClass)

        input := &amp;obs.CopyObjectInput{}
        input.Bucket = ad.backend.BucketName
        input.Key = object.ObjectId
        input.CopySourceBucket = ad.backend.BucketName
        input.CopySourceKey = object.ObjectId
        input.MetadataDirective = obs.CopyMetadata
        switch *newClass </span>{
        case "STANDARD_IA":<span class="cov0" title="0">
                input.StorageClass = obs.StorageClassWarm</span>
        case "GLACIER":<span class="cov0" title="0">
                input.StorageClass = obs.StorageClassCold</span>
        default:<span class="cov0" title="0">
                log.Infof("[OBS] unspport storage class:%s", newClass)
                return ErrInvalidStorageClass</span>
        }
        <span class="cov0" title="0">_, err := ad.client.CopyObject(input)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("[OBS] change storage class of object[%s] to %s failed: %v\n", object.ObjectId, newClass, err)
                return ErrPutToBackendFailed
        }</span> else<span class="cov0" title="0"> {
                log.Infof("[OBS] change storage class of object[%s] to %s succeed.\n", object.ObjectId, newClass)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (ad *OBSAdapter) Copy(ctx context.Context, stream io.Reader, target *pb.Object) (result dscommon.PutResult, err error) <span class="cov0" title="0">{
        return
}</span>

/*func (ad *OBSAdapter) GetObjectInfo(bucketName string, key string, context context.Context) (*pb.Object, S3Error) {
        return nil, nil
}*/

func (ad *OBSAdapter) InitMultipartUpload(ctx context.Context, object *pb.Object) (*pb.MultipartUpload, error) <span class="cov0" title="0">{
        bucket := ad.backend.BucketName
        objectId := object.BucketName + "/" + object.ObjectKey
        multipartUpload := &amp;pb.MultipartUpload{}
        log.Infof("init multipart upload[OBS], objectId:%s, bucket:%s\n", objectId, bucket)

        input := &amp;obs.InitiateMultipartUploadInput{}
        input.Bucket = bucket
        input.Key = objectId
        storClass, err := osdss3.GetNameFromTier(object.Tier, utils.OSTYPE_OBS)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("translate tier[%d] to obs storage class failed\n", object.Tier)
                return nil, ErrInternalError
        }</span>
        <span class="cov0" title="0">input.StorageClass = obs.StorageClassType(storClass)

        out, err := ad.client.InitiateMultipartUpload(input)
        if err != nil </span><span class="cov0" title="0">{
                log.Infof("init multipart upload[OBS] failed, objectId:%s, err:%v", objectId, err)
                return nil, ErrBackendInitMultipartFailed
        }</span>

        <span class="cov0" title="0">multipartUpload.Bucket = out.Bucket
        multipartUpload.Key = out.Key
        multipartUpload.UploadId = out.UploadId
        multipartUpload.ObjectId = objectId
        log.Infof("init multipart upload[OBS] succeed, objectId:%s\n", objectId)
        return multipartUpload, nil</span>
}

func (ad *OBSAdapter) UploadPart(ctx context.Context, stream io.Reader, multipartUpload *pb.MultipartUpload,
        partNumber int64, upBytes int64) (*model.UploadPartResult, error) <span class="cov0" title="0">{
        bucket := ad.backend.BucketName
        objectId := multipartUpload.Bucket + "/" + multipartUpload.Key
        log.Infof("upload part[OBS], objectId:%s, partNum:%d, bytes:%d\n", objectId, partNumber, upBytes)

        input := &amp;obs.UploadPartInput{}
        input.Bucket = bucket
        input.Key = objectId
        input.Body = stream
        input.PartNumber = int(partNumber)
        input.PartSize = upBytes
        log.Infof(" multipartUpload.UploadId is %v", multipartUpload.UploadId)
        input.UploadId = multipartUpload.UploadId
        out, err := ad.client.UploadPart(input)

        if err != nil </span><span class="cov0" title="0">{
                log.Infof("upload part[OBS] failed, objectId:%s, err:%v", objectId, err)
                return nil, ErrPutToBackendFailed
        }</span>

        <span class="cov0" title="0">log.Infof("upload part[OBS] succeed, objectId:%s, partNum:%d\n", objectId, out.PartNumber)
        result := &amp;model.UploadPartResult{ETag: out.ETag, PartNumber: partNumber}

        return result, nil</span>
}

func (ad *OBSAdapter) CompleteMultipartUpload(ctx context.Context, multipartUpload *pb.MultipartUpload,
        completeUpload *model.CompleteMultipartUpload) (*model.CompleteMultipartUploadResult, error) <span class="cov0" title="0">{
        bucket := ad.backend.BucketName
        objectId := multipartUpload.Bucket + "/" + multipartUpload.Key
        log.Infof("complete multipart upload[OBS], objectId:%s, bucket:%s\n", objectId, bucket)

        input := &amp;obs.CompleteMultipartUploadInput{}
        input.Bucket = bucket
        input.Key = objectId
        input.UploadId = multipartUpload.UploadId
        for _, p := range completeUpload.Parts </span><span class="cov0" title="0">{
                part := obs.Part{
                        PartNumber: int(p.PartNumber),
                        ETag:       p.ETag,
                }
                input.Parts = append(input.Parts, part)
        }</span>
        <span class="cov0" title="0">resp, err := ad.client.CompleteMultipartUpload(input)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("complete multipart upload[OBS] failed, objectid:%s, err:%v\n", objectId, err)
                return nil, ErrBackendCompleteMultipartFailed
        }</span>
        <span class="cov0" title="0">result := &amp;model.CompleteMultipartUploadResult{
                Xmlns:    model.Xmlns,
                Location: resp.Location,
                Bucket:   resp.Bucket,
                Key:      resp.Key,
                ETag:     resp.ETag,
        }
        if err != nil </span><span class="cov0" title="0">{
                log.Infof("complete multipart upload[OBS] failed, objectid:%s, err:%v", objectId, err)
                return nil, ErrBackendCompleteMultipartFailed
        }</span>

        <span class="cov0" title="0">log.Infof("complete multipart upload[OBS] succeed, objectId:%s\n", objectId)
        return result, nil</span>
}

func (ad *OBSAdapter) AbortMultipartUpload(ctx context.Context, multipartUpload *pb.MultipartUpload) error <span class="cov0" title="0">{
        bucket := ad.backend.BucketName
        objectId := multipartUpload.Bucket + "/" + multipartUpload.Key
        log.Infof("abort multipart upload[OBS], objectId:%s, bucket:%s\n", objectId, bucket)

        input := &amp;obs.AbortMultipartUploadInput{}
        input.UploadId = multipartUpload.UploadId
        input.Bucket = bucket
        input.Key = objectId
        _, err := ad.client.AbortMultipartUpload(input)
        if err != nil </span><span class="cov0" title="0">{
                log.Infof("abort multipart upload[OBS] failed, objectId:%s, err:%v", objectId, err)
                return ErrBackendAbortMultipartFailed
        }</span>

        <span class="cov0" title="0">log.Infof("abort multipart upload[OBS] succeed, objectId:%s\n", objectId)
        return nil</span>
}

func (ad *OBSAdapter) ListParts(context context.Context, listParts *pb.ListParts) (*model.ListPartsOutput, error) <span class="cov0" title="0">{
        bucket := ad.backend.BucketName
        if context.Value("operation") == "listParts" </span><span class="cov0" title="0">{
                input := &amp;obs.ListPartsInput{}
                input.Bucket = bucket
                input.Key = listParts.Key
                input.UploadId = listParts.UploadId
                input.MaxParts = int(listParts.MaxParts)
                listPartsOutput, err := ad.client.ListParts(input)
                listParts := &amp;model.ListPartsOutput{}
                listParts.Bucket = listPartsOutput.Bucket
                listParts.Key = listPartsOutput.Key
                listParts.UploadId = listPartsOutput.UploadId
                listParts.MaxParts = listPartsOutput.MaxParts

                for _, p := range listPartsOutput.Parts </span><span class="cov0" title="0">{
                        part := model.Part{
                                PartNumber: int64(p.PartNumber),
                                ETag:       p.ETag,
                        }
                        listParts.Parts = append(listParts.Parts, part)
                }</span>

                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        log.Infof("ListPartsListParts is nil:%v\n", err)
                        return nil, err
                }</span> else<span class="cov0" title="0"> {
                        log.Infof("ListParts successfully")
                        return listParts, nil
                }</span>
        }
        <span class="cov0" title="0">return nil, nil</span>
}

func (ad *OBSAdapter) Close() error <span class="cov0" title="0">{
        //TODO
        return nil
}</span>
</pre>
		
		<pre class="file" id="file77" style="display: none">package ibmcos

import (
        "github.com/soda/multi-cloud/backend/pkg/utils/constants"
        backendpb "github.com/soda/multi-cloud/backend/proto"
        "github.com/soda/multi-cloud/s3/pkg/datastore/aws"
        "github.com/soda/multi-cloud/s3/pkg/datastore/driver"
)

type IBMCOSDriverFactory struct {
}

func (factory *IBMCOSDriverFactory) CreateDriver(backend *backendpb.BackendDetail) (driver.StorageDriver, error) <span class="cov8" title="1">{
        awss3Fac := &amp;aws.AwsS3DriverFactory{}
        return awss3Fac.CreateDriver(backend)
}</span>

func init() <span class="cov8" title="1">{
        driver.RegisterDriverFactory(constants.BackendTypeAws, &amp;IBMCOSDriverFactory{})
}</span>
</pre>
		
		<pre class="file" id="file78" style="display: none">package config

import (
        "errors"
        "strings"

        "github.com/spf13/viper"
)

const (
        DEFAULT_DB_MAX_IDLE_CONNS = 1024
        DEFAULT_DB_MAX_OPEN_CONNS = 1024
        DEFAULT_GC_CHECK_TIME     = 5
)

type Config struct {
        Endpoint   EndpointConfig
        Log        LogConfig
        StorageCfg StorageConfig
        Database   DatabaseConfig
}

func (config *Config) Parse() error <span class="cov8" title="1">{
        endpoint := viper.GetStringMap("endpoint")
        log := viper.GetStringMap("log")
        storageCfg := viper.GetStringMap("storage")
        db := viper.GetStringMap("database")

        (&amp;config.Endpoint).Parse(endpoint)
        (&amp;config.Log).Parse(log)
        (&amp;config.StorageCfg).Parse(storageCfg)
        (&amp;config.Database).Parse(db)

        return nil
}</span>

type CommonConfig struct {
        Log   LogConfig
        Cache CacheConfig
}

func (cc *CommonConfig) Parse() error <span class="cov0" title="0">{
        log := viper.GetStringMap("log")
        cache := viper.GetStringMap("cache")

        cc.Log.Parse(log)
        cc.Cache.Parse(cache)

        return nil
}</span>

type EndpointConfig struct {
        Url       string
        MachineId int
        // how frequency to perform a gc in seconds.
        GcCheckTime int64
}

func (ec *EndpointConfig) Parse(vals map[string]interface{}) error <span class="cov8" title="1">{
        ec.GcCheckTime = DEFAULT_GC_CHECK_TIME
        if url, ok := vals["url"]; ok </span><span class="cov8" title="1">{
                ec.Url = url.(string)
                return nil
        }</span> else<span class="cov0" title="0"> {
                return errors.New("no url found")
        }</span>

        <span class="cov0" title="0">if id, ok := vals["machine_id"]; ok </span><span class="cov0" title="0">{
                ec.MachineId = id.(int)
                return nil
        }</span> else<span class="cov0" title="0"> {
                return errors.New("no machine_id found")
        }</span>
        <span class="cov0" title="0">if gc, ok := vals["gc_check_time"]; ok </span><span class="cov0" title="0">{
                ec.GcCheckTime = gc.(int64)
                return nil
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type LogConfig struct {
        Path  string
        Level int
}

func (lc *LogConfig) Parse(vals map[string]interface{}) error <span class="cov8" title="1">{
        if p, ok := vals["log_path"]; ok </span><span class="cov8" title="1">{
                lc.Path = p.(string)
        }</span>
        <span class="cov8" title="1">if l, ok := vals["log_level"]; ok </span><span class="cov8" title="1">{
                lc.Level = int(l.(int64))
        }</span>
        <span class="cov8" title="1">return nil</span>
}

type StorageConfig struct {
        CephPath string
}

func (sc *StorageConfig) Parse(vals map[string]interface{}) error <span class="cov8" title="1">{
        if p, ok := vals["ceph_dir"]; ok </span><span class="cov8" title="1">{
                sc.CephPath = p.(string)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

type CacheConfig struct {
        Mode              int
        Nodes             []string
        Master            string
        Address           string
        Password          string
        ConnectionTimeout int
        ReadTimeout       int
        WriteTimeout      int
        KeepAlive         int
        PoolMaxIdle       int
        PoolIdleTimeout   int
}

func (cc *CacheConfig) Parse(vals map[string]interface{}) error <span class="cov0" title="0">{
        if m, ok := vals["redis_mode"]; ok </span><span class="cov0" title="0">{
                cc.Mode = int(m.(int64))
        }</span>
        <span class="cov0" title="0">if n, ok := vals["redis_nodes"]; ok </span><span class="cov0" title="0">{
                nodes := n.(string)
                cc.Nodes = strings.Split(nodes, ",")
        }</span>
        <span class="cov0" title="0">if master, ok := vals["redis_master_name"]; ok </span><span class="cov0" title="0">{
                cc.Master = master.(string)
        }</span>
        <span class="cov0" title="0">if addr, ok := vals["redis_address"]; ok </span><span class="cov0" title="0">{
                cc.Address = addr.(string)
        }</span>
        <span class="cov0" title="0">if password, ok := vals["redis_password"]; ok </span><span class="cov0" title="0">{
                cc.Password = password.(string)
        }</span>
        <span class="cov0" title="0">if ct, ok := vals["redis_connect_timeout"]; ok </span><span class="cov0" title="0">{
                cc.ConnectionTimeout = int(ct.(int64))
        }</span>
        <span class="cov0" title="0">if rt, ok := vals["redis_read_timeout"]; ok </span><span class="cov0" title="0">{
                cc.ReadTimeout = int(rt.(int64))
        }</span>
        <span class="cov0" title="0">if wt, ok := vals["redis_write_timeout"]; ok </span><span class="cov0" title="0">{
                cc.WriteTimeout = int(wt.(int64))
        }</span>
        <span class="cov0" title="0">if ka, ok := vals["redis_keepalive"]; ok </span><span class="cov0" title="0">{
                cc.KeepAlive = int(ka.(int64))
        }</span>
        <span class="cov0" title="0">if pa, ok := vals["redis_pool_max_idle"]; ok </span><span class="cov0" title="0">{
                cc.PoolMaxIdle = int(pa.(int64))
        }</span>
        <span class="cov0" title="0">if pt, ok := vals["redis_pool_idle_timeout"]; ok </span><span class="cov0" title="0">{
                cc.PoolIdleTimeout = int(pt.(int64))
        }</span>

        <span class="cov0" title="0">return nil</span>
}

type DatabaseConfig struct {
        DbType       string
        DbUrl        string
        DbPassword   string
        MaxIdleConns int
        MaxOpenConns int
}

func (dc *DatabaseConfig) Parse(vals map[string]interface{}) error <span class="cov8" title="1">{
        dc.MaxIdleConns = DEFAULT_DB_MAX_IDLE_CONNS
        dc.MaxOpenConns = DEFAULT_DB_MAX_OPEN_CONNS

        if dt, ok := vals["db_type"]; ok </span><span class="cov8" title="1">{
                dc.DbType = dt.(string)
        }</span>
        <span class="cov8" title="1">if du, ok := vals["db_url"]; ok </span><span class="cov8" title="1">{
                dc.DbUrl = du.(string)
        }</span>
        <span class="cov8" title="1">if dp, ok := vals["db_password"]; ok </span><span class="cov0" title="0">{
                dc.DbPassword = dp.(string)
        }</span>
        <span class="cov8" title="1">if mi, ok := vals["db_maxidleconns"]; ok </span><span class="cov0" title="0">{
                dc.MaxIdleConns = mi.(int)
        }</span>
        <span class="cov8" title="1">if mc, ok := vals["db_maxopenconns"]; ok </span><span class="cov0" title="0">{
                dc.MaxOpenConns = mc.(int)
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file79" style="display: none">package config

import (
        "os"
        "path/filepath"

        "github.com/spf13/viper"
)

type FuncConfigParse func(config *Config) error

func ReadCommonConfig(dir string) (*CommonConfig, error) <span class="cov0" title="0">{
        viper.AddConfigPath(dir)
        viper.SetConfigName("common")
        err := viper.ReadInConfig()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">cc := &amp;CommonConfig{}
        err = cc.Parse()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return cc, nil</span>
}

func ReadConfigs(dir string, funcConfigParse FuncConfigParse) error <span class="cov8" title="1">{
        err := filepath.Walk(dir, func(path string, info os.FileInfo, err error) error </span><span class="cov8" title="1">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if info.IsDir() </span><span class="cov8" title="1">{
                        return nil
                }</span>

                <span class="cov8" title="1">if info.Name() == "common.toml" </span><span class="cov8" title="1">{
                        return nil
                }</span>

                <span class="cov8" title="1">viper.SetConfigFile(path)
                err = viper.ReadInConfig()
                if err != nil </span><span class="cov0" title="0">{
                        // skip the config file which is failed to parse and continue the next one.
                        return nil
                }</span>
                <span class="cov8" title="1">config := &amp;Config{}
                err = config.Parse()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">err = funcConfigParse(config)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov0" title="0">return nil</span>
        })

        <span class="cov8" title="1">return err</span>
}
</pre>
		
		<pre class="file" id="file80" style="display: none">package config

import (
        "errors"
        "strings"
        "sync"

        "github.com/fsnotify/fsnotify"
        "github.com/spf13/viper"
)

const (
        CFG_SUFFIX = "toml"
)

type ConfigWatcher struct {
        FuncConfigParse FuncConfigParse
        watcher         *fsnotify.Watcher
        stopSignal      chan bool
        wg              sync.WaitGroup
        err             error
}

func (cw *ConfigWatcher) Error() error <span class="cov0" title="0">{
        return cw.err
}</span>

func (cw *ConfigWatcher) Stop() <span class="cov0" title="0">{
        cw.stopSignal &lt;- true
        close(cw.stopSignal)
        cw.wg.Wait()
        cw.watcher.Close()
}</span>

func (cw *ConfigWatcher) Watch(dir string) <span class="cov0" title="0">{
        mask := fsnotify.Write | fsnotify.Create
        cw.wg.Add(1)
        go func() </span><span class="cov0" title="0">{
                defer cw.wg.Done()
                for </span><span class="cov0" title="0">{
                        select </span>{
                        case event, ok := &lt;-cw.watcher.Events:<span class="cov0" title="0">
                                if !ok </span><span class="cov0" title="0">{
                                        cw.err = errors.New("failed to read watcher events.")
                                        return
                                }</span>
                                <span class="cov0" title="0">if event.Op&amp;mask != 0 </span><span class="cov0" title="0">{
                                        // got we need.
                                        if strings.HasSuffix(event.Name, CFG_SUFFIX) </span><span class="cov0" title="0">{
                                                viper.SetConfigFile(event.Name)
                                                err := viper.ReadInConfig()
                                                if err != nil </span><span class="cov0" title="0">{
                                                        cw.err = err
                                                        return
                                                }</span>
                                                <span class="cov0" title="0">cfg := &amp;Config{}
                                                err = cfg.Parse()
                                                if err != nil </span><span class="cov0" title="0">{
                                                        cw.err = err
                                                        return
                                                }</span>
                                                <span class="cov0" title="0">err = cw.FuncConfigParse(cfg)
                                                if err != nil </span><span class="cov0" title="0">{
                                                        cw.err = err
                                                        return
                                                }</span>
                                        }
                                }
                        case err := &lt;-cw.watcher.Errors:<span class="cov0" title="0">
                                if err != nil </span><span class="cov0" title="0">{
                                        cw.err = err
                                        return
                                }</span>
                        case stopped := &lt;-cw.stopSignal:<span class="cov0" title="0">
                                if stopped </span><span class="cov0" title="0">{
                                        cw.err = nil
                                        return
                                }</span>
                        }
                }
        }()
}

func NewConfigWatcher(funcConfigParse FuncConfigParse) (*ConfigWatcher, error) <span class="cov0" title="0">{
        watcher, err := fsnotify.NewWatcher()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">cw := &amp;ConfigWatcher{
                FuncConfigParse: funcConfigParse,
                watcher:         watcher,
                stopSignal:      make(chan bool),
                err:             nil,
        }
        return cw, nil</span>
}
</pre>
		
		<pre class="file" id="file81" style="display: none">package crypto

import (
        "github.com/soda/multi-cloud/s3/pkg/helper"
        log "github.com/sirupsen/logrus"
)

func NewKMS() KMS <span class="cov8" title="1">{
        switch helper.CONFIG.KMS.Type </span>{
        case "vault":<span class="cov0" title="0">
                c, err := NewVaultConfig()
                if err != nil </span><span class="cov0" title="0">{
                        panic("read kms vault err:" + err.Error())</span>
                }
                <span class="cov0" title="0">vault, err := NewVault(c)
                if err != nil </span><span class="cov0" title="0">{
                        panic("create vault err:" + err.Error())</span>
                }
                <span class="cov0" title="0">return vault</span>

        //extention case here

        default:<span class="cov8" title="1">
                log.Error("not support kms type", helper.CONFIG.KMS.Type)
                return nil</span>
        }
}
</pre>
		
		<pre class="file" id="file82" style="display: none">// Minio Cloud Storage, (C) 2015, 2016, 2017, 2018 Minio, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package crypto

import "errors"

// Error is the generic type for any error happening during decrypting
// an object. It indicates that the object itself or its metadata was
// modified accidentally or maliciously.
type Error struct{ msg string }

func (e Error) Error() string <span class="cov0" title="0">{ return e.msg }</span>

var (
        // ErrInvalidEncryptionMethod indicates that the specified SSE encryption method
        // is not supported.
        ErrInvalidEncryptionMethod = errors.New("The encryption method is not supported")

        // ErrInvalidCustomerAlgorithm indicates that the specified SSE-C algorithm
        // is not supported.
        ErrInvalidCustomerAlgorithm = errors.New("The SSE-C algorithm is not supported")

        // ErrMissingCustomerKey indicates that the HTTP headers contains no SSE-C client key.
        ErrMissingCustomerKey = errors.New("The SSE-C request is missing the customer key")

        // ErrMissingCustomerKeyMD5 indicates that the HTTP headers contains no SSE-C client key
        // MD5 checksum.
        ErrMissingCustomerKeyMD5 = errors.New("The SSE-C request is missing the customer key MD5")

        // ErrInvalidCustomerKey indicates that the SSE-C client key is not valid - e.g. not a
        // base64-encoded string or not 256 bits long.
        ErrInvalidCustomerKey = errors.New("The SSE-C client key is invalid")

        // ErrSecretKeyMismatch indicates that the provided secret key (SSE-C client key / SSE-S3 KMS key)
        // does not match the secret key used during encrypting the object.
        ErrSecretKeyMismatch = errors.New("The secret key does not match the secret key used during upload")

        // ErrCustomerKeyMD5Mismatch indicates that the SSE-C key MD5 does not match the
        // computed MD5 sum. This means that the client provided either the wrong key for
        // a certain MD5 checksum or the wrong MD5 for a certain key.
        ErrCustomerKeyMD5Mismatch = errors.New("The provided SSE-C key MD5 does not match the computed MD5 of the SSE-C key")
        // ErrIncompatibleEncryptionMethod indicates that both SSE-C headers and SSE-S3 headers were specified, and are incompatible
        // The client needs to remove the SSE-S3 header or the SSE-C headers
        ErrIncompatibleEncryptionMethod = errors.New("Server side encryption specified with both SSE-C and SSE-S3 headers")
)

var (
        errMissingInternalIV            = Error{"The object metadata is missing the internal encryption IV"}
        errMissingInternalSealAlgorithm = Error{"The object metadata is missing the internal seal algorithm"}

        errInvalidInternalIV            = Error{"The internal encryption IV is malformed"}
        errInvalidInternalSealAlgorithm = Error{"The internal seal algorithm is invalid and not supported"}
)

var (
        // errOutOfEntropy indicates that the a source of randomness (PRNG) wasn't able
        // to produce enough random data. This is fatal error and should cause a panic.
        errOutOfEntropy = errors.New("Unable to read enough randomness from the system")
)
</pre>
		
		<pre class="file" id="file83" style="display: none">// Minio Cloud Storage, (C) 2015, 2016, 2017, 2018 Minio, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package crypto

import (
        "bytes"
        "crypto/md5"
        "encoding/base64"
        "net/http"
        "strings"
)

// SSEHeader is the general AWS SSE HTTP header key.
const SSEHeader = "X-Amz-Server-Side-Encryption"

const (
        // SSEKmsID is the HTTP header key referencing the SSE-KMS
        // key ID.
        SSEKmsID = SSEHeader + "-Aws-Kms-Key-Id"

        // SSEKmsContext is the HTTP header key referencing the
        // SSE-KMS encryption context.
        SSEKmsContext = SSEHeader + "-Context"
)

const (
        // SSECAlgorithm is the HTTP header key referencing
        // the SSE-C algorithm.
        SSECAlgorithm = SSEHeader + "-Customer-Algorithm"

        // SSECKey is the HTTP header key referencing the
        // SSE-C client-provided key..
        SSECKey = SSEHeader + "-Customer-Key"

        // SSECKeyMD5 is the HTTP header key referencing
        // the MD5 sum of the client-provided key.
        SSECKeyMD5 = SSEHeader + "-Customer-Key-Md5"
)

const (
        // SSECopyAlgorithm is the HTTP header key referencing
        // the SSE-C algorithm for SSE-C copy requests.
        SSECopyAlgorithm = "X-Amz-Copy-Source-Server-Side-Encryption-Customer-Algorithm"

        // SSECopyKey is the HTTP header key referencing the SSE-C
        // client-provided key for SSE-C copy requests.
        SSECopyKey = "X-Amz-Copy-Source-Server-Side-Encryption-Customer-Key"

        // SSECopyKeyMD5 is the HTTP header key referencing the
        // MD5 sum of the client key for SSE-C copy requests.
        SSECopyKeyMD5 = "X-Amz-Copy-Source-Server-Side-Encryption-Customer-Key-Md5"
)

const (
        // SSEAlgorithmAES256 is the only supported value for the SSE-S3 or SSE-C algorithm header.
        // For SSE-S3 see: https://docs.aws.amazon.com/AmazonS3/latest/dev/SSEUsingRESTAPI.html
        // For SSE-C  see: https://docs.aws.amazon.com/AmazonS3/latest/dev/ServerSideEncryptionCustomerKeys.html
        SSEAlgorithmAES256 = "AES256"

        // SSEAlgorithmKMS is the value of 'X-Amz-Server-Side-Encryption' for SSE-KMS.
        // See: https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingKMSEncryption.html
        SSEAlgorithmKMS = "aws:kms"
)

// RemoveSensitiveHeaders removes confidential encryption
// information - e.g. the SSE-C key - from the HTTP headers.
// It has the same semantics as RemoveSensitiveEntires.
func RemoveSensitiveHeaders(h http.Header) <span class="cov0" title="0">{
        h.Del(SSECKey)
        h.Del(SSECopyKey)
}</span>

// S3 represents AWS SSE-S3. It provides functionality to handle
// SSE-S3 requests.
var S3 = s3{}

type s3 struct{}

// IsRequested returns true if the HTTP headers indicates that
// the S3 client requests SSE-S3.
func (s3) IsRequested(h http.Header) bool <span class="cov0" title="0">{
        _, ok := h[SSEHeader]
        return ok &amp;&amp; strings.ToLower(h.Get(SSEHeader)) != SSEAlgorithmKMS // Return only true if the SSE header is specified and does not contain the SSE-KMS value
}</span>

// ParseHTTP parses the SSE-S3 related HTTP headers and checks
// whether they contain valid values.
func (s3) ParseHTTP(h http.Header) (err error) <span class="cov0" title="0">{
        if h.Get(SSEHeader) != SSEAlgorithmAES256 </span><span class="cov0" title="0">{
                err = ErrInvalidEncryptionMethod
        }</span>
        <span class="cov0" title="0">return</span>
}

// S3KMS represents AWS SSE-KMS. It provides functionality to
// handle SSE-KMS requests.
var S3KMS = s3KMS{}

type s3KMS struct{}

// IsRequested returns true if the HTTP headers indicates that
// the S3 client requests SSE-KMS.
func (s3KMS) IsRequested(h http.Header) bool <span class="cov0" title="0">{
        if _, ok := h[SSEKmsID]; ok </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">if _, ok := h[SSEKmsContext]; ok </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">if _, ok := h[SSEHeader]; ok </span><span class="cov0" title="0">{
                return strings.ToUpper(h.Get(SSEHeader)) != SSEAlgorithmAES256 // Return only true if the SSE header is specified and does not contain the SSE-S3 value
        }</span>
        <span class="cov0" title="0">return false</span>
}

var (
        // SSEC represents AWS SSE-C. It provides functionality to handle
        // SSE-C requests.
        SSEC = ssec{}

        // SSECopy represents AWS SSE-C for copy requests. It provides
        // functionality to handle SSE-C copy requests.
        SSECopy = ssecCopy{}
)

type ssec struct{}
type ssecCopy struct{}

// IsRequested returns true if the HTTP headers contains
// at least one SSE-C header. SSE-C copy headers are ignored.
func (ssec) IsRequested(h http.Header) bool <span class="cov0" title="0">{
        if _, ok := h[SSECAlgorithm]; ok </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">if _, ok := h[SSECKey]; ok </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">if _, ok := h[SSECKeyMD5]; ok </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">return false</span>
}

// IsRequested returns true if the HTTP headers contains
// at least one SSE-C copy header. Regular SSE-C headers
// are ignored.
func (ssecCopy) IsRequested(h http.Header) bool <span class="cov0" title="0">{
        if _, ok := h[SSECopyAlgorithm]; ok </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">if _, ok := h[SSECopyKey]; ok </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">if _, ok := h[SSECopyKeyMD5]; ok </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">return false</span>
}

// ParseHTTP parses the SSE-C headers and returns the SSE-C client key
// on success. SSE-C copy headers are ignored.
func (ssec) ParseHTTP(h http.Header) (key [32]byte, err error) <span class="cov0" title="0">{
        if h.Get(SSECAlgorithm) != SSEAlgorithmAES256 </span><span class="cov0" title="0">{
                return key, ErrInvalidCustomerAlgorithm
        }</span>
        <span class="cov0" title="0">if h.Get(SSECKey) == "" </span><span class="cov0" title="0">{
                return key, ErrMissingCustomerKey
        }</span>
        <span class="cov0" title="0">if h.Get(SSECKeyMD5) == "" </span><span class="cov0" title="0">{
                return key, ErrMissingCustomerKeyMD5
        }</span>

        <span class="cov0" title="0">clientKey, err := base64.StdEncoding.DecodeString(h.Get(SSECKey))
        if err != nil || len(clientKey) != 32 </span><span class="cov0" title="0">{ // The client key must be 256 bits long
                return key, ErrInvalidCustomerKey
        }</span>
        <span class="cov0" title="0">keyMD5, err := base64.StdEncoding.DecodeString(h.Get(SSECKeyMD5))
        if md5Sum := md5.Sum(clientKey); err != nil || !bytes.Equal(md5Sum[:], keyMD5) </span><span class="cov0" title="0">{
                return key, ErrCustomerKeyMD5Mismatch
        }</span>
        <span class="cov0" title="0">copy(key[:], clientKey)
        return key, nil</span>
}

// ParseHTTP parses the SSE-C copy headers and returns the SSE-C client key
// on success. Regular SSE-C headers are ignored.
func (ssecCopy) ParseHTTP(h http.Header) (key [32]byte, err error) <span class="cov0" title="0">{
        if h.Get(SSECopyAlgorithm) != SSEAlgorithmAES256 </span><span class="cov0" title="0">{
                return key, ErrInvalidCustomerAlgorithm
        }</span>
        <span class="cov0" title="0">if h.Get(SSECopyKey) == "" </span><span class="cov0" title="0">{
                return key, ErrMissingCustomerKey
        }</span>
        <span class="cov0" title="0">if h.Get(SSECopyKeyMD5) == "" </span><span class="cov0" title="0">{
                return key, ErrMissingCustomerKeyMD5
        }</span>

        <span class="cov0" title="0">clientKey, err := base64.StdEncoding.DecodeString(h.Get(SSECopyKey))
        if err != nil || len(clientKey) != 32 </span><span class="cov0" title="0">{ // The client key must be 256 bits long
                return key, ErrInvalidCustomerKey
        }</span>
        <span class="cov0" title="0">keyMD5, err := base64.StdEncoding.DecodeString(h.Get(SSECopyKeyMD5))
        if md5Sum := md5.Sum(clientKey); err != nil || !bytes.Equal(md5Sum[:], keyMD5) </span><span class="cov0" title="0">{
                return key, ErrCustomerKeyMD5Mismatch
        }</span>
        <span class="cov0" title="0">copy(key[:], clientKey)
        return key, nil</span>
}
</pre>
		
		<pre class="file" id="file84" style="display: none">// Minio Cloud Storage, (C) 2015, 2016, 2017, 2018 Minio, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package crypto

import (
        "crypto/hmac"
        "crypto/rand"
        "crypto/sha256"
        "encoding/binary"
        "io"

        log "github.com/sirupsen/logrus"
)

// ObjectKey is a 256 bit secret key used to encrypt the object.
// It must never be stored in plaintext.
type ObjectKey [32]byte

// GenerateKey generates a unique ObjectKey from a 256 bit external key
// and a source of randomness. If random is nil the default PRNG of the
// system (crypto/rand) is used.
func GenerateKey(extKey [32]byte, random io.Reader) (key ObjectKey) <span class="cov0" title="0">{
        if random == nil </span><span class="cov0" title="0">{
                random = rand.Reader
        }</span>
        <span class="cov0" title="0">var nonce [32]byte
        if _, err := io.ReadFull(random, nonce[:]); err != nil </span><span class="cov0" title="0">{
                log.Error(errOutOfEntropy)
                return key
        }</span>
        <span class="cov0" title="0">sha := sha256.New()
        sha.Write(extKey[:])
        sha.Write(nonce[:])
        sha.Sum(key[:0])
        return key</span>
}

// SealedKey represents a sealed object key. It can be stored
// at an untrusted location.
type SealedKey struct {
        Key       [64]byte // The encrypted and authenticted object-key.
        IV        [32]byte // The random IV used to encrypt the object-key.
        Algorithm string   // The sealing algorithm used to encrypt the object key.
}

// DerivePartKey derives an unique 256 bit key from an ObjectKey and the part index.
func (key ObjectKey) DerivePartKey(id uint32) (partKey [32]byte) <span class="cov0" title="0">{
        var bin [4]byte
        binary.LittleEndian.PutUint32(bin[:], id)

        mac := hmac.New(sha256.New, key[:])
        mac.Write(bin[:])
        mac.Sum(partKey[:0])
        return partKey
}</span>
</pre>
		
		<pre class="file" id="file85" style="display: none">// Minio Cloud Storage, (C) 2015, 2016, 2017, 2018 Minio, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package crypto

import (
        "fmt"
        "io"
        "sort"
)

// Context is a list of key-value pairs cryptographically
// associated with a certain object.
type Context map[string]string

// WriteTo writes the context in a canonical from to w.
// It returns the number of bytes and the first error
// encounter during writing to w, if any.
//
// WriteTo sorts the context keys and writes the sorted
// key-value pairs as canonical JSON object to w.
func (c Context) WriteTo(w io.Writer) (n int64, err error) <span class="cov0" title="0">{
        sortedKeys := make(sort.StringSlice, 0, len(c))
        for k := range c </span><span class="cov0" title="0">{
                sortedKeys = append(sortedKeys, k)
        }</span>
        <span class="cov0" title="0">sort.Sort(sortedKeys)

        nn, err := io.WriteString(w, "{")
        if err != nil </span><span class="cov0" title="0">{
                return n + int64(nn), err
        }</span>
        <span class="cov0" title="0">n += int64(nn)
        for i, k := range sortedKeys </span><span class="cov0" title="0">{
                s := fmt.Sprintf("\"%s\":\"%s\",", k, c[k])
                if i == len(sortedKeys)-1 </span><span class="cov0" title="0">{
                        s = s[:len(s)-1] // remove last ','
                }</span>

                <span class="cov0" title="0">nn, err = io.WriteString(w, s)
                if err != nil </span><span class="cov0" title="0">{
                        return n + int64(nn), err
                }</span>
                <span class="cov0" title="0">n += int64(nn)</span>
        }
        <span class="cov0" title="0">nn, err = io.WriteString(w, "}")
        return n + int64(nn), err</span>
}

// KMS represents an active and authenticted connection
// to a Key-Management-Service. It supports generating
// data key generation and unsealing of KMS-generated
// data keys.
type KMS interface {
        // GenerateKey generates a new random data key using
        // the master key referenced by the keyID. It returns
        // the plaintext key and the sealed plaintext key
        // on success.
        //
        // The context is cryptographically bound to the
        // generated key. The same context must be provided
        // again to unseal the generated key.
        GenerateKey(keyID string, context Context) (key [32]byte, sealedKey []byte, err error)

        // UnsealKey unseals the sealedKey using the master key
        // referenced by the keyID. The provided context must
        // match the context used to generate the sealed key.
        UnsealKey(keyID string, sealedKey []byte, context Context) (key [32]byte, err error)

        GetKeyID() string
}
</pre>
		
		<pre class="file" id="file86" style="display: none">// Minio Cloud Storage, (C) 2015, 2016, 2017, 2018 Minio, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package crypto

// RemoveSensitiveEntries removes confidential encryption
// information - e.g. the SSE-C key - from the metadata map.
// It has the same semantics as RemoveSensitiveHeaders.
func RemoveSensitiveEntries(metadata map[string]string) <span class="cov0" title="0">{ // The functions is tested in TestRemoveSensitiveHeaders for compatibility reasons
        delete(metadata, SSECKey)
        delete(metadata, SSECopyKey)
}</span>

// IsETagSealed returns true if the etag seems to be encrypted.
func IsETagSealed(etag []byte) bool <span class="cov0" title="0">{ return len(etag) &gt; 16 }</span>
</pre>
		
		<pre class="file" id="file87" style="display: none">// Minio Cloud Storage, (C) 2015, 2016, 2017, 2018 Minio, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package crypto

// String returns the SSE domain as string. For SSE-S3 the
// domain is "SSE-S3".
func (s3) String() string <span class="cov0" title="0">{ return "SSE-S3" }</span>

// String returns the SSE domain as string. For SSE-C the
// domain is "SSE-C".
func (ssec) String() string <span class="cov0" title="0">{ return "SSE-C" }</span>

func (s3KMS) String() string <span class="cov0" title="0">{ return "SSE-KMS" }</span>
</pre>
		
		<pre class="file" id="file88" style="display: none">// Minio Cloud Storage, (C) 2015, 2016, 2017, 2018 Minio, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package crypto

import (
        "bytes"
        "encoding/base64"
        "errors"
        "fmt"
        "strings"
        "time"

        vault "github.com/hashicorp/vault/api"
        "github.com/soda/multi-cloud/s3/pkg/helper"
        log "github.com/sirupsen/logrus"
)

const (
        DEBUG_ROOT_TOKEN     = "myroot"
        DEBUG_LEASE_DURATION = 60 * 60 * 24 * 30 // 30 days
)

var (
        //ErrKMSAuthLogin is raised when there is a failure authenticating to KMS
        ErrKMSAuthLogin = errors.New("Vault service did not return auth info")
)

type vaultService struct {
        config        *VaultConfig
        client        *vault.Client
        leaseDuration time.Duration
}

// return transit secret engine's path for generate data key operation
func (v *vaultService) genDataKeyEndpoint(key string) string <span class="cov0" title="0">{
        return "/transit/datakey/plaintext/" + key
}</span>

// return transit secret engine's path for decrypt operation
func (v *vaultService) decryptEndpoint(key string) string <span class="cov0" title="0">{
        return "/transit/decrypt/" + key
}</span>

// VaultKey represents vault encryption key-id name &amp; version
type VaultKey struct {
        Name    string `json:"name"`
        Version int    `json:"version"`
}

// VaultAuth represents vault auth type to use. For now, AppRole is the only supported
// auth type.
type VaultAuth struct {
        Type    string       `json:"type"`
        AppRole VaultAppRole `json:"approle"`
}

// VaultAppRole represents vault approle credentials
type VaultAppRole struct {
        ID     string `json:"id"`
        Secret string `json:"secret"`
}

// VaultConfig holds config required to start vault service
type VaultConfig struct {
        Endpoint string    `json:"endpoint"`
        Auth     VaultAuth `json:"auth"`
        Key      VaultKey  `json:"key-id"`
}

// validate whether all required env variables needed to start vault service have
// been set
func validateVaultConfig(c *VaultConfig) error <span class="cov0" title="0">{
        if c.Endpoint == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("Missing hashicorp vault endpoint - %s is empty", "c.Endpoint")
        }</span>
        <span class="cov0" title="0">if strings.ToLower(c.Auth.Type) != "approle" </span><span class="cov0" title="0">{
                return fmt.Errorf("Unsupported hashicorp vault auth type - %s", "c.Auth.Type")
        }</span>
        <span class="cov0" title="0">if c.Auth.AppRole.ID == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("Missing hashicorp vault AppRole ID - %s is empty", "c.Auth.AppRole.ID")
        }</span>
        <span class="cov0" title="0">if c.Auth.AppRole.Secret == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("Missing hashicorp vault AppSecret ID - %s is empty", "c.Auth.AppRole.Secret")
        }</span>
        <span class="cov0" title="0">if c.Key.Name == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("Invalid value set in environment variable %s", "c.Key.Name")
        }</span>
        <span class="cov0" title="0">if c.Key.Version &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("Invalid value set in environment variable %s", "c.Key.Version")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// authenticate to vault with app role id and app role secret, and get a client access token, lease duration
func getVaultAccessToken(client *vault.Client, appRoleID, appSecret string) (token string, duration int, err error) <span class="cov0" title="0">{
        data := map[string]interface{}{
                "role_id":   appRoleID,
                "secret_id": appSecret,
        }
        resp, e := client.Logical().Write("auth/approle/login", data)
        if e != nil </span><span class="cov0" title="0">{
                return token, duration, e
        }</span>
        <span class="cov0" title="0">if resp.Auth == nil </span><span class="cov0" title="0">{
                return token, duration, ErrKMSAuthLogin
        }</span>
        <span class="cov0" title="0">return resp.Auth.ClientToken, resp.Auth.LeaseDuration, nil</span>
}

// NewVaultConfig sets KMSConfig from environment
// variables and performs validations.
func NewVaultConfig() (KMSConfig, error) <span class="cov0" title="0">{
        kc := KMSConfig{}
        config := VaultConfig{
                Endpoint: helper.CONFIG.KMS.Endpoint,
                Auth: VaultAuth{
                        Type: "approle",
                        AppRole: VaultAppRole{
                                ID:     helper.CONFIG.KMS.Id,
                                Secret: helper.CONFIG.KMS.Secret,
                        },
                },
                Key: VaultKey{
                        Version: helper.CONFIG.KMS.Version,
                        Name:    helper.CONFIG.KMS.Keyname,
                },
        }

        // return if none of the vault env variables are configured
        if (config.Endpoint == "") &amp;&amp; (config.Auth.AppRole.ID == "") &amp;&amp; (config.Auth.AppRole.Secret == "") &amp;&amp;
                (config.Key.Name == "") &amp;&amp; (config.Key.Version == 0) </span><span class="cov0" title="0">{
                return kc, nil
        }</span>

        <span class="cov0" title="0">if err := validateVaultConfig(&amp;config); err != nil </span><span class="cov0" title="0">{
                return kc, err
        }</span>
        <span class="cov0" title="0">kc.Vault = config
        return kc, nil</span>
}

// NewVault initializes Hashicorp Vault KMS by
// authenticating to Vault with the credentials in KMSConfig,
// and gets a client token for future api calls.
func NewVault(kmsConf KMSConfig) (KMS, error) <span class="cov0" title="0">{
        config := kmsConf.Vault
        vconfig := &amp;vault.Config{
                Address: config.Endpoint,
        }

        c, err := vault.NewClient(vconfig)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var accessToken string
        var leaseDuration int
        if helper.CONFIG.DebugMode == true </span><span class="cov0" title="0">{
                accessToken = DEBUG_ROOT_TOKEN
                leaseDuration = DEBUG_LEASE_DURATION
        }</span> else<span class="cov0" title="0"> {
                accessToken, leaseDuration, err = getVaultAccessToken(c, config.Auth.AppRole.ID, config.Auth.AppRole.Secret)
                log.Info("get access token:", accessToken, "lease duration:", leaseDuration)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        // authenticate and get the access token
        <span class="cov0" title="0">log.Info("get vault token:", accessToken, "lease duration:", leaseDuration)
        c.SetToken(accessToken)
        v := vaultService{client: c, config: &amp;config, leaseDuration: time.Duration(leaseDuration)}
        v.renewToken(c)
        return &amp;v, nil</span>
}

func (v *vaultService) renewToken(c *vault.Client) <span class="cov0" title="0">{
        retryDelay := 1 * time.Minute
        go func() </span><span class="cov0" title="0">{
                for </span><span class="cov0" title="0">{
                        s, err := c.Auth().Token().RenewSelf(int(v.leaseDuration))
                        if err != nil </span><span class="cov0" title="0">{
                                time.Sleep(retryDelay)
                                continue</span>
                        }
                        <span class="cov0" title="0">nextRenew := s.Auth.LeaseDuration / 2
                        time.Sleep(time.Duration(nextRenew) * time.Second)</span>
                }
        }()
}

// Generates a random plain text key, sealed plain text key from
// Vault. It returns the plaintext key and sealed plaintext key on success
func (v *vaultService) GenerateKey(keyID string, ctx Context) (key [32]byte, sealedKey []byte, err error) <span class="cov0" title="0">{
        contextStream := new(bytes.Buffer)
        ctx.WriteTo(contextStream)

        payload := map[string]interface{}{
                "context": base64.StdEncoding.EncodeToString(contextStream.Bytes()),
        }
        s, err := v.client.Logical().Write(v.genDataKeyEndpoint(keyID), payload)

        if err != nil </span><span class="cov0" title="0">{
                return key, sealedKey, err
        }</span>
        <span class="cov0" title="0">sealKey := s.Data["ciphertext"].(string)
        plainKey, err := base64.StdEncoding.DecodeString(s.Data["plaintext"].(string))
        if err != nil </span><span class="cov0" title="0">{
                return key, sealedKey, err
        }</span>
        <span class="cov0" title="0">copy(key[:], []byte(plainKey))
        return key, []byte(sealKey), nil</span>
}

// unsealKMSKey unseals the sealedKey using the Vault master key
// referenced by the keyID. The plain text key is returned on success.
func (v *vaultService) UnsealKey(keyID string, sealedKey []byte, ctx Context) (key [32]byte, err error) <span class="cov0" title="0">{
        contextStream := new(bytes.Buffer)
        ctx.WriteTo(contextStream)
        payload := map[string]interface{}{
                "ciphertext": string(sealedKey),
                "context":    base64.StdEncoding.EncodeToString(contextStream.Bytes()),
        }
        s, err := v.client.Logical().Write(v.decryptEndpoint(keyID), payload)
        if err != nil </span><span class="cov0" title="0">{
                return key, err
        }</span>
        <span class="cov0" title="0">base64Key := s.Data["plaintext"].(string)
        plainKey, err1 := base64.StdEncoding.DecodeString(base64Key)
        if err1 != nil </span><span class="cov0" title="0">{
                return key, err
        }</span>
        <span class="cov0" title="0">copy(key[:], []byte(plainKey))

        return key, nil</span>
}

func (v *vaultService) GetKeyID() string <span class="cov0" title="0">{
        return v.config.Key.Name
}</span>
</pre>
		
		<pre class="file" id="file89" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package yig

import (
        "errors"
        "fmt"
        "math/rand"
        "sync"
        "sync/atomic"
        "time"

        "github.com/soda/multi-cloud/backend/pkg/utils/constants"
        backendpb "github.com/soda/multi-cloud/backend/proto"
        "github.com/soda/multi-cloud/s3/pkg/datastore/driver"
        "github.com/soda/multi-cloud/s3/pkg/datastore/yig/config"
        _ "github.com/soda/multi-cloud/s3/pkg/datastore/yig/meta/db"
        "github.com/soda/multi-cloud/s3/pkg/datastore/yig/storage"
        log "github.com/sirupsen/logrus"
)

type YigDriverFactory struct {
        Drivers    sync.Map
        cfgWatcher *config.ConfigWatcher
        initLock   sync.Mutex
        initFlag   int32
}

func (ydf *YigDriverFactory) CreateDriver(backend *backendpb.BackendDetail) (driver.StorageDriver, error) <span class="cov0" title="0">{
        err := ydf.Init()
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to perform YigDriverFactory init, err: %v", err)
                return nil, err
        }</span>
        // if driver already exists, just return it.
        <span class="cov0" title="0">if driver, ok := ydf.Drivers.Load(backend.Endpoint); ok </span><span class="cov0" title="0">{
                return driver.(*storage.YigStorage), nil
        }</span>

        <span class="cov0" title="0">log.Infof("no storage driver for yig endpoint %s", backend.Endpoint)
        return nil, errors.New(fmt.Sprintf("no storage driver for yig endpoint: %s", backend.Endpoint))</span>
}

func (ydf *YigDriverFactory) Init() error <span class="cov8" title="1">{
        // check
        if atomic.LoadInt32(&amp;ydf.initFlag) == 1 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // lock
        <span class="cov8" title="1">ydf.initLock.Lock()
        defer ydf.initLock.Unlock()

        // check
        if ydf.initFlag == 1 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // create the driver.
        <span class="cov8" title="1">rand.Seed(time.Now().UnixNano())

        // read the config.
        err := config.ReadConfigs("/etc/yig", ydf.driverInit)
        if err != nil </span><span class="cov8" title="1">{
                log.Errorf("failed to read yig configs, err: %v", err)
                return nil
        }</span>

        // init config watcher.
        <span class="cov0" title="0">watcher, err := config.NewConfigWatcher(ydf.driverInit)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to new config watcher, err: %v", err)
                return err
        }</span>
        <span class="cov0" title="0">ydf.cfgWatcher = watcher
        ydf.cfgWatcher.Watch("/etc/yig")

        atomic.StoreInt32(&amp;ydf.initFlag, 1)
        return nil</span>
}

func (ydf *YigDriverFactory) Close() <span class="cov8" title="1">{
        var keys []interface{}
        // stop config watcher
        if ydf.cfgWatcher != nil </span><span class="cov0" title="0">{
                ydf.cfgWatcher.Stop()
        }</span>
        // close the drivers
        <span class="cov8" title="1">ydf.Drivers.Range(func(k, v interface{}) bool </span><span class="cov0" title="0">{
                drv := v.(*storage.YigStorage)
                drv.Close()
                keys = append(keys, k)
                return true
        }</span>)

        // remove the drivers
        <span class="cov8" title="1">for _, k := range keys </span><span class="cov0" title="0">{
                ydf.Drivers.Delete(k)
        }</span>
}

func (ydf *YigDriverFactory) driverInit(cfg *config.Config) error <span class="cov8" title="1">{
        yigStorage, err := storage.New(cfg)
        if err != nil </span><span class="cov8" title="1">{
                log.Errorf("failed to create driver for %s, err: %v", cfg.Endpoint.Url, err)
                return err
        }</span>

        <span class="cov0" title="0">ydf.Drivers.Store(cfg.Endpoint.Url, yigStorage)

        return nil</span>
}

func init() <span class="cov8" title="1">{
        yigDf := &amp;YigDriverFactory{}
        err := yigDf.Init()
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">driver.AddCloser(yigDf)
        driver.RegisterDriverFactory(constants.BackendTypeYIGS3, yigDf)</span>
}
</pre>
		
		<pre class="file" id="file90" style="display: none">package log

import (
        "fmt"
        "io"
        "log"
        "os"
)

// These flags define which text to prefix to each log entry generated by the Logger.
const (
        // Bits or'ed together to control what's printed.
        // There is no control over the order they appear (the order listed
        // here) or the format they present (as described in the comments).
        // The prefix is followed by a colon only when Llongfile or Lshortfile
        // is specified.
        // For example, flags Ldate | Ltime (or LstdFlags) produce,
        //        2009/01/23 01:23:23 message
        // while flags Ldate | Ltime | Lmicroseconds | Llongfile produce,
        //        2009/01/23 01:23:23.123123 /a/b/c/d.go:23: message
        Ldate         = 1 &lt;&lt; iota     // the date in the local time zone: 2009/01/23
        Ltime                         // the time in the local time zone: 01:23:23
        Lmicroseconds                 // microsecond resolution: 01:23:23.123123.  assumes Ltime.
        Llongfile                     // full file name and line number: /a/b/c/d.go:23
        Lshortfile                    // final file name element and line number: d.go:23. overrides Llongfile
        LUTC                          // if Ldate or Ltime is set, use UTC rather than the local time zone
        LstdFlags     = Ldate | Ltime // initial values for the standard logger
)

type Logger struct {
        Logger   *log.Logger
        LogLevel int
}

func New(out io.Writer, prefix string, flag int, level int) *Logger <span class="cov0" title="0">{
        var logger Logger
        logger.LogLevel = level
        logger.Logger = log.New(out, prefix, flag)
        return &amp;logger
}</span>

// Printf calls l.Output to print to the logger.
// Arguments are handled in the manner of fmt.Printf.
func (l *Logger) Printf(level int, format string, v ...interface{}) <span class="cov0" title="0">{
        if l.LogLevel &gt;= level </span><span class="cov0" title="0">{
                l.Logger.Output(2, fmt.Sprintf(format, v...))
        }</span>
}

// Print calls l.Output to print to the logger.
// Arguments are handled in the manner of fmt.Print.
func (l *Logger) Print(level int, v ...interface{}) <span class="cov0" title="0">{
        if l.LogLevel &gt;= level </span><span class="cov0" title="0">{
                l.Logger.Output(2, fmt.Sprint(v...))
        }</span>
}

// Println calls l.Output to print to the logger.
// Arguments are handled in the manner of fmt.Println.
func (l *Logger) Println(level int, v ...interface{}) <span class="cov0" title="0">{
        if l.LogLevel &gt;= level </span><span class="cov0" title="0">{
                l.Logger.Output(2, fmt.Sprintln(v...))
        }</span>
}

// Fatal is equivalent to l.Print() followed by a call to os.Exit(1).
func (l *Logger) Fatal(level int, v ...interface{}) <span class="cov0" title="0">{
        if l.LogLevel &gt;= level </span><span class="cov0" title="0">{
                l.Logger.Output(2, fmt.Sprint(v...))
        }</span>
        <span class="cov0" title="0">os.Exit(1)</span>
}

// Fatalf is equivalent to l.Printf() followed by a call to os.Exit(1).
func (l *Logger) Fatalf(level int, format string, v ...interface{}) <span class="cov0" title="0">{
        if l.LogLevel &gt;= level </span><span class="cov0" title="0">{
                l.Logger.Output(2, fmt.Sprintf(format, v...))
        }</span>
        <span class="cov0" title="0">os.Exit(1)</span>
}

// Fatalln is equivalent to l.Println() followed by a call to os.Exit(1).
func (l *Logger) Fatalln(level int, v ...interface{}) <span class="cov0" title="0">{
        if l.LogLevel &gt;= level </span><span class="cov0" title="0">{
                l.Logger.Output(2, fmt.Sprintln(v...))
        }</span>
        <span class="cov0" title="0">os.Exit(1)</span>
}

// Panic is equivalent to l.Print() followed by a call to panic().
func (l *Logger) Panic(level int, v ...interface{}) <span class="cov0" title="0">{
        s := fmt.Sprint(v...)
        if l.LogLevel &gt;= level </span><span class="cov0" title="0">{
                l.Logger.Output(2, s)
        }</span>
        <span class="cov0" title="0">panic(s)</span>
}

// Panicf is equivalent to l.Printf() followed by a call to panic().
func (l *Logger) Panicf(level int, format string, v ...interface{}) <span class="cov0" title="0">{
        s := fmt.Sprintf(format, v...)
        if l.LogLevel &gt;= level </span><span class="cov0" title="0">{
                l.Logger.Output(2, s)
        }</span>
        <span class="cov0" title="0">panic(s)</span>
}

// Panicln is equivalent to l.Println() followed by a call to panic().
func (l *Logger) Panicln(level int, v ...interface{}) <span class="cov0" title="0">{
        s := fmt.Sprintln(v...)
        if l.LogLevel &gt;= level </span><span class="cov0" title="0">{
                l.Logger.Output(2, s)
        }</span>
        <span class="cov0" title="0">panic(s)</span>
}
</pre>
		
		<pre class="file" id="file91" style="display: none">package meta

import (
        "github.com/soda/multi-cloud/s3/pkg/datastore/yig/meta/types"
)

func (m *Meta) GetCluster(fsid, poolName string) (types.Cluster, error) <span class="cov0" title="0">{
        return m.db.GetCluster(fsid, poolName)
}</span>
</pre>
		
		<pre class="file" id="file92" style="display: none">package driver

import (
        "errors"
        "fmt"
        "sync"

        "github.com/soda/multi-cloud/s3/pkg/datastore/yig/config"
)

var (
        driversLock = sync.RWMutex{}
        drivers     = make(map[string]DBDriver)
)

func Open(dbCfg config.DatabaseConfig) (DB, error) <span class="cov8" title="1">{
        driversLock.RLock()
        driver, ok := drivers[dbCfg.DbType]
        driversLock.RUnlock()
        if !ok </span><span class="cov0" title="0">{
                return nil, errors.New(fmt.Sprintf("unknow db driver %s", dbCfg.DbType))
        }</span>
        <span class="cov8" title="1">return driver.OpenDB(dbCfg)</span>
}

func RegisterDBDriver(dbType string, dbDriver DBDriver) <span class="cov8" title="1">{
        if dbDriver == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">driversLock.Lock()
        defer driversLock.Unlock()
        drivers[dbType] = dbDriver</span>
}
</pre>
		
		<pre class="file" id="file93" style="display: none">package tidb

import (
        "github.com/soda/multi-cloud/s3/pkg/datastore/yig/meta/types"
)

//cluster
func (t *Tidb) GetCluster(fsid, pool string) (cluster types.Cluster, err error) <span class="cov0" title="0">{
        sqltext := "select fsid,pool,weight from cluster where fsid=? and pool=?"
        err = t.DB.QueryRow(sqltext, fsid, pool).Scan(
                &amp;cluster.Fsid,
                &amp;cluster.Pool,
                &amp;cluster.Weight,
        )
        return
}</span>
</pre>
		
		<pre class="file" id="file94" style="display: none">package tidb

import (
        "database/sql"
)

type Tidb struct {
        DB *sql.DB
}

func (t *Tidb) Close() <span class="cov0" title="0">{
        t.DB.Close()
}</span>
</pre>
		
		<pre class="file" id="file95" style="display: none">package tidb

import (
        "database/sql"

        _ "github.com/go-sql-driver/mysql"
        "github.com/soda/multi-cloud/s3/pkg/datastore/yig/config"
        "github.com/soda/multi-cloud/s3/pkg/datastore/yig/meta/db/driver"
        log "github.com/sirupsen/logrus"
)

const (
        TIDB_DRIVER_ID = "tidb"
)

type TidbDriver struct {
}

func (td *TidbDriver) OpenDB(dbCfg config.DatabaseConfig) (driver.DB, error) <span class="cov8" title="1">{
        db := &amp;Tidb{}
        var err error
        db.DB, err = sql.Open("mysql", dbCfg.DbUrl)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to open db: %s, err: %v", dbCfg.DbUrl, err)
                return nil, err
        }</span>
        <span class="cov8" title="1">log.Info("connected to tidb ...")
        db.DB.SetMaxIdleConns(dbCfg.MaxIdleConns)
        db.DB.SetMaxOpenConns(dbCfg.MaxOpenConns)
        return db, nil</span>
}

func init() <span class="cov8" title="1">{
        tidbDriver := &amp;TidbDriver{}
        driver.RegisterDBDriver(TIDB_DRIVER_ID, tidbDriver)
}</span>
</pre>
		
		<pre class="file" id="file96" style="display: none">package tidb

import (
        "database/sql"
        "time"

        "github.com/soda/multi-cloud/s3/pkg/datastore/yig/meta/types"
        mtypes "github.com/soda/multi-cloud/s3/pkg/meta/types"
        log "github.com/sirupsen/logrus"
)

func (t *Tidb) PutPartsInGc(parts []*types.PartInfo) (err error) <span class="cov0" title="0">{
        var tx *sql.Tx
        var stmt *sql.Stmt
        tx, err = t.DB.Begin()
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("PutPartsInGc(%v) failed, err: %v", parts, err)
                return err
        }</span>

        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err == nil </span><span class="cov0" title="0">{
                        if err = tx.Commit(); err != nil </span><span class="cov0" title="0">{
                                log.Errorf("PutPartsInGc(%v) failed, failed to commit, err: %v", parts, err)
                        }</span>
                        <span class="cov0" title="0">return</span>
                }
                <span class="cov0" title="0">if rErr := tx.Rollback(); rErr != nil </span><span class="cov0" title="0">{
                        log.Errorf("PutPartsInGc(%v) failed, failed to rollback, err: %v", parts, err)
                }</span>
        }()

        // put all the parts into gc.
        <span class="cov0" title="0">stmt, err = tx.Prepare("insert into gc(location, pool, object_id) values(?, ?, ?)")
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("PutPartsInGc(%v) failed, failed to prepare insert to gc, err: %v", parts, err)
                return err
        }</span>
        <span class="cov0" title="0">for _, p := range parts </span><span class="cov0" title="0">{
                _, err = stmt.Exec(p.Location, p.Pool, p.ObjectId)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("PutPartsInGc(%v) failed, failed to exec insert gc stmt(%v), err: %v", parts, p, err)
                        stmt.Close()
                        return err
                }</span>
        }
        <span class="cov0" title="0">stmt.Close()
        // remove all the parts from multiparts
        stmt, err = tx.Prepare("delete from multiparts where upload_id=? and part_num=?")
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("PutPartsInGc(%v) failed, failed to prepare to remove multiparts, err: %v", parts, err)
                return err
        }</span>
        <span class="cov0" title="0">for _, p := range parts </span><span class="cov0" title="0">{
                _, err = stmt.Exec(p.UploadId, p.PartNum)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("PutPartsInGc(%v) failed, failed to exec remove multiparts stmt(%v), err: %v", parts, p, err)
                        stmt.Close()
                        return err
                }</span>
        }
        <span class="cov0" title="0">stmt.Close()
        return nil</span>
}

// delete objects
func (t *Tidb) PutGcObjects(objects ...*types.GcObject) (err error) <span class="cov0" title="0">{
        var tx *sql.Tx
        var stmt *sql.Stmt
        tx, err = t.DB.Begin()
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("PutGcObjects(%v) failed, err: %v", objects, err)
                return err
        }</span>

        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err == nil </span><span class="cov0" title="0">{
                        if err = tx.Commit(); err != nil </span><span class="cov0" title="0">{
                                log.Errorf("PutGcObjects(%v) failed, failed to commit, err: %v", objects, err)
                        }</span>
                        <span class="cov0" title="0">return</span>
                }
                <span class="cov0" title="0">if rErr := tx.Rollback(); rErr != nil </span><span class="cov0" title="0">{
                        log.Errorf("PutGcObjects(%v) failed, failed to rollback, err: %v", objects, err)
                }</span>
        }()

        <span class="cov0" title="0">stmt, err = tx.Prepare("insert into gc(location, pool, object_id) values(?, ?, ?)")
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("PutGcObjects(%v) failed, failed to prepare, err: %v", objects, err)
                return err
        }</span>
        <span class="cov0" title="0">defer stmt.Close()
        for _, o := range objects </span><span class="cov0" title="0">{
                _, err = stmt.Exec(o.Location, o.Pool, o.ObjectId)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("PutGcObjects(%v) failed, failed to exec(%v), err: %v", objects, o, err)
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (t *Tidb) GetGcObjects(marker int64, limit int) ([]*types.GcObject, error) <span class="cov0" title="0">{
        sqlText := "select id, location, pool, object_id, create_time from gc where id&gt;=? order by create_time limit ?"
        var out []*types.GcObject
        rows, err := t.DB.Query(sqlText, marker, limit)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to GetGcObjects(%d, %d), err: %v", marker, limit, err)
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        for rows.Next() </span><span class="cov0" title="0">{
                var createTime sql.NullString
                o := &amp;types.GcObject{}
                err = rows.Scan(&amp;o.Id, &amp;o.Location, &amp;o.Pool, &amp;o.ObjectId, &amp;createTime)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("GetGcObjects(%d, %d) failed, failed to perform scan, err: %v", marker, limit, err)
                        return nil, err
                }</span>
                <span class="cov0" title="0">if createTime.Valid </span><span class="cov0" title="0">{
                        o.CreateTime, err = time.Parse(mtypes.TIME_LAYOUT_TIDB, createTime.String)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Errorf("GetGcObjects(%d, %d) failed, failed to parse create_time: %s, err: %v", marker, limit, createTime.String, err)
                                return nil, err
                        }</span>
                }
                <span class="cov0" title="0">out = append(out, o)</span>
        }
        <span class="cov0" title="0">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
                log.Errorf("GetGcObjects(%d, %d) failed, rows return error: %v", marker, limit, err)
                return nil, err
        }</span>

        <span class="cov0" title="0">return out, nil</span>
}

// delete gc objects meta.
func (t *Tidb) DeleteGcObjects(objects ...*types.GcObject) (err error) <span class="cov0" title="0">{
        var tx *sql.Tx
        var stmt *sql.Stmt
        tx, err = t.DB.Begin()
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("DeleteGcObjects(%v) failed, err: %v", objects, err)
                return err
        }</span>

        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err == nil </span><span class="cov0" title="0">{
                        if err = tx.Commit(); err != nil </span><span class="cov0" title="0">{
                                log.Errorf("DeleteGcObjects(%v) failed, failed to commit, err: %v", objects, err)
                        }</span>
                        <span class="cov0" title="0">return</span>
                }
                <span class="cov0" title="0">if rErr := tx.Rollback(); rErr != nil </span><span class="cov0" title="0">{
                        log.Errorf("DeleteGcObjects(%v) failed, failed to rollback, err: %v", objects, err)
                }</span>
        }()

        <span class="cov0" title="0">stmt, err = tx.Prepare("delete from gc where object_id=?")
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("DeleteGcObjects(%v) failed, failed to prepare, err: %v", objects, err)
                return err
        }</span>
        <span class="cov0" title="0">defer stmt.Close()
        for _, o := range objects </span><span class="cov0" title="0">{
                _, err = stmt.Exec(o.ObjectId)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("DeleteGcObjects(%v) failed, failed to exec(%v), err: %v", objects, o, err)
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file97" style="display: none">package tidb

import (
        "database/sql"
        "sort"
        "time"

        "github.com/soda/multi-cloud/s3/pkg/datastore/yig/meta/types"
        mtypes "github.com/soda/multi-cloud/s3/pkg/meta/types"
        log "github.com/sirupsen/logrus"
)

/*
* ListParts: list all the parts which belong to the uploadId.
* @return: the related parts which are sorted by PartNum asc.
*
 */
func (t *Tidb) ListParts(uploadId uint64) ([]*types.PartInfo, error) <span class="cov0" title="0">{
        sqlText := "select upload_id, part_num, object_id, location, pool, offset, size, etag, flag, create_time, update_time from multiparts where upload_id = ? order by part_num"
        var parts []*types.PartInfo
        rows, err := t.DB.Query(sqlText, uploadId)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to query parts for uploadId %d, err: %v", uploadId, err)
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        for rows.Next() </span><span class="cov0" title="0">{
                part := &amp;types.PartInfo{}
                var createTime sql.NullString
                var updateTime sql.NullString
                err = rows.Scan(&amp;part.UploadId, &amp;part.PartNum, &amp;part.ObjectId, &amp;part.Location, &amp;part.Pool, &amp;part.Offset, &amp;part.Size, &amp;part.Etag, &amp;part.Flag, &amp;createTime, &amp;updateTime)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("failed to scan rows for uploadId %d, err: %v", uploadId, err)
                        return nil, err
                }</span>
                <span class="cov0" title="0">if createTime.Valid </span><span class="cov0" title="0">{
                        part.CreateTime, err = time.Parse(mtypes.TIME_LAYOUT_TIDB, createTime.String)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Errorf("failed to parse create_time: %s, err: %v", createTime.String, err)
                                return nil, err
                        }</span>
                }
                <span class="cov0" title="0">if updateTime.Valid </span><span class="cov0" title="0">{
                        part.UpdateTime, err = time.Parse(mtypes.TIME_LAYOUT_TIDB, updateTime.String)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Errorf("failed to parse update_time: %s, err: %v", updateTime.String, err)
                                return nil, err
                        }</span>
                }
                <span class="cov0" title="0">parts = append(parts, part)</span>
        }
        <span class="cov0" title="0">err = rows.Err()
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to iterate the rows for uploadId %d, err: %v", uploadId, err)
                return nil, err
        }</span>
        <span class="cov0" title="0">sort.Sort(types.ByPartNum(parts))
        return parts, nil</span>
}

func (t *Tidb) PutPart(partInfo *types.PartInfo) (err error) <span class="cov0" title="0">{
        sqlText := "insert into multiparts(upload_id, part_num, object_id, location, pool, offset, size, etag, flag) values(?, ?, ?, ?, ?, ?, ?, ?, ?)"
        var tx *sql.Tx
        tx, err = t.DB.Begin()
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to Begin a transaction for %v, err: %v", partInfo, err)
                return err
        }</span>

        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        // do not use the err since since by doing so, it will overwite the original error.
                        if rErr := tx.Rollback(); rErr != nil </span><span class="cov0" title="0">{
                                log.Errorf("perform rollback for partInfo(%v) failed with err: %v", partInfo, rErr)
                        }</span>
                } else<span class="cov0" title="0"> {
                        // should check whether the transaction commit succeeds or not.
                        if err = tx.Commit(); err != nil </span><span class="cov0" title="0">{
                                log.Errorf("perform commit for partInfo(%v) failed with err: %v", partInfo, err)
                        }</span>
                }
        }()

        <span class="cov0" title="0">_, err = tx.Exec(sqlText, partInfo.UploadId, partInfo.PartNum, partInfo.ObjectId, partInfo.Location, partInfo.Pool, partInfo.Offset, partInfo.Size, partInfo.Etag, partInfo.Flag)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to save partInfo(%v), err: %v", partInfo, err)
                return err
        }</span>
        // must return err instead of nil, because commit may return error.
        <span class="cov0" title="0">return err</span>
}

func (t *Tidb) DeleteParts(uploadId uint64) error <span class="cov0" title="0">{
        sqlText := "delete from multiparts where upload_id=?"
        _, err := t.DB.Exec(sqlText, uploadId)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to remove parts from meta for uploadId(%d), err: %v", uploadId, err)
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (t *Tidb) CompleteParts(uploadId uint64, parts []*types.PartInfo) (err error) <span class="cov0" title="0">{
        sqlText := "update multiparts set offset=?, flag=? where upload_id=? and part_num=?"
        var tx *sql.Tx
        var stmt *sql.Stmt

        tx, err = t.DB.Begin()
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to complete parts for uploadId(%d), it was fail to create transaction, err: %v", uploadId, err)
                return err
        }</span>

        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err == nil </span><span class="cov0" title="0">{
                        if err = tx.Commit(); err != nil </span><span class="cov0" title="0">{
                                log.Errorf("failed to commit tranaction when completing uploadId(%d), err: %v", uploadId, err)
                        }</span>
                } else<span class="cov0" title="0"> {
                        if rErr := tx.Rollback(); rErr != nil </span><span class="cov0" title="0">{
                                log.Errorf("failed to rollback when completing uploadId(%d), err: %v", uploadId, rErr)
                        }</span>
                }
        }()

        <span class="cov0" title="0">stmt, err = tx.Prepare(sqlText)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to complete uploadId(%d), it was fail to prepare sql, err: %v", uploadId, err)
                return err
        }</span>

        <span class="cov0" title="0">defer stmt.Close()

        for _, part := range parts </span><span class="cov0" title="0">{
                _, err := stmt.Exec(part.Offset, part.Flag, uploadId, part.PartNum)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("failed to complete uploadId(%d), it was fail to perform stmt exec, err: %v", uploadId, err)
                        return err
                }</span>
        }

        <span class="cov0" title="0">return err</span>
}
</pre>
		
		<pre class="file" id="file98" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package meta

import (
        "github.com/soda/multi-cloud/s3/pkg/datastore/yig/meta/types"
)

// delete multipart uploaded part objects and put them into gc
func (m *Meta) PutPartsInGc(parts []*types.PartInfo) error <span class="cov0" title="0">{
        return m.db.PutPartsInGc(parts)
}</span>

func (m *Meta) PutGcObjects(objects ...*types.GcObject) error <span class="cov0" title="0">{
        return m.db.PutGcObjects(objects...)
}</span>

// get gc objects by marker and limit
func (m *Meta) GetGcObjects(marker int64, limit int) ([]*types.GcObject, error) <span class="cov0" title="0">{
        return m.db.GetGcObjects(marker, limit)
}</span>

// delete gc objects meta.
func (m *Meta) DeleteGcObjects(objects ...*types.GcObject) error <span class="cov0" title="0">{
        return m.db.DeleteGcObjects(objects...)
}</span>
</pre>
		
		<pre class="file" id="file99" style="display: none">package meta

import (
        "github.com/soda/multi-cloud/s3/pkg/datastore/yig/config"
        "github.com/soda/multi-cloud/s3/pkg/datastore/yig/meta/db/driver"
)

type MetaConfig struct {
        Dbcfg config.DatabaseConfig
}

type Meta struct {
        db driver.DB
}

func (m *Meta) Close() <span class="cov0" title="0">{
        m.db.Close()
}</span>

func New(cfg MetaConfig) (*Meta, error) <span class="cov8" title="1">{
        db, err := driver.Open(cfg.Dbcfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">m := &amp;Meta{
                db: db,
        }
        return m, nil</span>
}
</pre>
		
		<pre class="file" id="file100" style="display: none">package meta

import (
        "github.com/soda/multi-cloud/s3/pkg/datastore/yig/meta/types"
)

func (m *Meta) ListParts(uploadId uint64) ([]*types.PartInfo, error) <span class="cov0" title="0">{
        return m.db.ListParts(uploadId)
}</span>

func (m *Meta) PutPart(partInfo *types.PartInfo) error <span class="cov0" title="0">{
        return m.db.PutPart(partInfo)
}</span>

func (m *Meta) DeleteParts(uploadId uint64) error <span class="cov0" title="0">{
        return m.db.DeleteParts(uploadId)
}</span>

func (m *Meta) CompleteParts(uploadId uint64, parts []*types.PartInfo) error <span class="cov0" title="0">{
        return m.db.CompleteParts(uploadId, parts)
}</span>
</pre>
		
		<pre class="file" id="file101" style="display: none">package types

import (
        "time"
)

const (
        MULTIPART_UPLOAD_IN_PROCESS = 0
        MULTIPART_UPLOAD_COMPLETE   = 1
)

type PartInfo struct {
        // global unique upload id
        // Note: this upload id is increasing monoatomicly only in one node.
        UploadId uint64
        // part number in this upload
        PartNum int64
        // object id in ceph which relates to the part.
        ObjectId string
        // ceph cluster
        Location string
        // ceph pool name
        Pool string
        // offset of this part in the whole object
        Offset uint64
        // size of this part
        Size uint64
        // etag of this part
        Etag string
        // Flag determin whether this part is completed or not.
        // 0 by default.
        Flag uint8
        // create time of this upload
        CreateTime time.Time
        // this record changed time.
        UpdateTime time.Time
}

type ByPartNum []*PartInfo

func (bpn ByPartNum) Len() int <span class="cov0" title="0">{ return len(bpn) }</span>

func (bpn ByPartNum) Swap(i, j int) <span class="cov0" title="0">{ bpn[i], bpn[j] = bpn[j], bpn[i] }</span>

func (bpn ByPartNum) Less(i, j int) bool <span class="cov0" title="0">{ return bpn[i].PartNum &lt;= bpn[j].PartNum }</span>
</pre>
		
		<pre class="file" id="file102" style="display: none">package storage

import (
        "bytes"
        "container/list"
        "errors"
        "io"
        "sync"

        "fmt"
        "github.com/journeymidnight/radoshttpd/rados"
        log "github.com/sirupsen/logrus"
        "time"
)

const (
        MON_TIMEOUT         = "10"
        OSD_TIMEOUT         = "10"
        STRIPE_UNIT         = 512 &lt;&lt; 10 /* 512K */
        STRIPE_COUNT        = 2
        OBJECT_SIZE         = 8 &lt;&lt; 20         /* 8M */
        BUFFER_SIZE         = 1 &lt;&lt; 20         /* 1M */
        MIN_CHUNK_SIZE      = 512 &lt;&lt; 10       /* 512K */
        MAX_CHUNK_SIZE      = 8 * BUFFER_SIZE /* 8M */
        SMALL_FILE_POOLNAME = "rabbit"
        BIG_FILE_POOLNAME   = "tiger"
        BIG_FILE_THRESHOLD  = 128 &lt;&lt; 10 /* 128K */
        AIO_CONCURRENT      = 4
)

type CephStorage struct {
        Name       string
        Conn       *rados.Conn
        InstanceId uint64
        CountMutex *sync.Mutex
        Counter    uint64
        BufPool    *sync.Pool
        BigBufPool *sync.Pool
}

func NewCephStorage(configFile string) *CephStorage <span class="cov0" title="0">{
        log.Infof("Loading Ceph file %s\n", configFile)

        Rados, err := rados.NewConn("admin")
        Rados.SetConfigOption("rados_mon_op_timeout", MON_TIMEOUT)
        Rados.SetConfigOption("rados_osd_op_timeout", OSD_TIMEOUT)

        err = Rados.ReadConfigFile(configFile)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("Failed to open ceph.conf: %s\n", configFile)
                return nil
        }</span>

        <span class="cov0" title="0">err = Rados.Connect()
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("Failed to connect to remote cluster: %s\n", configFile)
                return nil
        }</span>

        <span class="cov0" title="0">name, err := Rados.GetFSID()
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("Failed to get FSID: %s\n", configFile)
                Rados.Shutdown()
                return nil
        }</span>

        <span class="cov0" title="0">id := Rados.GetInstanceID()

        cluster := CephStorage{
                Conn:       Rados,
                Name:       name,
                InstanceId: id,
                CountMutex: new(sync.Mutex),
                BufPool: &amp;sync.Pool{
                        New: func() interface{} </span><span class="cov0" title="0">{
                                return bytes.NewBuffer(make([]byte, BIG_FILE_THRESHOLD))
                        }</span>,
                },
                BigBufPool: &amp;sync.Pool{
                        New: func() interface{} <span class="cov0" title="0">{
                                return make([]byte, MAX_CHUNK_SIZE)
                        }</span>,
                },
        }

        <span class="cov0" title="0">log.Infof("Ceph Cluster %s is ready, InstanceId is %d\n", name, id)
        return &amp;cluster</span>
}

func setStripeLayout(p *rados.StriperPool) int <span class="cov0" title="0">{
        var ret int = 0
        if ret = p.SetLayoutStripeUnit(STRIPE_UNIT); ret &lt; 0 </span><span class="cov0" title="0">{
                return ret
        }</span>
        <span class="cov0" title="0">if ret = p.SetLayoutObjectSize(OBJECT_SIZE); ret &lt; 0 </span><span class="cov0" title="0">{
                return ret
        }</span>
        <span class="cov0" title="0">if ret = p.SetLayoutStripeCount(STRIPE_COUNT); ret &lt; 0 </span><span class="cov0" title="0">{
                return ret
        }</span>
        <span class="cov0" title="0">return ret</span>
}

func pending_has_completed(p *list.List) bool <span class="cov0" title="0">{
        if p.Len() == 0 </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">e := p.Front()
        c := e.Value.(*rados.AioCompletion)
        ret := c.IsComplete()
        if ret == 0 </span><span class="cov0" title="0">{
                return false
        }</span> else<span class="cov0" title="0"> {
                return true
        }</span>
}

func wait_pending_front(p *list.List) int <span class="cov0" title="0">{
        /* remove AioCompletion from list */
        e := p.Front()
        p.Remove(e)
        c := e.Value.(*rados.AioCompletion)
        c.WaitForComplete()
        ret := c.GetReturnValue()
        c.Release()
        return ret
}</span>

func drain_pending(p *list.List) int <span class="cov0" title="0">{
        var ret int
        for p.Len() &gt; 0 </span><span class="cov0" title="0">{
                ret = wait_pending_front(p)
        }</span>
        <span class="cov0" title="0">return ret</span>
}

func (cluster *CephStorage) GetUniqUploadName() string <span class="cov0" title="0">{
        cluster.CountMutex.Lock()
        defer cluster.CountMutex.Unlock()
        cluster.Counter += 1
        oid := fmt.Sprintf("%d:%d", cluster.InstanceId, cluster.Counter)
        return oid
}</span>

func (c *CephStorage) Shutdown() <span class="cov0" title="0">{
        c.Conn.Shutdown()
}</span>

func (cluster *CephStorage) doSmallPut(poolname string, oid string, data io.Reader) (size int64, err error) <span class="cov0" title="0">{
        tstart := time.Now()
        pool, err := cluster.Conn.OpenPool(poolname)
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.New("Bad poolname")
        }</span>
        <span class="cov0" title="0">defer pool.Destroy()
        tpool := time.Now()
        dur := tpool.Sub(tstart).Nanoseconds() / 1000000
        if dur &gt;= 10 </span><span class="cov0" title="0">{
                log.Warnf("slow log: doSmallPut OpenPool(%s, %s) spent %d", poolname, oid, dur)
        }</span>

        <span class="cov0" title="0">buffer := cluster.BufPool.Get().(*bytes.Buffer)
        buffer.Reset()
        defer cluster.BufPool.Put(buffer)
        written, err := buffer.ReadFrom(data)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to read data for pool %s, oid %s, err: %v", poolname, oid, err)
                return 0, err
        }</span>

        <span class="cov0" title="0">size = written

        tread := time.Now()
        dur = tread.Sub(tpool).Nanoseconds() / 1000000
        if dur &gt;= 10 </span><span class="cov0" title="0">{
                log.Warnf("slow log: doSmallPut read body(%s, %s) spent %d", poolname, oid, dur)
        }</span>

        <span class="cov0" title="0">err = pool.WriteSmallObject(oid, buffer.Bytes())
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">twrite := time.Now()
        dur = twrite.Sub(tread).Nanoseconds() / 1000000
        if dur &gt;= 50 </span><span class="cov0" title="0">{
                log.Warnf("slow log: doSmallPut ceph write(%s, %s) spent %d", poolname, oid, dur)
        }</span>

        <span class="cov0" title="0">dur = twrite.Sub(tstart).Nanoseconds() / 1000000
        if dur &gt;= 100 </span><span class="cov0" title="0">{
                log.Warnf("slow log: doSmallPut fin(%s, %s) spent %d", poolname, oid, dur)
        }</span>

        <span class="cov0" title="0">return size, nil</span>
}

type RadosSmallDownloader struct {
        oid       string
        offset    int64
        remaining int64
        pool      *rados.Pool
}

func (rd *RadosSmallDownloader) Read(p []byte) (n int, err error) <span class="cov0" title="0">{
        if rd.remaining &lt;= 0 </span><span class="cov0" title="0">{
                return 0, io.EOF
        }</span>
        <span class="cov0" title="0">if int64(len(p)) &gt; rd.remaining </span><span class="cov0" title="0">{
                p = p[:rd.remaining]
        }</span>
        <span class="cov0" title="0">count, err := rd.pool.Read(rd.oid, p, uint64(rd.offset))
        if count == 0 </span><span class="cov0" title="0">{
                return 0, io.EOF
        }</span>
        <span class="cov0" title="0">rd.offset += int64(count)
        rd.remaining -= int64(count)
        return count, err</span>
}

func (rd *RadosSmallDownloader) Seek(offset int64, whence int) (int64, error) <span class="cov0" title="0">{
        switch whence </span>{
        case 0:<span class="cov0" title="0">
                rd.offset = offset</span>
        case 1:<span class="cov0" title="0">
                rd.offset += offset</span>
        case 2:<span class="cov0" title="0">
                panic("Not implemented")</span>
        }
        <span class="cov0" title="0">return rd.offset, nil</span>
}

func (rd *RadosSmallDownloader) Close() error <span class="cov0" title="0">{
        rd.pool.Destroy()
        return nil
}</span>

func (cluster *CephStorage) Put(poolname string, oid string, data io.Reader) (size int64, err error) <span class="cov0" title="0">{
        if poolname == SMALL_FILE_POOLNAME </span><span class="cov0" title="0">{
                return cluster.doSmallPut(poolname, oid, data)
        }</span>

        <span class="cov0" title="0">pool, err := cluster.Conn.OpenPool(poolname)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("Bad poolname %s", poolname)
        }</span>
        <span class="cov0" title="0">defer pool.Destroy()

        striper, err := pool.CreateStriper()
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("Bad ioctx of pool %s", poolname)
        }</span>
        <span class="cov0" title="0">defer striper.Destroy()

        setStripeLayout(&amp;striper)

        /* if the data len in pending_data is bigger than current_upload_window, I will flush the data to ceph */
        /* current_upload_window could not dynamically increase or shrink */

        var c *rados.AioCompletion
        pending := list.New()
        var current_upload_window = MIN_CHUNK_SIZE /* initial window size as MIN_CHUNK_SIZE, max size is MAX_CHUNK_SIZE */
        var pending_data = cluster.BigBufPool.Get().([]byte)
        defer func() </span><span class="cov0" title="0">{
                cluster.BigBufPool.Put(pending_data)
        }</span>()

        <span class="cov0" title="0">var slice_offset = 0
        var slow_count = 0
        // slice is the buffer size of reader, the size is equal to remain size of pending_data
        var slice = pending_data[0:current_upload_window]

        var offset uint64 = 0

        for </span><span class="cov0" title="0">{
                start := time.Now()
                count, err := data.Read(slice)
                if err != nil &amp;&amp; err != io.EOF </span><span class="cov0" title="0">{
                        drain_pending(pending)
                        return 0, fmt.Errorf("Read from client failed. pool:%s oid:%s", poolname, oid)
                }</span>
                <span class="cov0" title="0">if count == 0 </span><span class="cov0" title="0">{
                        break</span>
                }
                // it's used to calculate next upload window
                <span class="cov0" title="0">elapsed_time := time.Since(start)

                slice_offset += count
                slice = pending_data[slice_offset:]

                //is pending_data full?
                if slice_offset &lt; len(pending_data) </span><span class="cov0" title="0">{
                        continue</span>
                }

                /* pending data is full now */
                <span class="cov0" title="0">c = new(rados.AioCompletion)
                c.Create()
                _, err = striper.WriteAIO(c, oid, pending_data, offset)
                if err != nil </span><span class="cov0" title="0">{
                        c.Release()
                        drain_pending(pending)
                        return 0, fmt.Errorf("Bad io. pool:%s oid:%s", poolname, oid)
                }</span>
                <span class="cov0" title="0">pending.PushBack(c)

                for pending_has_completed(pending) </span><span class="cov0" title="0">{
                        if ret := wait_pending_front(pending); ret &lt; 0 </span><span class="cov0" title="0">{
                                drain_pending(pending)
                                return 0, fmt.Errorf("Error drain_pending in pending_has_completed(%d). pool:%s oid:%s", ret, poolname, oid)
                        }</span>
                }

                <span class="cov0" title="0">if pending.Len() &gt; AIO_CONCURRENT </span><span class="cov0" title="0">{
                        if ret := wait_pending_front(pending); ret &lt; 0 </span><span class="cov0" title="0">{
                                drain_pending(pending)
                                return 0, fmt.Errorf("Error wait_pending_front(%d). pool:%s oid:%s", ret, poolname, oid)
                        }</span>
                }
                <span class="cov0" title="0">offset += uint64(len(pending_data))

                /* Resize current upload window */
                expected_time := count * 1000 * 1000 * 1000 / current_upload_window /* 1000 * 1000 * 1000 means use Nanoseconds */

                // If the upload speed is less than half of the current upload window, reduce the upload window by half.
                // If upload speed is larger than current window size per second, used the larger window and twice
                if elapsed_time.Nanoseconds() &gt; 2*int64(expected_time) </span><span class="cov0" title="0">{
                        if slow_count &gt; 2 &amp;&amp; current_upload_window &gt; MIN_CHUNK_SIZE </span><span class="cov0" title="0">{
                                current_upload_window = current_upload_window &gt;&gt; 1
                                slow_count = 0
                        }</span>
                        <span class="cov0" title="0">slow_count += 1</span>
                } else<span class="cov0" title="0"> if int64(expected_time) &gt; elapsed_time.Nanoseconds() </span><span class="cov0" title="0">{
                        /* if upload speed is fast enough, enlarge the current_upload_window a bit */
                        current_upload_window = current_upload_window &lt;&lt; 1
                        if current_upload_window &gt; MAX_CHUNK_SIZE </span><span class="cov0" title="0">{
                                current_upload_window = MAX_CHUNK_SIZE
                        }</span>
                        <span class="cov0" title="0">slow_count = 0</span>
                }
                /* allocate a new pending data */
                <span class="cov0" title="0">slice_offset = 0
                slice = pending_data[0:current_upload_window]</span>
        }

        <span class="cov0" title="0">size = int64(uint64(slice_offset) + offset)
        //write all remaining data
        if slice_offset &gt; 0 </span><span class="cov0" title="0">{
                c = new(rados.AioCompletion)
                c.Create()
                striper.WriteAIO(c, oid, pending_data[:slice_offset], offset)
                pending.PushBack(c)
        }</span>

        //drain_pending
        <span class="cov0" title="0">if ret := drain_pending(pending); ret &lt; 0 </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("Error wait_pending_front(%d). pool:%s oid:%s", ret, poolname, oid)
        }</span>
        <span class="cov0" title="0">return size, nil</span>
}

func (cluster *CephStorage) Append(poolname string, oid string, data io.Reader, offset uint64, isExist bool) (size int64, err error) <span class="cov0" title="0">{
        if poolname != BIG_FILE_POOLNAME </span><span class="cov0" title="0">{
                return 0, errors.New("specified pool must be used for storing big file.")
        }</span>

        <span class="cov0" title="0">pool, err := cluster.Conn.OpenPool(poolname)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("Bad poolname %s", poolname)
        }</span>
        <span class="cov0" title="0">defer pool.Destroy()

        striper, err := pool.CreateStriper()
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("Bad ioctx of pool %s", poolname)
        }</span>
        <span class="cov0" title="0">defer striper.Destroy()

        setStripeLayout(&amp;striper)

        var current_upload_window = MIN_CHUNK_SIZE /* initial window size as MIN_CHUNK_SIZE, max size is MAX_CHUNK_SIZE */
        var pending_data = make([]byte, current_upload_window)

        var origin_offset = offset
        var slice_offset = 0
        var slow_count = 0
        // slice is the buffer size of reader, the size is equal to remain size of pending_data
        var slice = pending_data[0:current_upload_window]
        for </span><span class="cov0" title="0">{
                start := time.Now()
                count, err := data.Read(slice)

                if count == 0 </span><span class="cov0" title="0">{
                        break</span>
                }
                // it's used to calculate next upload window
                <span class="cov0" title="0">elapsed_time := time.Since(start)

                slice_offset += count
                slice = pending_data[slice_offset:]

                //is pending_data full?
                if slice_offset &lt; len(pending_data) </span><span class="cov0" title="0">{
                        continue</span>
                }

                /* pending data is full now */
                <span class="cov0" title="0">_, err = striper.Write(oid, pending_data, offset)
                if err != nil </span><span class="cov0" title="0">{
                        return 0, fmt.Errorf("Bad io. pool:%s oid:%s", poolname, oid)
                }</span>

                <span class="cov0" title="0">offset += uint64(len(pending_data))

                /* Resize current upload window */
                expected_time := count * 1000 * 1000 * 1000 / current_upload_window /* 1000 * 1000 * 1000 means use Nanoseconds */

                // If the upload speed is less than half of the current upload window, reduce the upload window by half.
                // If upload speed is larger than current window size per second, used the larger window and twice
                if elapsed_time.Nanoseconds() &gt; 2*int64(expected_time) </span><span class="cov0" title="0">{
                        if slow_count &gt; 2 &amp;&amp; current_upload_window &gt; MIN_CHUNK_SIZE </span><span class="cov0" title="0">{
                                current_upload_window = current_upload_window &gt;&gt; 1
                                slow_count = 0
                        }</span>
                        <span class="cov0" title="0">slow_count += 1</span>
                } else<span class="cov0" title="0"> if int64(expected_time) &gt; elapsed_time.Nanoseconds() </span><span class="cov0" title="0">{
                        /* if upload speed is fast enough, enlarge the current_upload_window a bit */
                        current_upload_window = current_upload_window &lt;&lt; 1
                        if current_upload_window &gt; MAX_CHUNK_SIZE </span><span class="cov0" title="0">{
                                current_upload_window = MAX_CHUNK_SIZE
                        }</span>
                        <span class="cov0" title="0">slow_count = 0</span>
                }
                /* allocate a new pending data */
                <span class="cov0" title="0">pending_data = make([]byte, current_upload_window)
                slice_offset = 0
                slice = pending_data[0:current_upload_window]</span>
        }

        <span class="cov0" title="0">size = int64(uint64(slice_offset) + offset - origin_offset)
        //write all remaining data
        if slice_offset &gt; 0 </span><span class="cov0" title="0">{
                _, err = striper.Write(oid, pending_data, offset)
                if err != nil </span><span class="cov0" title="0">{
                        return 0, fmt.Errorf("Bad io. pool:%s oid:%s", poolname, oid)
                }</span>
        }

        <span class="cov0" title="0">return size, nil</span>
}

type RadosDownloader struct {
        striper   *rados.StriperPool
        oid       string
        offset    int64
        remaining int64
        pool      *rados.Pool
}

func (rd *RadosDownloader) Read(p []byte) (n int, err error) <span class="cov0" title="0">{
        if rd.remaining &lt;= 0 </span><span class="cov0" title="0">{
                return 0, io.EOF
        }</span>
        <span class="cov0" title="0">if int64(len(p)) &gt; rd.remaining </span><span class="cov0" title="0">{
                p = p[:rd.remaining]
        }</span>
        <span class="cov0" title="0">count, err := rd.striper.Read(rd.oid, p, uint64(rd.offset))
        if count == 0 </span><span class="cov0" title="0">{
                return 0, io.EOF
        }</span>
        <span class="cov0" title="0">rd.offset += int64(count)
        rd.remaining -= int64(count)
        return count, err</span>
}

func (rd *RadosDownloader) Seek(offset int64, whence int) (int64, error) <span class="cov0" title="0">{
        switch whence </span>{
        case 0:<span class="cov0" title="0">
                rd.offset = offset</span>
        case 1:<span class="cov0" title="0">
                rd.offset += offset</span>
        case 2:<span class="cov0" title="0">
                panic("Not implemented")</span>
        }
        <span class="cov0" title="0">return rd.offset, nil</span>
}

func (rd *RadosDownloader) Close() error <span class="cov0" title="0">{
        rd.striper.Destroy()
        rd.pool.Destroy()
        return nil
}</span>

func (cluster *CephStorage) getReader(poolName string, oid string, startOffset int64,
        length int64) (reader io.ReadCloser, err error) <span class="cov0" title="0">{

        if poolName == SMALL_FILE_POOLNAME </span><span class="cov0" title="0">{
                pool, e := cluster.Conn.OpenPool(poolName)
                if e != nil </span><span class="cov0" title="0">{
                        err = errors.New("bad poolname")
                        return
                }</span>
                <span class="cov0" title="0">radosSmallReader := &amp;RadosSmallDownloader{
                        oid:       oid,
                        offset:    startOffset,
                        pool:      pool,
                        remaining: length,
                }

                return radosSmallReader, nil</span>
        }

        <span class="cov0" title="0">pool, err := cluster.Conn.OpenPool(poolName)
        if err != nil </span><span class="cov0" title="0">{
                err = errors.New("bad poolname")
                return
        }</span>

        <span class="cov0" title="0">striper, err := pool.CreateStriper()
        if err != nil </span><span class="cov0" title="0">{
                err = errors.New("bad ioctx")
                return
        }</span>

        <span class="cov0" title="0">radosReader := &amp;RadosDownloader{
                striper:   &amp;striper,
                oid:       oid,
                offset:    startOffset,
                pool:      pool,
                remaining: length,
        }

        return radosReader, nil</span>
}

// Works together with `wrapAlignedEncryptionReader`, see comments there.
func (cluster *CephStorage) getAlignedReader(poolName string, oid string, startOffset int64,
        length int64) (reader io.ReadCloser, err error) <span class="cov0" title="0">{

        alignedOffset := startOffset / AES_BLOCK_SIZE * AES_BLOCK_SIZE
        length += startOffset - alignedOffset
        return cluster.getReader(poolName, oid, alignedOffset, length)
}</span>

func (cluster *CephStorage) doSmallRemove(poolname string, oid string) error <span class="cov0" title="0">{
        pool, err := cluster.Conn.OpenPool(poolname)
        if err != nil </span><span class="cov0" title="0">{
                return errors.New("Bad poolname")
        }</span>
        <span class="cov0" title="0">defer pool.Destroy()
        return pool.Delete(oid)</span>
}

func (cluster *CephStorage) Remove(poolname string, oid string) error <span class="cov0" title="0">{

        if poolname == SMALL_FILE_POOLNAME </span><span class="cov0" title="0">{
                return cluster.doSmallRemove(poolname, oid)
        }</span>

        <span class="cov0" title="0">pool, err := cluster.Conn.OpenPool(poolname)
        if err != nil </span><span class="cov0" title="0">{
                return errors.New("Bad poolname")
        }</span>
        <span class="cov0" title="0">defer pool.Destroy()

        striper, err := pool.CreateStriper()
        if err != nil </span><span class="cov0" title="0">{
                return errors.New("Bad ioctx")
        }</span>
        <span class="cov0" title="0">defer striper.Destroy()

        return striper.Delete(oid)</span>
}

func (cluster *CephStorage) GetUsedSpacePercent() (pct int, err error) <span class="cov0" title="0">{
        stat, err := cluster.Conn.GetClusterStats()
        if err != nil </span><span class="cov0" title="0">{
                return 0, errors.New("Stat error")
        }</span>
        <span class="cov0" title="0">pct = int(stat.Kb_used * uint64(100) / stat.Kb)
        return</span>
}
</pre>
		
		<pre class="file" id="file103" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package storage

import (
        "context"
        "errors"
        "runtime"
        "sync"
        "time"

        . "github.com/soda/multi-cloud/s3/error"
        "github.com/soda/multi-cloud/s3/pkg/datastore/yig/meta/types"
        log "github.com/sirupsen/logrus"
)

const (
        GC_OBJECT_LIMIT_NUM    = 10000
        CEPH_OBJ_NON_EXIST_ERR = "rados: ret=-2"
)

type GcMgr struct {
        // context to cancel the operations.
        ctx        context.Context
        cancelFunc context.CancelFunc
        yig        *YigStorage
        loopTime   int64
        wg         sync.WaitGroup
}

func (gm *GcMgr) Start() <span class="cov0" title="0">{
        // query the current available cpus
        threadNum := runtime.GOMAXPROCS(0)
        gm.wg.Add(1)
        go func() </span><span class="cov0" title="0">{
                for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-gm.ctx.Done():<span class="cov0" title="0">
                                log.Infof("GcMgr is stopping.")
                                gm.wg.Done()
                                return</span>
                        case &lt;-time.After(time.Second * time.Duration(gm.loopTime)):<span class="cov0" title="0"></span>
                        }
                        <span class="cov0" title="0">var chs []&lt;-chan *GcObjectResult
                        // get all the gc objects for this loop
                        gcChan := gm.QueryGcObjectStream()
                        // by default, we will start the go routines with the number of available cpus.
                        for i := 0; i &lt; threadNum; i++ </span><span class="cov0" title="0">{
                                // remove the gc objects from ceph storage
                                ch := gm.CreateObjectDeleteStream(gcChan)
                                chs = append(chs, ch)
                        }</span>
                        // clear the removed gc objects from gc table.
                        <span class="cov0" title="0">chResult := gm.CreateGcObjectRecordCleanStream(chs...)
                        // record the success or failure.
                        for result := range chResult </span><span class="cov0" title="0">{
                                if result.ErrNo == ErrNoErr </span><span class="cov0" title="0">{
                                        log.Debugf("succeed to remove object: %s", result.ObjectId)
                                        continue</span>
                                }
                                <span class="cov0" title="0">log.Errorf("failed to remove object: %s, err: %s", result.ObjectId, result.Err)</span>
                        }
                }
        }()
}

func (gm *GcMgr) Stop() <span class="cov0" title="0">{
        log.Infof("try to stop GcMgr...")
        gm.cancelFunc()
        gm.wg.Wait()
        log.Infof("GcMgr has stopped.")
}</span>

func (gm *GcMgr) QueryGcObjectStream() &lt;-chan *types.GcObject <span class="cov0" title="0">{
        out := make(chan *types.GcObject)
        go func() </span><span class="cov0" title="0">{
                defer close(out)
                start := int64(0)
                for </span><span class="cov0" title="0">{
                        gcObjects, err := gm.yig.MetaStorage.GetGcObjects(start, GC_OBJECT_LIMIT_NUM)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Errorf("failed to get gc objects(%d), err: %v", start, err)
                                return
                        }</span>
                        <span class="cov0" title="0">if gcObjects == nil || len(gcObjects) == 0 </span><span class="cov0" title="0">{
                                log.Debugf("got empty gc objects(%d)", start)
                                return
                        }</span>
                        // set the next marker to query the gc objects.
                        <span class="cov0" title="0">start = gcObjects[len(gcObjects)-1].Id + 1
                        for _, o := range gcObjects </span><span class="cov0" title="0">{
                                select </span>{
                                case out &lt;- o:<span class="cov0" title="0"></span>
                                case &lt;-gm.ctx.Done():<span class="cov0" title="0">
                                        return</span>
                                }
                        }
                        // check whether it is finished to read in this loop.
                        <span class="cov0" title="0">if len(gcObjects) &lt; GC_OBJECT_LIMIT_NUM </span><span class="cov0" title="0">{
                                return
                        }</span>
                }
        }()

        <span class="cov0" title="0">return out</span>
}

type GcObjectResult struct {
        ErrNo    S3ErrorCode
        Err      error
        Id       int64
        ObjectId string
}

func (gm *GcMgr) CreateObjectDeleteStream(in &lt;-chan *types.GcObject) &lt;-chan *GcObjectResult <span class="cov0" title="0">{
        out := make(chan *GcObjectResult)

        go func() </span><span class="cov0" title="0">{
                defer close(out)
                for o := range in </span><span class="cov0" title="0">{
                        result := &amp;GcObjectResult{
                                Id:       o.Id,
                                ObjectId: o.ObjectId,
                        }
                        ceph, ok := gm.yig.DataStorage[o.Location]
                        if !ok </span><span class="cov0" title="0">{
                                log.Errorf("cannot find the ceph storage for gc object(%s, %s, %s)", o.Location, o.Pool, o.ObjectId)
                                result.ErrNo = ErrNoSuchKey
                                result.Err = errors.New("cannot find the ceph storage")
                                select </span>{
                                case out &lt;- result:<span class="cov0" title="0"></span>
                                case &lt;-gm.ctx.Done():<span class="cov0" title="0">
                                        return</span>
                                }
                                <span class="cov0" title="0">continue</span>
                        }
                        <span class="cov0" title="0">err := ceph.Remove(o.Pool, o.ObjectId)
                        if err != nil &amp;&amp; err.Error() != CEPH_OBJ_NON_EXIST_ERR </span><span class="cov0" title="0">{
                                log.Errorf("failed to remove object(%s, %s, %s) from ceph, err: %v", o.Location, o.Pool, o.ObjectId, err)
                                result.ErrNo = ErrInternalError
                                result.Err = err
                                select </span>{
                                case out &lt;- result:<span class="cov0" title="0"></span>
                                case &lt;-gm.ctx.Done():<span class="cov0" title="0">
                                        return</span>
                                }
                                // just continue to remove next object.
                                <span class="cov0" title="0">continue</span>
                        }
                        <span class="cov0" title="0">result.Err = nil
                        result.ErrNo = ErrNoErr
                        select </span>{
                        case out &lt;- result:<span class="cov0" title="0"></span>
                        case &lt;-gm.ctx.Done():<span class="cov0" title="0">
                                return</span>
                        }
                }
        }()

        <span class="cov0" title="0">return out</span>
}

func (gm *GcMgr) CreateGcObjectRecordCleanStream(in ...&lt;-chan *GcObjectResult) &lt;-chan *GcObjectResult <span class="cov0" title="0">{
        wg := sync.WaitGroup{}
        out := make(chan *GcObjectResult)
        clearfunc := func(ch &lt;-chan *GcObjectResult) </span><span class="cov0" title="0">{
                defer wg.Done()
                count := 0
                var gcObjects []*types.GcObject
                for result := range ch </span><span class="cov0" title="0">{
                        // check error of the result
                        if result.ErrNo != ErrNoErr </span><span class="cov0" title="0">{
                                select </span>{
                                case out &lt;- result:<span class="cov0" title="0">
                                        continue</span>
                                case &lt;-gm.ctx.Done():<span class="cov0" title="0">
                                        return</span>
                                }
                        }
                        //batch clean the gc objects from gc table.
                        <span class="cov0" title="0">gcObj := &amp;types.GcObject{
                                ObjectId: result.ObjectId,
                        }
                        gcObjects = append(gcObjects, gcObj)
                        count += 1
                        if count &gt;= GC_OBJECT_LIMIT_NUM </span><span class="cov0" title="0">{
                                err := gm.yig.MetaStorage.DeleteGcObjects(gcObjects...)
                                if err != nil </span><span class="cov0" title="0">{
                                        for _, o := range gcObjects </span><span class="cov0" title="0">{
                                                clearResult := &amp;GcObjectResult{
                                                        ErrNo:    ErrInternalError,
                                                        Err:      err,
                                                        ObjectId: o.ObjectId,
                                                }
                                                select </span>{
                                                case out &lt;- clearResult:<span class="cov0" title="0"></span>
                                                case &lt;-gm.ctx.Done():<span class="cov0" title="0">
                                                        return</span>
                                                }
                                        }
                                } else<span class="cov0" title="0"> {
                                        for _, o := range gcObjects </span><span class="cov0" title="0">{
                                                clearResult := &amp;GcObjectResult{
                                                        ErrNo:    ErrNoErr,
                                                        Err:      nil,
                                                        ObjectId: o.ObjectId,
                                                }
                                                select </span>{
                                                case out &lt;- clearResult:<span class="cov0" title="0"></span>
                                                case &lt;-gm.ctx.Done():<span class="cov0" title="0">
                                                        return</span>
                                                }
                                        }
                                }
                                // free the buffer slice and re-calculate again.
                                <span class="cov0" title="0">count = 0
                                gcObjects = nil</span>
                        }
                }
                // clear the remaining gc objects.
                <span class="cov0" title="0">if len(gcObjects) &gt; 0 </span><span class="cov0" title="0">{
                        err := gm.yig.MetaStorage.DeleteGcObjects(gcObjects...)
                        if err != nil </span><span class="cov0" title="0">{
                                for _, o := range gcObjects </span><span class="cov0" title="0">{
                                        clearResult := &amp;GcObjectResult{
                                                ErrNo:    ErrInternalError,
                                                Err:      err,
                                                ObjectId: o.ObjectId,
                                        }
                                        select </span>{
                                        case out &lt;- clearResult:<span class="cov0" title="0"></span>
                                        case &lt;-gm.ctx.Done():<span class="cov0" title="0">
                                                return</span>
                                        }
                                }
                        } else<span class="cov0" title="0"> {
                                for _, o := range gcObjects </span><span class="cov0" title="0">{
                                        clearResult := &amp;GcObjectResult{
                                                ErrNo:    ErrNoErr,
                                                Err:      nil,
                                                ObjectId: o.ObjectId,
                                        }
                                        select </span>{
                                        case out &lt;- clearResult:<span class="cov0" title="0"></span>
                                        case &lt;-gm.ctx.Done():<span class="cov0" title="0">
                                                return</span>
                                        }
                                }
                        }
                }
        }
        <span class="cov0" title="0">for _, ch := range in </span><span class="cov0" title="0">{
                wg.Add(1)
                go clearfunc(ch)
        }</span>
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                wg.Wait()
                close(out)
        }</span>()
        <span class="cov0" title="0">return out</span>
}

func NewGcMgr(ctx context.Context, yig *YigStorage, loopTime int64) *GcMgr <span class="cov0" title="0">{
        cancelCtx, cancelFunc := context.WithCancel(ctx)
        return &amp;GcMgr{
                ctx:        cancelCtx,
                cancelFunc: cancelFunc,
                yig:        yig,
                loopTime:   loopTime,
                wg:         sync.WaitGroup{},
        }
}</span>
</pre>
		
		<pre class="file" id="file104" style="display: none">package storage

import (
        "context"
        "crypto/md5"
        "encoding/hex"
        "io"
        "sort"
        "strconv"

        s3err "github.com/soda/multi-cloud/s3/error"
        "github.com/soda/multi-cloud/s3/pkg/datastore/common"
        "github.com/soda/multi-cloud/s3/pkg/datastore/yig/meta/types"
        "github.com/soda/multi-cloud/s3/pkg/model"
        pb "github.com/soda/multi-cloud/s3/proto"
        log "github.com/sirupsen/logrus"
)

const (
        MAX_PART_SIZE   = 5 &lt;&lt; 30 // 5GB
        MIN_PART_SIZE   = 5 &lt;&lt; 20 // 5MB
        MIN_PART_NUMBER = 1
        MAX_PART_NUMBER = 10000
)

/*
* Below is the process of multipart upload:
* 1. InitMultipartUpload will return a upload id and object id, and the caller should save them.
* 2. caller should call UploadPart and input upload id and part number and then transfer the data.
* backend will save the upload id and the part number and other related information.
* 3. caller will call CompleteMultipartUpload and input the upload id, the backend
* will mark all the parts identified by upload id as completed. If the caller calls
* AbortMultipartUpload, backend will remove all the parts belongs to the upload id.
*
 */

func (yig *YigStorage) InitMultipartUpload(ctx context.Context, object *pb.Object) (*pb.MultipartUpload, error) <span class="cov0" title="0">{
        uploadId := uploadId2Str(yig.idGen.GetId())
        mu := &amp;pb.MultipartUpload{
                Bucket:   object.BucketName,
                Key:      object.ObjectKey,
                UploadId: uploadId,
                ObjectId: uploadId,
        }
        return mu, nil
}</span>

/*
* ctx: the context should contain below information: md5
*
 */

func (yig *YigStorage) UploadPart(ctx context.Context, stream io.Reader, multipartUpload *pb.MultipartUpload,
        partNumber int64, upBytes int64) (*model.UploadPartResult, error) <span class="cov0" title="0">{
        // check the limiation https://docs.aws.amazon.com/zh_cn/AmazonS3/latest/dev/qfacts.html
        if upBytes &gt; MAX_PART_SIZE </span><span class="cov0" title="0">{
                log.Errorf("UploadPart(%s, %s, %s, %d) failed, the size %d exceeds the maximum size.", multipartUpload.Bucket, multipartUpload.Key, multipartUpload.UploadId, partNumber, upBytes)
                return nil, s3err.ErrEntityTooLarge
        }</span>
        <span class="cov0" title="0">if partNumber &lt; MIN_PART_NUMBER || partNumber &gt; MAX_PART_NUMBER </span><span class="cov0" title="0">{
                log.Errorf("UploadPart(%s, %s, %s, %d) failed, got invalid partNumber.", multipartUpload.Bucket, multipartUpload.Key, multipartUpload.UploadId, partNumber)
                return nil, s3err.ErrInvalidPart
        }</span>
        <span class="cov0" title="0">uploadId, err := str2UploadId(multipartUpload.UploadId)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("UploadPart(%s, %s, %s, %d) failed, failed to convert uploadId to int64, err: %v", multipartUpload.Bucket, multipartUpload.Key, multipartUpload.UploadId, partNumber, err)
                return nil, s3err.ErrNoSuchUpload
        }</span>
        // TODO we need check whether the part number exists or not, if it already exists, we need to override it.
        <span class="cov0" title="0">md5Writer := md5.New()
        inputMd5 := ""
        if val := ctx.Value(common.CONTEXT_KEY_MD5); val != nil </span><span class="cov0" title="0">{
                inputMd5 = val.(string)
        }</span>

        <span class="cov0" title="0">limitedDataReader := io.LimitReader(stream, upBytes)
        cephCluster, poolName := yig.PickOneClusterAndPool(multipartUpload.Bucket, multipartUpload.Key, upBytes, false)
        if cephCluster == nil </span><span class="cov0" title="0">{
                log.Errorf("UploadPart(%s, %s, %s, %d) failed, cannot find the cluster", multipartUpload.Bucket, multipartUpload.Key, multipartUpload.UploadId, partNumber)
                return nil, s3err.ErrInternalError
        }</span>
        <span class="cov0" title="0">oid := cephCluster.GetUniqUploadName()
        dataReader := io.TeeReader(limitedDataReader, md5Writer)
        bytesWritten, err := cephCluster.Put(poolName, oid, dataReader)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to UploadPart(%s, %s, %s, %d), err: %v", multipartUpload.Bucket, multipartUpload.Key, multipartUpload.UploadId, partNumber, err)
                return nil, err
        }</span>
        // Should metadata update failed, put the object to gc,
        // so the object in Ceph could be removed asynchronously
        <span class="cov0" title="0">shouldGc := false
        defer func() </span><span class="cov0" title="0">{
                if shouldGc </span><span class="cov0" title="0">{
                        if err := yig.putObjToGc(cephCluster.Name, poolName, oid); err != nil </span><span class="cov0" title="0">{
                                log.Errorf("failed to put(%s, %s, %s) to gc, err: %v", cephCluster.Name, poolName, oid, err)
                        }</span>
                }
        }()

        <span class="cov0" title="0">if bytesWritten &lt; upBytes </span><span class="cov0" title="0">{
                shouldGc = true
                log.Errorf("failed to UploadPart(%s, %s, %s, %d), written: %d, total: %d", multipartUpload.Bucket, multipartUpload.Key, multipartUpload.UploadId, partNumber, bytesWritten, upBytes)
                return nil, s3err.ErrIncompleteBody
        }</span>
        <span class="cov0" title="0">calculatedMd5 := hex.EncodeToString(md5Writer.Sum(nil))
        if inputMd5 != "" &amp;&amp; inputMd5 != calculatedMd5 </span><span class="cov0" title="0">{
                shouldGc = true
                log.Errorf("failed to UploadPart(%s, %s, %s, %d), input md5: %s, calculated: %s", multipartUpload.Bucket, multipartUpload.Key, multipartUpload.UploadId, partNumber, inputMd5, calculatedMd5)
                return nil, s3err.ErrBadDigest
        }</span>
        <span class="cov0" title="0">partInfo := &amp;types.PartInfo{
                UploadId: uploadId,
                PartNum:  partNumber,
                ObjectId: oid,
                Location: cephCluster.Name,
                Pool:     poolName,
                Size:     uint64(upBytes),
                Etag:     calculatedMd5,
                Flag:     types.MULTIPART_UPLOAD_IN_PROCESS,
        }
        err = yig.MetaStorage.PutPart(partInfo)
        if err != nil </span><span class="cov0" title="0">{
                shouldGc = true
                log.Errorf("failed to  put part for %s, %s, %s, %d, err: %v", multipartUpload.Bucket, multipartUpload.Key, multipartUpload.UploadId, partNumber, err)
                return nil, err
        }</span>
        <span class="cov0" title="0">result := &amp;model.UploadPartResult{
                PartNumber: partNumber,
                ETag:       calculatedMd5,
        }
        return result, nil</span>
}

func (yig *YigStorage) CompleteMultipartUpload(ctx context.Context, multipartUpload *pb.MultipartUpload,
        completeUpload *model.CompleteMultipartUpload) (*model.CompleteMultipartUploadResult, error) <span class="cov0" title="0">{
        uploadId, err := str2UploadId(multipartUpload.UploadId)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to convert uploadId(%s) to int64, err: %v", multipartUpload.UploadId, err)
                return nil, err
        }</span>
        <span class="cov0" title="0">parts, err := yig.MetaStorage.ListParts(uploadId)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to list parts for uploadId(%d), err: %v", uploadId, err)
                return nil, err
        }</span>

        // check whether the given parts are already recorded in db.
        <span class="cov0" title="0">if len(parts) != len(completeUpload.Parts) </span><span class="cov0" title="0">{
                log.Errorf("input len(parts): %d, while we recorded len(parts): %d", len(completeUpload.Parts), len(parts))
                return nil, s3err.ErrInvalidPartOrder
        }</span>

        <span class="cov0" title="0">md5Writer := md5.New()
        totalSize := uint64(0)
        for k, part := range completeUpload.Parts </span><span class="cov0" title="0">{
                // chech whether the part number starts at 1 and increases one by one.
                if part.PartNumber != int64(k+1) </span><span class="cov0" title="0">{
                        log.Errorf("got invalid part[%d, %s] for uploadId %d with idx %d", part.PartNumber, part.ETag, uploadId, k)
                        return nil, s3err.ErrInvalidPart
                }</span>
                // check whether the given parts are already recorded in db.
                <span class="cov0" title="0">i := sort.Search(len(parts), func(i int) bool </span><span class="cov0" title="0">{ return parts[i].PartNum &gt;= part.PartNumber }</span>)
                <span class="cov0" title="0">if i &gt;= len(parts) || parts[i].PartNum != part.PartNumber </span><span class="cov0" title="0">{
                        log.Errorf("we cannot find the part[%d, %s] for uploadId %d", part.PartNumber, part.ETag, uploadId)
                        return nil, s3err.ErrInvalidPart
                }</span>
                // check whether etag is matched.
                <span class="cov0" title="0">if part.ETag != parts[i].Etag </span><span class="cov0" title="0">{
                        log.Errorf("got invalid part(%d, %s), the etag recorded is %s", part.PartNumber, part.ETag, parts[i].Etag)
                        return nil, s3err.ErrInvalidPart
                }</span>
                // caclulate the md5 of etag for the whole object.
                <span class="cov0" title="0">var etagBytes []byte
                etagBytes, err = hex.DecodeString(part.ETag)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("failed to decode etag of part(%d, %s) of uploadId(%d)", part.PartNumber, part.ETag, uploadId)
                        return nil, s3err.ErrInvalidPart
                }</span>
                <span class="cov0" title="0">md5Writer.Write(etagBytes)
                // check whether the size of each part except the last one is &gt;= 5M and &lt;= 5G.
                if parts[i].Size &lt; MIN_PART_SIZE &amp;&amp; i &lt; len(parts)-1 </span><span class="cov0" title="0">{
                        log.Errorf("got invalid size %d for part(%d, %s) of uploadId %d", parts[i].Size, parts[i].PartNum, parts[i].Etag, uploadId)
                        return nil, s3err.ErrInvalidPart
                }</span>
                // complete an already completed uploadId, 404 will be returned.
                <span class="cov0" title="0">if parts[i].Flag == types.MULTIPART_UPLOAD_COMPLETE </span><span class="cov0" title="0">{
                        log.Errorf("got completed part(%d) for uploadId %d", parts[i].PartNum, uploadId)
                        return nil, s3err.ErrNoSuchUpload
                }</span>

                <span class="cov0" title="0">parts[i].Flag = types.MULTIPART_UPLOAD_COMPLETE
                parts[i].Offset = totalSize
                totalSize += parts[i].Size</span>
        }
        // completes the parts.
        <span class="cov0" title="0">err = yig.MetaStorage.CompleteParts(uploadId, parts)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to complete parts for uploadId(%d), err: %v", uploadId, err)
                return nil, err
        }</span>
        <span class="cov0" title="0">result := &amp;model.CompleteMultipartUploadResult{
                Bucket: multipartUpload.Bucket,
                Key:    multipartUpload.Key,
        }
        result.ETag = hex.EncodeToString(md5Writer.Sum(nil))
        result.ETag += "-" + strconv.Itoa(len(parts))
        result.Size = int64(totalSize)
        return result, nil</span>
}

func (yig *YigStorage) AbortMultipartUpload(ctx context.Context, multipartUpload *pb.MultipartUpload) error <span class="cov0" title="0">{
        uploadId, err := str2UploadId(multipartUpload.UploadId)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to AbortMultipartUpload for %s, it was fail to parse uploadId, err: %v", multipartUpload.UploadId, err)
                return err
        }</span>
        <span class="cov0" title="0">parts, err := yig.MetaStorage.ListParts(uploadId)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to get parts for uploadId(%d), err: %v", uploadId, err)
                return err
        }</span>

        // remove the parts info from meta.
        <span class="cov0" title="0">err = yig.MetaStorage.DeleteParts(uploadId)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to delete parts from meta for uploadId(%d), err: %v", uploadId, err)
                return err
        }</span>

        // remove all the parts from ceph cluster.
        <span class="cov0" title="0">for _, p := range parts </span><span class="cov0" title="0">{
                err = yig.putObjToGc(p.Location, p.Pool, p.ObjectId)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("failed to put part(%s, %s, %s) to gc, err: %v", p.Location, p.Pool, p.ObjectId, err)
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (yig *YigStorage) ListParts(ctx context.Context, multipartUpload *pb.ListParts) (*model.ListPartsOutput, error) <span class="cov0" title="0">{
        uploadId, err := str2UploadId(multipartUpload.UploadId)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to ListParts for %s, it failed to parse uploadId, err: %v", multipartUpload.UploadId, err)
                return nil, err
        }</span>
        <span class="cov0" title="0">parts, err := yig.MetaStorage.ListParts(uploadId)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("ListParts failed, failed to get parts for uploadId(%d), err: %v", uploadId, err)
                return nil, err
        }</span>

        <span class="cov0" title="0">var partList []model.Part

        for i, part := range parts </span><span class="cov0" title="0">{
                if multipartUpload.PartNumberMarker &gt; 0 &amp;&amp; int64(i) &lt;= multipartUpload.PartNumberMarker </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if multipartUpload.MaxParts &gt; 0 &amp;&amp; int64(i) &gt; multipartUpload.MaxParts </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">p := model.Part{
                        PartNumber:     part.PartNum,
                        ETag:           part.Etag,
                        Size:           int64(part.Size),
                        LastModifyTime: part.UpdateTime.Unix(),
                }
                partList = append(partList, p)</span>
        }

        <span class="cov0" title="0">output := &amp;model.ListPartsOutput{
                Bucket:      multipartUpload.Bucket,
                Key:         multipartUpload.Key,
                UploadId:    multipartUpload.UploadId,
                MaxParts:    int(multipartUpload.MaxParts),
                IsTruncated: false,
                Parts:       partList,
        }

        return output, nil</span>
}

func uploadId2Str(id int64) string <span class="cov0" title="0">{
        return strconv.FormatUint(uint64(id), 16)
}</span>

func str2UploadId(id string) (uint64, error) <span class="cov0" title="0">{
        return strconv.ParseUint(id, 16, 64)
}</span>
</pre>
		
		<pre class="file" id="file105" style="display: none">package storage

import (
        "io"

        s3err "github.com/soda/multi-cloud/s3/error"
        "github.com/soda/multi-cloud/s3/pkg/datastore/yig/meta/types"
        log "github.com/sirupsen/logrus"
)

type MultipartReader struct {
        // uploadId for this multipart uploaded object.
        uploadId uint64
        // where to read from
        start int64
        // how much data to read
        len int64
        // parts for this uploadId, must be sorted by part number ascendly.
        parts []*types.PartInfo
        // YigStorage handle.
        yig *YigStorage
}

func (mr *MultipartReader) Read(p []byte) (int, error) <span class="cov0" title="0">{
        if len(mr.parts) == 0 || mr.len &lt;= 0 </span><span class="cov0" title="0">{
                return 0, io.EOF
        }</span>
        <span class="cov0" title="0">if mr.parts[len(mr.parts)-1].Offset+mr.parts[len(mr.parts)-1].Size &lt;= uint64(mr.start) </span><span class="cov0" title="0">{
                return 0, io.EOF
        }</span>
        // total length of input buffer
        <span class="cov0" title="0">total := len(p)
        if int64(total) &gt; mr.len </span><span class="cov0" title="0">{
                total = int(mr.len)
        }</span>
        // where to start read from in the buffer.
        // the data whose position &lt; begin is already read.
        <span class="cov0" title="0">begin := 0
        for _, part := range mr.parts </span><span class="cov0" title="0">{
                if part.Offset+part.Size &lt; uint64(mr.start) </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">cephCluster, ok := mr.yig.DataStorage[part.Location]
                if !ok </span><span class="cov0" title="0">{
                        log.Errorf("failed to get cephCluster for part(%d, %d, %s)", part.UploadId, part.PartNum, part.Location)
                        return 0, s3err.ErrInvalidPart
                }</span>
                <span class="cov0" title="0">reader, err := cephCluster.getReader(part.Pool, part.ObjectId, mr.start-int64(part.Offset), int64(total-begin))
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("failed to get reader from ceph cluter for part(%d, %d, %s), err: %v", part.UploadId, part.PartNum, part.Location)
                        return 0, s3err.ErrInvalidPart
                }</span>
                <span class="cov0" title="0">n, err := reader.Read(p[begin:])
                // one read will try to read the whole data for the input buffer on each reader.
                reader.Close()
                if err != nil </span><span class="cov0" title="0">{
                        if err == io.EOF </span><span class="cov0" title="0">{
                                mr.start += int64(n)
                                begin += n
                                mr.len -= int64(n)
                                if begin &lt; total </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov0" title="0">return 0, err</span>
                        }
                        <span class="cov0" title="0">log.Infof("read data from uploadId(%d) with start(%d), len(%d) failed, err: %v", mr.uploadId, mr.start, mr.len, err)
                        return n, err</span>
                }
                <span class="cov0" title="0">mr.start += int64(n)
                begin += n
                mr.len -= int64(n)
                if begin &gt;= total </span><span class="cov0" title="0">{
                        break</span>
                }
        }

        <span class="cov0" title="0">return begin, nil</span>
}

func (mr *MultipartReader) Close() error <span class="cov0" title="0">{
        return nil
}</span>

func NewMultipartReader(yig *YigStorage, uploadIdStr string, start int64, end int64) (*MultipartReader, error) <span class="cov0" title="0">{
        uploadId, err := str2UploadId(uploadIdStr)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to create MultipartReader, got invalid uploadId(%s), err: %v", uploadIdStr, err)
                return nil, err
        }</span>
        <span class="cov0" title="0">totalparts, err := yig.MetaStorage.ListParts(uploadId)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to create MultipartReader, failed to list parts for uploadId(%s), err: %v", uploadIdStr, err)
                return nil, err
        }</span>
        <span class="cov0" title="0">var parts []*types.PartInfo
        for _, part := range totalparts </span><span class="cov0" title="0">{
                if part.Offset+part.Size &gt;= uint64(start) &amp;&amp; part.Offset &lt;= uint64(end) </span><span class="cov0" title="0">{
                        parts = append(parts, part)
                }</span>
        }
        <span class="cov0" title="0">return &amp;MultipartReader{
                uploadId: uploadId,
                start:    start,
                len:      end - start + 1,
                parts:    parts,
                yig:      yig,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file106" style="display: none">package storage

import (
        "context"
        "crypto/md5"
        "encoding/hex"
        "encoding/json"
        "errors"
        "io"
        "math/rand"
        "time"

        . "github.com/soda/multi-cloud/s3/error"
        dscommon "github.com/soda/multi-cloud/s3/pkg/datastore/common"
        "github.com/soda/multi-cloud/s3/pkg/datastore/yig/meta/types"
        pb "github.com/soda/multi-cloud/s3/proto"
        log "github.com/sirupsen/logrus"
)

var latestQueryTime [2]time.Time // 0 is for SMALL_FILE_POOLNAME, 1 is for BIG_FILE_POOLNAME
const CLUSTER_MAX_USED_SPACE_PERCENT = 85

func (yig *YigStorage) PickOneClusterAndPool(bucket string, object string, size int64, isAppend bool) (cluster *CephStorage,
        poolName string) <span class="cov0" title="0">{

        var idx int
        if isAppend </span><span class="cov0" title="0">{
                poolName = BIG_FILE_POOLNAME
                idx = 1
        }</span> else<span class="cov0" title="0"> if size &lt; 0 </span><span class="cov0" title="0">{ // request.ContentLength is -1 if length is unknown
                poolName = BIG_FILE_POOLNAME
                idx = 1
        }</span> else<span class="cov0" title="0"> if size &lt; BIG_FILE_THRESHOLD </span><span class="cov0" title="0">{
                poolName = SMALL_FILE_POOLNAME
                idx = 0
        }</span> else<span class="cov0" title="0"> {
                poolName = BIG_FILE_POOLNAME
                idx = 1
        }</span>
        <span class="cov0" title="0">var needCheck bool
        queryTime := latestQueryTime[idx]
        if time.Since(queryTime).Hours() &gt; 24 </span><span class="cov0" title="0">{ // check used space every 24 hours
                latestQueryTime[idx] = time.Now()
                needCheck = true
        }</span>
        <span class="cov0" title="0">var totalWeight int
        clusterWeights := make(map[string]int, len(yig.DataStorage))
        for fsid, _ := range yig.DataStorage </span><span class="cov0" title="0">{
                cluster, err := yig.MetaStorage.GetCluster(fsid, poolName)
                if err != nil </span><span class="cov0" title="0">{
                        log.Debug("Error getting cluster: ", err)
                        continue</span>
                }
                <span class="cov0" title="0">if cluster.Weight == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if needCheck </span><span class="cov0" title="0">{
                        pct, err := yig.DataStorage[fsid].GetUsedSpacePercent()
                        if err != nil </span><span class="cov0" title="0">{
                                log.Error("Error getting used space: ", err, "fsid: ", fsid)
                                continue</span>
                        }
                        <span class="cov0" title="0">if pct &gt; CLUSTER_MAX_USED_SPACE_PERCENT </span><span class="cov0" title="0">{
                                log.Error("Cluster used space exceed ", CLUSTER_MAX_USED_SPACE_PERCENT, fsid)
                                continue</span>
                        }
                }
                <span class="cov0" title="0">totalWeight += cluster.Weight
                clusterWeights[fsid] = cluster.Weight</span>
        }
        <span class="cov0" title="0">if len(clusterWeights) == 0 || totalWeight == 0 </span><span class="cov0" title="0">{
                log.Warn("Error picking cluster from table cluster in DB! Use first cluster in config to write.")
                for _, c := range yig.DataStorage </span><span class="cov0" title="0">{
                        cluster = c
                        break</span>
                }
                <span class="cov0" title="0">return</span>
        }
        <span class="cov0" title="0">N := rand.Intn(totalWeight)
        n := 0
        for fsid, weight := range clusterWeights </span><span class="cov0" title="0">{
                n += weight
                if n &gt; N </span><span class="cov0" title="0">{
                        cluster = yig.DataStorage[fsid]
                        break</span>
                }
        }
        <span class="cov0" title="0">return</span>
}

func (yig *YigStorage) GetClusterByFsName(fsName string) (cluster *CephStorage, err error) <span class="cov0" title="0">{
        if c, ok := yig.DataStorage[fsName]; ok </span><span class="cov0" title="0">{
                cluster = c
        }</span> else<span class="cov0" title="0"> {
                err = errors.New("Cannot find specified ceph cluster: " + fsName)
        }</span>
        <span class="cov0" title="0">return</span>
}

// Write path:
//                                           +-----------+
// PUT object/part                           |           |   Ceph
//         +---------+------------+----------+ Encryptor +-----&gt;
//                   |            |          |           |
//                   |            |          +-----------+
//                   v            v
//                  SHA256      MD5(ETag)
//
// SHA256 is calculated only for v4 signed authentication
// Encryptor is enabled when user set SSE headers

/* ctx should contain below elements:
 * size: object size.
 * encryptionKey:
 * md5: the md5 put by user for the uploading object.
 */
func (yig *YigStorage) Put(ctx context.Context, stream io.Reader, obj *pb.Object) (result dscommon.PutResult,
        err error) <span class="cov0" title="0">{
        // get size from context.
        val := ctx.Value(dscommon.CONTEXT_KEY_SIZE)
        if val == nil </span><span class="cov0" title="0">{
                return result, ErrIncompleteBody
        }</span>
        <span class="cov0" title="0">size := val.(int64)
        // md5 provided by user for uploading object.
        userMd5 := ""
        if val = ctx.Value(dscommon.CONTEXT_KEY_MD5); val != nil </span><span class="cov0" title="0">{
                userMd5 = val.(string)
        }</span>

        // check and remove the old object if exists.
        <span class="cov0" title="0">if obj.StorageMeta != "" &amp;&amp; obj.ObjectId != "" </span><span class="cov0" title="0">{
                storageMeta, err := ParseObjectMeta(obj.StorageMeta)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("Put(%s, %s, %s) failed, failed to parse storage meta(%s), err: %v", obj.BucketName,
                                obj.ObjectKey, obj.ObjectId, obj.StorageMeta, err)
                        return result, err
                }</span>
                <span class="cov0" title="0">err = yig.putObjToGc(storageMeta.Cluster, storageMeta.Pool, obj.ObjectId)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("Put(%s, %s, %s) failed, failed to put old obj(%s) to gc, err: %v", obj.BucketName,
                                obj.ObjectKey, obj.ObjectId, obj.ObjectId, err)
                        return result, err
                }</span>
        }

        <span class="cov0" title="0">md5Writer := md5.New()

        // Limit the reader to its provided size if specified.
        var limitedDataReader io.Reader
        if size &gt; 0 </span><span class="cov0" title="0">{ // request.ContentLength is -1 if length is unknown
                limitedDataReader = io.LimitReader(stream, size)
        }</span> else<span class="cov0" title="0"> {
                limitedDataReader = stream
        }</span>

        <span class="cov0" title="0">cephCluster, poolName := yig.PickOneClusterAndPool(obj.BucketName, obj.ObjectKey, size, false)
        if cephCluster == nil </span><span class="cov0" title="0">{
                log.Errorf("failed to pick cluster and pool for(%s, %s), err: %v", obj.BucketName, obj.ObjectKey, err)
                return result, ErrInternalError
        }</span>

        <span class="cov0" title="0">objMeta := ObjectMetaInfo{
                Cluster: cephCluster.Name,
                Pool:    poolName,
        }

        metaBytes, err := json.Marshal(objMeta)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to marshal %v for (%s, %s), err: %v", objMeta, obj.BucketName, obj.ObjectKey, err)
                return result, ErrInternalError
        }</span>

        // Mapping a shorter name for the object
        <span class="cov0" title="0">oid := cephCluster.GetUniqUploadName()
        dataReader := io.TeeReader(limitedDataReader, md5Writer)

        bytesWritten, err := cephCluster.Put(poolName, oid, dataReader)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to put(%s, %s), err: %v", poolName, oid, err)
                return
        }</span>
        // Should metadata update failed, put the oid to gc,
        // so the object in Ceph could be removed asynchronously
        <span class="cov0" title="0">shouldGc := false
        defer func() </span><span class="cov0" title="0">{
                if shouldGc </span><span class="cov0" title="0">{
                        if err := yig.putObjToGc(cephCluster.Name, poolName, oid); err != nil </span><span class="cov0" title="0">{
                                log.Errorf("failed to put (%s, %s, %s) to gc, err: %v", cephCluster.Name, poolName, oid, err)
                        }</span>
                }
        }()
        <span class="cov0" title="0">if bytesWritten &lt; size </span><span class="cov0" title="0">{
                shouldGc = true
                log.Errorf("failed to write objects, already written(%d), total size(%d)", bytesWritten, size)
                return result, ErrIncompleteBody
        }</span>

        <span class="cov0" title="0">calculatedMd5 := hex.EncodeToString(md5Writer.Sum(nil))
        log.Info("### calculatedMd5:", calculatedMd5, "userMd5:", userMd5)
        if userMd5 != "" &amp;&amp; userMd5 != calculatedMd5 </span><span class="cov0" title="0">{
                shouldGc = true
                return result, ErrBadDigest
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                shouldGc = true
                return
        }</span>

        // set the bytes written.
        <span class="cov0" title="0">result.Written = bytesWritten
        result.ObjectId = oid
        result.Etag = calculatedMd5
        result.UpdateTime = time.Now().Unix()
        result.Meta = string(metaBytes)

        return result, nil</span>
}

func (yig *YigStorage) Get(ctx context.Context, object *pb.Object, start int64, end int64) (io.ReadCloser, error) <span class="cov0" title="0">{
        // if object.StorageMeta is nil, it may be the multipart uploaded object.
        if len(object.StorageMeta) == 0 </span><span class="cov0" title="0">{
                reader, err := NewMultipartReader(yig, object.ObjectId, start, end)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("failed to get object(%s, %s, %s) with start(%d), end(%d), err: %v", object.BucketName, object.ObjectKey, object.ObjectId, start, end, err)
                        return nil, err
                }</span>
                <span class="cov0" title="0">return reader, nil</span>
        }
        // get the cluster name and pool name from meta data of object
        <span class="cov0" title="0">objMeta, err := ParseObjectMeta(object.StorageMeta)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to unmarshal storage meta (%s) for (%s, %s), err: %v", object.StorageMeta, object.BucketName, object.ObjectKey, err)
                return nil, ErrUnmarshalFailed
        }</span>

        <span class="cov0" title="0">cephCluster, ok := yig.DataStorage[objMeta.Cluster]
        if !ok </span><span class="cov0" title="0">{
                log.Errorf("cannot find ceph cluster(%s) for obj(%s, %s)", objMeta.Cluster, object.BucketName, object.ObjectKey)
                return nil, ErrInvalidObjectName
        }</span>

        <span class="cov0" title="0">len := end - start + 1
        reader, err := cephCluster.getReader(objMeta.Pool, object.ObjectId, start, len)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to get ceph reader for pool(%s), obj(%s,%s) with err: %v", objMeta.Pool, object.BucketName, object.ObjectKey, err)
                return nil, err
        }</span>

        <span class="cov0" title="0">return reader, nil</span>
}

/*
* @objectId: input object id which will be deleted.
* Below is the process logic:
* 1. check whether objectId is multipart uploaded, if so
* retrieve all the object ids from multiparts and put them into gc.
* or else, put it into gc.
*
 */
func (yig *YigStorage) Delete(ctx context.Context, object *pb.DeleteObjectInput) error <span class="cov0" title="0">{
        // For multipart uploaded objects, no storage metas are returned to caller,
        // so, when delete these objects, the meta will be empty.
        // we need to perform check for multipart uploaded objects.
        if object.StorageMeta == "" </span><span class="cov0" title="0">{
                uploadId, err := str2UploadId(object.ObjectId)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("Delete(%s, %s, %s) failed, failed to parse uploadId(%s), err: %v", object.Bucket,
                                object.Key, object.ObjectId, object.ObjectId, err)
                        return err
                }</span>
                <span class="cov0" title="0">parts, err := yig.MetaStorage.ListParts(uploadId)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("Delete(%s, %s, %s) failed, cannot listParts(%d), err: %v", object.Bucket,
                                object.Key, object.ObjectId, uploadId, err)
                        return err
                }</span>
                <span class="cov0" title="0">err = yig.MetaStorage.PutPartsInGc(parts)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("Delete(%s, %s, %s) failed, failed to put parts in gc, err: %v", object.Bucket,
                                object.Key, object.ObjectId, err)
                        return err
                }</span>

                <span class="cov0" title="0">return nil</span>
        }

        // put the normal object into gc.
        <span class="cov0" title="0">objMeta, err := ParseObjectMeta(object.StorageMeta)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("Delete(%s, %s, %s) failed, cannot parse meta(%s), err: %v", object.Bucket,
                        object.Key, object.ObjectId, object.StorageMeta, err)
                return err
        }</span>
        <span class="cov0" title="0">gcObj := &amp;types.GcObject{
                Location: objMeta.Cluster,
                Pool:     objMeta.Pool,
                ObjectId: object.ObjectId,
        }
        err = yig.MetaStorage.PutGcObjects(gcObj)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("Delete(%s, %s, %s) failed, failed to put gc object, err: %v", object.Bucket,
                        object.Key, object.ObjectId, err)
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (yig *YigStorage) ChangeStorageClass(ctx context.Context, object *pb.Object, newClass *string) error <span class="cov0" title="0">{
        return errors.New("not implemented.")
}</span>

/*
* target: should contain BucketName, ObjectKey, Size, Etag
*
 */

func (yig *YigStorage) Copy(ctx context.Context, stream io.Reader, target *pb.Object) (result dscommon.PutResult, err error) <span class="cov0" title="0">{
        var limitedDataReader io.Reader
        limitedDataReader = io.LimitReader(stream, target.Size)
        cephCluster, poolName := yig.PickOneClusterAndPool(target.BucketName, target.ObjectKey, target.Size, false)
        md5Writer := md5.New()
        oid := cephCluster.GetUniqUploadName()

        objMeta := ObjectMetaInfo{
                Cluster: cephCluster.Name,
                Pool:    poolName,
        }

        metaBytes, err := json.Marshal(objMeta)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to marshal %v for (%s, %s), err: %v", objMeta, target.BucketName, target.ObjectKey, err)
                return result, ErrInternalError
        }</span>

        <span class="cov0" title="0">dataReader := io.TeeReader(limitedDataReader, md5Writer)
        var bytesWritten int64
        bytesWritten, err = cephCluster.Put(poolName, oid, dataReader)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to write oid[%s] for obj[%s] in bucket[%s] with err: %v", oid, target.ObjectKey, target.BucketName, err)
                return result, err
        }</span>
        // Should metadata update failed, put the object to gc,
        // so the object in Ceph could be removed asynchronously
        <span class="cov0" title="0">shouldGc := false
        defer func() </span><span class="cov0" title="0">{
                if shouldGc </span><span class="cov0" title="0">{
                        if err := yig.putObjToGc(cephCluster.Name, poolName, oid); err != nil </span><span class="cov0" title="0">{
                                log.Errorf("failed to put(%s, %s, %s) to gc, err: %v", cephCluster.Name, poolName, oid, err)
                        }</span>
                }
        }()

        <span class="cov0" title="0">if bytesWritten &lt; target.Size </span><span class="cov0" title="0">{
                shouldGc = true
                return result, ErrIncompleteBody
        }</span>

        <span class="cov0" title="0">calculatedMd5 := hex.EncodeToString(md5Writer.Sum(nil))
        if calculatedMd5 != target.Etag </span><span class="cov0" title="0">{
                shouldGc = true
                return result, ErrBadDigest
        }</span>

        <span class="cov0" title="0">result.Etag = calculatedMd5
        result.Written = bytesWritten
        result.ObjectId = oid
        result.UpdateTime = time.Now().Unix()
        result.Meta = string(metaBytes)
        target.ObjectId = oid

        log.Debugf("succeeded to copy object[%s] in bucket[%s] with oid[%s]", target.ObjectKey, target.BucketName, oid)
        return result, nil</span>
}

func (yig *YigStorage) putObjToGc(location, pool, objectId string) error <span class="cov0" title="0">{
        gcObj := &amp;types.GcObject{
                Location: location,
                Pool:     pool,
                ObjectId: objectId,
        }
        err := yig.MetaStorage.PutGcObjects(gcObj)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("Delete(%s, %s, %s) failed, failed to put gc object, err: %v", location,
                        pool, objectId, err)
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func ParseObjectMeta(meta string) (ObjectMetaInfo, error) <span class="cov0" title="0">{
        objMeta := ObjectMetaInfo{}

        err := json.Unmarshal([]byte(meta), &amp;objMeta)
        if err != nil </span><span class="cov0" title="0">{
                return objMeta, err
        }</span>

        <span class="cov0" title="0">return objMeta, nil</span>
}
</pre>
		
		<pre class="file" id="file107" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package storage

import (
        "context"
        "crypto/aes"
        "crypto/cipher"
        "crypto/rand"
        "errors"
        "io"
        "path/filepath"

        "github.com/soda/multi-cloud/s3/pkg/datastore/yig/config"
        "github.com/soda/multi-cloud/s3/pkg/datastore/yig/crypto"
        "github.com/soda/multi-cloud/s3/pkg/datastore/yig/meta"
        "github.com/soda/multi-cloud/s3/pkg/datastore/yig/utils"
        log "github.com/sirupsen/logrus"
)

const (
        AES_BLOCK_SIZE               = 16
        ENCRYPTION_KEY_LENGTH        = 32 // key size for AES-"256"
        INITIALIZATION_VECTOR_LENGTH = 16 // block size of AES
        DEFAULT_CEPHCONFIG_PATTERN   = "conf/*.conf"
)

var (
        RootContext = context.Background()
)

// YigStorage implements StorageDriver
type YigStorage struct {
        DataStorage map[string]*CephStorage
        MetaStorage *meta.Meta
        KMS         crypto.KMS
        Stopping    bool
        idGen       *utils.GlobalIdGen
        gcMgr       *GcMgr
}

func New(cfg *config.Config) (*YigStorage, error) <span class="cov8" title="1">{
        kms := crypto.NewKMS()
        metaCfg := meta.MetaConfig{
                Dbcfg: cfg.Database,
        }
        metaStorage, err := meta.New(metaCfg)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to new meta, err: %v", err)
                return nil, err
        }</span>
        <span class="cov8" title="1">idGen, err := utils.NewGlobalIdGen(int64(cfg.Endpoint.MachineId))
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to new global id generator, err: %v", err)
                return nil, err
        }</span>
        <span class="cov8" title="1">yig := YigStorage{
                DataStorage: make(map[string]*CephStorage),
                MetaStorage: metaStorage,
                KMS:         kms,
                Stopping:    false,
                idGen:       idGen,
        }
        CephConfigPattern := cfg.StorageCfg.CephPath
        if CephConfigPattern == "" </span><span class="cov0" title="0">{
                CephConfigPattern = DEFAULT_CEPHCONFIG_PATTERN
        }</span>
        <span class="cov8" title="1">cephConfs, err := filepath.Glob(CephConfigPattern)
        log.Infof("Reading Ceph conf files from %+v\n", cephConfs)
        if err != nil || len(cephConfs) == 0 </span><span class="cov8" title="1">{
                log.Errorf("PANIC: No ceph conf found")
                err = errors.New("no ceph conf found")
                return nil, err
        }</span>

        <span class="cov0" title="0">for _, conf := range cephConfs </span><span class="cov0" title="0">{
                c := NewCephStorage(conf)
                if c != nil </span><span class="cov0" title="0">{
                        yig.DataStorage[c.Name] = c
                }</span>
        }

        <span class="cov0" title="0">if len(yig.DataStorage) == 0 </span><span class="cov0" title="0">{
                log.Errorf("PANIC: No data storage can be used!")
                err = errors.New("no working data storage")
                return nil, err
        }</span>

        <span class="cov0" title="0">yig.gcMgr = NewGcMgr(RootContext, &amp;yig, cfg.Endpoint.GcCheckTime)
        // start gc
        yig.gcMgr.Start()
        return &amp;yig, nil</span>
}

func (y *YigStorage) Close() error <span class="cov0" title="0">{
        y.Stopping = true
        log.Info("Stopping storage...")
        y.gcMgr.Stop()
        log.Info("done")
        log.Info("Stopping MetaStorage...")
        y.MetaStorage.Close()

        return nil
}</span>

func newInitializationVector() (initializationVector []byte, err error) <span class="cov0" title="0">{

        initializationVector = make([]byte, INITIALIZATION_VECTOR_LENGTH)
        _, err = io.ReadFull(rand.Reader, initializationVector)
        return
}</span>

// Wraps reader with encryption if encryptionKey is not empty
func wrapEncryptionReader(reader io.Reader, encryptionKey []byte,
        initializationVector []byte) (wrappedReader io.Reader, err error) <span class="cov0" title="0">{

        if len(encryptionKey) == 0 </span><span class="cov0" title="0">{
                return reader, nil
        }</span>

        <span class="cov0" title="0">var block cipher.Block
        block, err = aes.NewCipher(encryptionKey)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">stream := cipher.NewCTR(block, initializationVector)
        wrappedReader = cipher.StreamReader{
                S: stream,
                R: reader,
        }
        return</span>
}

type alignedReader struct {
        aligned bool // indicate whether alignment has already been done
        offset  int64
        reader  io.Reader
}

func (r *alignedReader) Read(p []byte) (n int, err error) <span class="cov0" title="0">{
        if r.aligned </span><span class="cov0" title="0">{
                return r.reader.Read(p)
        }</span>

        <span class="cov0" title="0">r.aligned = true
        buffer := make([]byte, len(p))
        n, err = r.reader.Read(buffer)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">n = copy(p, buffer[r.offset:n])
        return</span>
}

// AES is a block cipher with block size of 16 bytes, i.e. the basic unit of encryption/decryption
// is 16 bytes. As an HTTP range request could start from any byte, we need to read one more
// block if necessary.
// Also, our chosen mode of operation for YIG is CTR(counter), which features parallel
// encryption/decryption and random read access. We need all these three features, this leaves
// us only three choices: ECB, CTR, and GCM.
// ECB is best known for its insecurity, meanwhile the GCM implementation of golang(as in 1.7) discourage
// users to encrypt large files in one pass, which requires us to read the whole file into memory. So
// the implement complexity is similar between GCM and CTR, we choose CTR because it's faster(but more
// prone to man-in-the-middle modifications)
//
// See https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation
// and http://stackoverflow.com/questions/39347206
func wrapAlignedEncryptionReader(reader io.Reader, startOffset int64, encryptionKey []byte,
        initializationVector []byte) (wrappedReader io.Reader, err error) <span class="cov0" title="0">{

        if len(encryptionKey) == 0 </span><span class="cov0" title="0">{
                return reader, nil
        }</span>

        <span class="cov0" title="0">alignedOffset := startOffset / AES_BLOCK_SIZE * AES_BLOCK_SIZE
        newReader, err := wrapEncryptionReader(reader, encryptionKey, initializationVector)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if alignedOffset == startOffset </span><span class="cov0" title="0">{
                return newReader, nil
        }</span>

        <span class="cov0" title="0">wrappedReader = &amp;alignedReader{
                aligned: false,
                offset:  startOffset - alignedOffset,
                reader:  newReader,
        }
        return</span>
}
</pre>
		
		<pre class="file" id="file108" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package utils

import (
        "errors"
        "net"
        "sync"
        "time"
)

const (
        START_EPOCH     int64 = 1571385784722
        MACHINE_LEN     uint8 = 10
        SEQ_LEN         uint8 = 12
        TIMESTAMP_SHIFS uint8 = 22
        MAX_MACHINE_NUM int64 = 1023
        MAX_SEQ_NUM     int64 = 4095
)

type GlobalIdGen struct {
        MachineId int64
        startTime int64
        seq       int64
        mux       sync.Mutex
}

/*
* machineId: a number which specify the id of the current node.
* if machineId &lt;=0, we will use lower bits of ip address for the node.
*
 */

func NewGlobalIdGen(machineId int64) (*GlobalIdGen, error) <span class="cov8" title="1">{
        gi := &amp;GlobalIdGen{
                seq: 0,
        }
        if machineId &lt;= 0 </span><span class="cov8" title="1">{
                id, err := gi.getMachineId()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">gi.MachineId = id</span>
        } else<span class="cov0" title="0"> {
                gi.MachineId = machineId
        }</span>
        <span class="cov8" title="1">return gi, nil</span>
}

/*
* the global id is generated according to snowflake algo.
* Please refer to https://github.com/twitter-archive/snowflake/tree/snowflake-2010.
 */

func (gi *GlobalIdGen) GetId() int64 <span class="cov0" title="0">{
        gi.mux.Lock()
        defer gi.mux.Unlock()
        current := time.Now().UnixNano() / 1000000
        if gi.startTime == current </span><span class="cov0" title="0">{
                gi.seq++
                if gi.seq &gt; MAX_SEQ_NUM </span><span class="cov0" title="0">{
                        // process the overflow
                        for current &lt;= gi.startTime </span><span class="cov0" title="0">{
                                current = time.Now().UnixNano() / 1000000
                        }</span>
                        <span class="cov0" title="0">gi.seq = 0</span>
                }
        }
        <span class="cov0" title="0">gi.startTime = current
        id := int64((current-START_EPOCH)&lt;&lt;TIMESTAMP_SHIFS | (gi.MachineId &lt;&lt; MACHINE_LEN) | (gi.seq))
        return id</span>
}

func (gi *GlobalIdGen) getMachineId() (int64, error) <span class="cov8" title="1">{
        addrs, err := net.InterfaceAddrs()
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov8" title="1">for _, address := range addrs </span><span class="cov8" title="1">{
                // check the address type and if it is not a loopback the display it
                if ipNet, ok := address.(*net.IPNet); ok &amp;&amp; !ipNet.IP.IsLoopback() </span><span class="cov8" title="1">{
                        ipAddr := ipNet.IP.To4()
                        if ipAddr != nil </span><span class="cov8" title="1">{
                                return (int64(ipAddr[2])&lt;&lt;8 + int64(ipAddr[3])) &amp; 0x0fff, nil
                        }</span>
                }
        }

        <span class="cov0" title="0">return 0, errors.New("failed to find the private ip addr")</span>
}
</pre>
		
		<pre class="file" id="file109" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package db

import (
        "context"
        "fmt"

        "github.com/soda/multi-cloud/s3/pkg/db/drivers/mongo"
        . "github.com/soda/multi-cloud/s3/pkg/exception"
        . "github.com/soda/multi-cloud/s3/pkg/utils"
        pb "github.com/soda/multi-cloud/s3/proto"
)

// DbAdapter is a global variable that controls database module.
var DbAdapter DBAdapter

// Init function can perform some initialization work of different databases.
func Init(db *Database) <span class="cov8" title="1">{
        switch db.Driver </span>{
        case "etcd":<span class="cov0" title="0">
                // C = etcd.Init(db.Driver, db.Crendential)
                fmt.Printf("etcd is not implemented right now!")
                return</span>
        case "mongodb":<span class="cov0" title="0">
                //DbAdapter = mongo.Init(strings.Split(db.Endpoint, ","))
                DbAdapter = mongo.Init(db.Endpoint)
                return</span>
        default:<span class="cov8" title="1">
                fmt.Printf("Can't find database driver %s!\n", db.Driver)</span>
        }
}

func Exit(db *Database) <span class="cov0" title="0">{
        switch db.Driver </span>{
        case "etcd":<span class="cov0" title="0">
                // C = etcd.Init(db.Driver, db.Crendential)
                fmt.Printf("etcd is not implemented right now!")
                return</span>
        case "mongodb":<span class="cov0" title="0">
                mongo.Exit()
                return</span>
        default:<span class="cov0" title="0">
                fmt.Printf("Can't find database driver %s!\n", db.Driver)</span>
        }
}

type DBAdapter interface {
        CreateBucket(ctx context.Context, bucket *pb.Bucket) S3Error
        DeleteBucket(ctx context.Context, name string) S3Error
        UpdateBucket(ctx context.Context, bucket *pb.Bucket) S3Error
        GetBucketByName(ctx context.Context, name string, out *pb.Bucket) S3Error
        ListBuckets(ctx context.Context, in *pb.BaseRequest, out *[]pb.Bucket) S3Error
        CreateObject(ctx context.Context, in *pb.Object) S3Error
        UpdateObject(ctx context.Context, in *pb.Object) S3Error
        DeleteObject(ctx context.Context, in *pb.DeleteObjectInput) S3Error
        GetObject(ctx context.Context, in *pb.GetObjectInput, out *pb.Object) S3Error
        CountObjects(ctx context.Context, in *pb.ListObjectsRequest, out *ObjsCountInfo) S3Error
        UpdateObjMeta(ctx context.Context, objKey *string, bucketName *string, lastmod int64, setting map[string]interface{}) S3Error
        AddMultipartUpload(ctx context.Context, record *pb.MultipartUploadRecord) S3Error
        DeleteMultipartUpload(ctx context.Context, record *pb.MultipartUploadRecord) S3Error
        //ListUploadRecords(ctx context.Context, in *pb.ListMultipartUploadRequest, out *[]pb.MultipartUploadRecord) S3Error
}
</pre>
		
		<pre class="file" id="file110" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mongo

import (
        "context"
        "strings"

        "github.com/globalsign/mgo"
        "github.com/globalsign/mgo/bson"
        log "github.com/sirupsen/logrus"
        . "github.com/soda/multi-cloud/s3/pkg/exception"
        . "github.com/soda/multi-cloud/s3/pkg/utils"
)

func (ad *adapter) DeleteBucket(ctx context.Context, bucketName string) S3Error <span class="cov0" title="0">{
        //Check if the connctor exist or not
        ss := ad.s.Copy()
        defer ss.Close()

        log.Infof("delete bucket, bucketName is %v:", bucketName)

        m := bson.M{DBKEY_NAME: bucketName}
        err := UpdateContextFilter(ctx, m)
        if err != nil </span><span class="cov0" title="0">{
                return InternalError
        }</span>

        //Delete it from database
        <span class="cov0" title="0">err = ss.DB(DataBaseName).C(BucketMD).Remove(m)
        log.Infof("err is %v:", err)
        if err != nil </span><span class="cov0" title="0">{
                if strings.Contains(err.Error(), "not found") </span><span class="cov0" title="0">{
                        log.Error("delete bucket from database failed, err: not found.")
                        return NoSuchBucket
                }</span> else<span class="cov0" title="0"> {
                        log.Infof("delete bucket from database failed, err: %v.\n", err.Error())
                        return DBError
                }</span>
        } else<span class="cov0" title="0"> {
                log.Infof("Delete bucket from database successfully")
                return NoError
        }</span>

        <span class="cov0" title="0">deleteErr := ss.DB(DataBaseName).C(bucketName).DropCollection()
        if deleteErr != nil &amp;&amp; deleteErr != mgo.ErrNotFound </span><span class="cov0" title="0">{
                log.Errorf("delete bucket collection from database failed, err: %v.\n", deleteErr)
                return InternalError
        }</span>

        <span class="cov0" title="0">return NoError</span>
}
</pre>
		
		<pre class="file" id="file111" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mongo

import (
        "context"

        "github.com/globalsign/mgo"
        "github.com/globalsign/mgo/bson"
        log "github.com/sirupsen/logrus"
        . "github.com/soda/multi-cloud/s3/pkg/exception"
        . "github.com/soda/multi-cloud/s3/pkg/utils"
        pb "github.com/soda/multi-cloud/s3/proto"
)

func (ad *adapter) GetBucketByName(ctx context.Context, bucketName string, out *pb.Bucket) S3Error <span class="cov0" title="0">{
        ss := ad.s.Copy()
        defer ss.Close()

        log.Infof("GetBucketByName: bucketName %s", bucketName)

        m := bson.M{DBKEY_NAME: bucketName}
        err := UpdateContextFilter(ctx, m)
        if err != nil </span><span class="cov0" title="0">{
                return InternalError
        }</span>

        <span class="cov0" title="0">err = ss.DB(DataBaseName).C(BucketMD).Find(m).One(out)
        if err == mgo.ErrNotFound </span><span class="cov0" title="0">{
                log.Error("bucket does not exist.")
                return NoSuchBucket
        }</span> else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                log.Errorf("get bucket from database failed, err: %v.\n", err)
                return InternalError
        }</span>

        <span class="cov0" title="0">return NoError</span>
}
</pre>
		
		<pre class="file" id="file112" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mongo

import (
        "context"

        "github.com/globalsign/mgo"
        "github.com/globalsign/mgo/bson"
        log "github.com/sirupsen/logrus"
        . "github.com/soda/multi-cloud/s3/pkg/exception"
        . "github.com/soda/multi-cloud/s3/pkg/utils"
        pb "github.com/soda/multi-cloud/s3/proto"
)

func (ad *adapter) CreateBucket(ctx context.Context, in *pb.Bucket) S3Error <span class="cov0" title="0">{
        ss := ad.s.Copy()
        defer ss.Close()

        m := bson.M{DBKEY_NAME: in.Name}
        err := UpdateContextFilter(ctx, m)
        if err != nil </span><span class="cov0" title="0">{
                return InternalError
        }</span>

        <span class="cov0" title="0">out := pb.Bucket{}
        err = ss.DB(DataBaseName).C(BucketMD).Find(m).One(out)
        if err == mgo.ErrNotFound </span><span class="cov0" title="0">{
                err := ss.DB(DataBaseName).C(BucketMD).Insert(&amp;in)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("add bucket to database failed, err:%v\n", err)
                        return InternalError
                }</span>
        } else<span class="cov0" title="0"> {
                log.Info("the bucket already exists")
                return BucketAlreadyExists
        }</span>

        <span class="cov0" title="0">return NoError</span>
}

func (ad *adapter) UpdateBucket(ctx context.Context, bucket *pb.Bucket) S3Error <span class="cov0" title="0">{
        //Check if the policy exist or not
        ss := ad.s.Copy()
        defer ss.Close()

        log.Infof("update bucket, bucket name is %s\n", bucket.Name)

        m := bson.M{DBKEY_NAME: bucket.Name}
        err := UpdateContextFilter(ctx, m)
        if err != nil </span><span class="cov0" title="0">{
                return InternalError
        }</span>

        //Update database
        <span class="cov0" title="0">err = ss.DB(DataBaseName).C(BucketMD).Update(m, bucket)
        if err == mgo.ErrNotFound </span><span class="cov0" title="0">{
                log.Error("update bucket failed: the specified bucket does not exist.")
                return NoSuchBucket
        }</span> else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                log.Errorf("update bucket in database failed, err: %v.\n", err)
                return InternalError
        }</span>
        <span class="cov0" title="0">return NoError</span>
}
</pre>
		
		<pre class="file" id="file113" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mongo

import (
        "context"

        "github.com/globalsign/mgo/bson"
        log "github.com/sirupsen/logrus"
        . "github.com/soda/multi-cloud/s3/pkg/exception"
        pb "github.com/soda/multi-cloud/s3/proto"
)

func (ad *adapter) ListBuckets(ctx context.Context, in *pb.BaseRequest, out *[]pb.Bucket) S3Error <span class="cov0" title="0">{
        ss := ad.s.Copy()
        defer ss.Close()
        c := ss.DB(DataBaseName).C(BucketMD)

        log.Info("list buckets from database...... \n")

        m := bson.M{}
        err := UpdateContextFilter(ctx, m)
        if err != nil </span><span class="cov0" title="0">{
                return InternalError
        }</span>

        <span class="cov0" title="0">err = c.Find(m).All(out)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("find buckets from database failed, err:%v\n", err)
                return DBError
        }</span>

        <span class="cov0" title="0">return NoError</span>
}
</pre>
		
		<pre class="file" id="file114" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mongo

import (
        "context"
        "github.com/globalsign/mgo"
        "github.com/globalsign/mgo/bson"
        log "github.com/sirupsen/logrus"
        "github.com/soda/multi-cloud/api/pkg/common"
        . "github.com/soda/multi-cloud/s3/pkg/exception"
        "github.com/soda/multi-cloud/s3/pkg/utils"
        pb "github.com/soda/multi-cloud/s3/proto"
)

func (ad *adapter) CountObjects(ctx context.Context, in *pb.ListObjectsRequest, out *utils.ObjsCountInfo) S3Error <span class="cov0" title="0">{
        ss := ad.s.Copy()
        defer ss.Close()
        c := ss.DB(DataBaseName).C(in.Bucket)

        filt := ""
        if in.Filter[common.KObjKey] != "" </span><span class="cov0" title="0">{
                filt = in.Filter[common.KObjKey]
        }</span>

        <span class="cov0" title="0">m := bson.M{
                utils.DBKEY_OBJECTKEY:    bson.M{"$regex": filt},
                utils.DBKEY_INITFLAG:     bson.M{"$ne": "0"},
                utils.DBKEY_DELETEMARKER: bson.M{"$ne": "1"},
        }
        err := UpdateContextFilter(ctx, m)
        if err != nil </span><span class="cov0" title="0">{
                return InternalError
        }</span>

        <span class="cov0" title="0">q1 := bson.M{
                "$match": m,
        }

        q2 := bson.M{
                "$group": bson.M{
                        "_id":   nil,
                        "size":  bson.M{"$sum": "$size"},
                        "count": bson.M{"$sum": 1},
                },
        }

        operations := []bson.M{q1, q2}
        pipe := c.Pipe(operations)
        var ret utils.ObjsCountInfo
        err = pipe.One(&amp;ret)
        if err == nil </span><span class="cov0" title="0">{
                out.Count = ret.Count
                out.Size = ret.Size
                log.Infof("count objects of bucket[%s] successfully, count=%d, size=%d\n", in.Bucket, out.Count, out.Size)
        }</span> else<span class="cov0" title="0"> if err == mgo.ErrNotFound </span><span class="cov0" title="0">{
                out.Count = 0
                out.Size = 0
                log.Infof("count objects of bucket[%s] successfully, count=0, size=0\n", in.Bucket)
        }</span> else<span class="cov0" title="0"> {
                log.Errorf("count objects of bucket[%s] failed, err:%v\n", in.Bucket, err)
                return InternalError
        }</span>

        <span class="cov0" title="0">return NoError</span>
}
</pre>
		
		<pre class="file" id="file115" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mongo

import (
        "context"
        "errors"

        log "github.com/sirupsen/logrus"
        "github.com/globalsign/mgo"
        "github.com/globalsign/mgo/bson"
        "github.com/micro/go-micro/metadata"
        "github.com/soda/multi-cloud/api/pkg/common"
)

var adap = &amp;adapter{}
var DataBaseName = "metadatastore"
var BucketMD = "metadatabucket"

func Init(host string) *adapter <span class="cov0" title="0">{
        //fmt.Println("edps:", deps)
        session, err := mgo.Dial(host)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        //defer session.Close()

        <span class="cov0" title="0">session.SetMode(mgo.Monotonic, true)
        adap.s = session
        adap.userID = "unknown"

        return adap</span>
}

func Exit() <span class="cov0" title="0">{
        adap.s.Close()
}</span>

type adapter struct {
        s      *mgo.Session
        userID string
}

func UpdateContextFilter(ctx context.Context, m bson.M) error <span class="cov0" title="0">{
        // if context is admin, no need filter by tenantId.
        md, ok := metadata.FromContext(ctx)
        if !ok </span><span class="cov0" title="0">{
                log.Error("get context failed")
                return errors.New("get context failed")
        }</span>

        <span class="cov0" title="0">isAdmin, _ := md[common.CTX_KEY_IS_ADMIN]
        if isAdmin != common.CTX_VAL_TRUE </span><span class="cov0" title="0">{
                tenantId, ok := md[common.CTX_KEY_TENANT_ID]
                if !ok </span><span class="cov0" title="0">{
                        log.Error("get tenantid failed")
                        return errors.New("get tenantid failed")
                }</span>
                <span class="cov0" title="0">m["tenantid"] = tenantId</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file116" style="display: none">package mongo

import (
        "context"
        //"time"

        "github.com/globalsign/mgo"
        "github.com/globalsign/mgo/bson"
        log "github.com/sirupsen/logrus"
        . "github.com/soda/multi-cloud/s3/pkg/exception"
        . "github.com/soda/multi-cloud/s3/pkg/utils"
        pb "github.com/soda/multi-cloud/s3/proto"
)

var CollMultipartUploadRecord = "multipartUploadRecords"

func (ad *adapter) AddMultipartUpload(ctx context.Context, record *pb.MultipartUploadRecord) S3Error <span class="cov0" title="0">{
        log.Infof("Add multipart upload: %+v\n", *record)
        session := ad.s.Copy()
        defer session.Close()

        err := session.DB(DataBaseName).C(CollMultipartUploadRecord).Insert(record)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("add multipart upload record[uploadid=%s] to database failed: %v\n", record.UploadId, err)
                return DBError
        }</span>

        <span class="cov0" title="0">log.Infof("add multipart upload record[uploadid=%s] successfully\n", record.UploadId)
        return NoError</span>
}

func (ad *adapter) DeleteMultipartUpload(ctx context.Context, record *pb.MultipartUploadRecord) S3Error <span class="cov0" title="0">{
        log.Infof("Delete multipart upload: %+v\n", *record)
        session := ad.s.Copy()
        defer session.Close()

        m := bson.M{DBKEY_OBJECTKEY: record.ObjectKey, DBKEY_UPLOADID: record.UploadId}
        err := UpdateContextFilter(ctx, m)
        if err != nil </span><span class="cov0" title="0">{
                return InternalError
        }</span>

        // objectkey is unique in soda, uploadid is unique for a specific physical bucket
        <span class="cov0" title="0">err = session.DB(DataBaseName).C(CollMultipartUploadRecord).Remove(m)
        if err != nil &amp;&amp; err != mgo.ErrNotFound </span><span class="cov0" title="0">{
                log.Errorf("delete multipart upload record[uploadid=%s] from database failed: %v\n", record.UploadId, err)
                return DBError
        }</span>

        <span class="cov0" title="0">log.Infof("delete multipart upload record[uploadid=%s] from database sucessfully\n", record.UploadId)
        return NoError</span>
}

/*func (ad *adapter) ListUploadRecords(ctx context.Context, in *pb.ListMultipartUploadRequest,
        out *[]pb.MultipartUploadRecord) S3Error {
        ss := ad.s.Copy()
        defer ss.Close()

        secs := time.Now().Unix() - int64(in.Days*24*60*60)
        log.Infof("list upload records here: bucket=%s, prefix=%s, daysAfterInitiation=%d, limit=%d, offset=%d, secs=%d\n",
                in.Bucket, in.Prefix, in.Days, in.Limit, in.Offset, secs)

        m := bson.M{DBKEY_BUCKET: in.Bucket, DBKEY_INITTIME: bson.M{"$lte": secs}, DBKEY_OBJECTKEY: bson.M{"$regex": "^" +
                in.Prefix}}
        err := UpdateContextFilter(ctx, m)
        if err != nil {
                return InternalError
        }

        err = ss.DB(DataBaseName).C(CollMultipartUploadRecord).Find(m).Skip(int(in.Offset)).Limit(int(in.Limit)).All(out)
        if err != nil &amp;&amp; err != mgo.ErrNotFound {
                log.Errorf("list upload records failed:%v\n", err)
                return DBError
        }

        return NoError
}*/

</pre>
		
		<pre class="file" id="file117" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mongo

import (
        "context"

        "github.com/globalsign/mgo"
        "github.com/globalsign/mgo/bson"
        log "github.com/sirupsen/logrus"
        . "github.com/soda/multi-cloud/s3/pkg/exception"
        . "github.com/soda/multi-cloud/s3/pkg/utils"
        pb "github.com/soda/multi-cloud/s3/proto"
)

func (ad *adapter) DeleteObject(ctx context.Context, in *pb.DeleteObjectInput) S3Error <span class="cov0" title="0">{
        //Check if the connctor exist or not
        ss := ad.s.Copy()
        defer ss.Close()

        m := bson.M{DBKEY_OBJECTKEY: in.Key}
        err := UpdateContextFilter(ctx, m)
        if err != nil </span><span class="cov0" title="0">{
                return InternalError
        }</span>

        //Delete it from database
        <span class="cov0" title="0">_, err = ss.DB(DataBaseName).C(in.Bucket).RemoveAll(m)
        if err == mgo.ErrNotFound </span><span class="cov0" title="0">{
                log.Errorf("delete object %s failed, err: the specified object does not exist", in.Key)
                return NoSuchObject
        }</span> else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                log.Errorf("delete object %s from database failed,err:%v.\n", in.Key, err)
                return InternalError
        }</span>
        <span class="cov0" title="0">return NoError</span>
}
</pre>
		
		<pre class="file" id="file118" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mongo

import (
        "context"

        "github.com/globalsign/mgo"
        "github.com/globalsign/mgo/bson"
        log "github.com/sirupsen/logrus"
        . "github.com/soda/multi-cloud/s3/pkg/exception"
        . "github.com/soda/multi-cloud/s3/pkg/utils"
        pb "github.com/soda/multi-cloud/s3/proto"
)

func (ad *adapter) GetObject(ctx context.Context, in *pb.GetObjectInput, out *pb.Object) S3Error <span class="cov0" title="0">{
        ss := ad.s.Copy()
        defer ss.Close()
        log.Info("Find object from database...... \n")

        m := bson.M{DBKEY_OBJECTKEY: in.Key}
        err := UpdateContextFilter(ctx, m)
        if err != nil </span><span class="cov0" title="0">{
                return InternalError
        }</span>

        <span class="cov0" title="0">err = ss.DB(DataBaseName).C(in.Bucket).Find(m).One(&amp;out)
        if err == mgo.ErrNotFound </span><span class="cov0" title="0">{
                log.Error("object does not exist.")
                return NoSuchObject
        }</span> else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                log.Errorf("find object from database failed, err:%v\n", err)
                return InternalError
        }</span>

        <span class="cov0" title="0">return NoError</span>
}
</pre>
		
		<pre class="file" id="file119" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mongo

import (
        "context"

        "github.com/globalsign/mgo"
        "github.com/globalsign/mgo/bson"
        log "github.com/sirupsen/logrus"
        . "github.com/soda/multi-cloud/s3/pkg/exception"
        . "github.com/soda/multi-cloud/s3/pkg/utils"
        pb "github.com/soda/multi-cloud/s3/proto"
)

func (ad *adapter) CreateObject(ctx context.Context, in *pb.Object) S3Error <span class="cov0" title="0">{
        ss := ad.s.Copy()
        defer ss.Close()

        m := bson.M{DBKEY_OBJECTKEY: in.ObjectKey}
        err := UpdateContextFilter(ctx, m)
        if err != nil </span><span class="cov0" title="0">{
                return InternalError
        }</span>

        <span class="cov0" title="0">out := pb.Object{}
        err = ss.DB(DataBaseName).C(in.BucketName).Find(m).One(out)
        if err == mgo.ErrNotFound </span><span class="cov0" title="0">{
                err := ss.DB(DataBaseName).C(in.BucketName).Insert(&amp;in)
                if err != nil </span><span class="cov0" title="0">{
                        log.Info("add object to database failed, err:%v\n", err)
                        return InternalError
                }</span>
        } else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                return InternalError
        }</span>

        <span class="cov0" title="0">return NoError</span>
}

func (ad *adapter) UpdateObject(ctx context.Context, in *pb.Object) S3Error <span class="cov0" title="0">{
        ss := ad.s.Copy()
        defer ss.Close()

        m := bson.M{DBKEY_OBJECTKEY: in.ObjectKey}
        err := UpdateContextFilter(ctx, m)
        if err != nil </span><span class="cov0" title="0">{
                return InternalError
        }</span>

        <span class="cov0" title="0">log.Infof("update object:%+v\n", *in)
        err = ss.DB(DataBaseName).C(in.BucketName).Update(m, in)
        if err == mgo.ErrNotFound </span><span class="cov0" title="0">{
                log.Info("update object to database failed, err:%v\n", err)
                return NoSuchObject
        }</span> else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                log.Info("update object to database failed, err:%v\n", err)
                return InternalError
        }</span>

        <span class="cov0" title="0">return NoError</span>
}

func (ad *adapter) UpdateObjMeta(ctx context.Context, objKey *string, bucketName *string, lastmod int64,
        setting map[string]interface{}) S3Error <span class="cov0" title="0">{
        ss := ad.s.Copy()
        defer ss.Close()

        log.Infof("update object metadata: key=%s, bucket=%s, lastmodified=%d\n", *objKey, *bucketName, lastmod)

        m := bson.M{DBKEY_OBJECTKEY: *objKey, DBKEY_LASTMODIFIED: lastmod}
        err := UpdateContextFilter(ctx, m)
        if err != nil </span><span class="cov0" title="0">{
                return InternalError
        }</span>

        <span class="cov0" title="0">data := bson.M{"$set": setting}
        err = ss.DB(DataBaseName).C(*bucketName).Update(m, data)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("update object[key=%s] metadata failed:%v.\n", *objKey, err)
                return DBError
        }</span>

        <span class="cov0" title="0">return NoError</span>
}

</pre>
		
		<pre class="file" id="file120" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package _exception

import (
        "errors"
        "fmt"
)

type S3Error struct {
        Code        int
        Description string
}

func (err *S3Error) Error() error <span class="cov0" title="0">{
        s := fmt.Sprintf("{\"code\":\"%d\",\"message\":\"%s\"}", err.Code, err.Description)
        return errors.New(s)
}</span>

var ERR_OK = 200
var NoError = S3Error{Code: ERR_OK}
var InternalError = S3Error{Code: 500, Description: "Internal error. Please retry"}
var NoSuchBucket = S3Error{Code: 404, Description: "The specified bucket does not exist."}
var DBError = S3Error{Code: 500, Description: "DB occured exception."}
var NoSuchObject = S3Error{Code: 404, Description: "The specified object does not exist."}
var BucketAlreadyExists = S3Error{Code: 409, Description: "The requested bucket name already exist. Bucket namespace is shared by all users in the system. Select a different name and retry."}

var NoSuchBackend = S3Error{Code: 404, Description: "The specified backend does not exists."}
var NoSuchType = S3Error{Code: 404, Description: "The specified backend type does not exists."}
var BucketDeleteError = S3Error{Code: 500, Description: "The bucket can not be deleted. please delete object first"}
var BackendDeleteError = S3Error{Code: 500, Description: "The backend can not be deleted. please delete bucket first"}

var InvalidQueryParameter = S3Error{Code:400, Description:"invalid query parameter"}
var InvalidContentLength = S3Error{Code:400, Description:"invalid content length"}
var InvalidStorageClass = S3Error{Code: 400, Description: "the storage class you specified is not valid"}
var BadRequest = S3Error{Code:400, Description:"request is invalid"}
</pre>
		
		<pre class="file" id="file121" style="display: none">package gc

import (
        "context"
        "strconv"
        "time"

        "github.com/micro/go-micro/client"
        bkd "github.com/soda/multi-cloud/backend/proto"
        "github.com/soda/multi-cloud/s3/pkg/meta/types"

        "github.com/micro/go-micro/metadata"
        "github.com/soda/multi-cloud/api/pkg/common"
        "github.com/soda/multi-cloud/s3/pkg/datastore/driver"
        "github.com/soda/multi-cloud/s3/pkg/meta"
        "github.com/soda/multi-cloud/s3/pkg/utils"
        pb "github.com/soda/multi-cloud/s3/proto"
        log "github.com/sirupsen/logrus"
)

var CTX context.Context
var CancleFunc context.CancelFunc

const (
        LIST_LIMIT = 1000
)

func Init(ctx context.Context, cancelFunc context.CancelFunc, meta *meta.Meta) <span class="cov8" title="1">{
        mt := meta
        CTX = ctx
        CancleFunc = cancelFunc
        backend := bkd.NewBackendService("backend", client.DefaultClient)
        go Run(mt, backend)
}</span>

func Stop() <span class="cov8" title="1">{
        CancleFunc()
}</span>

func Run(mt *meta.Meta, bkservice bkd.BackendService) <span class="cov8" title="1">{
        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-time.After(60 * time.Second):<span class="cov8" title="1"></span>
                case &lt;-CTX.Done():<span class="cov8" title="1">
                        log.Infoln("gc exit...")
                        return</span>
                }

                <span class="cov8" title="1">offset := 0
                for </span><span class="cov8" title="1">{
                        // get gc objects
                        log.Debugln("list gc objects ...")
                        objs, err := mt.ListGcObjs(CTX, offset, LIST_LIMIT)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Warnf("list gc objects failed, err:%v\n", err)
                                // try in next round
                                break</span>
                        }

                        <span class="cov8" title="1">total := len(objs)
                        deleted := 0
                        // for each obj, do clean
                        for _, o := range objs </span><span class="cov0" title="0">{
                                err = CleanFromBackend(o, bkservice)
                                if err == nil </span><span class="cov0" title="0">{
                                        err = mt.DeleteGcobjRecord(CTX, o)
                                        if err != nil </span><span class="cov0" title="0">{
                                                // if delete failed, it will be deleted in the next round
                                                log.Warnf("delete gc object[key=%s,version=%s] metadata failed, err:%v\n", o.ObjectKey, o.VersionId, err)
                                        }</span> else<span class="cov0" title="0"> {
                                                deleted++
                                        }</span>
                                }
                        }
                        // if some obj deleted failed, do not try to delete it again in this round, but do it in next round
                        <span class="cov8" title="1">offset += total - deleted
                        log.Debugf("total=%d, deleted=%d, offset=%d\n", total, deleted, offset)

                        if total &lt; LIST_LIMIT </span><span class="cov8" title="1">{
                                log.Debugln("break this round of gc")
                                break</span>
                        }
                }
        }
}

func CleanFromBackend(obj *types.Object, bkservice bkd.BackendService) error <span class="cov0" title="0">{
        ctx := metadata.NewContext(context.Background(), map[string]string{
                common.CTX_KEY_IS_ADMIN: strconv.FormatBool(true),
        })
        backend, err := utils.GetBackend(ctx, bkservice, obj.Location)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("get backend faild, err:%v\n", err)
                return err
        }</span>

        <span class="cov0" title="0">sd, err := driver.CreateStorageDriver(backend.Type, backend)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to create storage driver for %s, err:%v\n", backend.Type, err)
                return err
        }</span>

        // delete object data in backend
        <span class="cov0" title="0">log.Debugf("delete object, key=%s, verionid=%s, objectid=%s, storageMeta:%+v\n", obj.ObjectKey, obj.VersionId, obj.ObjectId, obj.StorageMeta)
        err = sd.Delete(ctx, &amp;pb.DeleteObjectInput{Bucket: obj.BucketName, Key: obj.ObjectKey, VersioId: obj.VersionId,
                StorageMeta: obj.StorageMeta, ObjectId: obj.ObjectId})
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to delete obejct[%s] from backend storage, err:", obj.ObjectKey, err)
        }</span> else<span class="cov0" title="0"> {
                log.Infof("delete obejct[%s] from backend storage successfully.", obj.ObjectKey)
        }</span>

        <span class="cov0" title="0">return err</span>
}
</pre>
		
		<pre class="file" id="file122" style="display: none">package helper

import (
        "fmt"
        "io/ioutil"
        "time"

        "github.com/BurntSushi/toml"
)

const (
        S3_CONF_PATH              = "/etc/multi-cloud/s3.toml"
        MIN_DOWNLOAD_BUFPOOL_SIZE = 512 &lt;&lt; 10 // 512k
        MAX_DOWNLOAD_BUFPOOL_SIZE = 8 &lt;&lt; 20   // 8M
)

type Config struct {
        S3Domain         []string                `toml:"s3domain"` // Domain name of YIG
        Region           string                  `toml:"region"`   // Region name this instance belongs to, e.g cn-bj-1
        Plugins          map[string]PluginConfig `toml:"plugins"`
        LogPath          string                  `toml:"log_path"`
        AccessLogPath    string                  `toml:"access_log_path"`
        AccessLogFormat  string                  `toml:"access_log_format"`
        PanicLogPath     string                  `toml:"panic_log_path"`
        PidFile          string                  `toml:"pid_file"`
        BindApiAddress   string                  `toml:"api_listener"`
        BindAdminAddress string                  `toml:"admin_listener"`
        SSLKeyPath       string                  `toml:"ssl_key_path"`
        SSLCertPath      string                  `toml:"ssl_cert_path"`
        ZookeeperAddress string                  `toml:"zk_address"`

        InstanceId             string // if empty, generated one at server startup
        ConcurrentRequestLimit int
        HbaseZnodeParent       string        // won't change default("/hbase") if leave this option empty
        HbaseTimeout           time.Duration // in seconds
        DebugMode              bool          `toml:"debug_mode"`
        AdminKey               string        `toml:"admin_key"` //used for tools/admin to communicate with yig
        GcThread               int           `toml:"gc_thread"`
        LcThread               int           //used for tools/lc only, set worker numbers to do lc
        LcDebug                bool          //used for tools/lc only, if this was set true, will treat days as seconds
        LogLevel               int           `toml:"log_level"` //1-20
        CephConfigPattern      string        `toml:"ceph_config_pattern"`
        ReservedOrigins        string        `toml:"reserved_origins"` // www.ccc.com,www.bbb.com,127.0.0.1
        MetaStore              string        `toml:"meta_store"`
        TidbInfo               string        `toml:"tidb_info"`
        KeepAlive              bool          `toml:"keepalive"`

        //About cache
        RedisAddress            string   `toml:"redis_address"`           // redis connection string, e.g localhost:1234
        RedisConnectionNumber   int      `toml:"redis_connection_number"` // number of connections to redis(i.e max concurrent request number)
        RedisPassword           string   `toml:"redis_password"`          // redis auth password
        MetaCacheType           int      `toml:"meta_cache_type"`
        EnableDataCache         bool     `toml:"enable_data_cache"`
        RedisMode               int      `toml:"redis_mode"`
        RedisNodes              []string `toml:"redis_nodes"`
        RedisSentinelMasterName string   `toml:"redis_sentinel_master_name"`
        RedisConnectTimeout     int      `toml:"redis_connect_timeout"`
        RedisReadTimeout        int      `toml:"redis_read_timeout"`
        RedisWriteTimeout       int      `toml:"redis_write_timeout"`
        RedisKeepAlive          int      `toml:"redis_keepalive"`
        RedisPoolMaxIdle        int      `toml:"redis_pool_max_idle"`
        RedisPoolIdleTimeout    int      `toml:"redis_pool_idle_timeout"`

        // If the value is not 0, the cached ping detection will be turned on, and the interval is the number of seconds.
        CacheCircuitCheckInterval int `toml:"cache_circuit_check_interval"`
        // This property sets the amount of seconds, after tripping the circuit,
        // to reject requests before allowing attempts again to determine if the circuit should again be closed.
        CacheCircuitCloseSleepWindow int `toml:"cache_circuit_close_sleep_window"`
        // This value is how may consecutive passing requests are required before the circuit is closed
        CacheCircuitCloseRequiredCount int `toml:"cache_circuit_close_required_count"`
        // This property sets the minimum number of requests in a rolling window that will trip the circuit.
        CacheCircuitOpenThreshold int `toml:"cache_circuit_open_threshold"`

        DownLoadBufPoolSize int `toml:"download_buf_pool_size"`

        KMS KMSConfig `toml:"kms"`

        // Message Bus
        MsgBus MsgBusConfig `toml:"msg_bus"`
}

type PluginConfig struct {
        Path   string                 `toml:"path"`
        Enable bool                   `toml:"enable"`
        Args   map[string]interface{} `toml:"args"`
}

type KMSConfig struct {
        Type     string
        Endpoint string
        Id       string `toml:"kms_id"`
        Secret   string `toml:"kms_secret"`
        Version  int
        Keyname  string
}

type MsgBusConfig struct {
        // Controls whether to enable message bus when receive the request.
        Enabled bool `toml:"msg_bus_enable"`
        // Controls the under implementation of message bus: 1 for kafka.
        Type int `toml:"msg_bus_type"`
        // Controls the message topic used by message bus.
        Topic string `toml:"msg_bus_topic"`
        // Controls the request timeout for sending a req through message bus.
        RequestTimeoutMs int `toml:"msg_bus_request_timeout_ms"`
        // Controls the total timeout for sending a req through message bus.
        // It will timeout if min(MessageTimeoutMs, SendMaxRetries * RequestTimeoutMs) meets.
        MessageTimeoutMs int `toml:"msg_bus_message_timeout_ms"`
        // Controls the retry time used by message bus if it fails to send a req.
        SendMaxRetries int `toml:"msg_bus_send_max_retries"`
        // Controls the settings for the implementation of message bus.
        // For kafka, the 'broker_list' must be set, like 'broker_list = "kafka:29092"'
        Server map[string]interface{} `toml:"msg_bus_server"`
}

var CONFIG Config

func SetupConfig() <span class="cov8" title="1">{
        MarshalTOMLConfig()
}</span>

func MarshalTOMLConfig() error <span class="cov8" title="1">{
        data, err := ioutil.ReadFile(S3_CONF_PATH)
        if err != nil </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        panic(fmt.Sprintf("failed to open %s, err: %v", S3_CONF_PATH, err))</span>
                }
        }

        <span class="cov8" title="1">fmt.Printf("config data: \n%s\n", string(data))
        var c Config
        _, err = toml.Decode(string(data), &amp;c)
        if err != nil </span><span class="cov0" title="0">{
                panic("load yig.toml error: " + err.Error())</span>
        }
        <span class="cov8" title="1">fmt.Printf("c: %+v\n", c)
        // setup CONFIG with defaults
        CONFIG.S3Domain = c.S3Domain
        CONFIG.Region = c.Region
        CONFIG.Plugins = c.Plugins
        CONFIG.LogPath = c.LogPath
        CONFIG.AccessLogPath = c.AccessLogPath
        CONFIG.AccessLogFormat = c.AccessLogFormat
        CONFIG.PanicLogPath = c.PanicLogPath
        CONFIG.PidFile = c.PidFile
        CONFIG.BindApiAddress = c.BindApiAddress
        CONFIG.BindAdminAddress = c.BindAdminAddress
        CONFIG.SSLKeyPath = c.SSLKeyPath
        CONFIG.SSLCertPath = c.SSLCertPath
        CONFIG.ZookeeperAddress = c.ZookeeperAddress
        CONFIG.DebugMode = c.DebugMode
        CONFIG.AdminKey = c.AdminKey
        CONFIG.LcDebug = c.LcDebug
        CONFIG.CephConfigPattern = c.CephConfigPattern
        CONFIG.ReservedOrigins = c.ReservedOrigins
        CONFIG.TidbInfo = c.TidbInfo
        CONFIG.KeepAlive = c.KeepAlive
        CONFIG.InstanceId = Ternary(c.InstanceId == "",
                string(GenerateRandomId()), c.InstanceId).(string)
        CONFIG.ConcurrentRequestLimit = Ternary(c.ConcurrentRequestLimit == 0,
                10000, c.ConcurrentRequestLimit).(int)
        CONFIG.HbaseZnodeParent = Ternary(c.HbaseZnodeParent == "",
                "/hbase", c.HbaseZnodeParent).(string)
        CONFIG.HbaseTimeout = Ternary(c.HbaseTimeout == 0, 30*time.Second,
                c.HbaseTimeout).(time.Duration)
        CONFIG.GcThread = Ternary(c.GcThread == 0,
                1, c.GcThread).(int)
        CONFIG.LcThread = Ternary(c.LcThread == 0,
                1, c.LcThread).(int)
        CONFIG.LogLevel = Ternary(c.LogLevel == 0, 5, c.LogLevel).(int)
        CONFIG.MetaStore = Ternary(c.MetaStore == "", "tidb", c.MetaStore).(string)

        CONFIG.RedisAddress = c.RedisAddress
        CONFIG.RedisPassword = c.RedisPassword
        CONFIG.RedisMode = c.RedisMode
        CONFIG.RedisNodes = c.RedisNodes
        CONFIG.RedisSentinelMasterName = c.RedisSentinelMasterName
        CONFIG.RedisConnectionNumber = Ternary(c.RedisConnectionNumber == 0,
                10, c.RedisConnectionNumber).(int)
        CONFIG.EnableDataCache = c.EnableDataCache
        CONFIG.MetaCacheType = c.MetaCacheType
        CONFIG.RedisConnectTimeout = Ternary(c.RedisConnectTimeout &lt; 0, 0, c.RedisConnectTimeout).(int)
        CONFIG.RedisReadTimeout = Ternary(c.RedisReadTimeout &lt; 0, 0, c.RedisReadTimeout).(int)
        CONFIG.RedisWriteTimeout = Ternary(c.RedisWriteTimeout &lt; 0, 0, c.RedisWriteTimeout).(int)
        CONFIG.RedisKeepAlive = Ternary(c.RedisKeepAlive &lt; 0, 0, c.RedisKeepAlive).(int)
        CONFIG.RedisPoolMaxIdle = Ternary(c.RedisPoolMaxIdle &lt; 0, 0, c.RedisPoolMaxIdle).(int)
        CONFIG.RedisPoolIdleTimeout = Ternary(c.RedisPoolIdleTimeout &lt; 0, 0, c.RedisPoolIdleTimeout).(int)

        CONFIG.CacheCircuitCheckInterval = Ternary(c.CacheCircuitCheckInterval &lt; 0, 0, c.CacheCircuitCheckInterval).(int)
        CONFIG.CacheCircuitCloseSleepWindow = Ternary(c.CacheCircuitCloseSleepWindow &lt; 0, 0, c.CacheCircuitCloseSleepWindow).(int)
        CONFIG.CacheCircuitCloseRequiredCount = Ternary(c.CacheCircuitCloseRequiredCount &lt; 0, 0, c.CacheCircuitCloseRequiredCount).(int)
        CONFIG.CacheCircuitOpenThreshold = Ternary(c.CacheCircuitOpenThreshold &lt; 0, 0, c.CacheCircuitOpenThreshold).(int)

        CONFIG.DownLoadBufPoolSize = Ternary(c.DownLoadBufPoolSize &lt; MIN_DOWNLOAD_BUFPOOL_SIZE || c.DownLoadBufPoolSize &gt; MAX_DOWNLOAD_BUFPOOL_SIZE, MIN_DOWNLOAD_BUFPOOL_SIZE, c.DownLoadBufPoolSize).(int)

        CONFIG.KMS = c.KMS

        CONFIG.MsgBus = c.MsgBus
        CONFIG.MsgBus.RequestTimeoutMs = Ternary(c.MsgBus.RequestTimeoutMs == 0, 3000, c.MsgBus.RequestTimeoutMs).(int)
        CONFIG.MsgBus.MessageTimeoutMs = Ternary(c.MsgBus.MessageTimeoutMs == 0, 5000, c.MsgBus.MessageTimeoutMs).(int)
        CONFIG.MsgBus.SendMaxRetries = Ternary(c.MsgBus.SendMaxRetries == 0, 2, c.MsgBus.SendMaxRetries).(int)

        return nil</span>
}
</pre>
		
		<pre class="file" id="file123" style="display: none">package helper

import (
        "bytes"
)

func EscapeColon(s string) string <span class="cov0" title="0">{
        //Byte loop is OK for utf8
        buf := new(bytes.Buffer)
        l := len(s)
        for i := 0; i &lt; l; i++ </span><span class="cov0" title="0">{
                if s[i] == '%' </span><span class="cov0" title="0">{
                        buf.WriteString("%%")
                }</span> else<span class="cov0" title="0"> if s[i] == ':' </span><span class="cov0" title="0">{
                        buf.WriteString("%n")
                }</span> else<span class="cov0" title="0"> {
                        buf.WriteByte(s[i])
                }</span>
        }
        <span class="cov0" title="0">return buf.String()</span>
}

func UnescapeColon(s string) string <span class="cov0" title="0">{
        buf := new(bytes.Buffer)
        l := len(s)
        for i := 0; i &lt; l; i++ </span><span class="cov0" title="0">{
                if s[i] == '%' </span><span class="cov0" title="0">{
                        i++
                        if i == l </span><span class="cov0" title="0">{
                                panic("never be here")</span>
                        }
                        <span class="cov0" title="0">if s[i] == '%' </span><span class="cov0" title="0">{
                                buf.WriteString("%")
                        }</span> else<span class="cov0" title="0"> if s[i] == 'n' </span><span class="cov0" title="0">{
                                buf.WriteString(":")
                        }</span> else<span class="cov0" title="0"> {
                                panic("never be here")</span>
                        }
                } else<span class="cov0" title="0"> {
                        buf.WriteByte(s[i])
                }</span>
        }
        <span class="cov0" title="0">return buf.String()</span>
}
</pre>
		
		<pre class="file" id="file124" style="display: none">package helper

import (
        "os"
)

func FileExists(path string) bool <span class="cov0" title="0">{
        st, e := os.Stat(path)
        // If file exists and is regular return true.
        if e == nil &amp;&amp; st.Mode().IsRegular() </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file125" style="display: none">package helper

func Filter(xs []string, f func(string) bool) []string <span class="cov0" title="0">{
        ans := make([]string, 0, len(xs))
        for _, x := range xs </span><span class="cov0" title="0">{
                if f(x) </span><span class="cov0" title="0">{
                        ans = append(ans, x)
                }</span>
        }
        <span class="cov0" title="0">return ans</span>
}

func Map(xs []string, f func(string) string) []string <span class="cov0" title="0">{
        ans := make([]string, 0, len(xs))
        for _, x := range xs </span><span class="cov0" title="0">{
                ans = append(ans, f(x))
        }</span>
        <span class="cov0" title="0">return ans</span>
}
</pre>
		
		<pre class="file" id="file126" style="display: none">package helper

import (
        "math/rand"
        "reflect"
)

// mimic `?:` operator
// Need type assertion to convert output to expected type
func Ternary(IF bool, THEN interface{}, ELSE interface{}) interface{} <span class="cov8" title="1">{
        if IF </span><span class="cov8" title="1">{
                return THEN
        }</span> else<span class="cov8" title="1"> {
                return ELSE
        }</span>
}

// Get keys of a map, i.e.
// map[string]interface{} -&gt; []string
// Note that some type checks are omitted for efficiency, you need to ensure them yourself,
// otherwise your program should panic
func Keys(v interface{}) []string <span class="cov8" title="1">{
        rv := reflect.ValueOf(v)
        result := make([]string, 0, rv.Len())
        for _, kv := range rv.MapKeys() </span><span class="cov0" title="0">{
                result = append(result, kv.String())
        }</span>
        <span class="cov8" title="1">return result</span>
}

// Static alphaNumeric table used for generating unique request ids
var alphaNumericTable = []byte("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ")

func GenerateRandomId() []byte <span class="cov8" title="1">{
        alpha := make([]byte, 16, 16)
        for i := 0; i &lt; 16; i++ </span><span class="cov8" title="1">{
                n := rand.Intn(len(alphaNumericTable))
                alpha[i] = alphaNumericTable[n]
        }</span>
        <span class="cov8" title="1">return alpha</span>
}
</pre>
		
		<pre class="file" id="file127" style="display: none">package helper

import (
        "encoding/json"
        "io"
        "io/ioutil"
)

// read from ReadCloser and unmarshal to out;
// `out` should be of POINTER type
func ReadJsonBody(body io.ReadCloser, out interface{}) (err error) <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                _ = body.Close()
        }</span>()
        <span class="cov0" title="0">jsonBytes, err := ioutil.ReadAll(body)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">err = json.Unmarshal(jsonBytes, out)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

</pre>
		
		<pre class="file" id="file128" style="display: none">package helper

import (
        "bytes"

        "github.com/ugorji/go/codec"
)

func MsgPackMarshal(v interface{}) ([]byte, error) <span class="cov0" title="0">{
        var buf = new(bytes.Buffer)
        enc := codec.NewEncoder(buf, new(codec.MsgpackHandle))
        err := enc.Encode(v)
        return buf.Bytes(), err
}</span>
func MsgPackUnMarshal(data []byte, v interface{}) error <span class="cov0" title="0">{
        var buf = bytes.NewBuffer(data)
        dec := codec.NewDecoder(buf, new(codec.MsgpackHandle))
        return dec.Decode(v)
}</span>
</pre>
		
		<pre class="file" id="file129" style="display: none">package helper

import "strings"

func HasBucketInDomain(host string, prefix string, domains []string) (ok bool, bucket string)  <span class="cov0" title="0">{
        for _, d := range domains </span><span class="cov0" title="0">{
                if strings.HasSuffix(host, prefix+d) </span><span class="cov0" title="0">{
                        return true, strings.TrimSuffix(host, prefix+d)
                }</span>
        }
        <span class="cov0" title="0">return false, ""</span>
}

func StringInSlice(s string, ss []string) bool <span class="cov0" title="0">{
        for _, x := range ss </span><span class="cov0" title="0">{
                if s == x </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func CopiedBytes(source []byte) (destination []byte) <span class="cov0" title="0">{
        destination = make([]byte, len(source), len(source))
        copy(destination, source)
        return destination
}</span>

func UnicodeIndex(str, substr string) int <span class="cov0" title="0">{
        result := strings.Index(str, substr)
        if result &gt;= 0 </span><span class="cov0" title="0">{
                prefix := []byte(str)[0:result]
                rs := []rune(string(prefix))
                result = len(rs)
        }</span>
        <span class="cov0" title="0">return result</span>
}

func SubString(str string, begin, length int) (substr string) <span class="cov0" title="0">{
        rs := []rune(str)
        lth := len(rs)
        if begin &lt; 0 </span><span class="cov0" title="0">{
                begin = 0
        }</span>
        <span class="cov0" title="0">if begin &gt;= lth </span><span class="cov0" title="0">{
                begin = lth
        }</span>
        <span class="cov0" title="0">var end int
        if length == -1 </span><span class="cov0" title="0">{
                end = lth
        }</span> else<span class="cov0" title="0"> {
                end = begin + length
        }</span>
        <span class="cov0" title="0">if end &gt; lth </span><span class="cov0" title="0">{
                end = lth
        }</span>
        <span class="cov0" title="0">return string(rs[begin:end])</span>
}
</pre>
		
		<pre class="file" id="file130" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package meta

import (
        "context"
        "fmt"

        . "github.com/soda/multi-cloud/s3/error"
        "github.com/soda/multi-cloud/s3/pkg/helper"
        "github.com/soda/multi-cloud/s3/pkg/meta/redis"
        . "github.com/soda/multi-cloud/s3/pkg/meta/types"
        pb "github.com/soda/multi-cloud/s3/proto"
        log "github.com/sirupsen/logrus"
)

const (
        BUCKET_CACHE_PREFIX = "bucket:"
        USER_CACHE_PREFIX   = "user:"
)

// Note the usage info got from this method is possibly not accurate because we don't
// invalid cache when updating usage. For accurate usage info, use `GetUsage()`
func (m *Meta) GetBucket(ctx context.Context, bucketName string, willNeed bool) (bucket *Bucket, err error) <span class="cov8" title="1">{
        getBucket := func() (b helper.Serializable, err error) </span><span class="cov8" title="1">{
                bt, err := m.Db.GetBucket(ctx, bucketName)
                log.Info("GetBucket CacheMiss. bucket:", bucketName)
                return bt, err
        }</span>

        <span class="cov8" title="1">toBucket := func(fields map[string]string) (interface{}, error) </span><span class="cov0" title="0">{
                b := &amp;Bucket{Bucket: &amp;pb.Bucket{}}
                return b.Deserialize(fields)
        }</span>

        <span class="cov8" title="1">b, err := m.Cache.Get(redis.BucketTable, BUCKET_CACHE_PREFIX, bucketName, getBucket, toBucket, willNeed)
        if err != nil </span><span class="cov0" title="0">{
                if err == ErrNoSuchKey </span><span class="cov0" title="0">{
                        err = ErrNoSuchBucket
                }</span> else<span class="cov0" title="0"> if err != ErrDBError </span><span class="cov0" title="0">{
                        err = ErrInternalError
                }</span>
                <span class="cov0" title="0">log.Errorf("get bucket failed:%v\n", err)
                return</span>
        }
        <span class="cov8" title="1">bucket, ok := b.(*Bucket)
        if !ok </span><span class="cov0" title="0">{
                log.Error("Cast b failed:", b)
                err = ErrInternalError
                return
        }</span>
        <span class="cov8" title="1">return bucket, nil</span>
}

/*
* init bucket usage cache when meta is newed.
*
 */
func (m *Meta) InitBucketUsageCache() error <span class="cov0" title="0">{
        // the map contains the bucket usage which are not in cache.
        bucketUsageMap := make(map[string]*Bucket)
        // the map contains the bucket usage which are in cache and will be synced into database.
        bucketUsageCacheMap := make(map[string]int64)
        // the usage in buckets table is accurate now.

        buckets, err := m.Db.GetBuckets(context.Background())
        if err != nil </span><span class="cov0" title="0">{
                log.Error("failed to get buckets from db. err: ", err)
                return err
        }</span>

        // init the bucket usage key in cache.
        <span class="cov0" title="0">for _, bucket := range buckets </span><span class="cov0" title="0">{
                bucketUsageMap[bucket.Name] = bucket
        }</span>

        // try to get all bucket usage keys from cache.
        <span class="cov0" title="0">pattern := fmt.Sprintf("%s*", BUCKET_CACHE_PREFIX)
        bucketsInCache, err := m.Cache.Keys(redis.BucketTable, pattern)
        if err != nil </span><span class="cov0" title="0">{
                log.Error("failed to get bucket usage from cache, err: ", err)
                return err
        }</span>

        <span class="cov0" title="0">if len(bucketsInCache) &gt; 0 </span><span class="cov0" title="0">{
                // query all usages from cache.
                for _, bic := range bucketsInCache </span><span class="cov0" title="0">{
                        usage, err := m.Cache.HGetInt64(redis.BucketTable, BUCKET_CACHE_PREFIX, bic, FIELD_NAME_USAGE)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Error("failed to get usage for bucket: ", bic, " with err: ", err)
                                continue</span>
                        }
                        // add the to be synced usage.
                        <span class="cov0" title="0">bucketUsageCacheMap[bic] = usage
                        if _, ok := bucketUsageMap[bic]; ok </span><span class="cov0" title="0">{
                                // if the key already exists in cache, then delete it from map
                                delete(bucketUsageMap, bic)
                        }</span>
                }

        }

        // init the bucket usage in cache.
        <span class="cov0" title="0">if len(bucketUsageMap) &gt; 0 </span><span class="cov0" title="0">{
                for _, bk := range bucketUsageMap </span><span class="cov0" title="0">{
                        fields, err := bk.Serialize()
                        if err != nil </span><span class="cov0" title="0">{
                                log.Error("failed to serialize for bucket: ", bk.Name, " with err: ", err)
                                return err
                        }</span>
                        <span class="cov0" title="0">_, err = m.Cache.HMSet(redis.BucketTable, BUCKET_CACHE_PREFIX, bk.Name, fields)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Error("failed to set bucket to cache: ", bk.Name, " with err: ", err)
                                return err
                        }</span>
                }

        }
        // sync the buckets usage in cache into database.
        <span class="cov0" title="0">if len(bucketUsageCacheMap) &gt; 0 </span><span class="cov0" title="0">{
                err = m.Db.UpdateUsages(context.Background(), bucketUsageCacheMap, nil)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error("failed to sync usages to database, err: ", err)
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

/*func (m *Meta) bucketUsageSync(event SyncEvent) error {
        bu := &amp;BucketUsageEvent{}
        err := helper.MsgPackUnMarshal(event.Data.([]byte), bu)
        if err != nil {
                log.Error("failed to unpack from event data to BucketUsageEvent, err: %v", err)
                return err
        }

        err = m.Db.UpdateUsage(bu.BucketName, bu.Usage, nil)
        if err != nil {
                log.Error("failed to update bucket usage ", bu.Usage, " to bucket: ", bu.BucketName,
                        " err: ", err)
                return err
        }

        log.Infof("succeed to update bucket usage ", bu.Usage, " for bucket: ", bu.BucketName)
        return nil
}*/

func AddBucketUsageSyncEvent(bucketName string, usage int64) <span class="cov0" title="0">{
        bu := &amp;BucketUsageEvent{
                Usage:      usage,
                BucketName: bucketName,
        }
        data, err := helper.MsgPackMarshal(bu)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to package bucket usage event for bucket %s with usage %d, err: %v",
                        bucketName, usage, err)
                return
        }</span>
        <span class="cov0" title="0">if MetaSyncQueue != nil </span><span class="cov0" title="0">{
                event := SyncEvent{
                        Type: SYNC_EVENT_TYPE_BUCKET_USAGE,
                        Data: data,
                }
                MetaSyncQueue &lt;- event
        }</span>
}
</pre>
		
		<pre class="file" id="file131" style="display: none">package meta

import (
        "errors"

        "github.com/soda/multi-cloud/s3/pkg/helper"
        "github.com/soda/multi-cloud/s3/pkg/meta/redis"
        log "github.com/sirupsen/logrus"
)

type CacheType int

const (
        NoCache CacheType = iota
        EnableCache
        SimpleCache
)

const (
        MSG_NOT_IMPL = "not implemented."
)

var cacheNames = [...]string{"NOCACHE", "EnableCache", "SimpleCache"}

type MetaCache interface {
        Close()
        Get(table redis.RedisDatabase, prefix, key string,
                onCacheMiss func() (helper.Serializable, error),
                onDeserialize func(map[string]string) (interface{}, error),
                willNeed bool) (value interface{}, err error)
        Remove(table redis.RedisDatabase, prefix, key string)
        GetCacheHitRatio() float64
        Keys(table redis.RedisDatabase, pattern string) ([]string, error)
        HGetInt64(table redis.RedisDatabase, prefix, key, field string) (int64, error)
        HMSet(table redis.RedisDatabase, prefix, key string, fields map[string]interface{}) (string, error)
        HIncrBy(table redis.RedisDatabase, prefix, key, field string, value int64) (int64, error)
}

type disabledMetaCache struct{}

type entry struct {
        table redis.RedisDatabase
        key   string
        value interface{}
}

func newMetaCache(myType CacheType) (m MetaCache) <span class="cov8" title="1">{

        log.Infof("Setting Up Metadata Cache: %s\n", cacheNames[int(myType)])
        if myType == SimpleCache </span><span class="cov0" title="0">{
                m := new(enabledSimpleMetaCache)
                m.Hit = 0
                m.Miss = 0
                return m
        }</span>
        <span class="cov8" title="1">return &amp;disabledMetaCache{}</span>
}

func (m *disabledMetaCache) Get(table redis.RedisDatabase, prefix, key string,
        onCacheMiss func() (helper.Serializable, error),
        onDeserialize func(map[string]string) (interface{}, error),
        willNeed bool) (value interface{}, err error) <span class="cov8" title="1">{
        return onCacheMiss()
}</span>

func (m *disabledMetaCache) Remove(table redis.RedisDatabase, prefix, key string) <span class="cov0" title="0">{
        return
}</span>

func (m *disabledMetaCache) GetCacheHitRatio() float64 <span class="cov0" title="0">{
        return -1
}</span>

func (m *disabledMetaCache) Keys(table redis.RedisDatabase, pattern string) ([]string, error) <span class="cov0" title="0">{
        return nil, errors.New(MSG_NOT_IMPL)
}</span>

func (m *disabledMetaCache) HGetInt64(table redis.RedisDatabase, prefix, key, field string) (int64, error) <span class="cov0" title="0">{
        return 0, errors.New(MSG_NOT_IMPL)
}</span>

func (m *disabledMetaCache) HMSet(table redis.RedisDatabase, prefix, key string, fields map[string]interface{}) (string, error) <span class="cov0" title="0">{
        return "", errors.New(MSG_NOT_IMPL)
}</span>

func (m *disabledMetaCache) HIncrBy(table redis.RedisDatabase, prefix, key, field string, value int64) (int64, error) <span class="cov0" title="0">{
        return 0, errors.New(MSG_NOT_IMPL)
}</span>

func (m *disabledMetaCache) Close() {<span class="cov0" title="0">
}</span>

type enabledSimpleMetaCache struct {
        Hit  int64
        Miss int64
}

func (m *enabledSimpleMetaCache) Get(
        table redis.RedisDatabase,
        prefix, key string,
        onCacheMiss func() (helper.Serializable, error),
        onDeserialize func(map[string]string) (interface{}, error),
        willNeed bool) (value interface{}, err error) <span class="cov0" title="0">{

        log.Info("enabledSimpleMetaCache Get. table:", table, "key:", key)

        fields, err := redis.HGetAll(table, prefix, key)
        if err != nil </span><span class="cov0" title="0">{
                log.Error("enabledSimpleMetaCache Get err:", err, "table:", table, "key:", key)
        }</span>
        <span class="cov0" title="0">if err == nil &amp;&amp; fields != nil &amp;&amp; len(fields) &gt; 0 </span><span class="cov0" title="0">{
                value, err = onDeserialize(fields)
                m.Hit = m.Hit + 1
                return value, err
        }</span>

        //if redis doesn't have the entry
        <span class="cov0" title="0">if onCacheMiss != nil </span><span class="cov0" title="0">{
                obj, err := onCacheMiss()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">if willNeed == true </span><span class="cov0" title="0">{
                        values, err := obj.Serialize()
                        if err != nil </span><span class="cov0" title="0">{
                                log.Error("failed to serialize from %v", obj, " with err: ", err)
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">_, err = redis.HMSet(table, prefix, key, values)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Error("failed to set key: ", key, " with err: ", err)
                                //do nothing, even if redis is down.
                        }</span>
                }
                <span class="cov0" title="0">m.Miss = m.Miss + 1
                return obj, nil</span>
        }
        <span class="cov0" title="0">return nil, nil</span>
}

func (m *enabledSimpleMetaCache) Remove(table redis.RedisDatabase, prefix, key string) <span class="cov0" title="0">{
        redis.Remove(table, prefix, key)
}</span>

func (m *enabledSimpleMetaCache) GetCacheHitRatio() float64 <span class="cov0" title="0">{
        return float64(m.Hit) / float64(m.Hit+m.Miss)
}</span>

func (m *enabledSimpleMetaCache) Keys(table redis.RedisDatabase, pattern string) ([]string, error) <span class="cov0" title="0">{
        return redis.Keys(table, pattern)
}</span>

func (m *enabledSimpleMetaCache) HGetInt64(table redis.RedisDatabase, prefix, key, field string) (int64, error) <span class="cov0" title="0">{
        return redis.HGetInt64(table, prefix, key, field)
}</span>

func (m *enabledSimpleMetaCache) HMSet(table redis.RedisDatabase, prefix, key string, fields map[string]interface{}) (string, error) <span class="cov0" title="0">{
        return redis.HMSet(table, prefix, key, fields)
}</span>

func (m *enabledSimpleMetaCache) HIncrBy(table redis.RedisDatabase, prefix, key, field string, value int64) (int64, error) <span class="cov0" title="0">{
        return redis.HIncrBy(table, prefix, key, field, value)
}</span>

func (m *enabledSimpleMetaCache) Close() <span class="cov0" title="0">{
        redis.Close()
}</span>
</pre>
		
		<pre class="file" id="file132" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package tidbclient

import (
        "context"
        "database/sql"
        "encoding/json"
        "strconv"
        "strings"
        "time"

        _ "github.com/go-sql-driver/mysql"
        "github.com/soda/multi-cloud/api/pkg/common"
        . "github.com/soda/multi-cloud/s3/error"
        "github.com/soda/multi-cloud/s3/pkg/helper"
        . "github.com/soda/multi-cloud/s3/pkg/meta/types"
        "github.com/soda/multi-cloud/s3/pkg/meta/util"
        "github.com/soda/multi-cloud/s3/pkg/utils"
        pb "github.com/soda/multi-cloud/s3/proto"
        log "github.com/sirupsen/logrus"
)

const TimeDur = 5000 // milisecond

func (t *TidbClient) GetBucket(ctx context.Context, bucketName string) (bucket *Bucket, err error) <span class="cov8" title="1">{
        log.Infof("get bucket[%s] from tidb ...\n", bucketName)
        var acl, cors, lc, policy, replication, createTime string
        var updateTime sql.NullString
        var row *sql.Row

        sqltext := "select bucketname,tenantid,createtime,usages,location,acl,cors,lc,policy,versioning,replication," +
                "update_time from buckets where bucketname=?;"
        row = t.Client.QueryRow(sqltext, bucketName)

        tmp := &amp;Bucket{Bucket: &amp;pb.Bucket{}}
        tmp.Versioning = &amp;pb.BucketVersioning{}
        err = row.Scan(
                &amp;tmp.Name,
                &amp;tmp.TenantId,
                &amp;createTime,
                &amp;tmp.Usages,
                &amp;tmp.DefaultLocation,
                &amp;acl,
                &amp;cors,
                &amp;lc,
                &amp;policy,
                &amp;tmp.Versioning.Status,
                &amp;replication,
                &amp;updateTime,
        )
        if err != nil </span><span class="cov8" title="1">{
                err = handleDBError(err)
                return
        }</span>

        <span class="cov8" title="1">ct, err := time.Parse(TIME_LAYOUT_TIDB, createTime)
        if err != nil </span><span class="cov0" title="0">{
                err = handleDBError(err)
                return
        }</span>
        <span class="cov8" title="1">tmp.CreateTime = ct.Unix()

        pbAcl := pb.Acl{}
        err = json.Unmarshal([]byte(acl), &amp;pbAcl)
        if err != nil </span><span class="cov0" title="0">{
                err = handleDBError(err)
                return
        }</span>
        <span class="cov8" title="1">tmp.Acl = &amp;pbAcl

        err = json.Unmarshal([]byte(cors), &amp;tmp.Cors)
        if err != nil </span><span class="cov0" title="0">{
                err = handleDBError(err)
                return
        }</span>
        <span class="cov8" title="1">err = json.Unmarshal([]byte(lc), &amp;tmp.LifecycleConfiguration)
        if err != nil </span><span class="cov0" title="0">{
                err = handleDBError(err)
                return
        }</span>
        <span class="cov8" title="1">err = json.Unmarshal([]byte(policy), &amp;tmp.BucketPolicy)
        if err != nil </span><span class="cov0" title="0">{
                err = handleDBError(err)
                return
        }</span>
        <span class="cov8" title="1">err = json.Unmarshal([]byte(replication), &amp;tmp.ReplicationConfiguration)
        if err != nil </span><span class="cov0" title="0">{
                err = handleDBError(err)
                return
        }</span>
        //get versioning for the bucket
        <span class="cov8" title="1">versionOpts, versionErr := t.GetBucketVersioning(ctx, tmp.Name)
        if versionErr != nil </span><span class="cov0" title="0">{
                log.Error("error in getting versioning information, err:%v\n", versionErr)
                err = handleDBError(versionErr)
                return
        }</span>
        <span class="cov8" title="1">tmp.Versioning = &amp;pb.BucketVersioning{}
        if versionOpts != nil </span><span class="cov8" title="1">{
                tmp.Versioning.Status = versionOpts.Status
        }</span>

        // get SSE info for this bucket
        <span class="cov8" title="1">tmp.ServerSideEncryption = &amp;pb.ServerSideEncryption{}
        sseOpts, sseErr := t.GetBucketSSE(ctx, tmp.Name)
        if sseErr != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">sseType := "NONE"
        if sseOpts != nil </span><span class="cov8" title="1">{
                sseType = sseOpts.SseType
                tmp.ServerSideEncryption.EncryptionKey = sseOpts.EncryptionKey
        }</span>
        <span class="cov8" title="1">tmp.ServerSideEncryption.SseType = sseType
        bucket = tmp
        return</span>
}

// For the request that list buckets, better to filter according to tenant.
func (t *TidbClient) GetBuckets(ctx context.Context) (buckets []*Bucket, err error) <span class="cov8" title="1">{
        log.Info("list buckets from tidb ...")

        isAdmin, tenantId, _, err := util.GetCredentialFromCtx(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, ErrInternalError
        }</span>

        <span class="cov8" title="1">var rows *sql.Rows
        sqltext := "select bucketname,tenantid,userid,createtime,usages,location,deleted,acl,cors,lc,policy," +
                "versioning,replication,update_time from buckets;"

        if !isAdmin </span><span class="cov8" title="1">{
                sqltext = "select bucketname,tenantid,userid,createtime,usages,location,deleted,acl,cors,lc,policy," +
                        "versioning,replication,update_time from buckets where tenantid=?;"
                rows, err = t.Client.Query(sqltext, tenantId)
        }</span> else<span class="cov0" title="0"> {
                rows, err = t.Client.Query(sqltext)
        }</span>

        <span class="cov8" title="1">if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                err = nil
                return
        }</span> else<span class="cov8" title="1"> if err != nil </span><span class="cov0" title="0">{
                err = handleDBError(err)
                return
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        for rows.Next() </span><span class="cov8" title="1">{
                tmp := Bucket{Bucket: &amp;pb.Bucket{}}
                bucketVer := pb.BucketVersioning{}
                tmp.Versioning = &amp;bucketVer
                var acl, cors, lc, policy, createTime, replication string
                var updateTime sql.NullString
                err = rows.Scan(
                        &amp;tmp.Name,
                        &amp;tmp.TenantId,
                        &amp;tmp.UserId,
                        &amp;createTime,
                        &amp;tmp.Usages,
                        &amp;tmp.DefaultLocation,
                        &amp;tmp.Deleted,
                        &amp;acl,
                        &amp;cors,
                        &amp;lc,
                        &amp;policy,
                        &amp;tmp.Versioning.Status,
                        &amp;replication,
                        &amp;updateTime)
                if err != nil </span><span class="cov0" title="0">{
                        err = handleDBError(err)
                        return
                }</span>

                //get versioning for the bucket
                <span class="cov8" title="1">versionOpts, versionErr := t.GetBucketVersioning(ctx, tmp.Name)
                if versionErr != nil </span><span class="cov0" title="0">{
                        log.Error("error in getting versioning information, err:%v\n", versionErr)
                        err = handleDBError(versionErr)
                        return
                }</span>
                <span class="cov8" title="1">tmp.Versioning = &amp;pb.BucketVersioning{}
                if versionOpts != nil </span><span class="cov8" title="1">{
                        tmp.Versioning.Status = versionOpts.Status
                }</span>

                // get SSE info for this bucket
                <span class="cov8" title="1">sseOpts, sseErr := t.GetBucketSSE(ctx, tmp.Name)
                if sseErr != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov8" title="1">sseType := "NONE"
                if sseOpts != nil </span><span class="cov8" title="1">{
                        sseType = sseOpts.SseType
                }</span>
                <span class="cov8" title="1">tmp.ServerSideEncryption = &amp;pb.ServerSideEncryption{}
                tmp.ServerSideEncryption.SseType = sseType

                var ctime time.Time
                ctime, err = time.ParseInLocation(TIME_LAYOUT_TIDB, createTime, time.Local)
                if err != nil </span><span class="cov0" title="0">{
                        err = handleDBError(err)
                        return
                }</span>
                <span class="cov8" title="1">tmp.CreateTime = ctime.Unix()
                err = json.Unmarshal([]byte(acl), &amp;tmp.Acl)
                if err != nil </span><span class="cov0" title="0">{
                        err = handleDBError(err)
                        return
                }</span>
                <span class="cov8" title="1">err = json.Unmarshal([]byte(cors), &amp;tmp.Cors)
                if err != nil </span><span class="cov0" title="0">{
                        err = handleDBError(err)
                        return
                }</span>
                <span class="cov8" title="1">err = json.Unmarshal([]byte(lc), &amp;tmp.LifecycleConfiguration)
                if err != nil </span><span class="cov0" title="0">{
                        err = handleDBError(err)
                        return
                }</span>
                <span class="cov8" title="1">err = json.Unmarshal([]byte(policy), &amp;tmp.BucketPolicy)
                if err != nil </span><span class="cov0" title="0">{
                        err = handleDBError(err)
                        return
                }</span>
                <span class="cov8" title="1">err = json.Unmarshal([]byte(replication), &amp;tmp.ReplicationConfiguration)
                if err != nil </span><span class="cov0" title="0">{
                        err = handleDBError(err)
                        return
                }</span>
                <span class="cov8" title="1">buckets = append(buckets, &amp;tmp)</span>
        }
        <span class="cov8" title="1">return</span>
}

//Actually this method is used to update bucket
func (t *TidbClient) PutBucket(ctx context.Context, bucket *Bucket) error <span class="cov0" title="0">{
        log.Infof("put bucket[%s] into tidb ...\n", bucket.Name)
        acl, _ := json.Marshal(bucket.Acl)
        cors, _ := json.Marshal(bucket.Cors)
        lc, _ := json.Marshal(bucket.LifecycleConfiguration)
        bucket_policy, _ := json.Marshal(bucket.BucketPolicy)
        sql := "update buckets set bucketname=?,acl=?,policy=?,cors=?,lc=?,tenantid=?,versioning=? where bucketname=?"
        args := []interface{}{bucket.Name, acl, bucket_policy, cors, lc, bucket.TenantId, bucket.Versioning.Status, bucket.Name}

        _, err := t.Client.Exec(sql, args...)
        if err != nil </span><span class="cov0" title="0">{
                return handleDBError(err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (t *TidbClient) CheckAndPutBucket(ctx context.Context, bucket *Bucket) (bool, error) <span class="cov8" title="1">{
        var processed bool
        _, err := t.GetBucket(ctx, bucket.Name)
        if err == nil </span><span class="cov0" title="0">{
                processed = false
                return processed, err
        }</span> else<span class="cov8" title="1"> if err != ErrNoSuchKey </span><span class="cov0" title="0">{
                processed = false
                return processed, err
        }</span> else<span class="cov8" title="1"> {
                processed = true
        }</span>
        <span class="cov8" title="1">log.Infof("insert bucket[%s] into database.\n", bucket.Name)
        sql, args := bucket.GetCreateSql()
        _, err = t.Client.Exec(sql, args...)
        if err != nil </span><span class="cov0" title="0">{
                err = handleDBError(err)

        }</span>
        <span class="cov8" title="1">return processed, err</span>
}

func (t *TidbClient) ListObjects(ctx context.Context, bucketName string, versioned bool, maxKeys int,
        filter map[string]string) (retObjects []*Object, appendInfo utils.ListObjsAppendInfo, err error) <span class="cov8" title="1">{
        const MaxObjectList = 10000
        // TODO: support versioning
        if versioned </span><span class="cov0" title="0">{
                log.Errorf("not supported.")
                err = ErrInternalError
                return
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                err = handleDBError(err)
        }</span>()
        <span class="cov8" title="1">var count int
        var exit bool
        objectMap := make(map[string]struct{})
        objectNum := make(map[string]int)
        commonPrefixes := make(map[string]struct{})
        if filter == nil </span><span class="cov0" title="0">{
                filter = make(map[string]string)
        }</span>
        <span class="cov8" title="1">omarker := filter[common.KMarker]
        delimiter := filter[common.KDelimiter]
        prefix := filter[common.KPrefix]
        for </span><span class="cov8" title="1">{
                var loopcount int
                var sqltext string
                var rows *sql.Rows
                args := make([]interface{}, 0)
                // only select index column here to avoid slow query
                sqltext = "select bucketname,name,version from objects where bucketName=? and deletemarker=0"
                args = append(args, bucketName)
                var inargs []interface{}
                sqltext, inargs, err = buildSql(ctx, filter, sqltext)
                for _, v := range inargs </span><span class="cov8" title="1">{
                        args = append(args, v)
                }</span>
                <span class="cov8" title="1">log.Infof("sqltext:%s, args:%v\n", sqltext, args)
                tstart := time.Now()
                rows, err = t.Client.Query(sqltext, args...)
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov8" title="1">tqueryend := time.Now()
                tdur := tqueryend.Sub(tstart).Nanoseconds()
                if tdur/1000000 &gt; TimeDur </span><span class="cov0" title="0">{
                        log.Debugf("slow query when list objects, sqltext:%s, args:%v, nanoseconds:%d\n", sqltext, args, tdur)
                }</span>
                <span class="cov8" title="1">defer rows.Close()
                for rows.Next() </span><span class="cov8" title="1">{
                        loopcount += 1
                        //var name, lastModified string
                        var bname, name string
                        var version uint64
                        err = rows.Scan(
                                &amp;bname,
                                &amp;name,
                                &amp;version,
                        )
                        if err != nil </span><span class="cov0" title="0">{
                                log.Errorf("err:%v\n", err)
                                return
                        }</span>
                        //prepare next marker, marker is last bucketname got from the last query,
                        //TODU: be sure how tidb/mysql compare strings
                        <span class="cov8" title="1">if _, ok := objectNum[name]; !ok </span><span class="cov8" title="1">{
                                objectNum[name] = 0
                        }</span>
                        <span class="cov8" title="1">objectNum[name] += 1
                        filter[common.KMarker] = name

                        if _, ok := objectMap[name]; !ok </span><span class="cov8" title="1">{
                                objectMap[name] = struct{}{}
                        }</span> else<span class="cov0" title="0"> {
                                continue</span>
                        }

                        // TODO: filter by deletemarker if versioning enabled

                        <span class="cov8" title="1">if name == omarker </span><span class="cov0" title="0">{
                                log.Infof("%s euqals to omarker, continue\n", name)
                                continue</span>
                        }

                        // Group by delimiter, delimiter is used to group object keys. Object keys that contain the same string
                        // between the prefix and the first occurrence of the delimiter to be rolled up into a single result element
                        // in the CommonPrefixes collection. These rolled-up keys are not returned elsewhere in the response. Each
                        // rolled-up result counts as only one return against the MaxKeys value. Those are compatible with AWS S3,
                        // please see https://docs.aws.amazon.com/zh_cn/AmazonS3/latest/API/API_ListObjectsV2.html for details.
                        <span class="cov8" title="1">if len(delimiter) != 0 </span><span class="cov0" title="0">{
                                subStr := strings.TrimPrefix(name, prefix)
                                n := strings.Index(subStr, delimiter)
                                if n != -1 </span><span class="cov0" title="0">{
                                        prefixKey := prefix + string([]byte(subStr)[0:(n+1)])
                                        filter[common.KMarker] = prefixKey[0:(len(prefixKey)-1)] + string(delimiter[len(delimiter)-1]+1)
                                        if prefixKey == omarker </span><span class="cov0" title="0">{
                                                continue</span>
                                        }
                                        <span class="cov0" title="0">if _, ok := commonPrefixes[prefixKey]; !ok </span><span class="cov0" title="0">{
                                                if count == maxKeys </span><span class="cov0" title="0">{
                                                        appendInfo.Truncated = true
                                                        exit = true
                                                        break</span>
                                                }
                                                <span class="cov0" title="0">commonPrefixes[prefixKey] = struct{}{}
                                                // When response is truncated (the IsTruncated element value in the response is true), you can
                                                // use the key name in this field as marker in the subsequent request to get next set of objects,
                                                // the same as AWS S3. See https://docs.aws.amazon.com/zh_cn/AmazonS3/latest/API/API_ListObjects.html
                                                // for details.
                                                appendInfo.NextMarker = prefixKey
                                                count += 1</span>
                                        }
                                        <span class="cov0" title="0">continue</span>
                                }
                        }

                        <span class="cov8" title="1">var o *Object
                        strVer := strconv.FormatUint(version, 10)
                        o, err = t.GetObject(ctx, bname, name, strVer)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Errorf("err:%v\n", err)
                                return
                        }</span>

                        <span class="cov8" title="1">count += 1
                        if count == maxKeys </span><span class="cov0" title="0">{
                                appendInfo.NextMarker = name
                        }</span>

                        <span class="cov8" title="1">if count &gt; maxKeys </span><span class="cov0" title="0">{
                                appendInfo.Truncated = true
                                exit = true
                                break</span>
                        }

                        <span class="cov8" title="1">retObjects = append(retObjects, o)</span>
                }

                <span class="cov8" title="1">tend := time.Now()
                tdur = tend.Sub(tqueryend).Nanoseconds()
                if tdur/1000000 &gt; TimeDur </span><span class="cov0" title="0">{
                        log.Debugf("slow get when list objects, time:%d\n", tdur)
                }</span>

                <span class="cov8" title="1">if loopcount &lt; MaxObjectList </span><span class="cov8" title="1">{
                        exit = true
                }</span>
                <span class="cov8" title="1">if exit </span><span class="cov8" title="1">{
                        break</span>
                }

                <span class="cov0" title="0">err = rows.Err()
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("err:%v\n", err)
                        return
                }</span>
        }

        <span class="cov8" title="1">appendInfo.Prefixes = helper.Keys(commonPrefixes)

        return</span>
}

func (t *TidbClient) CountObjects(ctx context.Context, bucketName, prefix string) (*utils.ObjsCountInfo, error) <span class="cov0" title="0">{
        var sqltext string
        rsp := utils.ObjsCountInfo{}
        var err error
        var sizeStr sql.NullString
        if prefix == "" </span><span class="cov0" title="0">{
                sqltext = "select count(*),sum(size) from objects where bucketname=? and tier&lt;?;"
                err = t.Client.QueryRow(sqltext, bucketName, utils.Tier999).Scan(&amp;rsp.Count, &amp;sizeStr)
        }</span> else<span class="cov0" title="0"> {
                filt := prefix + "%"
                sqltext = "select count(*),sum(size) from objects where bucketname=? and tier&lt;? and name like ?;"
                err = t.Client.QueryRow(sqltext, bucketName, utils.Tier999, filt).Scan(&amp;rsp.Count, &amp;sizeStr)
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                log.Errorf("db error:%v\n", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">if sizeStr.Valid </span><span class="cov0" title="0">{
                size, err := strconv.ParseInt(sizeStr.String, 10, 64)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("error:%v\n", err)
                }</span> else<span class="cov0" title="0"> {
                        rsp.Size = size
                }</span>
        }

        <span class="cov0" title="0">return &amp;rsp, err</span>
}

func (t *TidbClient) DeleteBucket(ctx context.Context, bucket *Bucket) error <span class="cov0" title="0">{
        sqltext := "delete from buckets where bucketname=?;"
        _, err := t.Client.Exec(sqltext, bucket.Name)
        if err != nil </span><span class="cov0" title="0">{
                return handleDBError(err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (t *TidbClient) UpdateUsage(ctx context.Context, bucketName string, size int64, tx interface{}) (err error) <span class="cov0" title="0">{
        var sqlTx *sql.Tx
        if tx == nil </span><span class="cov0" title="0">{
                tx, err = t.Client.Begin()

                defer func() </span><span class="cov0" title="0">{
                        if err == nil </span><span class="cov0" title="0">{
                                err = sqlTx.Commit()
                        }</span>
                        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                                sqlTx.Rollback()
                        }</span>
                }()
        }
        <span class="cov0" title="0">sqlTx, _ = tx.(*sql.Tx)

        sql := "update buckets set usages=? where bucketname=?;"
        _, err = sqlTx.Exec(sql, size, bucketName)
        if err != nil </span><span class="cov0" title="0">{
                err = handleDBError(err)
        }</span>
        <span class="cov0" title="0">return</span>
}

func (t *TidbClient) UpdateUsages(ctx context.Context, usages map[string]int64, tx interface{}) error <span class="cov0" title="0">{
        var sqlTx *sql.Tx
        var err error
        if nil == tx </span><span class="cov0" title="0">{
                tx, err = t.Client.Begin()
                defer func() </span><span class="cov0" title="0">{
                        if nil == err </span><span class="cov0" title="0">{
                                err = sqlTx.Commit()
                        }</span> else<span class="cov0" title="0"> {
                                sqlTx.Rollback()
                        }</span>
                }()
        }
        <span class="cov0" title="0">sqlTx, _ = tx.(*sql.Tx)
        sqlStr := "update buckets set usages = ? where bucketname = ?;"
        st, err := sqlTx.Prepare(sqlStr)
        if err != nil </span><span class="cov0" title="0">{
                log.Error("failed to prepare statment with sql: ", sqlStr, ", err: ", err)
                return ErrDBError
        }</span>
        <span class="cov0" title="0">defer st.Close()

        for bucket, usage := range usages </span><span class="cov0" title="0">{
                _, err = st.Exec(usage, bucket)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error("failed to update usage for bucket: ", bucket, " with usage: ", usage, ", err: ", err)
                        return ErrDBError
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (t *TidbClient) ListBucketLifecycle(ctx context.Context) (buckets []*Bucket, err error) <span class="cov0" title="0">{
        log.Infoln("list bucket lifecycle from tidb ...\n")
        defer func() </span><span class="cov0" title="0">{
                err = handleDBError(err)
        }</span>()

        <span class="cov0" title="0">var rows *sql.Rows
        sqltext := "select bucketname,lc from buckets where lc!=CAST('null' AS JSON);"
        rows, err = t.Client.Query(sqltext)
        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                err = nil
                return
        }</span> else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                log.Errorf("db err:%v\n", err)
                return
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        for rows.Next() </span><span class="cov0" title="0">{
                tmp := Bucket{Bucket: &amp;pb.Bucket{}}
                var lc string
                err = rows.Scan(
                        &amp;tmp.Name,
                        &amp;lc)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("db err:%v\n", err)
                        return
                }</span>

                <span class="cov0" title="0">err = json.Unmarshal([]byte(lc), &amp;tmp.LifecycleConfiguration)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("db err:%v\n", err)
                        return
                }</span>

                <span class="cov0" title="0">buckets = append(buckets, &amp;tmp)</span>
        }

        <span class="cov0" title="0">err = rows.Err()
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("db err:%v\n", err)
        }</span>

        <span class="cov0" title="0">return</span>
}

func (t *TidbClient) UpdateBucketVersioning(ctx context.Context, bucketName string, versionStatus string) error <span class="cov8" title="1">{
        log.Infof("put bucket[%s] Version info[%s] into tidb ...\n", bucketName, versionStatus)

        sql := "update bucket_versionopts set versionstatus=? where bucketname=?"
        args := []interface{}{versionStatus, bucketName}

        _, err := t.Client.Exec(sql, args...)
        if err != nil </span><span class="cov0" title="0">{
                log.Error("error in updating versioning information, err:%v\n", err)
                return handleDBError(err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (t *TidbClient) CreateBucketVersioning(ctx context.Context, bucketName string, versionStatus string) error <span class="cov8" title="1">{
        log.Infof("create bucket[%s] Version info[%s] into tidb ...\n", bucketName, versionStatus)

        sql := "insert into bucket_versionopts(bucketname, versionstatus) values(?,?);"
        args := []interface{}{bucketName, versionStatus}

        _, err := t.Client.Exec(sql, args...)
        if err != nil </span><span class="cov0" title="0">{
                log.Error("error in creating versioning information, err:%v\n", err)
                return handleDBError(err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (t *TidbClient) GetBucketVersioning(ctx context.Context, bucketName string) (versionOptsPtr *pb.BucketVersioning, err error) <span class="cov8" title="1">{
        log.Info("list bucket Versions info from tidb ...")
        /*m := bson.M{}
        err = UpdateContextFilter(ctx, m)
        if err != nil {
                return nil, ErrInternalError
        }*/

        var rows *sql.Rows
        sqltext := "select versionstatus from bucket_versionopts where bucketname=?;"

        rows, err = t.Client.Query(sqltext, bucketName)

        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                err = nil
                return
        }</span> else<span class="cov8" title="1"> if err != nil </span><span class="cov0" title="0">{
                log.Error("error in getting bucket versioning configuration, err:%v\n", err)
                err = handleDBError(err)
                return
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        for rows.Next() </span><span class="cov8" title="1">{
                tmp := &amp;pb.BucketVersioning{}
                err = rows.Scan(
                        &amp;tmp.Status)
                if err != nil </span><span class="cov0" title="0">{
                        err = handleDBError(err)
                        return
                }</span>
                <span class="cov8" title="1">return tmp, nil</span>
        }
        <span class="cov0" title="0">return</span>
}

func (t *TidbClient) CreateBucketSSE(ctx context.Context, bucketName string, sseType string, sseKey []byte) error <span class="cov8" title="1">{
        log.Infof("create bucket[%s] SSE info[%s] into tidb ...\n", bucketName, sseType)

        sql := "insert into bucket_sseopts(bucketname, sse, sseserverkey) values(?,?,?);"
        args := []interface{}{bucketName, sseType, sseKey}

        _, err := t.Client.Exec(sql, args...)
        if err != nil </span><span class="cov0" title="0">{
                return handleDBError(err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (t *TidbClient) GetBucketSSE(ctx context.Context, bucketName string) (sseOptsPtr *pb.ServerSideEncryption, err error) <span class="cov8" title="1">{
        log.Info("list bucket SSE info from tidb ...")

        var rows *sql.Rows
        sqltext := "select sse,sseserverkey from bucket_sseopts where bucketname=?;"

        rows, err = t.Client.Query(sqltext, bucketName)

        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                err = nil
                return
        }</span> else<span class="cov8" title="1"> if err != nil </span><span class="cov0" title="0">{
                err = handleDBError(err)
                return
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        for rows.Next() </span><span class="cov8" title="1">{
                tmp := &amp;pb.ServerSideEncryption{}

                err = rows.Scan(
                        &amp;tmp.SseType,
                        &amp;tmp.EncryptionKey)
                if err != nil </span><span class="cov0" title="0">{
                        err = handleDBError(err)
                        return
                }</span>
                <span class="cov8" title="1">rErr := rows.Err()
                if rErr != nil </span><span class="cov0" title="0">{
                        rErr = handleDBError(rErr)
                        return
                }</span>
                <span class="cov8" title="1">return tmp, nil</span>
        }
        <span class="cov0" title="0">return</span>
}

func (t *TidbClient) UpdateBucketSSE(ctx context.Context, bucketName string, sseType string, sseKey []byte) error <span class="cov8" title="1">{
        log.Infof("put bucket[%s] SSE info[%s] into tidb ...\n", bucketName, sseType)

        sql := "update bucket_sseopts set sse=?,sseserverkey=? where bucketname=?"
        args := []interface{}{sseType, sseKey, bucketName}

        _, err := t.Client.Exec(sql, args...)
        if err != nil </span><span class="cov0" title="0">{
                return handleDBError(err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file133" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package tidbclient

import (
        "context"
        "database/sql"
        "encoding/hex"
        "encoding/json"
        "math"
        "os"
        "strconv"
        "strings"

        _ "github.com/go-sql-driver/mysql"
        "github.com/soda/multi-cloud/api/pkg/common"
        . "github.com/soda/multi-cloud/s3/error"
        . "github.com/soda/multi-cloud/s3/pkg/meta/types"
        log "github.com/sirupsen/logrus"
        "github.com/xxtea/xxtea-go/xxtea"
)

const MAX_OPEN_CONNS = 1024

type TidbClient struct {
        Client *sql.DB
}

func NewTidbClient(dbInfo string) *TidbClient <span class="cov8" title="1">{
        cli := &amp;TidbClient{}
        conn, err := sql.Open("mysql", dbInfo)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("connect to tidb failed, err:%v\n", err)
                os.Exit(1)
        }</span>
        <span class="cov8" title="1">log.Info("connected to tidb ...")
        conn.SetMaxIdleConns(0)
        conn.SetMaxOpenConns(MAX_OPEN_CONNS)
        cli.Client = conn
        return cli</span>
}

func handleDBError(in error) (out error) <span class="cov8" title="1">{
        if in == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">log.Errorf("db error:%v\n", in)
        if in == sql.ErrNoRows </span><span class="cov8" title="1">{
                out = ErrNoSuchKey
        }</span> else<span class="cov0" title="0"> {
                out = ErrDBError
        }</span>
        <span class="cov8" title="1">return</span>
}

func buildSql(ctx context.Context, filter map[string]string, sqltxt string) (string, []interface{}, error) <span class="cov8" title="1">{
        const MaxObjectList = 10000
        args := make([]interface{}, 0)

        prefix := filter[common.KPrefix]
        if prefix != "" </span><span class="cov0" title="0">{
                sqltxt += " and name like ?"
                args = append(args, prefix+"%")
                log.Debug("query prefix:", prefix)
        }</span>
        <span class="cov8" title="1">if filter[common.KMarker] != "" </span><span class="cov0" title="0">{
                sqltxt += " and name &gt;= ?"
                args = append(args, filter[common.KMarker])
                log.Debug("query marker:", filter[common.KMarker])
        }</span>

        // lifecycle management may need to filter by LastModified
        <span class="cov8" title="1">if filter[common.KLastModified] != "" </span><span class="cov0" title="0">{
                var tmFilter map[string]string
                err := json.Unmarshal([]byte(filter[common.KLastModified]), &amp;tmFilter)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("unmarshal lastmodified value failed:%s\n", err)
                        return sqltxt, args, ErrInternalError
                }</span>
                <span class="cov0" title="0">log.Debugf("tmpFilter:%+v\n", tmFilter)

                for k, v := range tmFilter </span><span class="cov0" title="0">{
                        var op string
                        switch k </span>{
                        case "lt":<span class="cov0" title="0">
                                op = "&lt;"</span>
                        case "gt":<span class="cov0" title="0">
                                op = "&gt;"</span>
                        case "lte":<span class="cov0" title="0">
                                op = "&lt;="</span>
                        case "gte":<span class="cov0" title="0">
                                op = "&gt;="</span>
                        default:<span class="cov0" title="0">
                                log.Infof("unsupport filter action:%s\n", k)
                                return sqltxt, args, ErrInternalError</span>
                        }

                        <span class="cov0" title="0">sqltxt += " and lastmodifiedtime " + op + " ?"
                        args = append(args, v)</span>
                }
        }

        // lifecycle management may need to filter by StorageTier
        <span class="cov8" title="1">if filter[common.KStorageTier] != "" </span><span class="cov0" title="0">{
                tier, err := strconv.Atoi(filter[common.KStorageTier])
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("invalid storage tier:%s\n", filter[common.KStorageTier])
                        return sqltxt, args, ErrInternalError
                }</span>

                <span class="cov0" title="0">sqltxt += " and tier &lt;= ?"
                args = append(args, tier)</span>
        }

        <span class="cov8" title="1">delimiter := filter[common.KDelimiter]
        if delimiter == "" </span><span class="cov8" title="1">{
                sqltxt += " order by bucketname,name,version limit ?"
                args = append(args, MaxObjectList)
        }</span> else<span class="cov0" title="0"> {
                num := len(strings.Split(prefix, delimiter))
                if prefix == "" </span><span class="cov0" title="0">{
                        num += 1
                }</span>

                <span class="cov0" title="0">sqltxt += " group by SUBSTRING_INDEX(name, ?, ?) order by bucketname, name,version limit ?"
                args = append(args, delimiter, num, MaxObjectList)</span>
        }

        <span class="cov8" title="1">return sqltxt, args, nil</span>
}

func VersionStr2UInt64(vers string) uint64 <span class="cov0" title="0">{
        vidByte, _ := hex.DecodeString(vers)
        decrByte := xxtea.Decrypt(vidByte, XXTEA_KEY)
        reVersion, _ := strconv.ParseUint(string(decrByte), 10, 64)
        version := math.MaxUint64 - reVersion

        return version
}</span>
</pre>
		
		<pre class="file" id="file134" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package tidbclient

import (
        "context"
        "database/sql"
        "math"
        "strconv"
        "time"

        . "github.com/soda/multi-cloud/s3/pkg/meta/types"
        pb "github.com/soda/multi-cloud/s3/proto"
        log "github.com/sirupsen/logrus"
)

func (t *TidbClient) PutGcobjRecord(ctx context.Context, o *Object, tx interface{}) (err error) <span class="cov0" title="0">{
        var sqlTx *sql.Tx
        if tx == nil </span><span class="cov0" title="0">{
                tx, err = t.Client.Begin()
                defer func() </span><span class="cov0" title="0">{
                        if err == nil </span><span class="cov0" title="0">{
                                err = sqlTx.Commit()
                        }</span>
                        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                                sqlTx.Rollback()
                        }</span>
                }()
        }
        <span class="cov0" title="0">sqlTx, _ = tx.(*sql.Tx)

        version := math.MaxUint64 - uint64(o.LastModified)
        lastModifiedTime := time.Unix(o.LastModified, 0).Format(TIME_LAYOUT_TIDB)
        sqltext := "insert into gcobjs (bucketname, name, version, location, tenantid, userid, size, objectid, " +
                " lastmodifiedtime, storageMeta) values(?,?,?,?,?,?,?,?,?,?)"
        args := []interface{}{o.BucketName, o.ObjectKey, version, o.Location, o.TenantId, o.UserId, o.Size, o.ObjectId,
                lastModifiedTime, o.StorageMeta}
        log.Debugf("sqltext:%s, args:%v\n", sqltext, args)
        _, err = sqlTx.Exec(sqltext, args...)
        log.Debugf("err:%v\n", err)

        return err</span>
}

func (t *TidbClient) DeleteGcobjRecord(ctx context.Context, o *Object, tx interface{}) (err error) <span class="cov0" title="0">{
        var sqlTx *sql.Tx
        if tx == nil </span><span class="cov0" title="0">{
                tx, err = t.Client.Begin()
                defer func() </span><span class="cov0" title="0">{
                        if err == nil </span><span class="cov0" title="0">{
                                err = sqlTx.Commit()
                        }</span>
                        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                                sqlTx.Rollback()
                        }</span>
                }()
        }
        <span class="cov0" title="0">sqlTx, _ = tx.(*sql.Tx)

        sqltext := "delete from gcobjs where bucketname=? and name=? and version=?"
        version, err := strconv.ParseUint(o.VersionId, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                log.Error("delete gc failed, err: ", err)
                return err
        }</span>
        <span class="cov0" title="0">args := []interface{}{o.BucketName, o.ObjectKey, version}
        log.Debugf("sqltext:%s, args:%v\n", sqltext, args)
        _, err = sqlTx.Exec(sqltext, args...)
        log.Debugf("err:%v\n", err)

        return err</span>
}

func (t *TidbClient) ListGcObjs(ctx context.Context, offset, limit int) (objs []*Object, err error) <span class="cov8" title="1">{
        sqltext := "select bucketname,name,version,location,objectid,storageMeta from gcobjs order by bucketname,name," +
                "version limit ?,?;"
        args := []interface{}{offset, limit}
        log.Debugf("sqltext:%s, args:%v\n", sqltext, args)

        rows, err := t.Client.Query(sqltext, args...)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("err:%v\n", err)
                return
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        var iversion uint64
        for rows.Next() </span><span class="cov0" title="0">{
                obj := &amp;Object{Object: &amp;pb.Object{}}

                err = rows.Scan(
                        &amp;obj.BucketName,
                        &amp;obj.ObjectKey,
                        &amp;iversion,
                        &amp;obj.Location,
                        &amp;obj.ObjectId,
                        &amp;obj.StorageMeta,
                )
                obj.VersionId = strconv.FormatUint(iversion, 10)
                objs = append(objs, obj)
        }</span>

        <span class="cov8" title="1">err = rows.Err()
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("err:%v\n", err)
        }</span>

        <span class="cov8" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file135" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package tidbclient

import (
        "database/sql"
        "encoding/json"
        "strings"
        "time"

        . "github.com/soda/multi-cloud/s3/error"
        "github.com/soda/multi-cloud/s3/pkg/helper"
        . "github.com/soda/multi-cloud/s3/pkg/meta/types"
        pb "github.com/soda/multi-cloud/s3/proto"
        log "github.com/sirupsen/logrus"
)

func (t *TidbClient) CreateMultipart(multipart Multipart) (err error) <span class="cov0" title="0">{
        m := multipart.Metadata
        uploadTime := multipart.InitialTime.Format(TIME_LAYOUT_TIDB)
        acl, _ := json.Marshal(m.Acl)
        attrs, _ := json.Marshal(m.Attrs)
        sqltext := "insert into multiparts(bucketname,objectname,uploadid,uploadtime,initiatorid,tenantid,userid,contenttype, " +
                "location,acl,attrs,objectid,storageMeta,storageclass) " +
                "values(?,?,?,?,?,?,?,?,?,?,?,?,?,?)"
        _, err = t.Client.Exec(sqltext, multipart.BucketName, multipart.ObjectKey, multipart.UploadId, uploadTime,
                m.InitiatorId, m.TenantId, m.UserId, m.ContentType,
                m.Location, acl, attrs, multipart.ObjectId, multipart.StorageMeta, m.Tier)
        return
}</span>

func (t *TidbClient) GetMultipart(bucketName, objectName, uploadId string) (multipart Multipart, err error) <span class="cov0" title="0">{
        sqltext := "select bucketname,objectname,uploadid,uploadtime,initiatorid,tenantid,userid,contenttype," +
                "location,acl,attrs,objectid,storageMeta,storageclass from multiparts " +
                "where bucketname=? and objectname=? and uploadid=?;"
        var acl, attrs, uploadTime string
        err = t.Client.QueryRow(sqltext, bucketName, objectName, uploadId).Scan(
                &amp;multipart.BucketName,
                &amp;multipart.ObjectKey,
                &amp;multipart.UploadId,
                &amp;uploadTime,
                &amp;multipart.Metadata.InitiatorId,
                &amp;multipart.Metadata.TenantId,
                &amp;multipart.Metadata.UserId,
                &amp;multipart.Metadata.ContentType,
                &amp;multipart.Metadata.Location,
                &amp;acl,
                &amp;attrs,
                &amp;multipart.ObjectId,
                &amp;multipart.StorageMeta,
                &amp;multipart.Metadata.Tier,
        )
        if err != nil &amp;&amp; err == sql.ErrNoRows </span><span class="cov0" title="0">{
                err = ErrNoSuchUpload
                return
        }</span> else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">ut, err := time.Parse(TIME_LAYOUT_TIDB, uploadTime)
        if err != nil </span><span class="cov0" title="0">{
                err = handleDBError(err)
                return
        }</span>
        <span class="cov0" title="0">multipart.InitialTime = ut

        err = json.Unmarshal([]byte(acl), &amp;multipart.Metadata.Acl)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">err = json.Unmarshal([]byte(attrs), &amp;multipart.Metadata.Attrs)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">sqltext = "select partnumber,size,objectid,offset,etag,lastmodified from objectparts " +
                "where bucketname=? and objectname=? and uploadid=?;"
        rows, err := t.Client.Query(sqltext, bucketName, objectName, uploadId)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        multipart.Parts = make(map[int]*Part)
        for rows.Next() </span><span class="cov0" title="0">{
                p := &amp;Part{}
                err = rows.Scan(
                        &amp;p.PartNumber,
                        &amp;p.Size,
                        &amp;p.ObjectId,
                        &amp;p.Offset,
                        &amp;p.Etag,
                        &amp;p.LastModified,
                )
                ts, e := time.Parse(TIME_LAYOUT_TIDB, p.LastModified)
                if e != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">p.LastModified = ts.Format(CREATE_TIME_LAYOUT)
                multipart.Parts[p.PartNumber] = p
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
        }

        <span class="cov0" title="0">return</span>
}

func (t *TidbClient) DeleteMultipart(multipart *Multipart, tx interface{}) (err error) <span class="cov0" title="0">{
        var sqlTx *sql.Tx
        if tx == nil </span><span class="cov0" title="0">{
                tx, err = t.Client.Begin()
                defer func() </span><span class="cov0" title="0">{
                        if err == nil </span><span class="cov0" title="0">{
                                err = sqlTx.Commit()
                        }</span>
                        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                                sqlTx.Rollback()
                        }</span>
                }()
        }
        <span class="cov0" title="0">sqlTx, _ = tx.(*sql.Tx)

        sqltext := "delete from multiparts where bucketname=? and objectname=? and uploadid=?;"
        _, err = sqlTx.Exec(sqltext, multipart.BucketName, multipart.ObjectKey, multipart.UploadId)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">sqltext = "delete from objectparts where bucketname=? and objectname=? and uploadid=?;"
        _, err = sqlTx.Exec(sqltext, multipart.BucketName, multipart.ObjectKey, multipart.UploadId)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">return</span>
}

func (t *TidbClient) ListMultipartUploads(input *pb.ListBucketUploadRequest) (output *pb.ListBucketUploadResult, err error) <span class="cov0" title="0">{
        var count int
        var exit bool
        bucketName := input.BucketName
        keyMarker := input.KeyMarker
        uploadIdMarker := input.UploadIdMarker
        prefix := input.Prefix
        delimiter := input.Delimiter
        maxUploads := int(input.MaxUploads)

        output = &amp;pb.ListBucketUploadResult{}

        log.Infof("bucketName:%v, keyMarker:%v, uploadIdMarker:%v,prefix:%v,delimiter:%v,maxUploads:%v",
                bucketName, keyMarker, uploadIdMarker, prefix, delimiter, maxUploads)

        commonPrefixes := make(map[string]struct{})
        objectMap := make(map[string]struct{})
        uploadIdMap := make(map[string]struct{})
        currentMarker := keyMarker
        currentUploadIdMarker := uploadIdMarker
        for !exit </span><span class="cov0" title="0">{
                var loopnum int
                var sqltext string
                var rows *sql.Rows
                args := make([]interface{}, 0)
                sqltext = "select objectname,uploadid,uploadtime,initiatorid,tenantid,userid from multiparts where bucketName=?"
                args = append(args, bucketName)
                if prefix != "" </span><span class="cov0" title="0">{
                        sqltext += " and objectname like ?"
                        args = append(args, prefix+"%")
                        log.Infof("query prefix: %s", prefix)
                }</span>
                <span class="cov0" title="0">if currentMarker != "" </span><span class="cov0" title="0">{
                        sqltext += " and objectname &gt;= ?"
                        args = append(args, currentMarker)
                        log.Infof("query object name marker: %s", currentMarker)
                }</span>
                <span class="cov0" title="0">if uploadIdMarker != "" </span><span class="cov0" title="0">{
                        sqltext += " and uploadid &gt;= ?"
                        args = append(args, uploadIdMarker)
                        log.Infof("query uplaodid marker: %s", uploadIdMarker)
                }</span>
                <span class="cov0" title="0">if delimiter == "" </span><span class="cov0" title="0">{
                        sqltext += " order by bucketname,objectname,uploadid limit ?"
                        args = append(args, maxUploads)
                }</span> else<span class="cov0" title="0"> {
                        num := len(strings.Split(prefix, delimiter))
                        args = append(args, delimiter, num, maxUploads)
                        sqltext += " group by SUBSTRING_INDEX(name, ?, ?) order by bucketname,objectname,uploadid limit ?"
                }</span>
                <span class="cov0" title="0">rows, err = t.Client.Query(sqltext, args...)
                if err != nil </span><span class="cov0" title="0">{
                        err = handleDBError(err)
                        return
                }</span>
                <span class="cov0" title="0">defer rows.Close()
                for rows.Next() </span><span class="cov0" title="0">{
                        // loopnum is used to calculate the total number of the query result
                        loopnum += 1
                        var objName, uploadId, initiatorId, tenantId, uploadTime, userId string
                        err = rows.Scan(
                                &amp;objName,
                                &amp;uploadId,
                                &amp;uploadTime,
                                &amp;initiatorId,
                                &amp;tenantId,
                                &amp;userId,
                        )
                        if err != nil </span><span class="cov0" title="0">{
                                err = handleDBError(err)
                                log.Errorln("sql err:", err)
                                return
                        }</span>
                        <span class="cov0" title="0">log.Infoln("objectName:", objName, " uploadId:", uploadId)
                        // if update marker for next query
                        currentMarker = objName
                        currentUploadIdMarker = uploadId

                        // if the object name and upload id have not been processed, we use objectMap and uploadIdMap to flag them
                        var objExist, uploadIdExist bool
                        if _, objExist := objectMap[objName]; !objExist </span><span class="cov0" title="0">{
                                objectMap[objName] = struct{}{}
                        }</span>
                        <span class="cov0" title="0">if _, uploadIdExist := uploadIdMap[uploadId]; !uploadIdExist </span><span class="cov0" title="0">{
                                uploadIdMap[uploadId] = struct{}{}
                        }</span>
                        // if the same record row is processed before, we should skip to next row
                        <span class="cov0" title="0">if objExist &amp;&amp; uploadIdExist </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">if currentMarker == keyMarker &amp;&amp; currentUploadIdMarker == uploadIdMarker </span><span class="cov0" title="0">{
                                // because we search result from maker and the result should not include origin marker from client.
                                continue</span>
                        }

                        // filter by delimiter
                        <span class="cov0" title="0">if len(delimiter) != 0 </span><span class="cov0" title="0">{
                                subStr := strings.TrimPrefix(objName, prefix)
                                n := strings.Index(subStr, delimiter)
                                if n != -1 </span><span class="cov0" title="0">{
                                        prefixKey := prefix + string([]byte(subStr)[0:(n+1)])
                                        // the example is from https://docs.aws.amazon.com/AmazonS3/latest/API/API_ListMultipartUploads.html
                                        // some multipart object key as follows:
                                        // photos/2006/January/sample.jpg
                                        // photos/2006/February/sample.jpg
                                        // photos/2006/March/sample.jpg
                                        // videos/2006/March/sample.wmv
                                        // sample.jpg
                                        // we get "photos" as prefix, and "photos0" as marker for next query. The value of character '0' is
                                        // next to the value of "/", and next query we should use it as marker
                                        currentMarker = prefixKey[0:(len(prefixKey)-1)] + string(delimiter[len(delimiter)-1]+1)
                                        if prefixKey == keyMarker </span><span class="cov0" title="0">{
                                                // because we search result from maker and the result should not include origin marker from client.
                                                continue</span>
                                        }
                                        <span class="cov0" title="0">if _, ok := commonPrefixes[prefixKey]; !ok </span><span class="cov0" title="0">{
                                                if count == maxUploads </span><span class="cov0" title="0">{
                                                        output.IsTruncated = true
                                                        exit = true
                                                        break</span>
                                                }
                                                <span class="cov0" title="0">commonPrefixes[prefixKey] = struct{}{}
                                                output.NextKeyMarker = objName
                                                output.NextUploadIdMarker = uploadId
                                                count += 1</span>
                                        }
                                        <span class="cov0" title="0">continue</span>
                                }
                        }
                        // now start to get out multipart upload records, and update nextmarker if necessary
                        <span class="cov0" title="0">count += 1
                        if count == maxUploads </span><span class="cov0" title="0">{
                                output.NextKeyMarker = objName
                                output.NextUploadIdMarker = uploadId
                        }</span>
                        // if count are more than maxUploads, it means that we should exit the loop and set IsTruncated true
                        <span class="cov0" title="0">if count &gt; maxUploads </span><span class="cov0" title="0">{
                                output.IsTruncated = true
                                exit = true
                                break</span>
                        }

                        <span class="cov0" title="0">var ct time.Time
                        ct, err = time.Parse(TIME_LAYOUT_TIDB, uploadTime)
                        if err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov0" title="0">output.Uploads = append(output.Uploads, &amp;pb.Upload{
                                Key:      objName,
                                UploadId: uploadId,
                                Initiator: &amp;pb.Owner{
                                        Id:          tenantId,
                                        DisplayName: tenantId,
                                },
                                Owner: &amp;pb.Owner{
                                        Id:          initiatorId,
                                        DisplayName: initiatorId,
                                },
                                Initiated:    ct.Format(CREATE_TIME_LAYOUT),
                                StorageClass: "STANDARD",
                        })</span>
                }

                // if the number of query result are less maxUploads, it must be no more result, and we can exit the loop
                <span class="cov0" title="0">if loopnum &lt; maxUploads </span><span class="cov0" title="0">{
                        exit = true
                }</span>
        }
        <span class="cov0" title="0">output.CommonPrefix = helper.Keys(commonPrefixes)
        return</span>
}

func (t *TidbClient) PutObjectPart(multipart *Multipart, part *Part, tx interface{}) (err error) <span class="cov0" title="0">{
        var sqlTx *sql.Tx
        if tx == nil </span><span class="cov0" title="0">{
                tx, err = t.Client.Begin()
                defer func() </span><span class="cov0" title="0">{
                        if err == nil </span><span class="cov0" title="0">{
                                err = sqlTx.Commit()
                        }</span>
                        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                                sqlTx.Rollback()
                        }</span>
                }()
        }
        <span class="cov0" title="0">sqlTx, _ = tx.(*sql.Tx)

        lastt, err := time.Parse(CREATE_TIME_LAYOUT, part.LastModified)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">lastModified := lastt.Format(TIME_LAYOUT_TIDB)
        sqltext := "insert into objectparts(bucketname,objectname,uploadid,partnumber,size,objectid,offset,etag,lastmodified) " +
                "values(?,?,?,?,?,?,?,?,?)"
        _, err = sqlTx.Exec(sqltext, multipart.BucketName, multipart.ObjectKey, multipart.UploadId, part.PartNumber, part.Size,
                part.ObjectId, part.Offset, part.Etag, lastModified)
        return</span>
}
</pre>
		
		<pre class="file" id="file136" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package tidbclient

import (
        "context"
        "database/sql"
        "encoding/hex"
        "encoding/json"
        "math"
        "strconv"
        "time"

        . "github.com/soda/multi-cloud/s3/pkg/meta/types"
        pb "github.com/soda/multi-cloud/s3/proto"
        log "github.com/sirupsen/logrus"
        "github.com/xxtea/xxtea-go/xxtea"
)

func (t *TidbClient) GetObject(ctx context.Context, bucketName, objectName, version string) (object *Object, err error) <span class="cov8" title="1">{
        var sqltext, ibucketname, iname, customattributes, acl, lastModified string
        var iversion uint64
        var row *sql.Row
        if version == "" </span><span class="cov8" title="1">{
                sqltext = "select bucketname,name,version,location,tenantid,userid,size,objectid,lastmodifiedtime,etag," +
                        "contenttype,customattributes,acl,nullversion,deletemarker,ssetype,encryptionkey,initializationvector,type,tier,storageMeta,encsize" +
                        " from objects where bucketname=? and name=? order by bucketname,name,version limit 1;"
                row = t.Client.QueryRow(sqltext, bucketName, objectName)
        }</span> else<span class="cov8" title="1"> {
                sqltext = "select bucketname,name,version,location,tenantid,userid,size,objectid,lastmodifiedtime,etag," +
                        "contenttype,customattributes,acl,nullversion,deletemarker,ssetype,encryptionkey,initializationvector,type,tier,storageMeta,encsize" +
                        " from objects where bucketname=? and name=? and version=?;"
                row = t.Client.QueryRow(sqltext, bucketName, objectName, version)
        }</span>
        <span class="cov8" title="1">log.Infof("sqltext:%s, bucketName=%s, objectName=%s, version:%s\n", sqltext, bucketName, objectName, version)
        object = &amp;Object{Object: &amp;pb.Object{ServerSideEncryption: &amp;pb.ServerSideEncryption{}}}
        err = row.Scan(
                &amp;ibucketname,
                &amp;iname,
                &amp;iversion,
                &amp;object.Location,
                &amp;object.TenantId,
                &amp;object.UserId,
                &amp;object.Size,
                &amp;object.ObjectId,
                &amp;lastModified,
                &amp;object.Etag,
                &amp;object.ContentType,
                &amp;customattributes,
                &amp;acl,
                &amp;object.NullVersion,
                &amp;object.DeleteMarker,
                &amp;object.ServerSideEncryption.SseType,
                &amp;object.ServerSideEncryption.EncryptionKey,
                &amp;object.ServerSideEncryption.InitilizationVector,
                &amp;object.Type,
                &amp;object.Tier,
                &amp;object.StorageMeta,
                &amp;object.EncSize,
        )
        if err != nil </span><span class="cov8" title="1">{
                log.Errorf("err: %v\n", err)
                err = handleDBError(err)
                return
        }</span>

        <span class="cov8" title="1">object.ObjectKey = objectName
        object.BucketName = bucketName
        lastModifiedTime, _ := time.ParseInLocation(TIME_LAYOUT_TIDB, lastModified, time.Local)
        object.LastModified = lastModifiedTime.Unix()

        err = json.Unmarshal([]byte(acl), &amp;object.Acl)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">err = json.Unmarshal([]byte(customattributes), &amp;object.CustomAttributes)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        // TODO: getting multi-parts
        <span class="cov8" title="1">timestamp := math.MaxUint64 - iversion
        timeData := []byte(strconv.FormatUint(timestamp, 10))
        object.VersionId = hex.EncodeToString(xxtea.Encrypt(timeData, XXTEA_KEY))
        return</span>
}

func (t *TidbClient) UpdateObjectMeta(object *Object) error <span class="cov0" title="0">{
        sql, args := object.GetUpdateMetaSql()
        _, err := t.Client.Exec(sql, args...)
        return err
}</span>

func (t *TidbClient) PutObject(ctx context.Context, object *Object, tx interface{}) (err error) <span class="cov8" title="1">{
        var sqlTx *sql.Tx
        if tx == nil </span><span class="cov0" title="0">{
                tx, err = t.Client.Begin()
                defer func() </span><span class="cov0" title="0">{
                        if err == nil </span><span class="cov0" title="0">{
                                err = sqlTx.Commit()
                        }</span>
                        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                                sqlTx.Rollback()
                        }</span>
                }()
        }
        <span class="cov8" title="1">sqlTx, _ = tx.(*sql.Tx)
        sql, args := object.GetCreateSql()
        _, err = sqlTx.Exec(sql, args...)
        // TODO: multi-part handle, see issue https://github.com/soda/multi-cloud/issues/690

        return err</span>
}

func (t *TidbClient) DeleteObject(ctx context.Context, object *Object, tx interface{}) (err error) <span class="cov0" title="0">{
        var sqlTx *sql.Tx
        if tx == nil </span><span class="cov0" title="0">{
                tx, err = t.Client.Begin()
                defer func() </span><span class="cov0" title="0">{
                        if err == nil </span><span class="cov0" title="0">{
                                err = sqlTx.Commit()
                        }</span>
                        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                                sqlTx.Rollback()
                        }</span>
                }()
        }
        <span class="cov0" title="0">sqlTx, _ = tx.(*sql.Tx)

        version := VersionStr2UInt64(object.VersionId)
        log.Infof("delete from objects where name=%s and bucketname=%s and version=%d;\n",
                object.ObjectKey, object.BucketName, version)

        sqltext := "delete from objects where name=? and bucketname=? and version=?;"
        _, err = sqlTx.Exec(sqltext, object.ObjectKey, object.BucketName, version)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (t *TidbClient) SetObjectDeleteMarker(ctx context.Context, object *Object, deleteMarker bool) error <span class="cov0" title="0">{
        version := VersionStr2UInt64(object.VersionId)

        sqltext := "update objects set deletemarker=? where bucketname=? and name=? and version=?;"
        _, err := t.Client.Exec(sqltext, deleteMarker, object.BucketName, object.ObjectKey, version)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (t *TidbClient) UpdateObject4Lifecycle(ctx context.Context, old, new *Object, tx interface{}) (err error) <span class="cov0" title="0">{
        var sqlTx *sql.Tx
        if tx == nil </span><span class="cov0" title="0">{
                tx, err = t.Client.Begin()
                defer func() </span><span class="cov0" title="0">{
                        if err == nil </span><span class="cov0" title="0">{
                                err = sqlTx.Commit()
                        }</span>
                        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                                sqlTx.Rollback()
                        }</span>
                }()
        }
        <span class="cov0" title="0">sqlTx, _ = tx.(*sql.Tx)

        oldversion := VersionStr2UInt64(old.VersionId)

        sqltext := "update objects set location=?,objectid=?,tier=?,storageMeta=? where bucketname=? and name=? and version=?"
        args := []interface{}{new.Location, new.ObjectId, new.Tier, new.StorageMeta, old.BucketName, old.ObjectKey, oldversion}

        log.Debugf("sqltext:%s, args:%+v\n", sqltext, args)
        _, err = sqlTx.Exec(sqltext, args...)

        log.Debugf("err:%v\n", err)
        return err</span>
}
</pre>
		
		<pre class="file" id="file137" style="display: none">package tidbclient

import (
        "database/sql"
        . "github.com/soda/multi-cloud/s3/pkg/meta/types"
        "strconv"
)

//objmap
func (t *TidbClient) GetObjectMap(bucketName, objectName string) (objMap *ObjMap, err error) <span class="cov0" title="0">{
        objMap = &amp;ObjMap{}
        sqltext := "select bucketname,objectname,nullvernum from objmap where bucketname=? and objectName=?;"
        err = t.Client.QueryRow(sqltext, bucketName, objectName).Scan(
                &amp;objMap.BucketName,
                &amp;objMap.Name,
                &amp;objMap.NullVerNum,
        )
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">objMap.NullVerId = strconv.FormatUint(objMap.NullVerNum, 10)
        return</span>
}

func (t *TidbClient) PutObjectMap(objMap *ObjMap, tx interface{}) (err error) <span class="cov0" title="0">{
        var sqlTx *sql.Tx
        if tx == nil </span><span class="cov0" title="0">{
                tx, err = t.Client.Begin()
                defer func() </span><span class="cov0" title="0">{
                        if err == nil </span><span class="cov0" title="0">{
                                err = sqlTx.Commit()
                        }</span>
                        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                                sqlTx.Rollback()
                        }</span>
                }()
        }
        <span class="cov0" title="0">sqlTx, _ = tx.(*sql.Tx)

        sqltext := "insert into objmap(bucketname,objectname,nullvernum) values(?,?,?);"
        _, err = sqlTx.Exec(sqltext, objMap.BucketName, objMap.Name, objMap.NullVerNum)
        return err</span>
}

func (t *TidbClient) DeleteObjectMap(objMap *ObjMap, tx interface{}) (err error) <span class="cov0" title="0">{
        var sqlTx *sql.Tx
        if tx == nil </span><span class="cov0" title="0">{
                tx, err = t.Client.Begin()
                defer func() </span><span class="cov0" title="0">{
                        if err == nil </span><span class="cov0" title="0">{
                                err = sqlTx.Commit()
                        }</span>
                        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                                sqlTx.Rollback()
                        }</span>
                }()
        }
        <span class="cov0" title="0">sqlTx, _ = tx.(*sql.Tx)
        sqltext := "delete from objmap where bucketname=? and objectname=?;"
        _, err = sqlTx.Exec(sqltext, objMap.BucketName, objMap.Name)
        return err</span>
}
</pre>
		
		<pre class="file" id="file138" style="display: none">package tidbclient

import "database/sql"

func (t *TidbClient) NewTrans()(tx interface{}, err error) <span class="cov8" title="1">{
        tx, err = t.Client.Begin()
        return
}</span>

func (t *TidbClient) AbortTrans(tx interface{}) (err error) <span class="cov0" title="0">{
        err = tx.(* sql.Tx).Rollback()
        return
}</span>

func (t *TidbClient) CommitTrans(tx interface{}) (err error) <span class="cov8" title="1">{
        err = tx.(* sql.Tx).Commit()
        return
}</pre>
		
		<pre class="file" id="file139" style="display: none">package meta

import (
        "context"
        "github.com/soda/multi-cloud/s3/pkg/meta/types"
)

func (m *Meta) AddGcobjRecord(ctx context.Context, obj *types.Object) error <span class="cov0" title="0">{
        return m.Db.PutGcobjRecord(ctx, obj, nil)
}</span>

func (m *Meta) DeleteGcobjRecord(ctx context.Context, obj *types.Object) error <span class="cov0" title="0">{
        return m.Db.DeleteGcobjRecord(ctx, obj, nil)
}</span>

func (m *Meta) ListGcObjs(ctx context.Context, offset, limit int) ([]*types.Object, error) <span class="cov8" title="1">{
        return m.Db.ListGcObjs(ctx, offset, limit)
}</span>
</pre>
		
		<pre class="file" id="file140" style="display: none">package meta

import (
        "github.com/soda/multi-cloud/s3/pkg/datastore/yig/log"
        "github.com/soda/multi-cloud/s3/pkg/meta/db"
        "github.com/soda/multi-cloud/s3/pkg/meta/db/drivers/tidb"
)

const (
        ENCRYPTION_KEY_LENGTH = 32 // 32 bytes for AES-"256"
)

type MetaConfig struct {
        CacheType     CacheType
        TidbInfo      string
}

type Meta struct {
        Db db.DBAdapter
        Logger *log.Logger
        Cache  MetaCache
}

func (m *Meta) Stop() <span class="cov0" title="0">{
        if m.Cache != nil </span><span class="cov0" title="0">{
                m.Cache.Close()
        }</span>
}

func New(cfg MetaConfig) *Meta <span class="cov8" title="1">{
        meta := Meta{
                Cache:  newMetaCache(cfg.CacheType),
        }
        meta.Db = tidbclient.NewTidbClient(cfg.TidbInfo)
        return &amp;meta
}</span>
</pre>
		
		<pre class="file" id="file141" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package meta

import (
        "context"

        . "github.com/soda/multi-cloud/s3/pkg/meta/types"
)

func (m *Meta) GetMultipart(bucketName, objectName, uploadId string) (Multipart, error) <span class="cov0" title="0">{
        return m.Db.GetMultipart(bucketName, objectName, uploadId)
}</span>

func (m *Meta) DeleteMultipart(ctx context.Context, multipart Multipart) (err error) <span class="cov0" title="0">{
        tx, err := m.Db.NewTrans()
        defer func() </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        m.Db.AbortTrans(tx)
                }</span>
        }()
        <span class="cov0" title="0">err = m.Db.DeleteMultipart(&amp;multipart, tx)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        // TODO: usage need to be updated for charging, it depends on redis, and the mechanism is:
        // 1. Update usage in redis when each delete happens.
        // 2. Update usage in database periodically based on redis.
        // see https://github.com/soda/multi-cloud/issues/698 for redis related issue.

        <span class="cov0" title="0">err = m.Db.CommitTrans(tx)
        return</span>
}

func (m *Meta) PutObjectPart(ctx context.Context, multipart Multipart, part Part) (err error) <span class="cov0" title="0">{
        tx, err := m.Db.NewTrans()
        defer func() </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        m.Db.AbortTrans(tx)
                }</span>
        }()
        <span class="cov0" title="0">err = m.Db.PutObjectPart(&amp;multipart, &amp;part, tx)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        //TODO: update bucket size
        <span class="cov0" title="0">err = m.Db.CommitTrans(tx)
        return</span>
}
</pre>
		
		<pre class="file" id="file142" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package meta

import (
        "context"

        . "github.com/soda/multi-cloud/s3/error"
        "github.com/soda/multi-cloud/s3/pkg/helper"
        "github.com/soda/multi-cloud/s3/pkg/meta/db/drivers/tidb"
        "github.com/soda/multi-cloud/s3/pkg/meta/redis"
        . "github.com/soda/multi-cloud/s3/pkg/meta/types"
        log "github.com/sirupsen/logrus"
        "strconv"
)

const (
        OBJECT_CACHE_PREFIX = "object:"
)

// Object will be updated to cache while willNeed is true
func (m *Meta) GetObject(ctx context.Context, bucketName string, objectName string, versionId string, willNeed bool) (object *Object, err error) <span class="cov8" title="1">{
        getObject := func() (o helper.Serializable, err error) </span><span class="cov8" title="1">{
                log.Info("GetObject CacheMiss. bucket:", bucketName, ", object:", objectName)
                version := ""
                if versionId != "" </span><span class="cov0" title="0">{
                        version = strconv.FormatUint(tidbclient.VersionStr2UInt64(versionId), 10)
                }</span>
                <span class="cov8" title="1">object, err := m.Db.GetObject(ctx, bucketName, objectName, version)
                if err != nil </span><span class="cov8" title="1">{
                        log.Errorln("get object failed, err:", err)
                        return
                }</span>
                <span class="cov8" title="1">log.Infoln("GetObject object.Name:", objectName)
                if object.ObjectKey != objectName </span><span class="cov0" title="0">{
                        err = ErrNoSuchKey
                        return
                }</span>
                <span class="cov8" title="1">return object, nil</span>
        }

        <span class="cov8" title="1">toObject := func(fields map[string]string) (interface{}, error) </span><span class="cov0" title="0">{
                o := &amp;Object{}
                return o.Deserialize(fields)
        }</span>

        <span class="cov8" title="1">o, err := m.Cache.Get(redis.ObjectTable, OBJECT_CACHE_PREFIX, bucketName+":"+objectName+":",
                getObject, toObject, willNeed)
        if err != nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">object, ok := o.(*Object)
        if !ok </span><span class="cov0" title="0">{
                err = ErrInternalError
                return
        }</span>
        <span class="cov8" title="1">return object, nil</span>
}

func (m *Meta) PutObject(ctx context.Context, object, deleteObj *Object, multipart *Multipart, objMap *ObjMap, updateUsage bool) error <span class="cov8" title="1">{
        log.Debugf("PutObject begin, object=%+v, deleteObj:%+v\n", object, deleteObj)
        tx, err := m.Db.NewTrans()
        defer func() </span><span class="cov8" title="1">{
                if err != nil </span><span class="cov0" title="0">{
                        m.Db.AbortTrans(tx)
                }</span>
        }()

        // if target object exist and it's location is different from new location, need to clean it
        <span class="cov8" title="1">if deleteObj != nil </span><span class="cov0" title="0">{
                if deleteObj.Location != object.Location </span><span class="cov0" title="0">{
                        log.Infoln("put gc, deleteObj:", deleteObj)
                        err = m.Db.PutGcobjRecord(ctx, deleteObj, tx)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

                <span class="cov0" title="0">log.Infoln("delete object metadata, deleteObj:", deleteObj)
                err = m.Db.DeleteObject(ctx, deleteObj, tx)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">err = m.Db.PutObject(ctx, object, tx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if multipart != nil </span><span class="cov0" title="0">{
                err = m.Db.DeleteMultipart(multipart, tx)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // TODO: usage need to be updated for charging, and it depends on redis, and the mechanism is:
        // 1. Update usage in redis when each put happens.
        // 2. Update usage in database periodically based on redis.
        // see https://github.com/soda/multi-cloud/issues/698 for redis related issue.

        <span class="cov8" title="1">err = m.Db.CommitTrans(tx)
        return nil</span>
}

func (m *Meta) UpdateObjectMeta(object *Object) error <span class="cov0" title="0">{
        err := m.Db.UpdateObjectMeta(object)
        return err
}</span>

func (m *Meta) DeleteObject(ctx context.Context, object *Object) error <span class="cov0" title="0">{
        tx, err := m.Db.NewTrans()
        defer func() </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        m.Db.AbortTrans(tx)
                }</span>
        }()

        <span class="cov0" title="0">err = m.Db.DeleteObject(ctx, object, tx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // TODO: usage need to be updated for charging, it depends on redis, and the mechanism is:
        // 1. Update usage in redis when each delete happens.
        // 2. Update usage in database periodically based on redis.
        // see https://github.com/soda/multi-cloud/issues/698 for redis related issue.

        <span class="cov0" title="0">err = m.Db.CommitTrans(tx)

        return err</span>
}

func (m *Meta) MarkObjectAsDeleted(ctx context.Context, object *Object) error <span class="cov0" title="0">{
        return m.Db.SetObjectDeleteMarker(ctx, object, true)
}</span>

func (m *Meta) UpdateObject4Lifecycle(ctx context.Context, old, new *Object, multipart *Multipart) (err error) <span class="cov0" title="0">{
        log.Infof("update object from %v to %v\n", *old, *new)
        tx, err := m.Db.NewTrans()
        defer func() </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        m.Db.AbortTrans(tx)
                }</span>
        }()

        <span class="cov0" title="0">err = m.Db.UpdateObject4Lifecycle(ctx, old, new, tx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if multipart != nil </span><span class="cov0" title="0">{
                err = m.Db.DeleteMultipart(multipart, tx)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">err = m.Db.CommitTrans(tx)
        return err</span>
}
</pre>
		
		<pre class="file" id="file143" style="display: none">package redis

import (
        "strconv"

        log "github.com/sirupsen/logrus"
        "github.com/soda/multi-cloud/s3/pkg/datastore/yig/config"
        "github.com/soda/multi-cloud/s3/pkg/helper"
)

var (
        redisClient *RedisCli
)

const InvalidQueueName = "InvalidQueue"

const keyvalue = "000102030405060708090A0B0C0D0E0FF0E0D0C0B0A090807060504030201000" // This is the key for hash sum !

type RedisDatabase int

func (r RedisDatabase) String() string <span class="cov0" title="0">{
        return strconv.Itoa(int(r))
}</span>

func (r RedisDatabase) InvalidQueue() string <span class="cov0" title="0">{
        return InvalidQueueName + r.String()
}</span>

const (
        UserTable RedisDatabase = iota
        BucketTable
        ObjectTable
        FileTable
        ClusterTable
)

var MetadataTables = []RedisDatabase{UserTable, BucketTable, ObjectTable, ClusterTable}
var DataTables = []RedisDatabase{FileTable}

func Initialize(cfg *config.CacheConfig) <span class="cov0" title="0">{
        redisClient = NewRedisCli()
        redisClient.Init(cfg)
}</span>

func Close() <span class="cov0" title="0">{
        if redisClient != nil &amp;&amp; redisClient.IsValid() </span><span class="cov0" title="0">{
                err := redisClient.Close()
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("Cannot close redis pool, err: %v", err)
                }</span>
        }
}

func GetClient() (*RedisCli, error) <span class="cov0" title="0">{
        return redisClient, nil
}</span>

func HasRedisClient() bool <span class="cov0" title="0">{
        if redisClient != nil &amp;&amp; redisClient.IsValid() </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">return false</span>
}

func Remove(table RedisDatabase, prefix, key string) (err error) <span class="cov0" title="0">{
        c, err := GetClient()
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to get redis client, err: %v", err)
                return err
        }</span>

        // Use table.String() + hashkey as Redis key
        <span class="cov0" title="0">_, err = c.Del(table.String() + prefix + helper.EscapeColon(key))
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to call redis del for (%s), err: %v", table.String()+prefix+helper.EscapeColon(key), err)
                return err
        }</span>

        <span class="cov0" title="0">log.Infof("Cmd: %s. Key: %s.", "DEL", table.String()+key)
        return nil</span>
}

func Set(table RedisDatabase, prefix, key string, value interface{}) (err error) <span class="cov0" title="0">{
        c, err := GetClient()
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to get redis client, err: %v", err)
                return err
        }</span>
        <span class="cov0" title="0">encodedValue, err := helper.MsgPackMarshal(value)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to make pack for(%s, %s, %v), err: %v", prefix, key, value, err)
                return err
        }</span>

        // Use table.String() + hashkey as Redis key. Set expire time to 30s.
        <span class="cov0" title="0">r, err := c.Set(table.String()+prefix+helper.EscapeColon(key), encodedValue, 30000)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to call redis Set(%s, %v), err: %v", table.String()+prefix+helper.EscapeColon(key), string(encodedValue), err)
                return err
        }</span>
        <span class="cov0" title="0">log.Infof("Cmd: %s. Key: %s. Value: %s. Reply: %s.", "SET", table.String()+key, string(encodedValue), r)
        return nil</span>
}

func Get(table RedisDatabase, prefix, key string) (value interface{}, err error) <span class="cov0" title="0">{
        var encodedValue []byte
        c, err := GetClient()
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to get redis client, err: %v", err)
                return nil, err
        }</span>

        // Use table.String() + hashkey as Redis key
        <span class="cov0" title="0">encodedValue, err = c.Get(table.String() + prefix + helper.EscapeColon(key))
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to call redis Get(%s), err: %v", table.String()+prefix+helper.EscapeColon(key), err)
                return nil, err
        }</span>
        <span class="cov0" title="0">if len(encodedValue) == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">err = helper.MsgPackUnMarshal(encodedValue, value)
        return value, err</span>
}

// don't use the escapecolon in keys command.
func Keys(table RedisDatabase, pattern string) ([]string, error) <span class="cov0" title="0">{
        var keys []string
        query := table.String() + pattern
        c, err := GetClient()
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to get redis client, err: %v", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">keys, err = c.Keys(query)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to call redis Keys(%s), err: %s", query, err)
                return nil, err
        }</span>

        <span class="cov0" title="0">return keys, nil</span>

}

func MGet(table RedisDatabase, prefix string, keys []string) ([]interface{}, error) <span class="cov0" title="0">{
        var results []interface{}
        var queryKeys []string
        for _, key := range keys </span><span class="cov0" title="0">{
                queryKeys = append(queryKeys, table.String()+prefix+helper.EscapeColon(key))
        }</span>
        <span class="cov0" title="0">c, err := GetClient()
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to get redis client, err: %v", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">results, err = c.MGet(queryKeys)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to call redis MGet(%v), err: %v", queryKeys, err)
                return nil, err
        }</span>
        <span class="cov0" title="0">return results, nil</span>
}

func MSet(table RedisDatabase, prefix string, pairs map[string]interface{}) (string, error) <span class="cov0" title="0">{
        var result string
        tmpPairs := make(map[interface{}]interface{})
        for k, v := range pairs </span><span class="cov0" title="0">{
                tmpPairs[table.String()+prefix+helper.EscapeColon(k)] = v
        }</span>

        <span class="cov0" title="0">c, err := GetClient()
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to get redis client, err: %v", err)
                return "", err
        }</span>

        <span class="cov0" title="0">result, err = c.MSet(tmpPairs)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to call redis MSet(%s, %v), err: %v", prefix, pairs, err)
                return "", err
        }</span>

        <span class="cov0" title="0">return result, nil</span>

}

func IncrBy(table RedisDatabase, prefix, key string, value int64) (int64, error) <span class="cov0" title="0">{
        var result int64
        c, err := GetClient()
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to get redis client, err: %v", err)
                return 0, err
        }</span>

        <span class="cov0" title="0">result, err = c.IncrBy(prefix+helper.EscapeColon(key), value)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to call redis IncrBy(%s, %d), err: %v", prefix+helper.EscapeColon(key), value, err)
                return 0, err
        }</span>
        <span class="cov0" title="0">return result, nil</span>
}

// Get file bytes
// `start` and `end` are inclusive
// FIXME: this API causes an extra memory copy, need to patch radix to fix it
func GetBytes(key string, start int64, end int64) ([]byte, error) <span class="cov0" title="0">{
        var value []byte
        c, err := GetClient()
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to get redis client, err: %v", err)
                return nil, err
        }</span>

        // Use table.String() + hashkey as Redis key
        <span class="cov0" title="0">value, err = c.GetRange(FileTable.String()+helper.EscapeColon(key), start, end)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to call redis GetRange(%s, %d, %d), err: %v", FileTable.String()+helper.EscapeColon(key), start, end, err)
                return nil, err
        }</span>
        <span class="cov0" title="0">return value, nil</span>
}

// Set file bytes
func SetBytes(key string, value []byte) (err error) <span class="cov0" title="0">{
        c, err := GetClient()
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to get redis client, err: %v", err)
                return err
        }</span>

        // Use table.String() + hashkey as Redis key
        <span class="cov0" title="0">_, err = c.Set(FileTable.String()+helper.EscapeColon(key), value, 0)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to call redis set(%s), err: %d", FileTable.String()+helper.EscapeColon(key), err)
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func HSet(table RedisDatabase, prefix, key, field string, value interface{}) (bool, error) <span class="cov0" title="0">{
        var r bool
        c, err := GetClient()
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to get redis client, err: %v", err)
                return false, err
        }</span>

        <span class="cov0" title="0">r, err = c.HSet(table.String()+prefix+helper.EscapeColon(key), field, value)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to call redis HSet(%s, %s), err: %v", table.String()+prefix+helper.EscapeColon(key), field, err)
                return false, err
        }</span>
        <span class="cov0" title="0">return r, nil</span>
}

func HGet(table RedisDatabase, prefix, key, field string) (string, error) <span class="cov0" title="0">{
        var r string
        c, err := GetClient()
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to get redis client, err: %v", err)
                return "", err
        }</span>

        <span class="cov0" title="0">r, err = c.HGet(table.String()+prefix+helper.EscapeColon(key), field)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to call redis HGet(%s, %s), err: %v", table.String()+prefix+helper.EscapeColon(key), field)
                return "", err
        }</span>
        <span class="cov0" title="0">return r, nil</span>
}

func HDel(table RedisDatabase, prefix, key string, fields []string) (int64, error) <span class="cov0" title="0">{
        var r int64
        c, err := GetClient()
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to get redis client, err: %v", err)
                return 0, err
        }</span>

        <span class="cov0" title="0">r, err = c.HDel(table.String()+prefix+helper.EscapeColon(key), fields)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to call redis HDel(%s, %v), err: %v", table.String()+prefix+helper.EscapeColon(key), fields, err)
                return 0, err
        }</span>
        <span class="cov0" title="0">return r, nil</span>
}

func HGetInt64(table RedisDatabase, prefix, key, field string) (int64, error) <span class="cov0" title="0">{
        var r int64
        c, err := GetClient()
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to get redis client, err: %v", err)
                return 0, err
        }</span>

        <span class="cov0" title="0">theKey := table.String() + prefix + helper.EscapeColon(key)
        r, err = c.HGetInt64(theKey, field)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to call redis HGetInt64(%s, %s), err: %v", theKey, field, err)
                return 0, err
        }</span>
        <span class="cov0" title="0">return r, nil</span>
}

func HGetAll(table RedisDatabase, prefix, key string) (map[string]string, error) <span class="cov0" title="0">{
        var r map[string]string
        c, err := GetClient()
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to get redis client, err: %v", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">r, err = c.HGetAll(table.String() + prefix + helper.EscapeColon(key))
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to call redis HGetAll(%s), err: %v", table.String()+prefix+helper.EscapeColon(key), err)
                return nil, err
        }</span>
        <span class="cov0" title="0">return r, nil</span>
}

func HIncrBy(table RedisDatabase, prefix, key, field string, incr int64) (int64, error) <span class="cov0" title="0">{
        var r int64
        c, err := GetClient()
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to get redis client, err: %v", err)
                return 0, err
        }</span>

        <span class="cov0" title="0">r, err = c.HIncrBy(table.String()+prefix+helper.EscapeColon(key), field, incr)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to call redis HIncrBy(%s, %s, %d), err: %v", table.String()+prefix+helper.EscapeColon(key), field, incr)
                return 0, err
        }</span>
        <span class="cov0" title="0">return r, nil</span>
}

func HMSet(table RedisDatabase, prefix, key string, fields map[string]interface{}) (string, error) <span class="cov0" title="0">{
        var r string
        c, err := GetClient()
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to get redis client, err: %v", err)
                return "", err
        }</span>

        <span class="cov0" title="0">r, err = c.HMSet(table.String()+prefix+helper.EscapeColon(key), fields)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to call redis HMSet(%s, %v), err: %v", table.String()+prefix+helper.EscapeColon(key), fields, err)
                return "", err
        }</span>
        <span class="cov0" title="0">return r, nil</span>
}

func HMGet(table RedisDatabase, prefix, key string, fields []string) (map[string]interface{}, error) <span class="cov0" title="0">{
        var r map[string]interface{}
        c, err := GetClient()
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to get redis client, err: %v", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">r, err = c.HMGet(table.String()+prefix+helper.EscapeColon(key), fields)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to call redis HMGet(%s, %v), err: %v", table.String()+prefix+helper.EscapeColon(key), fields, err)
                return nil, err
        }</span>
        <span class="cov0" title="0">return r, nil</span>
}

// Publish the invalid message to other YIG instances through Redis
func Invalid(table RedisDatabase, key string) (err error) <span class="cov0" title="0">{
        c, err := GetClient()
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to get redis client, err: %v", err)
                return err
        }</span>

        // Use table.String() + hashkey as Redis key
        <span class="cov0" title="0">_, err = c.Publish(table.InvalidQueue(), helper.EscapeColon(key))
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to call redis Public(%s), err: %v", helper.EscapeColon(key), err)
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file144" style="display: none">package redis

import (
        "errors"
        "time"

        log "github.com/sirupsen/logrus"
        "github.com/go-redis/redis"
        "github.com/soda/multi-cloud/s3/pkg/datastore/yig/config"
)

const (
        REDIS_UNKNOWN_CLIENT = iota
        REDIS_NORMAL_CLIENT
        REDIS_CLUSTER_CLIENT
        REDIS_SENTINEL_CLIENT
)

const ERR_NOT_INIT_MSG = "redis client is not initialized yet."

type RedisCli struct {
        clientType         int
        redisClient        *redis.Client
        redisClusterClient *redis.ClusterClient
}

func NewRedisCli() *RedisCli <span class="cov0" title="0">{
        return &amp;RedisCli{
                clientType: REDIS_UNKNOWN_CLIENT,
        }
}</span>

func (cli *RedisCli) Init(cfg *config.CacheConfig) <span class="cov0" title="0">{
        switch cfg.Mode </span>{
        case 1:<span class="cov0" title="0">
                options := &amp;redis.ClusterOptions{
                        Addrs:        cfg.Nodes,
                        ReadTimeout:  time.Duration(cfg.ReadTimeout) * time.Second,
                        DialTimeout:  time.Duration(cfg.ConnectionTimeout) * time.Second,
                        WriteTimeout: time.Duration(cfg.WriteTimeout) * time.Second,
                        IdleTimeout:  time.Duration(cfg.KeepAlive) * time.Second,
                }
                if cfg.PoolMaxIdle &gt; 0 </span><span class="cov0" title="0">{
                        options.PoolSize = cfg.PoolMaxIdle
                }</span>
                <span class="cov0" title="0">if cfg.Password != "" </span><span class="cov0" title="0">{
                        options.Password = cfg.Password
                }</span>
                <span class="cov0" title="0">cli.redisClusterClient = redis.NewClusterClient(options)
                cli.clientType = REDIS_CLUSTER_CLIENT</span>
        case 2:<span class="cov0" title="0">
                options := &amp;redis.FailoverOptions{
                        MasterName:    cfg.Master,
                        SentinelAddrs: cfg.Nodes,
                        ReadTimeout:   time.Duration(cfg.ReadTimeout) * time.Second,
                        DialTimeout:   time.Duration(cfg.ConnectionTimeout) * time.Second,
                        WriteTimeout:  time.Duration(cfg.WriteTimeout) * time.Second,
                        IdleTimeout:   time.Duration(cfg.KeepAlive) * time.Second,
                }
                if cfg.PoolMaxIdle &gt; 0 </span><span class="cov0" title="0">{
                        options.PoolSize = cfg.PoolMaxIdle
                }</span>
                <span class="cov0" title="0">if cfg.Password != "" </span><span class="cov0" title="0">{
                        options.Password = cfg.Password
                }</span>
                <span class="cov0" title="0">cli.redisClient = redis.NewFailoverClient(options)
                cli.clientType = REDIS_SENTINEL_CLIENT</span>
        default:<span class="cov0" title="0">
                options := &amp;redis.Options{
                        Addr:         cfg.Address,
                        ReadTimeout:  time.Duration(cfg.ReadTimeout) * time.Second,
                        DialTimeout:  time.Duration(cfg.ConnectionTimeout) * time.Second,
                        WriteTimeout: time.Duration(cfg.WriteTimeout) * time.Second,
                        IdleTimeout:  time.Duration(cfg.KeepAlive) * time.Second,
                }

                if cfg.PoolMaxIdle &gt; 0 </span><span class="cov0" title="0">{
                        options.PoolSize = cfg.PoolMaxIdle
                }</span>

                <span class="cov0" title="0">if cfg.Password != "" </span><span class="cov0" title="0">{
                        options.Password = cfg.Password
                }</span>

                <span class="cov0" title="0">log.Infoln("create redis for options: ", options)
                cli.redisClient = redis.NewClient(options)
                cli.clientType = REDIS_NORMAL_CLIENT</span>
        }
}

func (cli *RedisCli) IsValid() bool <span class="cov0" title="0">{
        return cli.clientType != REDIS_UNKNOWN_CLIENT
}</span>

func (cli *RedisCli) Close() error <span class="cov0" title="0">{
        switch cli.clientType </span>{
        case REDIS_CLUSTER_CLIENT:<span class="cov0" title="0">
                return cli.redisClusterClient.Close()</span>
        case REDIS_NORMAL_CLIENT, REDIS_SENTINEL_CLIENT:<span class="cov0" title="0">
                return cli.redisClient.Close()</span>
        default:<span class="cov0" title="0">
                return nil</span>
        }
}

func (cli *RedisCli) Del(key string) (int64, error) <span class="cov0" title="0">{
        var err error
        var val int64
        switch cli.clientType </span>{
        case REDIS_NORMAL_CLIENT, REDIS_SENTINEL_CLIENT:<span class="cov0" title="0">
                val, err = cli.redisClient.Del(key).Result()</span>
        case REDIS_CLUSTER_CLIENT:<span class="cov0" title="0">
                val, err = cli.redisClusterClient.Del(key).Result()</span>
        default:<span class="cov0" title="0">
                return 0, errors.New(ERR_NOT_INIT_MSG)</span>
        }
        <span class="cov0" title="0">if err == redis.Nil </span><span class="cov0" title="0">{
                return val, nil
        }</span>
        <span class="cov0" title="0">return val, err</span>
}

/*
* @key: input key
* @value: input value
* @expire: expiration for the key in milliseconds.
 */

func (cli *RedisCli) Set(key string, value interface{}, expire int64) (string, error) <span class="cov0" title="0">{
        switch cli.clientType </span>{
        case REDIS_NORMAL_CLIENT, REDIS_SENTINEL_CLIENT:<span class="cov0" title="0">
                return cli.redisClient.Set(key, value, time.Duration(expire)*time.Millisecond).Result()</span>
        case REDIS_CLUSTER_CLIENT:<span class="cov0" title="0">
                return cli.redisClusterClient.Set(key, value, time.Duration(expire)*time.Millisecond).Result()</span>
        default:<span class="cov0" title="0">
                return "", errors.New(ERR_NOT_INIT_MSG)</span>
        }
}

func (cli *RedisCli) Get(key string) (val []byte, err error) <span class="cov0" title="0">{
        switch cli.clientType </span>{
        case REDIS_NORMAL_CLIENT:<span class="cov0" title="0">
                val, err = cli.redisClient.Get(key).Bytes()</span>
        case REDIS_CLUSTER_CLIENT:<span class="cov0" title="0">
                val, err = cli.redisClusterClient.Get(key).Bytes()</span>
        default:<span class="cov0" title="0">
                return nil, errors.New(ERR_NOT_INIT_MSG)</span>
        }

        <span class="cov0" title="0">if err == redis.Nil </span><span class="cov0" title="0">{
                return val, nil
        }</span>
        <span class="cov0" title="0">return val, err</span>
}

func (cli *RedisCli) GetRange(key string, start, end int64) (val []byte, err error) <span class="cov0" title="0">{
        switch cli.clientType </span>{
        case REDIS_NORMAL_CLIENT, REDIS_SENTINEL_CLIENT:<span class="cov0" title="0">
                val, err = cli.redisClient.GetRange(key, start, end).Bytes()</span>
        case REDIS_CLUSTER_CLIENT:<span class="cov0" title="0">
                val, err = cli.redisClusterClient.GetRange(key, start, end).Bytes()</span>
        default:<span class="cov0" title="0">
                return nil, errors.New(ERR_NOT_INIT_MSG)</span>
        }

        <span class="cov0" title="0">if err == redis.Nil </span><span class="cov0" title="0">{
                return val, nil
        }</span>
        <span class="cov0" title="0">return val, err</span>
}

func (cli *RedisCli) Publish(channel string, message interface{}) (int64, error) <span class="cov0" title="0">{
        switch cli.clientType </span>{
        case REDIS_NORMAL_CLIENT, REDIS_SENTINEL_CLIENT:<span class="cov0" title="0">
                return cli.redisClient.Publish(channel, message).Result()</span>
        case REDIS_CLUSTER_CLIENT:<span class="cov0" title="0">
                return cli.redisClusterClient.Publish(channel, message).Result()</span>
        default:<span class="cov0" title="0">
                return 0, errors.New(ERR_NOT_INIT_MSG)</span>
        }
}

func (cli *RedisCli) Ping() (string, error) <span class="cov0" title="0">{
        switch cli.clientType </span>{
        case REDIS_NORMAL_CLIENT, REDIS_SENTINEL_CLIENT:<span class="cov0" title="0">
                return cli.redisClient.Ping().Result()</span>
        case REDIS_CLUSTER_CLIENT:<span class="cov0" title="0">
                return cli.redisClusterClient.Ping().Result()</span>
        default:<span class="cov0" title="0">
                return "", errors.New(ERR_NOT_INIT_MSG)</span>
        }
}

func (cli *RedisCli) Keys(pattern string) ([]string, error) <span class="cov0" title="0">{
        switch cli.clientType </span>{
        case REDIS_NORMAL_CLIENT, REDIS_SENTINEL_CLIENT:<span class="cov0" title="0">
                return cli.redisClient.Keys(pattern).Result()</span>
        case REDIS_CLUSTER_CLIENT:<span class="cov0" title="0">
                return cli.redisClusterClient.Keys(pattern).Result()</span>
        default:<span class="cov0" title="0">
                return nil, errors.New(ERR_NOT_INIT_MSG)</span>
        }
}

func (cli *RedisCli) MGet(keys []string) ([]interface{}, error) <span class="cov0" title="0">{
        switch cli.clientType </span>{
        case REDIS_NORMAL_CLIENT, REDIS_SENTINEL_CLIENT:<span class="cov0" title="0">
                return cli.redisClient.MGet(keys...).Result()</span>
        case REDIS_CLUSTER_CLIENT:<span class="cov0" title="0">
                return cli.redisClusterClient.MGet(keys...).Result()</span>
        default:<span class="cov0" title="0">
                return nil, errors.New(ERR_NOT_INIT_MSG)</span>
        }
}

func (cli *RedisCli) MSet(pairs map[interface{}]interface{}) (string, error) <span class="cov0" title="0">{
        var pairList []interface{}

        for k, v := range pairs </span><span class="cov0" title="0">{
                pairList = append(pairList, k, v)
        }</span>

        <span class="cov0" title="0">switch cli.clientType </span>{
        case REDIS_NORMAL_CLIENT, REDIS_SENTINEL_CLIENT:<span class="cov0" title="0">
                return cli.redisClient.MSet(pairList...).Result()</span>
        case REDIS_CLUSTER_CLIENT:<span class="cov0" title="0">
                return cli.redisClusterClient.MSet(pairList...).Result()</span>
        default:<span class="cov0" title="0">
                return "", errors.New(ERR_NOT_INIT_MSG)</span>
        }
}

func (cli *RedisCli) IncrBy(key string, value int64) (int64, error) <span class="cov0" title="0">{
        switch cli.clientType </span>{
        case REDIS_NORMAL_CLIENT, REDIS_SENTINEL_CLIENT:<span class="cov0" title="0">
                return cli.redisClient.IncrBy(key, value).Result()</span>
        case REDIS_CLUSTER_CLIENT:<span class="cov0" title="0">
                return cli.redisClusterClient.IncrBy(key, value).Result()</span>
        default:<span class="cov0" title="0">
                return 0, errors.New(ERR_NOT_INIT_MSG)</span>
        }
}

func (cli *RedisCli) Expire(key string, expire int64) (bool, error) <span class="cov0" title="0">{
        switch cli.clientType </span>{
        case REDIS_NORMAL_CLIENT, REDIS_SENTINEL_CLIENT:<span class="cov0" title="0">
                return cli.redisClient.Expire(key, time.Duration(expire)*time.Millisecond).Result()</span>
        case REDIS_CLUSTER_CLIENT:<span class="cov0" title="0">
                return cli.redisClusterClient.Expire(key, time.Duration(expire)*time.Millisecond).Result()</span>
        default:<span class="cov0" title="0">
                return false, errors.New(ERR_NOT_INIT_MSG)</span>
        }
}

/***************** below are hashes commands *************************/

func (cli *RedisCli) HSet(key, field string, value interface{}) (bool, error) <span class="cov0" title="0">{
        switch cli.clientType </span>{
        case REDIS_NORMAL_CLIENT, REDIS_SENTINEL_CLIENT:<span class="cov0" title="0">
                return cli.redisClient.HSet(key, field, value).Result()</span>
        case REDIS_CLUSTER_CLIENT:<span class="cov0" title="0">
                return cli.redisClusterClient.HSet(key, field, value).Result()</span>
        default:<span class="cov0" title="0">
                return false, errors.New(ERR_NOT_INIT_MSG)</span>
        }
}

func (cli *RedisCli) HGet(key, field string) (val string, err error) <span class="cov0" title="0">{
        switch cli.clientType </span>{
        case REDIS_NORMAL_CLIENT, REDIS_SENTINEL_CLIENT:<span class="cov0" title="0">
                val, err = cli.redisClient.HGet(key, field).Result()</span>
        case REDIS_CLUSTER_CLIENT:<span class="cov0" title="0">
                val, err = cli.redisClusterClient.HGet(key, field).Result()</span>
        default:<span class="cov0" title="0">
                return "", errors.New(ERR_NOT_INIT_MSG)</span>
        }

        <span class="cov0" title="0">if err == redis.Nil </span><span class="cov0" title="0">{
                return val, nil
        }</span>
        <span class="cov0" title="0">return val, err</span>
}

func (cli *RedisCli) HDel(key string, fields []string) (val int64, err error) <span class="cov0" title="0">{
        switch cli.clientType </span>{
        case REDIS_NORMAL_CLIENT, REDIS_SENTINEL_CLIENT:<span class="cov0" title="0">
                val, err = cli.redisClient.HDel(key, fields...).Result()</span>
        case REDIS_CLUSTER_CLIENT:<span class="cov0" title="0">
                val, err = cli.redisClusterClient.HDel(key, fields...).Result()</span>
        default:<span class="cov0" title="0">
                return 0, errors.New(ERR_NOT_INIT_MSG)</span>
        }

        <span class="cov0" title="0">if err == redis.Nil </span><span class="cov0" title="0">{
                return val, nil
        }</span>
        <span class="cov0" title="0">return val, err</span>
}

func (cli *RedisCli) HGetInt64(key, field string) (val int64, err error) <span class="cov0" title="0">{
        switch cli.clientType </span>{
        case REDIS_NORMAL_CLIENT, REDIS_SENTINEL_CLIENT:<span class="cov0" title="0">
                val, err = cli.redisClient.HGet(key, field).Int64()</span>
        case REDIS_CLUSTER_CLIENT:<span class="cov0" title="0">
                val, err = cli.redisClusterClient.HGet(key, field).Int64()</span>
        default:<span class="cov0" title="0">
                return 0, errors.New(ERR_NOT_INIT_MSG)</span>
        }

        <span class="cov0" title="0">if err == redis.Nil </span><span class="cov0" title="0">{
                return val, nil
        }</span>
        <span class="cov0" title="0">return val, err</span>
}

func (cli *RedisCli) HGetAll(key string) (val map[string]string, err error) <span class="cov0" title="0">{
        switch cli.clientType </span>{
        case REDIS_NORMAL_CLIENT, REDIS_SENTINEL_CLIENT:<span class="cov0" title="0">
                val, err = cli.redisClient.HGetAll(key).Result()</span>
        case REDIS_CLUSTER_CLIENT:<span class="cov0" title="0">
                val, err = cli.redisClusterClient.HGetAll(key).Result()</span>
        default:<span class="cov0" title="0">
                return nil, errors.New(ERR_NOT_INIT_MSG)</span>
        }

        <span class="cov0" title="0">if err == redis.Nil </span><span class="cov0" title="0">{
                return val, nil
        }</span>
        <span class="cov0" title="0">return val, err</span>
}

func (cli *RedisCli) HIncrBy(key, field string, incr int64) (int64, error) <span class="cov0" title="0">{
        switch cli.clientType </span>{
        case REDIS_NORMAL_CLIENT, REDIS_SENTINEL_CLIENT:<span class="cov0" title="0">
                return cli.redisClient.HIncrBy(key, field, incr).Result()</span>
        case REDIS_CLUSTER_CLIENT:<span class="cov0" title="0">
                return cli.redisClusterClient.HIncrBy(key, field, incr).Result()</span>
        default:<span class="cov0" title="0">
                return 0, errors.New(ERR_NOT_INIT_MSG)</span>
        }
}

func (cli *RedisCli) HMSet(key string, fields map[string]interface{}) (string, error) <span class="cov0" title="0">{
        switch cli.clientType </span>{
        case REDIS_NORMAL_CLIENT, REDIS_SENTINEL_CLIENT:<span class="cov0" title="0">
                return cli.redisClient.HMSet(key, fields).Result()</span>
        case REDIS_CLUSTER_CLIENT:<span class="cov0" title="0">
                return cli.redisClusterClient.HMSet(key, fields).Result()</span>
        default:<span class="cov0" title="0">
                return "", errors.New(ERR_NOT_INIT_MSG)</span>
        }
}

func (cli *RedisCli) HMGet(key string, fields []string) (map[string]interface{}, error) <span class="cov0" title="0">{
        results := make(map[string]interface{})
        var values []interface{}
        var err error

        switch cli.clientType </span>{
        case REDIS_NORMAL_CLIENT, REDIS_SENTINEL_CLIENT:<span class="cov0" title="0">
                values, err = cli.redisClient.HMGet(key, fields...).Result()</span>
        case REDIS_CLUSTER_CLIENT:<span class="cov0" title="0">
                values, err = cli.redisClusterClient.HMGet(key, fields...).Result()</span>
        default:<span class="cov0" title="0">
                return nil, errors.New(ERR_NOT_INIT_MSG)</span>
        }

        <span class="cov0" title="0">if err == redis.Nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                log.Error("failed to HMGet for key ", key, " with err: ", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">if len(fields) != len(values) </span><span class="cov0" title="0">{
                log.Error("panic HMGet, input fields number: ", len(fields), " got values number: ",
                        len(values))
                return nil, errors.New("HMGet fields number is not equal to values number.")
        }</span>

        <span class="cov0" title="0">for i, key := range fields </span><span class="cov0" title="0">{
                results[key] = values[i]
        }</span>
        <span class="cov0" title="0">return results, nil</span>
}
</pre>
		
		<pre class="file" id="file145" style="display: none">package types

import (
        "bytes"
        "encoding/binary"
        "encoding/json"
        "errors"
        "fmt"
        "strconv"
        "time"

        "github.com/dustin/go-humanize"
        "github.com/soda/multi-cloud/s3/pkg/helper"
        pb "github.com/soda/multi-cloud/s3/proto"
        log "github.com/sirupsen/logrus"
)

const (
        FIELD_NAME_BODY       = "body"
        FIELD_NAME_USAGE      = "usage"
        FIELD_NAME_FILECOUNTS = "file_counts"
)

type Bucket struct {
        *pb.Bucket
}

// implements the Serializable interface
func (b *Bucket) Serialize() (map[string]interface{}, error) <span class="cov0" title="0">{
        fields := make(map[string]interface{})
        bytes, err := helper.MsgPackMarshal(b)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">fields[FIELD_NAME_BODY] = string(bytes)
        fields[FIELD_NAME_USAGE] = b.Usages
        return fields, nil</span>
}

func (b *Bucket) Deserialize(fields map[string]string) (interface{}, error) <span class="cov0" title="0">{
        body, ok := fields[FIELD_NAME_BODY]
        if !ok </span><span class="cov0" title="0">{
                return nil, errors.New(fmt.Sprintf("no field %s found", FIELD_NAME_BODY))
        }</span>

        <span class="cov0" title="0">err := helper.MsgPackUnMarshal([]byte(body), b)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if usageStr, ok := fields[FIELD_NAME_USAGE]; ok </span><span class="cov0" title="0">{
                b.Usages, err = strconv.ParseInt(usageStr, 10, 64)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">return b, nil</span>
}

func (b *Bucket) String() (s string) <span class="cov0" title="0">{
        s += "Name: " + b.Name + "\n"
        s += "CreateTime: " + time.Unix(b.CreateTime, 0).Format(CREATE_TIME_LAYOUT) + "\n"
        s += "TenantId: " + b.TenantId + "\n"
        s += "DefaultLocation: " + b.DefaultLocation + "\n"
        s += "CORS: " + fmt.Sprintf("%+v", b.Cors) + "\n"
        s += "ACL: " + fmt.Sprintf("%+v", b.Acl) + "\n"
        s += "LifeCycle: " + fmt.Sprintf("%+v", b.LifecycleConfiguration) + "\n"
        s += "Policy: " + fmt.Sprintf("%+v", b.BucketPolicy) + "\n"
        s += "Versioning: " + fmt.Sprintf("%+v", b.Versioning) + "\n"
        s += "Usage: " + humanize.Bytes(uint64(b.Usages)) + "\n"
        return
}</span>

/* Learn from this, http://stackoverflow.com/questions/33587227/golang-method-sets-pointer-vs-value-receiver */
/* If you have a T and it is addressable you can call methods that have a receiver type of *T as well as methods that have a receiver type of T */
func (b *Bucket) GetValues() (values map[string]map[string][]byte, err error) <span class="cov0" title="0">{
        cors, err := json.Marshal(b.Cors)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">lc, err := json.Marshal(b.LifecycleConfiguration)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">var usage bytes.Buffer
        err = binary.Write(&amp;usage, binary.BigEndian, b.Usages)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">values = map[string]map[string][]byte{
                BUCKET_COLUMN_FAMILY: map[string][]byte{
                        "UID":        []byte(b.TenantId),
                        "ACL":        []byte(b.Acl.CannedAcl),
                        "CORS":       cors,
                        "LC":         lc,
                        "createTime": []byte(time.Unix(b.CreateTime, 0).Format(CREATE_TIME_LAYOUT)),
                        "usage":      usage.Bytes(),
                },
                // TODO fancy ACL
        }
        return</span>
}

func (b Bucket) GetCreateSql() (string, []interface{}) <span class="cov8" title="1">{
        acl, _ := json.Marshal(b.Acl)
        cors, _ := json.Marshal(b.Cors)
        lc, _ := json.Marshal(b.LifecycleConfiguration)
        bucket_policy, _ := json.Marshal(b.BucketPolicy)
        replia, _ := json.Marshal(b.ReplicationConfiguration)
        //createTime := time.Unix(b.CreateTime, 0).Format(TIME_LAYOUT_TIDB)
        createTime := time.Now().Format(TIME_LAYOUT_TIDB)
        log.Infof("createTime=%v\n", createTime)

        sql := "insert into buckets(bucketname,tenantid,userid,createtime,usages,location,acl,cors,lc,policy,versioning," +
                "replication) values(?,?,?,?,?,?,?,?,?,?,?,?);"
        args := []interface{}{b.Name, b.TenantId, b.UserId, createTime, b.Usages, b.DefaultLocation, acl, cors, lc,
                bucket_policy, b.Versioning.Status, replia}
        return sql, args
}</span>
</pre>
		
		<pre class="file" id="file146" style="display: none">package types

import (
        "errors"
        "fmt"
        "strconv"

        "github.com/soda/multi-cloud/s3/pkg/helper"
)

type Cluster struct {
        Fsid   string
        Pool   string
        Weight int
}

func (c *Cluster) Serialize() (map[string]interface{}, error) <span class="cov0" title="0">{
        fields := make(map[string]interface{})
        bytes, err := helper.MsgPackMarshal(c)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">fields[FIELD_NAME_BODY] = string(bytes)
        return fields, nil</span>
}

func (c *Cluster) Deserialize(fields map[string]string) (interface{}, error) <span class="cov0" title="0">{
        body, ok := fields[FIELD_NAME_BODY]
        if !ok </span><span class="cov0" title="0">{
                return nil, errors.New(fmt.Sprintf("no field %s found", FIELD_NAME_BODY))
        }</span>

        <span class="cov0" title="0">err := helper.MsgPackUnMarshal([]byte(body), c)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return c, nil</span>
}

func (c *Cluster) GetValues() (values map[string]map[string][]byte, err error) <span class="cov0" title="0">{
        values = map[string]map[string][]byte{
                CLUSTER_COLUMN_FAMILY: map[string][]byte{
                        "weight": []byte(strconv.Itoa(c.Weight)),
                },
        }
        return
}</span>
</pre>
		
		<pre class="file" id="file147" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package types

import (
        "bytes"
        "encoding/binary"
        "strconv"
        "time"
)

type GarbageCollection struct {
        Rowkey      string // rowkey cache
        BucketName  string
        ObjectName  string
        Location    string
        ObjectId    string
        Status      string    // status of this entry, in Pending/Deleting
        StorageMeta string    // meta data used by storage driver, different storage driver may have different information
        MTime       time.Time // last modify time of status
        Parts       map[int]*Part
        TriedTimes  int
}

func (gc GarbageCollection) GetValues() (values map[string]map[string][]byte, err error) <span class="cov0" title="0">{
        values = map[string]map[string][]byte{
                GARBAGE_COLLECTION_COLUMN_FAMILY: map[string][]byte{
                        "location":    []byte(gc.Location),
                        "storagemeta": []byte(gc.StorageMeta),
                        "oid":         []byte(gc.ObjectId),
                        "status":      []byte(gc.Status),
                        "mtime":       []byte(gc.MTime.Format(CREATE_TIME_LAYOUT)),
                        "tried":       []byte(strconv.Itoa(gc.TriedTimes)),
                },
        }
        if len(gc.Parts) != 0 </span><span class="cov0" title="0">{
                values[GARBAGE_COLLECTION_PART_COLUMN_FAMILY], err = valuesForParts(gc.Parts)
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
        }
        <span class="cov0" title="0">return</span>
}

func (gc GarbageCollection) GetValuesForDelete() map[string]map[string][]byte <span class="cov0" title="0">{
        return map[string]map[string][]byte{
                GARBAGE_COLLECTION_COLUMN_FAMILY:      map[string][]byte{},
                GARBAGE_COLLECTION_PART_COLUMN_FAMILY: map[string][]byte{},
        }
}</span>

// Rowkey format:
// bigEndian(unixNanoTimestamp) + BucketName + ObjectName
func (gc GarbageCollection) GetRowkey() (string, error) <span class="cov0" title="0">{
        var rowkey bytes.Buffer
        err := binary.Write(&amp;rowkey, binary.BigEndian,
                uint64(time.Now().UnixNano()))
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">rowkey.WriteString(gc.BucketName)
        rowkey.WriteString(gc.ObjectName)
        return rowkey.String(), nil</span>
}
</pre>
		
		<pre class="file" id="file148" style="display: none">package types

import (
        "encoding/hex"
        "encoding/json"
        "errors"
        "math"
        "strconv"
        "time"

        "github.com/soda/multi-cloud/api/pkg/s3/datatype"
        "github.com/soda/multi-cloud/s3/proto"
        "github.com/xxtea/xxtea-go/xxtea"
)

type Part struct {
        PartNumber int
        Size       int64
        ObjectId   string

        // offset of this part in whole object, calculated when moving parts from
        // `multiparts` table to `objects` table
        Offset               int64
        Etag                 string
        LastModified         string // time string of format "2006-01-02T15:04:05.000Z"
        InitializationVector []byte
}

type MultipartMetadata struct {
        InitiatorId   string //TenantId
        TenantId      string
        UserId        string
        ContentType   string
        Location      string
        Pool          string
        Acl           s3.Acl
        SseRequest    datatype.SseRequest
        EncryptionKey []byte
        CipherKey     []byte
        Attrs         map[string]string
        Tier          int32
}

type Multipart struct {
        BucketName  string
        ObjectKey   string
        InitialTime time.Time
        UploadId    string // upload id cache
        ObjectId    string
        StorageMeta string
        Metadata    MultipartMetadata
        Parts       map[int]*Part
}

func (m *Multipart) GetUploadId() (string, error) <span class="cov0" title="0">{
        if m.UploadId != "" </span><span class="cov0" title="0">{
                return m.UploadId, nil
        }</span>
        <span class="cov0" title="0">if m.InitialTime.IsZero() </span><span class="cov0" title="0">{
                return "", errors.New("Zero value InitialTime for Multipart")
        }</span>
        <span class="cov0" title="0">m.UploadId = getMultipartUploadId(m.InitialTime)
        return m.UploadId, nil</span>
}
func getMultipartUploadId(t time.Time) string <span class="cov0" title="0">{
        timeData := []byte(strconv.FormatUint(uint64(t.UnixNano()), 10))
        return hex.EncodeToString(xxtea.Encrypt(timeData, XXTEA_KEY))
}</span>

func GetMultipartUploadIdForTidb(uploadtime uint64) string <span class="cov0" title="0">{
        realUploadTime := math.MaxUint64 - uploadtime
        timeData := []byte(strconv.FormatUint(realUploadTime, 10))
        return hex.EncodeToString(xxtea.Encrypt(timeData, XXTEA_KEY))
}</span>

func (m *Multipart) GetValuesForDelete() map[string]map[string][]byte <span class="cov0" title="0">{
        return map[string]map[string][]byte{
                MULTIPART_COLUMN_FAMILY: map[string][]byte{},
        }
}</span>

func valuesForParts(parts map[int]*Part) (values map[string][]byte, err error) <span class="cov0" title="0">{
        for partNumber, part := range parts </span><span class="cov0" title="0">{
                var marshaled []byte
                marshaled, err = json.Marshal(part)
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">if values == nil </span><span class="cov0" title="0">{
                        values = make(map[string][]byte)
                }</span>
                <span class="cov0" title="0">values[strconv.Itoa(partNumber)] = marshaled</span>
        }
        <span class="cov0" title="0">return</span>
}
</pre>
		
		<pre class="file" id="file149" style="display: none">/*
 * Minio Cloud Storage, (C) 2015 Minio, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package types

import (
        "fmt"
)

// PartTooSmall - error if part size is less than 5MB.
type PartTooSmall struct {
        PartSize   int64
        PartNumber int
        PartETag   string
}

func (e PartTooSmall) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("Part size for %d should be atleast 5MB. The part size is %d. Etag: %s",
                e.PartNumber, e.PartNumber, e.PartETag)
}</span>
</pre>
		
		<pre class="file" id="file150" style="display: none">package types

import (
        "bytes"
        "crypto/aes"
        "crypto/cipher"
        "crypto/rand"
        "encoding/binary"
        "encoding/hex"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "math"
        "strconv"
        "time"

        "github.com/soda/multi-cloud/s3/pkg/helper"
        "github.com/soda/multi-cloud/s3/pkg/meta/util"
        pb "github.com/soda/multi-cloud/s3/proto"
        "github.com/xxtea/xxtea-go/xxtea"
)

type Object struct {
        *pb.Object
}

type ObjectType string

const (
        ObjectTypeNormal = iota
        ObjectTypeAppendable
        ObjectTypeMultipart
)

func (o *Object) Serialize() (map[string]interface{}, error) <span class="cov0" title="0">{
        fields := make(map[string]interface{})
        body, err := helper.MsgPackMarshal(o)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">fields[FIELD_NAME_BODY] = string(body)
        return fields, nil</span>
}

func (o *Object) Deserialize(fields map[string]string) (interface{}, error) <span class="cov0" title="0">{
        body, ok := fields[FIELD_NAME_BODY]
        if !ok </span><span class="cov0" title="0">{
                return nil, errors.New(fmt.Sprintf("no field %s", FIELD_NAME_BODY))
        }</span>

        <span class="cov0" title="0">err := helper.MsgPackUnMarshal([]byte(body), o)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return o, nil</span>
}

func (o *Object) ObjectTypeToString() string <span class="cov8" title="1">{
        switch o.Type </span>{
        case ObjectTypeNormal:<span class="cov8" title="1">
                return "Normal"</span>
        case ObjectTypeAppendable:<span class="cov0" title="0">
                return "Appendable"</span>
        case ObjectTypeMultipart:<span class="cov0" title="0">
                return "Multipart"</span>
        default:<span class="cov0" title="0">
                return "Unknown"</span>
        }
}

func (o *Object) String() (s string) <span class="cov8" title="1">{
        s += "Name: " + o.ObjectKey + "\n"
        s += "Bucket: " + o.BucketName + "\n"
        s += "Location: " + o.Location + "\n"
        //s += "Pool: " + o.Pool + "\n"
        s += "Object ID: " + o.ObjectId + "\n"
        s += "Last Modified Time: " + time.Unix(o.LastModified, 0).Format(CREATE_TIME_LAYOUT) + "\n"
        s += "Version: " + o.VersionId + "\n"
        s += "Type: " + o.ObjectTypeToString() + "\n"
        s += "Tier: " + fmt.Sprintf("%d", o.Tier) + "\n"
        // TODO: multi-part handle

        return s
}</span>

func (o *Object) GetVersionNumber() (uint64, error) <span class="cov0" title="0">{
        decrypted, err := util.Decrypt(o.VersionId)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">version, err := strconv.ParseUint(decrypted, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">return version, nil</span>
}

func (o *Object) GetValues() (values map[string]map[string][]byte, err error) <span class="cov0" title="0">{
        var size, tier bytes.Buffer
        err = binary.Write(&amp;size, binary.BigEndian, o.Size)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">err = binary.Write(&amp;tier, binary.BigEndian, o.Tier)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">err = o.encryptSseKey()
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if o.ServerSideEncryption.EncryptionKey == nil </span><span class="cov0" title="0">{
                o.ServerSideEncryption.EncryptionKey = []byte{}
        }</span>
        <span class="cov0" title="0">if o.ServerSideEncryption.InitilizationVector == nil </span><span class="cov0" title="0">{
                o.ServerSideEncryption.InitilizationVector = []byte{}
        }</span>
        <span class="cov0" title="0">var attrsData []byte
        if o.CustomAttributes != nil </span><span class="cov0" title="0">{
                attrsData, err = json.Marshal(o.CustomAttributes)
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
        }
        <span class="cov0" title="0">values = map[string]map[string][]byte{
                OBJECT_COLUMN_FAMILY: map[string][]byte{
                        "bucket":        []byte(o.BucketName),
                        "location":      []byte(o.Location),
                        "owner":         []byte(o.UserId),
                        "oid":           []byte(o.ObjectId),
                        "size":          size.Bytes(),
                        "lastModified":  []byte(time.Unix(o.LastModified, 0).Format(CREATE_TIME_LAYOUT)),
                        "etag":          []byte(o.Etag),
                        "content-type":  []byte(o.ContentType),
                        "attributes":    attrsData, // TODO
                        "ACL":           []byte(o.Acl.CannedAcl),
                        "nullVersion":   []byte(helper.Ternary(o.NullVersion, "true", "false").(string)),
                        "deleteMarker":  []byte(helper.Ternary(o.DeleteMarker, "true", "false").(string)),
                        "sseType":       []byte(o.ServerSideEncryption.SseType),
                        "encryptionKey": o.ServerSideEncryption.EncryptionKey,
                        "IV":            o.ServerSideEncryption.InitilizationVector,
                        "type":          []byte(o.ObjectTypeToString()),
                        "tier":          tier.Bytes(),
                },
        }
        // TODO: multipart handle

        return</span>
}

func (o *Object) GetValuesForDelete() (values map[string]map[string][]byte) <span class="cov0" title="0">{
        return map[string]map[string][]byte{
                OBJECT_COLUMN_FAMILY:      map[string][]byte{},
                OBJECT_PART_COLUMN_FAMILY: map[string][]byte{},
        }
}</span>

func (o *Object) encryptSseKey() (err error) <span class="cov0" title="0">{
        // Don't encrypt if `EncryptionKey` is not set
        if len(o.ServerSideEncryption.EncryptionKey) == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">if len(o.ServerSideEncryption.InitilizationVector) == 0 </span><span class="cov0" title="0">{
                o.ServerSideEncryption.InitilizationVector = make([]byte, INITIALIZATION_VECTOR_LENGTH)
                _, err = io.ReadFull(rand.Reader, o.ServerSideEncryption.InitilizationVector)
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
        }

        <span class="cov0" title="0">block, err := aes.NewCipher(SSE_S3_MASTER_KEY)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">aesGcm, err := cipher.NewGCM(block)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // InitializationVector is 16 bytes(because of CTR), but use only first 12 bytes in GCM
        // for performance
        <span class="cov0" title="0">o.ServerSideEncryption.EncryptionKey = aesGcm.Seal(nil, o.ServerSideEncryption.InitilizationVector[:12], o.ServerSideEncryption.EncryptionKey, nil)
        return nil</span>
}

func (o *Object) GetVersionId() string <span class="cov0" title="0">{
        if o.NullVersion </span><span class="cov0" title="0">{
                return "null"
        }</span>
        <span class="cov0" title="0">if o.VersionId != "" </span><span class="cov0" title="0">{
                return o.VersionId
        }</span>
        <span class="cov0" title="0">timeData := []byte(strconv.FormatUint(uint64(o.LastModified), 10))
        o.VersionId = hex.EncodeToString(xxtea.Encrypt(timeData, XXTEA_KEY))
        return o.VersionId</span>
}

//Tidb related function

func (o *Object) GetCreateSql() (string, []interface{}) <span class="cov8" title="1">{
        version := math.MaxUint64 - uint64(o.LastModified)
        customAttributes, _ := json.Marshal(o.CustomAttributes)
        acl, _ := json.Marshal(o.Acl)
        var sseType string
        var encryptionKey, initVector []byte
        if o.ServerSideEncryption != nil </span><span class="cov0" title="0">{
                sseType = o.ServerSideEncryption.SseType
                encryptionKey = o.ServerSideEncryption.EncryptionKey
                initVector = o.ServerSideEncryption.InitilizationVector
        }</span>

        <span class="cov8" title="1">lastModifiedTime := time.Unix(o.LastModified, 0).Format(TIME_LAYOUT_TIDB)
        sql := "insert into objects (bucketname, name, version, location, tenantid, userid, size, objectid, " +
                " lastmodifiedtime, etag, contenttype, customattributes, acl, nullversion, deletemarker, ssetype, " +
                " encryptionkey, initializationvector, type, tier, storageMeta, encsize) " +
                "values(?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)"
        args := []interface{}{o.BucketName, o.ObjectKey, version, o.Location, o.TenantId, o.UserId, o.Size, o.ObjectId,
                lastModifiedTime, o.Etag, o.ContentType, customAttributes, acl, o.NullVersion, o.DeleteMarker, sseType,
                encryptionKey, initVector, o.Type, o.Tier, o.StorageMeta, o.EncSize}

        return sql, args</span>
}

func (o *Object) GetUpdateMetaSql() (string, []interface{}) <span class="cov0" title="0">{
        version := math.MaxUint64 - uint64(o.LastModified)
        attrs, _ := json.Marshal(o.CustomAttributes)
        acl, _ := json.Marshal(o.Acl)
        sql := "update objects set acl = ?, contenttype = ?, customattributes =? where bucketname=? and name=? and version=?"
        args := []interface{}{acl, o.ContentType, attrs, o.BucketName, o.ObjectKey, version}
        return sql, args

}</span>

</pre>
		
		<pre class="file" id="file151" style="display: none">package types

import (
        "bytes"
        "encoding/binary"
)

type ObjMap struct {
        Rowkey     []byte // Rowkey cache
        Name       string
        BucketName string
        NullVerNum uint64
        NullVerId  string
}

func (om *ObjMap) GetRowKey() (string, error) <span class="cov0" title="0">{
        if len(om.Rowkey) != 0 </span><span class="cov0" title="0">{
                return string(om.Rowkey), nil
        }</span>
        <span class="cov0" title="0">var rowkey bytes.Buffer
        rowkey.WriteString(om.BucketName + ObjectNameSeparator)

        rowkey.WriteString(om.Name + ObjectNameSeparator)

        om.Rowkey = rowkey.Bytes()
        return string(om.Rowkey), nil</span>
}

func (om *ObjMap) GetValues() (values map[string]map[string][]byte, err error) <span class="cov0" title="0">{
        var nullVerNum bytes.Buffer
        err = binary.Write(&amp;nullVerNum, binary.BigEndian, om.NullVerNum)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">values = map[string]map[string][]byte{
                OBJMAP_COLUMN_FAMILY: map[string][]byte{
                        "nullVerNum": nullVerNum.Bytes(),
                },
        }
        return</span>
}

func (om *ObjMap) GetValuesForDelete() (values map[string]map[string][]byte) <span class="cov0" title="0">{
        return map[string]map[string][]byte{
                OBJMAP_COLUMN_FAMILY: map[string][]byte{},
        }
}</span>
</pre>
		
		<pre class="file" id="file152" style="display: none">package types

type SimpleIndex struct {
        Index []int64
}

func (array *SimpleIndex) SearchLowerBound(key int64) int <span class="cov0" title="0">{
        var low int = 0
        var high int = len(array.Index) - 1
        var mid = (low + high) / 2

        if array.Index[low] &gt; key </span><span class="cov0" title="0">{
                return -1
        }</span>

        <span class="cov0" title="0">for low &lt;= high </span><span class="cov0" title="0">{

                if array.Index[mid] == key </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">if array.Index[mid] &gt; key </span><span class="cov0" title="0">{
                        high = mid - 1
                }</span> else<span class="cov0" title="0"> {
                        low = mid + 1
                }</span>
                <span class="cov0" title="0">mid = (low + high) / 2</span>

        }

        <span class="cov0" title="0">return mid</span>

}

func (array *SimpleIndex) SearchUpperBound(key int64) int <span class="cov0" title="0">{
        var low int = 0
        var high int = len(array.Index) - 1
        var mid = (low + high) / 2

        if array.Index[high] &lt;= key </span><span class="cov0" title="0">{
                return -1
        }</span>

        <span class="cov0" title="0">for low &lt;= high </span><span class="cov0" title="0">{
                if array.Index[mid] &gt; key </span><span class="cov0" title="0">{
                        if mid-1 &gt;= low &amp;&amp; key &gt;= array.Index[mid-1] </span><span class="cov0" title="0">{
                                return mid
                        }</span> else<span class="cov0" title="0"> {
                                high = mid - 1
                        }</span>
                } else<span class="cov0" title="0"> {
                        if mid+1 &lt;= high &amp;&amp; key &lt; array.Index[mid+1] </span><span class="cov0" title="0">{
                                return mid + 1
                        }</span> else<span class="cov0" title="0"> {
                                low = mid + 1
                        }</span>
                }
                <span class="cov0" title="0">mid = (low + high) / 2</span>
        }

        <span class="cov0" title="0">return mid</span>
}
</pre>
		
		<pre class="file" id="file153" style="display: none">package types

import (
        . "github.com/soda/multi-cloud/s3/error"
        "github.com/soda/multi-cloud/s3/pkg/utils"
)

type StorageClass int32

var (
        StorageClassIndexMap = map[StorageClass]string{
                utils.Tier1:   "STANDARD",
                utils.Tier99:  "STANDARD_IA",
                utils.Tier999: "GLACIER",
        }

        StorageClassStringMap = map[string]StorageClass{
                "STANDARD":    utils.Tier1,
                "STANDARD_IA": utils.Tier99,
                "GLACIER":     utils.Tier999,
        }
)

func (s StorageClass) ToString() string <span class="cov0" title="0">{
        return StorageClassIndexMap[s]
}</span>

func MatchStorageClassIndex(storageClass string) (StorageClass, error) <span class="cov0" title="0">{
        if index, ok := StorageClassStringMap[storageClass]; ok </span><span class="cov0" title="0">{
                return index, nil
        }</span> else<span class="cov0" title="0"> {
                return 0, ErrInvalidStorageClass
        }</span>
}
</pre>
		
		<pre class="file" id="file154" style="display: none">package util

import (
        "context"
        "encoding/hex"
        "github.com/micro/go-micro/metadata"
        "github.com/soda/multi-cloud/api/pkg/common"
        . "github.com/soda/multi-cloud/s3/error"
        log "github.com/sirupsen/logrus"
        "github.com/xxtea/xxtea-go/xxtea"
)

var XXTEA_KEY = []byte("hehehehe")

func Decrypt(value string) (string, error) <span class="cov0" title="0">{
        bytes, err := hex.DecodeString(value)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return string(xxtea.Decrypt(bytes, XXTEA_KEY)), nil</span>
}

func Encrypt(value string) string <span class="cov0" title="0">{
        return hex.EncodeToString(xxtea.Encrypt([]byte(value), XXTEA_KEY))
}</span>

func GetCredentialFromCtx(ctx context.Context) (isAdmin bool, tenantId string, userId string, err error) <span class="cov8" title="1">{
        var ok bool
        var md map[string]string
        md, ok = metadata.FromContext(ctx)
        if !ok </span><span class="cov0" title="0">{
                log.Error("get metadata from ctx failed.")
                err = ErrInternalError
                return
        }</span>

        <span class="cov8" title="1">isAdmin = false
        isAdminStr, _ := md[common.CTX_KEY_IS_ADMIN]
        if isAdminStr == common.CTX_VAL_TRUE </span><span class="cov0" title="0">{
                isAdmin = true
        }</span>

        <span class="cov8" title="1">tenantId, ok = md[common.CTX_KEY_TENANT_ID]
        userId, ok = md[common.CTX_KEY_USER_ID]

        log.Debugf("isAdmin=%v, tenantId=%s, userId=%s, err=%v\n", isAdmin, tenantId, userId, err)
        return</span>
}
</pre>
		
		<pre class="file" id="file155" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package model

import "encoding/xml"

var Xmlns = "http://s3.amazonaws.com/doc/2006-03-01"

type CreateBucketConfiguration struct {
        Xmlns              string `xml:"xmlns,attr"`
        LocationConstraint string `xml:"LocationConstraint"`
        SSEOpts            SSEConfiguration
}

type Owner struct {
        ID          string `xml:"ID"`
        DisplayName string `xml:"DisplayName"`
}

type Bucket struct {
        Name               string `xml:"Name"`
        CreateTime         string `xml:"CreateTime"`
        LocationConstraint string `xml:"LocationConstraint"`
        VersionOpts        VersioningConfiguration
        SSEOpts            SSEConfiguration
}

type ListAllMyBucketsResult struct {
        Xmlns   string   `xml:"xmlns,attr"`
        Owner   Owner    `xml:"Owner"`
        Buckets []Bucket `xml:"Buckets"`
}

type InitiateMultipartUploadResult struct {
        Xmlns    string `xml:"xmlns,attr"`
        Bucket   string `xml:"Bucket"`
        Key      string `xml:"Key"`
        UploadId string `xml:"UploadId"`
}

//PartNumber should be between 1 and 10000.
//Please refer to https://docs.aws.amazon.com/zh_cn/AmazonS3/latest/dev/qfacts.html
type UploadPartResult struct {
        Xmlns      string `xml:"xmlns,attr"`
        PartNumber int64  `xml:"PartNumber"`
        ETag       string `xml:"ETag"`
}

// completedParts - is a collection satisfying sort.Interface.
type CompletedParts []Part

func (a CompletedParts) Len() int           <span class="cov0" title="0">{ return len(a) }</span>
func (a CompletedParts) Swap(i, j int)      <span class="cov0" title="0">{ a[i], a[j] = a[j], a[i] }</span>
func (a CompletedParts) Less(i, j int) bool <span class="cov0" title="0">{ return a[i].PartNumber &lt; a[j].PartNumber }</span>

type Part struct {
        PartNumber     int64  `xml:"PartNumber"`
        ETag           string `xml:"ETag"`
        Size           int64  `xml:"Size"`
        LastModifyTime int64  `xml:"LastModifyTime"`
}

type CompleteMultipartUpload struct {
        Xmlns string `xml:"xmlns,attr"`
        Parts []Part `xml:"Part"`
}

type CompleteMultipartUploadResult struct {
        Xmlns    string `xml:"xmlns,attr"`
        Location string `xml:"Location"`
        Bucket   string `xml:"Bucket"`
        Key      string `xml:"Key"`
        Size     int64  `xml:"Size"`
        ETag     string `xml:"ETag"`
}

type ListPartsOutput struct {
        Xmlns       string `xml:"xmlns,attr"`
        Bucket      string `xml:"Bucket"`
        Key         string `xml:"Key"`
        UploadId    string `xml:"UploadId"`
        MaxParts    int    `xml:"MaxParts"`
        IsTruncated bool   `xml:"IsTruncated"`
        Owner       Owner  `xml:"Owner"`
        Parts       []Part `xml:"Part"`
}

type LifecycleConfiguration struct {
        Rule []Rule `xml:"Rule"`
}

type SSEConfiguration struct {
        XMLName xml.Name `xml:"SSEConfiguration"`
        Text    string   `xml:",chardata"`
        SSE     struct {
                Text    string `xml:",chardata"`
                Enabled string `xml:"enabled"`
        } `xml:"SSE"`
        SSEKMS struct {
                Text                string `xml:",chardata"`
                Enabled             string `xml:"enabled"`
                DefaultKMSMasterKey string `xml:"DefaultKMSMasterKey"`
        } `xml:"SSE-KMS"`
}

type Rule struct {
        ID                             string                         `xml:"ID"`
        Filter                         Filter                         `xml:"Filter"`
        Status                         string                         `xml:"Status"`
        Transition                     []Transition                   `xml:"Transition"`
        Expiration                     []Expiration                   `xml:"Expiration"`
        AbortIncompleteMultipartUpload AbortIncompleteMultipartUpload `xml:"AbortIncompleteMultipartUpload"`
}

type Filter struct {
        Prefix string `xml:"Prefix"`
}

type Transition struct {
        Days         int32  `xml:"Days"`
        StorageClass string `xml:"StorageClass"`
        Backend      string `xml:"Backend"`
}

type Expiration struct {
        Days int32 `xml:"Days"`
        //Delete marker will be used in later release
        //ExpiredObjectDeleteMarker string   `xml:"ExpiredObjectDeleteMArker"`
}

type AbortIncompleteMultipartUpload struct {
        DaysAfterInitiation int32 `xml:"DaysAfterInitiation"`
}

type StorageClass struct {
        Name string `xml:"Name"`
        Tier int32  `xml:"Tier"`
}

type ListStorageClasses struct {
        Xmlns   string         `xml:"xmlns,attr"`
        Classes []StorageClass `xml:"Class"`
}

type VersioningConfiguration struct {
        XMLName xml.Name `xml:"VersioningConfiguration"`
        Status  string   `xml:"Status"`
}
</pre>
		
		<pre class="file" id="file156" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package service

import (
        "context"
        "github.com/soda/multi-cloud/s3/pkg/utils"

        "github.com/soda/multi-cloud/api/pkg/s3"
        . "github.com/soda/multi-cloud/s3/error"
        . "github.com/soda/multi-cloud/s3/pkg/meta/types"
        "github.com/soda/multi-cloud/s3/pkg/meta/util"
        pb "github.com/soda/multi-cloud/s3/proto"
        log "github.com/sirupsen/logrus"
)

func (s *s3Service) ListBuckets(ctx context.Context, in *pb.BaseRequest, out *pb.ListBucketsResponse) error <span class="cov8" title="1">{
        log.Info("ListBuckets is called in s3 service.")
        var err error
        defer func() </span><span class="cov8" title="1">{
                out.ErrorCode = GetErrCode(err)
        }</span>()

        <span class="cov8" title="1">buckets, err := s.MetaStorage.Db.GetBuckets(ctx)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("list buckets failed, err:%v\n", err)
                return nil
        }</span>

        // TODO: paging list
        <span class="cov8" title="1">for j := 0; j &lt; len(buckets); j++ </span><span class="cov8" title="1">{
                if buckets[j].Deleted != true </span><span class="cov8" title="1">{
                        out.Buckets = append(out.Buckets, &amp;pb.Bucket{
                                Name:                 buckets[j].Name,
                                TenantId:             buckets[j].TenantId,
                                CreateTime:           buckets[j].CreateTime,
                                Usages:               buckets[j].Usages,
                                Tier:                 buckets[j].Tier,
                                DefaultLocation:      buckets[j].DefaultLocation,
                                Versioning:           buckets[j].Versioning,
                                ServerSideEncryption: buckets[j].ServerSideEncryption,
                        })
                }</span>
        }

        <span class="cov8" title="1">log.Infof("out.Buckets:%+v\n", out.Buckets)
        return nil</span>
}

func (s *s3Service) CreateBucket(ctx context.Context, in *pb.Bucket, out *pb.BaseResponse) error <span class="cov8" title="1">{
        log.Infof("CreateBucket is called in s3 service, in:%+v\n", in)
        var err error
        defer func() </span><span class="cov8" title="1">{
                out.ErrorCode = GetErrCode(err)
        }</span>()

        <span class="cov8" title="1">bucketName := in.Name
        if err = s3.CheckValidBucketName(bucketName); err != nil </span><span class="cov0" title="0">{
                log.Errorf("invalid bucket name:%v\n", err)
                err = ErrInvalidBucketName
                return nil
        }</span>

        <span class="cov8" title="1">processed, err := s.MetaStorage.Db.CheckAndPutBucket(ctx, &amp;Bucket{Bucket: in})
        if err != nil </span><span class="cov0" title="0">{
                log.Error("Error making checkandput: ", err)
                return nil
        }</span>
        <span class="cov8" title="1">log.Infof("create bucket[%s] in database succeed, processed=%v.\n", in.Name, processed)
        if !processed </span><span class="cov0" title="0">{ // bucket already exists, return accurate message
                /*bucket*/ _, err := s.MetaStorage.GetBucket(ctx, bucketName, false)
                if err == nil </span><span class="cov0" title="0">{
                        log.Error("Error get bucket: ", bucketName, ", with error", err)
                        err = ErrBucketAlreadyExists
                }</span>
        }
        <span class="cov8" title="1">if in.Versioning != nil </span><span class="cov8" title="1">{
                err = s.MetaStorage.Db.CreateBucketVersioning(ctx, in.Name, in.Versioning.Status)
                if err != nil </span><span class="cov0" title="0">{
                        // set default version to disabled
                        err = s.MetaStorage.Db.CreateBucketVersioning(ctx, in.Name, "Disabled")
                        log.Error("Error creating version entry: ", err)
                        return err
                }</span>
        }

        <span class="cov8" title="1">if in.ServerSideEncryption != nil</span><span class="cov0" title="0">{
                byteArr, keyErr := utils.GetRandom32BitKey()
                if keyErr != nil </span><span class="cov0" title="0">{
                        log.Error("Error generating SSE key", keyErr)
                        return keyErr
                }</span>
                <span class="cov0" title="0">err = s.MetaStorage.Db.CreateBucketSSE(ctx, in.Name, in.ServerSideEncryption.SseType, byteArr)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error("Error creating SSE entry: ", err)
                        return err
                }</span>
        } else<span class="cov8" title="1">{
                // set default SSE option to none
                err = s.MetaStorage.Db.CreateBucketSSE(ctx, in.Name, "NONE", []byte("NONE"))
                if err != nil </span><span class="cov0" title="0">{
                        log.Error("Error creating SSE entry: ", err)
                        return err
                }</span>
        }
        <span class="cov8" title="1">return err</span>
}

func (s *s3Service) GetBucket(ctx context.Context, in *pb.Bucket, out *pb.GetBucketResponse) error <span class="cov8" title="1">{
        log.Infof("GetBucket %s is called in s3 service.", in.Id)
        var err error
        defer func() </span><span class="cov8" title="1">{
                out.ErrorCode = GetErrCode(err)
        }</span>()

        <span class="cov8" title="1">bucket, err := s.MetaStorage.GetBucket(ctx, in.Name, false)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("get bucket[%s] failed, err:%v\n", in.Name, err)
                // return nil, otherwise api cannot get error code
                return nil
        }</span>

        <span class="cov8" title="1">isAdmin, tenantId, _, err := util.GetCredentialFromCtx(ctx)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("get credential faied, err:%v\n", err)
                return err
        }</span>
        <span class="cov8" title="1">if !isAdmin </span><span class="cov8" title="1">{
                if tenantId != bucket.TenantId </span><span class="cov0" title="0">{
                        switch bucket.Acl.CannedAcl </span>{
                        case "public-read", "public-read-write":<span class="cov0" title="0">
                                break</span>
                        default:<span class="cov0" title="0">
                                err = ErrBucketAccessForbidden
                                return err</span>
                        }
                }
        }

        <span class="cov8" title="1">out.BucketMeta = &amp;pb.Bucket{
                Id:                   bucket.Id,
                Name:                 bucket.Name,
                TenantId:             bucket.TenantId,
                UserId:               bucket.UserId,
                Acl:                  bucket.Acl,
                CreateTime:           bucket.CreateTime,
                Deleted:              bucket.Deleted,
                DefaultLocation:      bucket.DefaultLocation,
                Tier:                 bucket.Tier,
                Usages:               bucket.Usages,
                Versioning:           bucket.Versioning,
                ServerSideEncryption: bucket.ServerSideEncryption,
        }

        return nil</span>
}

func (s *s3Service) DeleteBucket(ctx context.Context, in *pb.Bucket, out *pb.BaseResponse) error <span class="cov0" title="0">{
        bucketName := in.Name
        log.Infof("DeleteBucket is called in s3 service, bucketName is %s.\n", bucketName)
        var err error
        defer func() </span><span class="cov0" title="0">{
                out.ErrorCode = GetErrCode(err)
        }</span>()

        <span class="cov0" title="0">bucket, err := s.MetaStorage.GetBucket(ctx, bucketName, false)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("get bucket failed, err:%+v\n", err)
                return nil
        }</span>
        <span class="cov0" title="0">_, _, _, err = CheckRights(ctx, bucket.TenantId)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorln("failed to check rights, err:", err)
                return nil
        }</span>

        // Check if bucket is empty
        <span class="cov0" title="0">objs, _, err := s.MetaStorage.Db.ListObjects(ctx, bucketName, false, 1, nil)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("list objects failed, err:%v\n", err)
                return nil
        }</span>
        <span class="cov0" title="0">if len(objs) != 0 </span><span class="cov0" title="0">{
                log.Errorf("bucket[%s] is not empty.\n", bucketName)
                err = ErrBucketNotEmpty
                return nil
        }</span>
        <span class="cov0" title="0">err = s.MetaStorage.Db.DeleteBucket(ctx, bucket)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("delete bucket[%s] failed, err:%v\n", bucketName, err)
                return nil
        }</span>

        <span class="cov0" title="0">log.Infof("delete bucket[%s] successfully\n", bucketName)
        return nil</span>
}

func (s *s3Service) PutBucketLifecycle(ctx context.Context, in *pb.PutBucketLifecycleRequest, out *pb.BaseResponse) error <span class="cov0" title="0">{
        log.Infof("set lifecycle for bucket[%s]\n", in.BucketName)
        var err error
        defer func() </span><span class="cov0" title="0">{
                out.ErrorCode = GetErrCode(err)
        }</span>()

        <span class="cov0" title="0">bucket, err := s.MetaStorage.GetBucket(ctx, in.BucketName, true)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("get bucket failed, err:%v\n", err)
                return nil
        }</span>

        <span class="cov0" title="0">_, _, _, err = CheckRights(ctx, bucket.TenantId)
        if err != nil </span><span class="cov0" title="0">{
                if err == ErrAccessDenied </span><span class="cov0" title="0">{
                        err = ErrBucketAccessForbidden
                }</span>
                <span class="cov0" title="0">return nil</span>
        }

        <span class="cov0" title="0">bucket.LifecycleConfiguration = in.Lc
        err = s.MetaStorage.Db.PutBucket(ctx, bucket)
        /* TODO: enable cache, see https://github.com/soda/multi-cloud/issues/698
        if err == nil {
                s.MetaStorage.Cache.Remove(redis.BucketTable, meta.BUCKET_CACHE_PREFIX, bucketName)
        }*/

        return nil</span>
}

func (s *s3Service) GetBucketLifecycle(ctx context.Context, in *pb.BaseRequest, out *pb.GetBucketLifecycleResponse) error <span class="cov8" title="1">{
        var err error
        defer func() </span><span class="cov8" title="1">{
                out.ErrorCode = GetErrCode(err)
        }</span>()

        <span class="cov8" title="1">bucket, err := s.MetaStorage.GetBucket(ctx, in.Id, true)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("get bucket failed, err:%v\n", err)
                return nil
        }</span>

        <span class="cov8" title="1">_, _, _, err = CheckRights(ctx, bucket.TenantId)
        if err != nil </span><span class="cov0" title="0">{
                if err == ErrAccessDenied </span><span class="cov0" title="0">{
                        err = ErrBucketAccessForbidden
                }</span>
                <span class="cov0" title="0">return nil</span>
        }

        <span class="cov8" title="1">if len(bucket.LifecycleConfiguration) == 0 </span><span class="cov8" title="1">{
                log.Errorf("bucket[%s] has no lifecycle configuration\n", in.Id)
                err = ErrNoSuchBucketLc
        }</span> else<span class="cov0" title="0"> {
                out.Lc = bucket.LifecycleConfiguration
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (s *s3Service) DeleteBucketLifecycle(ctx context.Context, in *pb.BaseRequest, out *pb.BaseResponse) error <span class="cov0" title="0">{
        log.Infof("delete lifecycle for bucket:%s\n", in.Id)
        var err error
        defer func() </span><span class="cov0" title="0">{
                out.ErrorCode = GetErrCode(err)
        }</span>()

        <span class="cov0" title="0">bucket, err := s.MetaStorage.GetBucket(ctx, in.Id, true)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("get bucket err: %v\n", err)
                return nil
        }</span>
        <span class="cov0" title="0">_, _, _, err = CheckRights(ctx, bucket.TenantId)
        if err != nil </span><span class="cov0" title="0">{
                if err == ErrAccessDenied </span><span class="cov0" title="0">{
                        err = ErrBucketAccessForbidden
                }</span>
                <span class="cov0" title="0">return nil</span>
        }

        <span class="cov0" title="0">bucket.LifecycleConfiguration = nil
        err = s.MetaStorage.Db.PutBucket(ctx, bucket)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("update bucket failed, err: %v\n", err)
                return nil
        }</span> else<span class="cov0" title="0"> {
                log.Infof("delete lifecycle for bucket:%s successfully\n", in.Id)
        }</span>

        /* TODO: enable cache
        if err == nil {
                yig.MetaStorage.Cache.Remove(redis.BucketTable, meta.BUCKET_CACHE_PREFIX, bucketName)
        }*/

        <span class="cov0" title="0">return nil</span>
}

// ListBucketLifecycle is used by lifecycle management service, not need to return error code
func (s *s3Service) ListBucketLifecycle(ctx context.Context, in *pb.BaseRequest, out *pb.ListBucketsResponse) error <span class="cov0" title="0">{
        log.Info("ListBucketLifecycle is called in s3 service.")
        //buckets := []pb.Bucket{}
        buckets, err := s.MetaStorage.Db.ListBucketLifecycle(ctx)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("list buckets with lifecycle failed, err:%v\n", err)
                return err
        }</span>

        // TODO: paging list
        <span class="cov0" title="0">for _, v := range buckets </span><span class="cov0" title="0">{
                if v.Deleted != true </span><span class="cov0" title="0">{
                        out.Buckets = append(out.Buckets, &amp;pb.Bucket{
                                Name:                   v.Name,
                                DefaultLocation:        v.DefaultLocation,
                                LifecycleConfiguration: v.LifecycleConfiguration,
                        })
                }</span>
        }

        <span class="cov0" title="0">log.Info("list lifecycle successfully")
        return nil</span>
}

func (s *s3Service) PutBucketACL(ctx context.Context, in *pb.PutBucketACLRequest, out *pb.BaseResponse) error <span class="cov0" title="0">{
        log.Info("PutBucketACL is called in s3 service.")
        var err error
        defer func() </span><span class="cov0" title="0">{
                out.ErrorCode = GetErrCode(err)
        }</span>()

        <span class="cov0" title="0">bucket, err := s.MetaStorage.GetBucket(ctx, in.ACLConfig.BucketName, true)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to get bucket meta. err: %v\n", err)
                return err
        }</span>

        <span class="cov0" title="0">_, _, _, err = CheckRights(ctx, bucket.TenantId)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorln("failed to check rights, err:", err)
                return nil
        }</span>

        <span class="cov0" title="0">bucket.Acl = &amp;pb.Acl{CannedAcl: in.ACLConfig.CannedAcl}
        err = s.MetaStorage.Db.PutBucket(ctx, bucket)
        if err != nil </span><span class="cov0" title="0">{
                log.Error("failed to put bucket, err:", err)
                return err
        }</span>
        <span class="cov0" title="0">log.Infoln("Put bucket acl successfully.")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file157" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package service

import (
        "context"
        "crypto/md5"
        "encoding/hex"
        "io"
        "strconv"
        "time"

        . "github.com/soda/multi-cloud/s3/error"
        dscommon "github.com/soda/multi-cloud/s3/pkg/datastore/common"
        "github.com/soda/multi-cloud/s3/pkg/datastore/driver"
        . "github.com/soda/multi-cloud/s3/pkg/meta/types"
        "github.com/soda/multi-cloud/s3/pkg/meta/util"
        "github.com/soda/multi-cloud/s3/pkg/model"
        "github.com/soda/multi-cloud/s3/pkg/utils"
        pb "github.com/soda/multi-cloud/s3/proto"
        log "github.com/sirupsen/logrus"
)

const (
        MAX_PART_SIZE   = 5 &lt;&lt; 30 // 5GB, max object size in single upload
        MAX_PART_NUMBER = 10000   // max upload part number in one multipart upload
)

func (s *s3Service) ListBucketUploadRecords(ctx context.Context, in *pb.ListBucketUploadRequest, out *pb.ListBucketUploadResponse) error <span class="cov0" title="0">{
        log.Info("ListBucketUploadRecords is called in s3 service.")
        bucketName := in.BucketName

        var err error
        defer func() </span><span class="cov0" title="0">{
                out.ErrorCode = GetErrCode(err)
        }</span>()

        <span class="cov0" title="0">bucket, err := s.MetaStorage.GetBucket(ctx, bucketName, true)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorln("failed to get bucket meta. err:", err)
                return err
        }</span>

        <span class="cov0" title="0">isAdmin, tenantId, _, err := util.GetCredentialFromCtx(ctx)
        if err != nil &amp;&amp; isAdmin == false </span><span class="cov0" title="0">{
                log.Error("get tenant id failed")
                err = ErrInternalError
                return err
        }</span>

        <span class="cov0" title="0">if !isAdmin </span><span class="cov0" title="0">{
                switch bucket.Acl.CannedAcl </span>{
                case "public-read", "public-read-write":<span class="cov0" title="0">
                        break</span>
                default:<span class="cov0" title="0">
                        if bucket.TenantId != tenantId </span><span class="cov0" title="0">{
                                log.Errorln("bucket owner is not equal to request owner.")
                                err = ErrBucketAccessForbidden
                                return err
                        }</span>
                }
        }

        <span class="cov0" title="0">result, err := s.MetaStorage.Db.ListMultipartUploads(in)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorln("failed to list multipart uploads in meta storage. err:", err)
                return err
        }</span>
        <span class="cov0" title="0">out.Result = result

        log.Infoln("List bucket multipart uploads successfully.")
        return nil</span>
}

func (s *s3Service) InitMultipartUpload(ctx context.Context, in *pb.InitMultiPartRequest, out *pb.InitMultiPartResponse) error <span class="cov0" title="0">{
        bucketName := in.BucketName
        objectKey := in.ObjectKey
        log.Infof("InitMultipartUpload is called in s3 service, bucketName=%s, objectKey=%s\n", bucketName, objectKey)

        var err error
        defer func() </span><span class="cov0" title="0">{
                out.ErrorCode = GetErrCode(err)
        }</span>()

        <span class="cov0" title="0">isAdmin, tenantId, _, err := util.GetCredentialFromCtx(ctx)
        if err != nil &amp;&amp; isAdmin == false </span><span class="cov0" title="0">{
                log.Error("get tenant id failed")
                err = ErrInternalError
                return err
        }</span>

        <span class="cov0" title="0">bucket, err := s.MetaStorage.GetBucket(ctx, bucketName, true)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorln("failed to get bucket from meta storage. err:", err)
                return err
        }</span>
        <span class="cov0" title="0">if !isAdmin </span><span class="cov0" title="0">{
                switch bucket.Acl.CannedAcl </span>{
                case "public-read-write":<span class="cov0" title="0">
                        break</span>
                default:<span class="cov0" title="0">
                        if bucket.TenantId != tenantId </span><span class="cov0" title="0">{
                                log.Errorln("bucket owner is not equal to request owner.")
                                err = ErrBucketAccessForbidden
                                return err
                        }</span>
                }
        }

        <span class="cov0" title="0">attrs := in.Attrs
        contentType, ok := attrs["Content-Type"]
        if !ok </span><span class="cov0" title="0">{
                contentType = "application/octet-stream"
        }</span>

        <span class="cov0" title="0">backendName := in.Location
        if backendName == "" </span><span class="cov0" title="0">{
                backendName = bucket.DefaultLocation
        }</span>
        <span class="cov0" title="0">backend, err := utils.GetBackend(ctx, s.backendClient, backendName)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorln("failed to get backend client with err:", err)
                return err
        }</span>

        <span class="cov0" title="0">sd, err := driver.CreateStorageDriver(backend.Type, backend)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorln("failed to create storage. err:", err)
                return err
        }</span>
        <span class="cov0" title="0">tier := in.Tier
        if tier == 0 </span><span class="cov0" title="0">{
                // if not set, use the default tier
                tier = utils.Tier1
        }</span>
        <span class="cov0" title="0">res, err := sd.InitMultipartUpload(ctx, &amp;pb.Object{BucketName: bucketName, ObjectKey: objectKey, Tier: tier})
        if err != nil </span><span class="cov0" title="0">{
                log.Errorln("failed to init multipart upload. err:", err)
                return err
        }</span>

        <span class="cov0" title="0">multipartMetadata := MultipartMetadata{
                InitiatorId: tenantId,
                TenantId:    bucket.TenantId,
                UserId:      bucket.UserId,
                ContentType: contentType,
                Attrs:       attrs,
                Tier:        tier,
                Location:    backendName,
                // TODO: add sse information
        }
        if in.Acl != nil </span><span class="cov0" title="0">{
                multipartMetadata.Acl = *in.Acl
        }</span> else<span class="cov0" title="0"> {
                multipartMetadata.Acl.CannedAcl = "private"
        }</span>

        <span class="cov0" title="0">multipart := Multipart{
                BucketName:  bucketName,
                ObjectKey:   objectKey,
                UploadId:    res.UploadId,
                ObjectId:    res.ObjectId,
                InitialTime: time.Now().UTC(),
                Metadata:    multipartMetadata,
        }

        err = s.MetaStorage.Db.CreateMultipart(multipart)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorln("failed to create multipart in meta. err:", err)
                return err
        }</span>
        <span class="cov0" title="0">out.UploadID = res.UploadId

        return nil</span>
}

func (s *s3Service) UploadPart(ctx context.Context, stream pb.S3_UploadPartStream) error <span class="cov0" title="0">{
        log.Info("UploadPart is called in s3 service.")
        var err error
        uploadResponse := pb.UploadPartResponse{}
        defer func() </span><span class="cov0" title="0">{
                uploadResponse.ErrorCode = GetErrCode(err)
                stream.SendMsg(&amp;uploadResponse)
        }</span>()

        <span class="cov0" title="0">uploadRequest := pb.UploadPartRequest{}
        err = stream.RecvMsg(&amp;uploadRequest)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorln("failed to receive msg. err:", err)
                return err
        }</span>
        <span class="cov0" title="0">bucketName := uploadRequest.BucketName
        objectKey := uploadRequest.ObjectKey
        partId := uploadRequest.PartId
        uploadId := uploadRequest.UploadId
        size := uploadRequest.Size

        log.Infof("uploadpart, bucketname:%v, objectkey:%v, partId:%v, uploadId:%v,size:%v", bucketName, objectKey, partId, uploadId, size)
        multipart, err := s.MetaStorage.GetMultipart(bucketName, objectKey, uploadId)
        if err != nil </span><span class="cov0" title="0">{
                log.Infoln("failed to get multipart. err:", err)
                return err
        }</span>

        <span class="cov0" title="0">if size &gt; MAX_PART_SIZE </span><span class="cov0" title="0">{
                log.Errorf("object part size is too large. size:", size)
                err = ErrEntityTooLarge
                return err
        }</span>

        <span class="cov0" title="0">isAdmin, tenantId, _, err := util.GetCredentialFromCtx(ctx)
        if err != nil &amp;&amp; isAdmin == false </span><span class="cov0" title="0">{
                log.Error("get tenant id failed")
                err = ErrInternalError
                return err
        }</span>

        <span class="cov0" title="0">bucket, err := s.MetaStorage.GetBucket(ctx, bucketName, true)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorln("get bucket failed with err:", err)
                return err
        }</span>

        <span class="cov0" title="0">if !isAdmin </span><span class="cov0" title="0">{
                switch bucket.Acl.CannedAcl </span>{
                case "public-read-write":<span class="cov0" title="0">
                        break</span>
                default:<span class="cov0" title="0">
                        if bucket.TenantId != tenantId </span><span class="cov0" title="0">{
                                err = ErrBucketAccessForbidden
                                log.Errorln("bucket owner is not equal to request owner.")
                                return err
                        }</span>
                }
        }

        <span class="cov0" title="0">backendName := bucket.DefaultLocation
        backend, err := utils.GetBackend(ctx, s.backendClient, backendName)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorln("failed to get backend client with err:", err)
                return err
        }</span>

        <span class="cov0" title="0">md5Writer := md5.New()
        data := &amp;StreamReader{in: stream}
        limitedDataReader := io.LimitReader(data, size)
        dataReader := io.TeeReader(limitedDataReader, md5Writer)
        sd, err := driver.CreateStorageDriver(backend.Type, backend)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorln("failed to create storage. err:", err)
                return nil
        }</span>
        <span class="cov0" title="0">ctx = context.Background()
        ctx = context.WithValue(ctx, dscommon.CONTEXT_KEY_MD5, uploadRequest.Md5Hex)
        log.Infoln("bucketname:", bucketName, " objectKey:", objectKey, " uploadid:", uploadId, " objectId:", multipart.ObjectId, " partid:", partId)
        _, err = sd.UploadPart(ctx, dataReader, &amp;pb.MultipartUpload{
                Bucket:   bucketName,
                Key:      objectKey,
                UploadId: uploadId,
                ObjectId: multipart.ObjectId},
                int64(partId), size)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorln("failed to upload part to backend. err:", err)
                return err
        }</span>

        <span class="cov0" title="0">calculatedMd5 := hex.EncodeToString(md5Writer.Sum(nil))
        part := Part{
                PartNumber:   int(partId),
                Size:         size,
                ObjectId:     multipart.ObjectId,
                Etag:         calculatedMd5,
                LastModified: time.Now().UTC().Format(CREATE_TIME_LAYOUT),
        }

        err = s.MetaStorage.PutObjectPart(ctx, multipart, part)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorln("failed to put object part. err:", err)
                // because the backend will delete object part that has the same part id in next upload, we return error directly here
                return err
        }</span>

        <span class="cov0" title="0">uploadResponse.ETag = calculatedMd5

        log.Infoln("UploadPart upload part successfully.")
        return nil</span>
}

func (s *s3Service) CompleteMultipartUpload(ctx context.Context, in *pb.CompleteMultipartRequest, out *pb.CompleteMultipartResponse) error <span class="cov0" title="0">{
        log.Info("CompleteMultipartUpload is called in s3 service.")
        bucketName := in.BucketName
        objectKey := in.ObjectKey
        uploadId := in.UploadId

        var err error
        defer func() </span><span class="cov0" title="0">{
                out.ErrorCode = GetErrCode(err)
        }</span>()

        <span class="cov0" title="0">isAdmin, tenantId, _, err := util.GetCredentialFromCtx(ctx)
        if err != nil </span><span class="cov0" title="0">{
                log.Error("get tenant id failed")
                err = ErrInternalError
                return err
        }</span>

        <span class="cov0" title="0">bucket, err := s.MetaStorage.GetBucket(ctx, bucketName, true)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to get bucket from meta stoarge. err:", err)
                return err
        }</span>

        <span class="cov0" title="0">if !isAdmin </span><span class="cov0" title="0">{
                switch bucket.Acl.CannedAcl </span>{
                case "public-read-write":<span class="cov0" title="0">
                        break</span>
                default:<span class="cov0" title="0">
                        if bucket.TenantId != tenantId </span><span class="cov0" title="0">{
                                log.Errorln("bucket owner is not equal to request owner.")
                                err = ErrBucketAccessForbidden
                                return err
                        }</span>
                }
        }

        <span class="cov0" title="0">multipart, err := s.MetaStorage.GetMultipart(bucketName, objectKey, uploadId)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorln("failed to get multipart info. err:", err)
                return err
        }</span>

        <span class="cov0" title="0">md5Writer := md5.New()
        var totalSize int64 = 0
        for i := 0; i &lt; len(in.CompleteParts); i++ </span><span class="cov0" title="0">{
                if in.CompleteParts[i].PartNumber != int64(i+1) </span><span class="cov0" title="0">{
                        log.Errorln("wrong order for part number. ")
                        err = ErrInvalidPart
                        return err
                }</span>
                <span class="cov0" title="0">part, ok := multipart.Parts[i+1]
                if !ok </span><span class="cov0" title="0">{
                        log.Errorln("missed object part. partno:", i)
                        err = ErrInvalidPart
                        return err
                }</span>

                <span class="cov0" title="0">if part.Etag != in.CompleteParts[i].ETag </span><span class="cov0" title="0">{
                        log.Errorln("part etag in meta store is not the same with client's part, partno:", i)
                        err = ErrInvalidPart
                        return err
                }</span>
                <span class="cov0" title="0">var etagBytes []byte
                etagBytes, err = hex.DecodeString(part.Etag)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorln("failed to decode etag string. err:", err)
                        err = ErrInvalidPart
                        return err
                }</span>
                <span class="cov0" title="0">part.Offset = totalSize
                totalSize += part.Size
                md5Writer.Write(etagBytes)</span>
        }
        <span class="cov0" title="0">eTag := hex.EncodeToString(md5Writer.Sum(nil))
        eTag += "-" + strconv.Itoa(len(in.CompleteParts))

        backendName := bucket.DefaultLocation
        backend, err := utils.GetBackend(ctx, s.backendClient, backendName)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorln("failed to get backend client with err:", err)
                return err
        }</span>
        <span class="cov0" title="0">sd, err := driver.CreateStorageDriver(backend.Type, backend)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorln("failed to create storage. err:", err)
                return nil
        }</span>

        <span class="cov0" title="0">parts := make([]model.Part, 0)
        completeUpload := &amp;model.CompleteMultipartUpload{}
        for _, part := range in.CompleteParts </span><span class="cov0" title="0">{
                parts = append(parts, model.Part{
                        PartNumber: part.PartNumber,
                        ETag:       part.ETag,
                })
        }</span>
        <span class="cov0" title="0">completeUpload.Parts = parts
        _, err = sd.CompleteMultipartUpload(ctx, &amp;pb.MultipartUpload{
                Bucket:   bucketName,
                Key:      objectKey,
                UploadId: uploadId,
                ObjectId: multipart.ObjectId,
                Location: multipart.Metadata.Location,
                Tier:     multipart.Metadata.Tier,
        }, completeUpload)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorln("failed to complete multipart. err:", err)
                return err
        }</span>

        // TODO: if versioning is enabled, not need to delete oldObj
        <span class="cov0" title="0">oldObj, err := s.MetaStorage.GetObject(ctx, bucketName, objectKey, "", false)
        if err != nil &amp;&amp; err != ErrNoSuchKey </span><span class="cov0" title="0">{
                log.Errorf("get object[%s] failed, err:%v\n", objectKey, err)
                return ErrInternalError
        }</span>
        <span class="cov0" title="0">log.Debugf("bucketName=%s,objectKey=%s,version=%s,existObj=%v, err=%v\n", bucketName, objectKey, in.SourceVersionID, oldObj, err)

        // Add to objects table
        contentType := multipart.Metadata.ContentType
        object := &amp;pb.Object{
                BucketName:       bucketName,
                ObjectKey:        objectKey,
                TenantId:         multipart.Metadata.TenantId,
                UserId:           multipart.Metadata.UserId,
                ContentType:      contentType,
                ObjectId:         multipart.ObjectId,
                LastModified:     time.Now().UTC().Unix(),
                Etag:             eTag,
                DeleteMarker:     false,
                CustomAttributes: multipart.Metadata.Attrs,
                Type:             ObjectTypeNormal,
                Tier:             multipart.Metadata.Tier,
                Size:             totalSize,
                Location:         multipart.Metadata.Location,
                Acl:              &amp;multipart.Metadata.Acl,
        }

        if in.RequestType != utils.RequestType_Lifecycle </span><span class="cov0" title="0">{
                err = s.MetaStorage.PutObject(ctx, &amp;Object{Object: object}, oldObj, &amp;multipart, nil, true)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("failed to put object meta[object:%+v, oldObj:%+v]. err:%v\n", object, oldObj, err)
                        // TODO: consistent check &amp; clean
                        return ErrDBError
                }</span>
        } else<span class="cov0" title="0"> {
                err = s.MetaStorage.UpdateObject4Lifecycle(ctx, oldObj, &amp;Object{Object: object}, &amp;multipart)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorln("failed to put object meta. err:", err)
                        // delete new object, lifecycle will try again in the next schedule round
                        s.cleanObject(ctx, &amp;Object{Object: object}, sd)
                        return err
                }</span>
        }

        <span class="cov0" title="0">log.Infoln("CompleteMultipartUpload upload part successfully.")
        return nil</span>
}

func (s *s3Service) AbortMultipartUpload(ctx context.Context, in *pb.AbortMultipartRequest, out *pb.BaseResponse) error <span class="cov0" title="0">{
        log.Info("AbortMultipartUpload is called in s3 service.")
        bucketName := in.BucketName
        objectKey := in.ObjectKey
        uploadId := in.UploadId

        var err error
        defer func() </span><span class="cov0" title="0">{
                out.ErrorCode = GetErrCode(err)
        }</span>()

        <span class="cov0" title="0">isAdmin, tenantId, _, err := util.GetCredentialFromCtx(ctx)
        if err != nil &amp;&amp; isAdmin == false </span><span class="cov0" title="0">{
                log.Error("get tenant id failed")
                err = ErrInternalError
                return err
        }</span>

        <span class="cov0" title="0">bucket, err := s.MetaStorage.GetBucket(ctx, bucketName, true)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorln("failed to get bucket from meta storage. err:", err)
                return err
        }</span>

        <span class="cov0" title="0">if !isAdmin </span><span class="cov0" title="0">{
                switch bucket.Acl.CannedAcl </span>{
                case "public-read-write":<span class="cov0" title="0">
                        break</span>
                default:<span class="cov0" title="0">
                        if bucket.TenantId != tenantId </span><span class="cov0" title="0">{
                                log.Errorln("bucket owner is not equal to request owner.")
                                return ErrBucketAccessForbidden
                        }</span>
                }
        }

        <span class="cov0" title="0">multipart, err := s.MetaStorage.GetMultipart(bucketName, objectKey, uploadId)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorln("failed to get multipart info. err:", err)
                return err
        }</span>

        <span class="cov0" title="0">backendName := bucket.DefaultLocation
        backend, err := utils.GetBackend(ctx, s.backendClient, backendName)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorln("failed to get backend client with err:", err)
                return err
        }</span>
        <span class="cov0" title="0">sd, err := driver.CreateStorageDriver(backend.Type, backend)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorln("failed to create storage. err:", err)
                return err
        }</span>

        <span class="cov0" title="0">err = sd.AbortMultipartUpload(ctx, &amp;pb.MultipartUpload{
                Bucket:   bucketName,
                Key:      objectKey,
                UploadId: uploadId,
                ObjectId: multipart.ObjectId})
        if err != nil </span><span class="cov0" title="0">{
                log.Errorln("failed to abort multipart. err:", err)
                return err
        }</span>

        <span class="cov0" title="0">err = s.MetaStorage.DeleteMultipart(ctx, multipart)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorln("failed to delete multipart. err:", err)
                return err
        }</span>

        <span class="cov0" title="0">log.Infoln("Abort multipart successfully.")
        return nil</span>
}

func (s *s3Service) ListObjectParts(ctx context.Context, in *pb.ListObjectPartsRequest, out *pb.ListObjectPartsResponse) error <span class="cov0" title="0">{
        log.Info("ListObjectParts is called in s3 service.")
        var err error
        defer func() </span><span class="cov0" title="0">{
                out.ErrorCode = GetErrCode(err)
        }</span>()

        <span class="cov0" title="0">bucketName := in.BucketName
        objectKey := in.ObjectKey
        uploadId := in.UploadId

        multipart, err := s.MetaStorage.GetMultipart(bucketName, objectKey, uploadId)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorln("failed to get multipart info. err:", err)
                return err
        }</span>

        <span class="cov0" title="0">isAdmin, tenantId, _, err := util.GetCredentialFromCtx(ctx)
        if err != nil </span><span class="cov0" title="0">{
                log.Error("get tenant id failed")
                err = ErrInternalError
                return err
        }</span>

        <span class="cov0" title="0">if !isAdmin </span><span class="cov0" title="0">{
                switch multipart.Metadata.Acl.CannedAcl </span>{
                case "public-read", "public-read-write":<span class="cov0" title="0">
                        break</span>
                default:<span class="cov0" title="0">
                        if multipart.Metadata.TenantId != tenantId </span><span class="cov0" title="0">{
                                err = ErrAccessDenied
                                return err
                        }</span>
                }
        }

        <span class="cov0" title="0">out.Initiator = &amp;pb.Owner{Id: multipart.Metadata.InitiatorId, DisplayName: multipart.Metadata.InitiatorId}
        out.Owner = &amp;pb.Owner{Id: multipart.Metadata.TenantId, DisplayName: multipart.Metadata.TenantId}
        out.MaxParts = int64(in.MaxParts)
        out.Parts = make([]*pb.Part, 0)
        for i := in.PartNumberMarker + 1; i &lt;= MAX_PART_NUMBER; i++ </span><span class="cov0" title="0">{
                if p, ok := multipart.Parts[int(i)]; ok </span><span class="cov0" title="0">{
                        out.Parts = append(out.Parts, &amp;pb.Part{
                                PartNumber:   i,
                                ETag:         "\"" + p.Etag + "\"",
                                Size:         p.Size,
                                LastModified: p.LastModified,
                        })

                        if int64(len(out.Parts)) &gt; in.MaxParts </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
        }
        <span class="cov0" title="0">if int64(len(out.Parts)) == in.MaxParts+1 </span><span class="cov0" title="0">{
                out.IsTruncated = true
                out.NextPartNumberMarker = out.Parts[out.MaxParts].PartNumber
                out.Parts = out.Parts[:in.MaxParts]
        }</span>
        <span class="cov0" title="0">out.PartNumberMarker = in.PartNumberMarker

        log.Infof("list object part successfully. ")

        return nil</span>
}

func (s *s3Service) CopyObjPart(ctx context.Context, in *pb.CopyObjPartRequest, out *pb.CopyObjPartResponse) error <span class="cov0" title="0">{
        log.Info("CopyObjPart is called in s3 service.")
        var err error
        defer func() </span><span class="cov0" title="0">{
                out.ErrorCode = GetErrCode(err)
        }</span>()

        <span class="cov0" title="0">srcBucketName := in.SourceBucket
        srcObjectName := in.SourceObject
        targetBucketName := in.TargetBucket
        targetObjectName := in.TargetObject
        uploadId := in.UploadID
        partId := in.PartID
        size := in.ReadLength
        offset := in.ReadOffset

        srcBucket, err := s.MetaStorage.GetBucket(ctx, srcBucketName, true)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorln("get bucket failed with err:", err)
                return err
        }</span>
        <span class="cov0" title="0">srcObject, err := s.MetaStorage.GetObject(ctx, srcBucketName, srcObjectName, "", true)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorln("failed to get object info from meta storage. err:", err)
                return err
        }</span>
        <span class="cov0" title="0">targetBucket, err := s.MetaStorage.GetBucket(ctx, targetBucketName, true)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorln("get bucket failed with err:", err)
                return err
        }</span>

        <span class="cov0" title="0">isAdmin, tenantId, _, err := util.GetCredentialFromCtx(ctx)
        if err != nil </span><span class="cov0" title="0">{
                log.Error("get tenant id failed, err:", err)
                err = ErrInternalError
                return err
        }</span>

        <span class="cov0" title="0">if !isAdmin </span><span class="cov0" title="0">{
                //check source object acl
                switch srcObject.Acl.CannedAcl </span>{
                case "public-read", "public-read-write":<span class="cov0" title="0">
                        break</span>
                default:<span class="cov0" title="0">
                        if srcObject.TenantId != tenantId </span><span class="cov0" title="0">{
                                err = ErrAccessDenied
                                return err
                        }</span>
                }
                //check target acl
                <span class="cov0" title="0">switch targetBucket.Acl.CannedAcl </span>{
                case "public-read-write":<span class="cov0" title="0">
                        break</span>
                default:<span class="cov0" title="0">
                        if targetBucket.TenantId != tenantId </span><span class="cov0" title="0">{
                                err = ErrBucketAccessForbidden
                                return err
                        }</span>
                } // TODO policy and fancy ACL
        }

        <span class="cov0" title="0">backendName := srcBucket.DefaultLocation
        if srcObject.Location != "" </span><span class="cov0" title="0">{
                backendName = srcObject.Location
        }</span>
        <span class="cov0" title="0">srcBackend, err := utils.GetBackend(ctx, s.backendClient, backendName)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorln("failed to get backend client with err:", err)
                return err
        }</span>
        <span class="cov0" title="0">srcSd, err := driver.CreateStorageDriver(srcBackend.Type, srcBackend)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorln("failed to create storage driver. err:", err)
                return err
        }</span>
        <span class="cov0" title="0">targetBackendName := targetBucket.DefaultLocation
        if in.TargetLocation != "" </span><span class="cov0" title="0">{
                targetBackendName = in.TargetLocation
        }</span>
        <span class="cov0" title="0">targetBackend, err := utils.GetBackend(ctx, s.backendClient, targetBackendName)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorln("failed to get backend client with err:", err)
                return err
        }</span>
        <span class="cov0" title="0">targetSd, err := driver.CreateStorageDriver(targetBackend.Type, targetBackend)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorln("failed to create storage driver. err:", err)
                return err
        }</span>
        <span class="cov0" title="0">reader, err := srcSd.Get(ctx, srcObject.Object, offset, offset+size-1)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorln("failed to get data reader. err:", err)
                return err
        }</span>
        <span class="cov0" title="0">limitedDataReader := io.LimitReader(reader, size)
        md5Writer := md5.New()
        dataReader := io.TeeReader(limitedDataReader, md5Writer)

        multipart, err := s.MetaStorage.GetMultipart(targetBucketName, targetObjectName, uploadId)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorln("failed to get multipart. err:", err)
                return err
        }</span>
        <span class="cov0" title="0">_, err = targetSd.UploadPart(ctx, dataReader, &amp;pb.MultipartUpload{
                Bucket:   targetBucketName,
                Key:      targetObjectName,
                UploadId: uploadId,
                ObjectId: multipart.ObjectId},
                partId, size)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorln("failed to upload part to backend. err:", err)
                return err
        }</span>
        <span class="cov0" title="0">calculatedMd5 := hex.EncodeToString(md5Writer.Sum(nil))
        part := Part{
                PartNumber:   int(partId),
                Size:         size,
                ObjectId:     multipart.ObjectId,
                Etag:         calculatedMd5,
                LastModified: time.Now().UTC().Format(CREATE_TIME_LAYOUT),
        }

        err = s.MetaStorage.PutObjectPart(ctx, multipart, part)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorln("failed to put object part. err:", err)
                // because the backend will delete object part that has the same part id in next upload, we return error directly here
                return err
        }</span>

        <span class="cov0" title="0">out.Etag = calculatedMd5
        out.LastModified = time.Now().UTC().Unix()

        log.Infoln("copy object part successfully.")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file158" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package service

import (
        "bytes"
        "context"
        "encoding/binary"
        "io"
        "io/ioutil"
        "net/url"
        "time"

        "github.com/journeymidnight/yig/helper"
        "github.com/micro/go-micro/metadata"
        "github.com/soda/multi-cloud/api/pkg/common"
        "github.com/soda/multi-cloud/api/pkg/utils/constants"
        . "github.com/soda/multi-cloud/s3/error"
        dscommon "github.com/soda/multi-cloud/s3/pkg/datastore/common"
        "github.com/soda/multi-cloud/s3/pkg/datastore/driver"
        "github.com/soda/multi-cloud/s3/pkg/meta/types"
        . "github.com/soda/multi-cloud/s3/pkg/meta/types"
        meta "github.com/soda/multi-cloud/s3/pkg/meta/types"
        "github.com/soda/multi-cloud/s3/pkg/meta/util"
        "github.com/soda/multi-cloud/s3/pkg/utils"
        pb "github.com/soda/multi-cloud/s3/proto"
        log "github.com/sirupsen/logrus"
)

var ChunkSize int = 2048

func (s *s3Service) CreateObject(ctx context.Context, in *pb.Object, out *pb.BaseResponse) error <span class="cov0" title="0">{
        log.Infoln("CreateObject is called in s3 service.")

        return nil
}</span>

func (s *s3Service) UpdateObject(ctx context.Context, in *pb.Object, out *pb.BaseResponse) error <span class="cov0" title="0">{
        log.Infoln("PutObject is called in s3 service.")

        return nil
}</span>

type DataStreamRecv interface {
        Recv() (*pb.PutDataStream, error)
}

type StreamReader struct {
        in   DataStreamRecv
        req  *pb.PutDataStream
        curr int
}

func (dr *StreamReader) Read(p []byte) (n int, err error) <span class="cov8" title="1">{
        left := len(p)
        for left &gt; 0 </span><span class="cov8" title="1">{
                if dr.curr == 0 || (dr.req != nil &amp;&amp; dr.curr == len(dr.req.Data)) </span><span class="cov8" title="1">{
                        dr.req, err = dr.in.Recv()
                        if err != nil &amp;&amp; err != io.EOF </span><span class="cov0" title="0">{
                                log.Errorln("failed to recv data with err:", err)
                                return
                        }</span>
                        <span class="cov8" title="1">if dr.req == nil || len(dr.req.Data) == 0 </span><span class="cov0" title="0">{
                                log.Errorln("no data left to read.")
                                err = io.EOF
                                return
                        }</span>
                        <span class="cov8" title="1">dr.curr = 0</span>
                }

                <span class="cov8" title="1">copyLen := 0
                if len(dr.req.Data)-dr.curr &gt; left </span><span class="cov0" title="0">{
                        copyLen = left
                }</span> else<span class="cov8" title="1"> {
                        copyLen = len(dr.req.Data) - dr.curr
                }</span>
                <span class="cov8" title="1">log.Traceln("copy len:", copyLen)
                copy(p[n:], dr.req.Data[dr.curr:(dr.curr+copyLen)])
                dr.curr += copyLen
                left -= copyLen
                n += copyLen</span>
        }
        <span class="cov8" title="1">return</span>
}

func (s *s3Service) removeObjectFromBackend(ctx context.Context, sd driver.StorageDriver, obj *pb.DeleteObjectInput) error <span class="cov0" title="0">{
        if obj != nil </span><span class="cov0" title="0">{
                err := sd.Delete(ctx, obj)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorln("failed to delete written object. err:", err)
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (s *s3Service) PutObject(ctx context.Context, in pb.S3_PutObjectStream) error <span class="cov8" title="1">{
        log.Infoln("PutObject is called in s3 service.")

        var err error
        result := &amp;pb.PutObjectResponse{}
        defer func() </span><span class="cov8" title="1">{
                result.ErrorCode = GetErrCode(err)
                in.SendMsg(result)
        }</span>()

        <span class="cov8" title="1">isAdmin, tenantId, userId, err := util.GetCredentialFromCtx(ctx)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorln("failed to get credential info. err:", err)
                return nil
        }</span>

        <span class="cov8" title="1">req := &amp;pb.PutObjectRequest{}
        err = in.RecvMsg(req)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorln("failed to get msg with err:", err)
                return ErrInternalError
        }</span>

        <span class="cov8" title="1">log.Infof("*********bucket:%s,key:%s,size:%d\n", req.BucketName, req.ObjectKey, req.Size)
        bucket, err := s.MetaStorage.GetBucket(ctx, req.BucketName, true)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorln("get bucket failed with err:", err)
                return err
        }</span>

        <span class="cov8" title="1">if !isAdmin </span><span class="cov8" title="1">{
                switch bucket.Acl.CannedAcl </span>{
                case "public-read-write":<span class="cov0" title="0">
                        break</span>
                default:<span class="cov8" title="1">
                        if bucket.TenantId != tenantId </span><span class="cov0" title="0">{
                                err = ErrBucketAccessForbidden
                                return err
                        }</span>
                }
        }

        // get old object meta if it exist, this is not needed if versioning is enabled
        <span class="cov8" title="1">oldObj, err := s.MetaStorage.GetObject(ctx, bucket.Name, req.ObjectKey, "", false)
        if err != nil &amp;&amp; err != ErrNoSuchKey </span><span class="cov0" title="0">{
                log.Errorf("get object[%s] failed, err:%v\n", req.ObjectKey, err)
                return ErrInternalError
        }</span>
        <span class="cov8" title="1">log.Debugf("existObj=%v, err=%v\n", oldObj, err)

        data := &amp;StreamReader{in: in}
        var limitedDataReader io.Reader
        if req.Size &gt; 0 </span><span class="cov8" title="1">{ // request.ContentLength is -1 if length is unknown
                limitedDataReader = io.LimitReader(data, req.Size)
        }</span> else<span class="cov0" title="0"> {
                limitedDataReader = data
        }</span>

        <span class="cov8" title="1">actualSize := req.Size
        // encrypt if needed
        if bucket.ServerSideEncryption.SseType == "SSE" </span><span class="cov8" title="1">{
                byteArr, _ := ioutil.ReadAll(limitedDataReader)
                _, encBuf := utils.EncryptWithAES256RandomKey(byteArr, bucket.ServerSideEncryption.EncryptionKey)
                reader := bytes.NewReader(encBuf)
                limitedDataReader = io.LimitReader(reader, int64(binary.Size(encBuf)))
                req.Size = int64(binary.Size(encBuf))
        }</span>

        <span class="cov8" title="1">backendName := bucket.DefaultLocation
        if req.Location != "" </span><span class="cov8" title="1">{
                backendName = req.Location
        }</span>
        <span class="cov8" title="1">backend, err := utils.GetBackend(ctx, s.backendClient, backendName)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorln("failed to get backend client with err:", err)
                return err
        }</span>

        <span class="cov8" title="1">log.Infoln("bucket location:", req.Location, " backendtype:", backend.Type, " endpoint:", backend.Endpoint)
        bodyMd5 := req.Attrs["md5Sum"]
        ctx = context.Background()
        ctx = context.WithValue(ctx, dscommon.CONTEXT_KEY_SIZE, req.Size)
        ctx = context.WithValue(ctx, dscommon.CONTEXT_KEY_MD5, bodyMd5)
        sd, err := driver.CreateStorageDriver(backend.Type, backend)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorln("failed to create storage. err:", err)
                return err
        }</span>
        <span class="cov8" title="1">obj := &amp;pb.Object{BucketName: req.BucketName, ObjectKey: req.ObjectKey}
        if oldObj != nil &amp;&amp; oldObj.Location == backendName </span><span class="cov0" title="0">{
                obj.StorageMeta = oldObj.StorageMeta
                obj.ObjectId = oldObj.ObjectId
        }</span>
        <span class="cov8" title="1">res, err := sd.Put(ctx, limitedDataReader, obj)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorln("failed to put data. err:", err)
                return err
        }</span>

        <span class="cov8" title="1">obj.BucketName = req.BucketName
        obj.ObjectKey = req.ObjectKey
        obj.Acl = req.Acl
        obj.TenantId = tenantId
        obj.UserId = userId
        obj.ObjectId = res.ObjectId
        obj.LastModified = time.Now().UTC().Unix()
        obj.Etag = res.Etag
        obj.ContentType = req.ContentType
        obj.DeleteMarker = false
        obj.CustomAttributes = req.Attrs
        obj.Type = meta.ObjectTypeNormal
        obj.Tier = utils.Tier1 // Currently only support tier1
        obj.StorageMeta = res.Meta
        obj.Size = actualSize
        obj.EncSize = req.Size
        obj.Location = backendName

        object := &amp;meta.Object{Object: obj}

        result.Md5 = res.Etag
        result.LastModified = object.LastModified

        err = s.MetaStorage.PutObject(ctx, object, oldObj, nil, nil, true)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to put object meta[object:%+v, oldObj:%+v]. err:%v\n", object, oldObj, err)
                // TODO: consistent check &amp; clean
                return ErrDBError
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (s *s3Service) checkGetObjectRights(ctx context.Context, isAdmin bool, tenantId string, bucket *pb.Bucket, object *pb.Object) (err error) <span class="cov8" title="1">{
        if !isAdmin </span><span class="cov8" title="1">{
                switch object.Acl.CannedAcl </span>{
                case "public-read", "public-read-write":<span class="cov0" title="0">
                        break</span>
                default:<span class="cov8" title="1">
                        if object.TenantId != tenantId </span><span class="cov0" title="0">{
                                err = ErrAccessDenied
                                return
                        }</span>
                }
        }
        <span class="cov8" title="1">return</span>
}

func (s *s3Service) GetObjectMeta(ctx context.Context, in *pb.Object, out *pb.GetObjectMetaResult) error <span class="cov8" title="1">{
        var err error
        defer func() </span><span class="cov8" title="1">{
                out.ErrorCode = GetErrCode(err)
        }</span>()

        <span class="cov8" title="1">bucket, err := s.MetaStorage.GetBucket(ctx, in.BucketName, true)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorln("failed to get bucket from meta storage. err:", err)
                return err
        }</span>

        <span class="cov8" title="1">object, err := s.MetaStorage.GetObject(ctx, in.BucketName, in.ObjectKey, "", true)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorln("failed to get object info from meta storage. err:", err)
                return nil
        }</span>

        <span class="cov8" title="1">isAdmin, tenantId, _, err := util.GetCredentialFromCtx(ctx)
        if err != nil </span><span class="cov0" title="0">{
                log.Error("get tenant id failed")
                err = ErrInternalError
                return nil
        }</span>

        <span class="cov8" title="1">err = s.checkGetObjectRights(ctx, isAdmin, tenantId, bucket.Bucket, object.Object)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorln("failed to check source object rights. err:", err)
                return err
        }</span>

        <span class="cov8" title="1">out.Object = object.Object
        object.StorageClass, _ = GetNameFromTier(object.Tier, utils.OSTYPE_soda)
        return nil</span>
}

func (s *s3Service) GetObject(ctx context.Context, req *pb.GetObjectInput, stream pb.S3_GetObjectStream) error <span class="cov8" title="1">{
        log.Infoln("GetObject is called in s3 service.")
        bucketName := req.Bucket
        bucket, err := s.MetaStorage.GetBucket(ctx, bucketName, true)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorln("failed to get bucket from meta storage. err:", err)
                return err
        }</span>
        <span class="cov8" title="1">if bucket.ServerSideEncryption != nil &amp;&amp; bucket.ServerSideEncryption.SseType == "SSE" </span><span class="cov8" title="1">{
                return GetEncObject(ctx, req, stream, s)
        }</span> else<span class="cov0" title="0"> {
                return GetObject(ctx, req, stream, s)
        }</span>
}

func GetObject(ctx context.Context, req *pb.GetObjectInput, stream pb.S3_GetObjectStream, s *s3Service) error <span class="cov0" title="0">{
        log.Infoln("GetObject is called in s3 service.")
        bucketName := req.Bucket
        objectName := req.Key
        offset := req.Offset
        length := req.Length

        var err error
        getObjRes := &amp;pb.GetObjectResponse{}
        defer func() </span><span class="cov0" title="0">{
                getObjRes.ErrorCode = GetErrCode(err)
                stream.SendMsg(getObjRes)
        }</span>()

        <span class="cov0" title="0">object, err := s.MetaStorage.GetObject(ctx, bucketName, objectName, "", true)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorln("failed to get object info from meta storage. err:", err)
                return err
        }</span>

        <span class="cov0" title="0">bucket, err := s.MetaStorage.GetBucket(ctx, bucketName, true)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorln("failed to get bucket from meta storage. err:", err)
                return err
        }</span>

        <span class="cov0" title="0">isAdmin, tenantId, _, err := util.GetCredentialFromCtx(ctx)
        if err != nil &amp;&amp; isAdmin == false </span><span class="cov0" title="0">{
                log.Error("get tenant id failed")
                err = ErrInternalError
                return nil
        }</span>

        <span class="cov0" title="0">err = s.checkGetObjectRights(ctx, isAdmin, tenantId, bucket.Bucket, object.Object)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorln("failed to check source object rights. err:", err)
                return err
        }</span>

        <span class="cov0" title="0">backendName := bucket.DefaultLocation
        if object.Location != "" </span><span class="cov0" title="0">{
                backendName = object.Location
        }</span>
        // if this object has only one part
        <span class="cov0" title="0">backend, err := utils.GetBackend(ctx, s.backendClient, backendName)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorln("unable to get backend. err:", err)
                return err
        }</span>
        <span class="cov0" title="0">sd, err := driver.CreateStorageDriver(backend.Type, backend)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorln("failed to create storage driver. err:", err)
                return err
        }</span>
        <span class="cov0" title="0">log.Infof("get object offset %v, length %v", offset, length)
        reader, err := sd.Get(ctx, object.Object, offset, offset+length-1)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorln("failed to get data. err:", err)
                return err
        }</span>

        <span class="cov0" title="0">eof := false
        left := object.Size
        buf := make([]byte, ChunkSize)
        for !eof &amp;&amp; left &gt; 0 </span><span class="cov0" title="0">{
                n, err := reader.Read(buf)
                if err != nil &amp;&amp; err != io.EOF </span><span class="cov0" title="0">{
                        log.Errorln("failed to read, err:", err)
                        break</span>
                }
                // From https://golang.org/pkg/io/, a Reader returning a non-zero number of bytes at the end of the input stream
                // may return either err == EOF or err == nil. The next Read should return 0, EOF.
                // If err is equal to io.EOF, a non-zero number of bytes may be returned.
                <span class="cov0" title="0">if err == io.EOF </span><span class="cov0" title="0">{
                        log.Debugln("finished read")
                        eof = true
                }</span>
                // From https://golang.org/pkg/io/, there is the following statement.
                // Implementations of Read are discouraged from returning a zero byte count with a nil error, except when len(p) ==
                // 0. Callers should treat a return of 0 and nil as indicating that nothing happened; in particular it does not indicate EOF.
                // If n is equal 0, it indicate that there is no more data to read
                <span class="cov0" title="0">if n == 0 </span><span class="cov0" title="0">{
                        log.Infoln("reader return zero bytes.")
                        break</span>
                }

                <span class="cov0" title="0">err = stream.Send(&amp;pb.GetObjectResponse{ErrorCode: int32(ErrNoErr), Data: buf[0:n]})
                if err != nil </span><span class="cov0" title="0">{
                        log.Infof("stream send error: %v\n", err)
                        break</span>
                }
                <span class="cov0" title="0">left -= int64(n)</span>
        }

        <span class="cov0" title="0">log.Infof("get object end, object:%s, left bytes:%d, err:%v\n", objectName, left, err)
        return err</span>
}

func GetEncObject(ctx context.Context, req *pb.GetObjectInput, stream pb.S3_GetObjectStream, s *s3Service) error <span class="cov8" title="1">{
        log.Infoln("GetObject is called in s3 service.")
        bucketName := req.Bucket
        objectName := req.Key
        offset := req.Offset
        length := req.Length

        var err error
        getObjRes := &amp;pb.GetObjectResponse{}
        defer func() </span><span class="cov8" title="1">{
                getObjRes.ErrorCode = GetErrCode(err)
                stream.SendMsg(getObjRes)
        }</span>()

        <span class="cov8" title="1">object, err := s.MetaStorage.GetObject(ctx, bucketName, objectName, "", true)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorln("failed to get object info from meta storage. err:", err)
                return err
        }</span>

        <span class="cov8" title="1">bucket, err := s.MetaStorage.GetBucket(ctx, bucketName, true)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorln("failed to get bucket from meta storage. err:", err)
                return err
        }</span>

        <span class="cov8" title="1">isAdmin, tenantId, _, err := util.GetCredentialFromCtx(ctx)
        if err != nil &amp;&amp; isAdmin == false </span><span class="cov0" title="0">{
                log.Error("get tenant id failed")
                err = ErrInternalError
                return nil
        }</span>

        <span class="cov8" title="1">err = s.checkGetObjectRights(ctx, isAdmin, tenantId, bucket.Bucket, object.Object)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorln("failed to check source object rights. err:", err)
                return err
        }</span>

        <span class="cov8" title="1">backendName := bucket.DefaultLocation
        if object.Location != "" </span><span class="cov8" title="1">{
                backendName = object.Location
        }</span>
        // if this object has only one part
        <span class="cov8" title="1">backend, err := utils.GetBackend(ctx, s.backendClient, backendName)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorln("unable to get backend. err:", err)
                return err
        }</span>
        <span class="cov8" title="1">sd, err := driver.CreateStorageDriver(backend.Type, backend)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorln("failed to create storage driver. err:", err)
                return err
        }</span>
        <span class="cov8" title="1">if bucket.ServerSideEncryption.SseType == "SSE" </span><span class="cov8" title="1">{
                length = object.EncSize
        }</span>
        <span class="cov8" title="1">log.Infof("get object offset %v, length %v", offset, length)
        reader, err := sd.Get(ctx, object.Object, offset, offset+length-1)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorln("failed to get data. err:", err)
                return err
        }</span>

        <span class="cov8" title="1">buf := make([]byte, object.EncSize)

        n, err := reader.Read(buf)
        if err != nil &amp;&amp; err != io.EOF </span><span class="cov0" title="0">{
                log.Errorln("failed to read, err:", err)
                return err
        }</span>
        // From https://golang.org/pkg/io/, a Reader returning a non-zero number of bytes at the end of the input stream
        // may return either err == EOF or err == nil. The next Read should return 0, EOF.
        // If err is equal to io.EOF, a non-zero number of bytes may be returned.
        <span class="cov8" title="1">if err == io.EOF </span><span class="cov8" title="1">{
                log.Debugln("finished read")
        }</span>
        // From https://golang.org/pkg/io/, there is the following statement.
        // Implementations of Read are discouraged from returning a zero byte count with a nil error, except when len(p) ==
        // 0. Callers should treat a return of 0 and nil as indicating that nothing happened; in particular it does not indicate EOF.
        // If n is equal 0, it indicate that there is no more data to read
        <span class="cov8" title="1">if n == 0 </span><span class="cov0" title="0">{
                log.Infoln("reader return zero bytes.")
                return err
        }</span>

        // decrypt and write
        <span class="cov8" title="1">decErr, decBytes := utils.DecryptWithAES256(buf[0:object.EncSize], bucket.ServerSideEncryption.EncryptionKey)
        if decErr != nil </span><span class="cov0" title="0">{
                log.Errorln("failed to decrypt data. err:", decErr)
                return decErr
        }</span>
        <span class="cov8" title="1">log.Infoln("successfully decrypted")
        buf = decBytes
        n = binary.Size(decBytes)

        err = stream.Send(&amp;pb.GetObjectResponse{ErrorCode: int32(ErrNoErr), Data: buf[0:n]})
        if err != nil </span><span class="cov0" title="0">{
                log.Infof("stream send error: %v\n", err)
                return err
        }</span>

        <span class="cov8" title="1">log.Infoln("get object successfully")
        return err</span>
}

func (s *s3Service) UpdateObjectMeta(ctx context.Context, in *pb.Object, out *pb.PutObjectResponse) error <span class="cov0" title="0">{
        log.Infoln("UpdateObjectMeta is called in s3 service.")
        var err error
        defer func() </span><span class="cov0" title="0">{
                out.ErrorCode = GetErrCode(err)
        }</span>()

        <span class="cov0" title="0">object, err := s.MetaStorage.GetObject(ctx, in.BucketName, in.ObjectKey, "", true)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorln("failed to get object info from meta storage. err:", err)
                return err
        }</span>
        <span class="cov0" title="0">_, _, _, err = CheckRights(ctx, object.TenantId)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorln("failed to check rights, err:", err)
                return err
        }</span>

        <span class="cov0" title="0">err = s.MetaStorage.UpdateObjectMeta(&amp;meta.Object{Object: in})
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to update object meta storage, err:", err)
                err = ErrInternalError
                return err
        }</span>
        <span class="cov0" title="0">out.LastModified = in.LastModified
        out.Md5 = in.Etag
        out.VersionId = in.GetVersionId()

        return nil</span>
}

func (s *s3Service) CopyObject(ctx context.Context, in *pb.CopyObjectRequest, out *pb.CopyObjectResponse) error <span class="cov0" title="0">{
        log.Infoln("CopyObject is called in s3 service.")
        var err error
        defer func() </span><span class="cov0" title="0">{
                out.ErrorCode = GetErrCode(err)
        }</span>()

        <span class="cov0" title="0">srcBucketName := in.SrcBucketName
        srcObjectName := in.SrcObjectName
        targetBucketName := in.TargetBucketName
        targetObjectName := in.TargetObjectName
        targetBucket, err := s.MetaStorage.GetBucket(ctx, targetBucketName, true)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorln("get bucket failed with err:", err)
                return err
        }</span>

        <span class="cov0" title="0">isAdmin, tenantId, _, err := util.GetCredentialFromCtx(ctx)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("get credential faied, err:%v\n", err)
                return err
        }</span>

        <span class="cov0" title="0">if !isAdmin </span><span class="cov0" title="0">{
                switch targetBucket.Acl.CannedAcl </span>{
                case "public-read-write":<span class="cov0" title="0">
                        break</span>
                default:<span class="cov0" title="0">
                        if targetBucket.TenantId != tenantId </span><span class="cov0" title="0">{
                                err = ErrBucketAccessForbidden
                                return err
                        }</span>
                }
        }

        <span class="cov0" title="0">srcBucket, err := s.MetaStorage.GetBucket(ctx, srcBucketName, true)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorln("get bucket failed with err:", err)
                return err
        }</span>
        <span class="cov0" title="0">srcObject, err := s.MetaStorage.GetObject(ctx, srcBucketName, srcObjectName, "", true)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorln("failed to get object info from meta storage. err:", err)
                return err
        }</span>

        <span class="cov0" title="0">err = s.checkGetObjectRights(ctx, isAdmin, tenantId, srcBucket.Bucket, srcObject.Object)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorln("failed to check source object rights. err:", err)
                return err
        }</span>

        <span class="cov0" title="0">backendName := srcBucket.DefaultLocation
        if srcObject.Location != "" </span><span class="cov0" title="0">{
                backendName = srcObject.Location
        }</span>
        <span class="cov0" title="0">srcBackend, err := utils.GetBackend(ctx, s.backendClient, backendName)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorln("failed to get backend client with err:", err)
                return err
        }</span>
        <span class="cov0" title="0">srcSd, err := driver.CreateStorageDriver(srcBackend.Type, srcBackend)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorln("failed to create storage. err:", err)
                return err
        }</span>

        <span class="cov0" title="0">targetBackendName := targetBucket.DefaultLocation
        targetBackend, err := utils.GetBackend(ctx, s.backendClient, targetBackendName)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorln("failed to get backend client with err:", err)
                return err
        }</span>
        // get old object meta if it exist
        <span class="cov0" title="0">oldObj, err := s.MetaStorage.GetObject(ctx, targetBucketName, targetObjectName, "", false)
        if err != nil &amp;&amp; err != ErrNoSuchKey </span><span class="cov0" title="0">{
                log.Errorf("get object[%s] failed, err:%v\n", targetObjectName, err)
                return ErrInternalError
        }</span>
        <span class="cov0" title="0">log.Debugf("existObj=%v, err=%v\n", oldObj, err)
        targetSd, err := driver.CreateStorageDriver(targetBackend.Type, targetBackend)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorln("failed to create storage. err:", err)
                return err
        }</span>
        <span class="cov0" title="0">log.Debugf("***ctx:%+v\n", ctx)
        reader, err := srcSd.Get(ctx, srcObject.Object, 0, srcObject.Size-1)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorln("failed to put data. err:", err)
                return err
        }</span>
        <span class="cov0" title="0">limitedDataReader := io.LimitReader(reader, srcObject.Size)

        targetObject := &amp;pb.Object{
                ObjectKey:  targetObjectName,
                BucketName: targetBucketName,
                Size:       srcObject.Size,
        }
        if oldObj != nil &amp;&amp; oldObj.Location == targetBackendName </span><span class="cov0" title="0">{
                targetObject.StorageMeta = oldObj.StorageMeta
                targetObject.ObjectId = oldObj.ObjectId
        }</span>
        <span class="cov0" title="0">ctx = context.WithValue(ctx, dscommon.CONTEXT_KEY_SIZE, srcObject.Size)
        res, err := targetSd.Put(ctx, limitedDataReader, targetObject)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorln("failed to put data. err:", err)
                return err
        }</span>
        <span class="cov0" title="0">if res.Written &lt; srcObject.Size </span><span class="cov0" title="0">{
                // TODO: delete incomplete object at backend
                log.Warnf("write objects, already written(%d), total size(%d)\n", res.Written, srcObject.Size)
                err = ErrIncompleteBody
                return err
        }</span>

        <span class="cov0" title="0">targetObject.Etag = res.Etag
        targetObject.ObjectId = res.ObjectId
        targetObject.LastModified = time.Now().UTC().Unix()
        targetObject.ContentType = srcObject.ContentType
        targetObject.DeleteMarker = false
        targetObject.CustomAttributes = srcObject.CustomAttributes
        targetObject.Type = meta.ObjectTypeNormal
        targetObject.StorageMeta = res.Meta
        targetObject.Location = targetBackendName
        targetObject.TenantId = tenantId
        // this is the default acl setting
        targetObject.Acl = &amp;pb.Acl{CannedAcl: "private"}
        // we only support copy data with sse but not support copy data without sse right now
        targetObject.ServerSideEncryption = srcObject.ServerSideEncryption

        err = s.MetaStorage.PutObject(ctx, &amp;meta.Object{Object: targetObject}, oldObj, nil, nil, true)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to put object meta[object:%+v, oldObj:%+v]. err:%v\n", targetObject, oldObj, err)
                // TODO: consistent check &amp; clean
                err = ErrDBError
                return err
        }</span>

        <span class="cov0" title="0">out.Md5 = res.Etag
        out.LastModified = targetObject.LastModified

        log.Infoln("Successfully copy object ", res.Written, " bytes.")
        return nil</span>
}

func initTargeObject(ctx context.Context, in *pb.MoveObjectRequest, srcObject *pb.Object) (*pb.Object, error) <span class="cov0" title="0">{
        md, ok := metadata.FromContext(ctx)
        if !ok </span><span class="cov0" title="0">{
                log.Error("get metadata from ctx failed.")
                return nil, ErrInternalError
        }</span>

        <span class="cov0" title="0">targetObject := &amp;pb.Object{
                ObjectKey:            srcObject.ObjectKey,
                BucketName:           srcObject.BucketName,
                ObjectId:             srcObject.ObjectId,
                Size:                 srcObject.Size,
                Etag:                 srcObject.Etag,
                Location:             srcObject.Location,
                Tier:                 srcObject.Tier,
                TenantId:             srcObject.TenantId,
                UserId:               srcObject.UserId,
                StorageMeta:          srcObject.StorageMeta,
                LastModified:         srcObject.LastModified,
                ContentType:          srcObject.ContentType,
                ServerSideEncryption: srcObject.ServerSideEncryption,
                Acl:                  srcObject.Acl,
                Type:                 srcObject.Type,
                DeleteMarker:         false,
                CustomAttributes:     md, /* TODO: only reserve http header attr*/
        }

        if in.TargetTier &gt; 0 </span><span class="cov0" title="0">{
                targetObject.Tier = in.TargetTier
        }</span>

        <span class="cov0" title="0">return targetObject, nil</span>
}

// This is for lifecycle management.
func (s *s3Service) MoveObject(ctx context.Context, in *pb.MoveObjectRequest, out *pb.MoveObjectResponse) error <span class="cov0" title="0">{
        log.Infoln("MoveObject is called in s3 service.")

        err := s.checkMoveRequest(ctx, in)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">srcObject, err := s.MetaStorage.GetObject(ctx, in.SrcBucket, in.SrcObject, in.SrcObjectVersion, true)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to get object[%s] of bucket[%s]. err:%v\n", in.SrcObject, in.SrcBucket, err)
                return err
        }</span>

        <span class="cov0" title="0">targetObject, err := initTargeObject(ctx, in, srcObject.Object)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to get init target obejct. err:%v\n", err)
                return err
        }</span>

        <span class="cov0" title="0">var srcSd, targetSd driver.StorageDriver
        var srcBucket, targetBucket *types.Bucket
        srcBucket, err = s.MetaStorage.GetBucket(ctx, in.SrcBucket, true)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("get source bucket[%s] failed with err:%v", in.SrcBucket, err)
                return err
        }</span>

        <span class="cov0" title="0">srcBackend, err := utils.GetBackend(ctx, s.backendClient, srcObject.Location)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorln("failed to get backend client with err:", err)
                return err
        }</span>
        <span class="cov0" title="0">srcSd, err = driver.CreateStorageDriver(srcBackend.Type, srcBackend)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorln("failed to create storage. err:", err)
                return err
        }</span>

        <span class="cov0" title="0">if in.MoveType == utils.MoveType_ChangeStorageTier </span><span class="cov0" title="0">{
                log.Infof("chagne storage class of %s\n", targetObject.ObjectKey)
                // just change storage tier
                targetBucket = srcBucket
                className, err := GetNameFromTier(in.TargetTier, srcBackend.Type)
                if err != nil </span><span class="cov0" title="0">{
                        return ErrInternalError
                }</span>
                <span class="cov0" title="0">err = srcSd.ChangeStorageClass(ctx, targetObject, &amp;className)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("change storage class of object[%s] failed, err:%v\n", targetObject.ObjectKey, err)
                        return err
                }</span>
                <span class="cov0" title="0">newObj := &amp;meta.Object{Object: targetObject}
                err = s.MetaStorage.UpdateObject4Lifecycle(ctx, srcObject, newObj, nil)</span>
        } else<span class="cov0" title="0"> {
                // need move data, get target location first
                if in.MoveType == utils.MoveType_ChangeLocation </span><span class="cov0" title="0">{
                        targetBucket = srcBucket
                        targetObject.Location = in.TargetLocation
                        log.Infof("move %s cross backends, srcBackend=%s, targetBackend=%s, targetTier=%d\n",
                                srcObject.ObjectKey, srcObject.Location, targetObject.Location, targetObject.Tier)
                }</span> else<span class="cov0" title="0"> { // MoveType_MoveCrossBuckets
                        log.Infof("move %s from bucket[%s] to bucket[%s]\n", targetObject.ObjectKey, srcObject.BucketName,
                                targetObject.BucketName)
                        targetBucket, err = s.MetaStorage.GetBucket(ctx, in.TargetBucket, true)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Errorf("get bucket[%s] failed with err:%v\n", in.TargetBucket, err)
                                return err
                        }</span>
                        <span class="cov0" title="0">targetObject.ObjectKey = in.TargetObject
                        targetObject.Location = targetBucket.DefaultLocation
                        targetObject.BucketName = targetBucket.Name
                        log.Infof("move %s cross buckets, targetBucket=%s, targetBackend=%s, targetTier=%d\n",
                                srcObject.ObjectKey, targetObject.BucketName, targetObject.Location, targetObject.Tier)</span>
                }

                // get storage driver
                <span class="cov0" title="0">targetBackend, err := utils.GetBackend(ctx, s.backendClient, targetObject.Location)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorln("failed to get backend client with err:", err)
                        return err
                }</span>
                <span class="cov0" title="0">targetSd, err = driver.CreateStorageDriver(targetBackend.Type, targetBackend)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorln("failed to create storage. err:", err)
                        return err
                }</span>

                // copy data from one backend to another
                <span class="cov0" title="0">err = s.copyData(ctx, srcSd, targetSd, srcObject.Object, targetObject)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("failed to copy object[%s], err:%v", srcObject.ObjectKey, err)
                        return err
                }</span>
                <span class="cov0" title="0">newObj := &amp;meta.Object{Object: targetObject}
                if srcObject.Etag != targetObject.Etag </span><span class="cov0" title="0">{
                        log.Errorf("data integrity check failed, etag of source object is %s, etag of target object is:%s\n",
                                srcObject.Etag, targetObject.Etag)
                        // if failed, delete target object
                        s.cleanObject(ctx, newObj, targetSd)
                        return err
                }</span>
                <span class="cov0" title="0">out.Md5 = targetObject.Etag
                out.LastModified = targetObject.LastModified
                // update object meta data
                err = s.MetaStorage.UpdateObject4Lifecycle(ctx, srcObject, newObj, nil)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorln("failed to update meta data after copy, err:", err)
                        // if failed, delete target object
                        s.cleanObject(ctx, newObj, targetSd)
                        return err
                }</span>
                // delete source object
                <span class="cov0" title="0">s.cleanObject(ctx, srcObject, srcSd)
                log.Infof("delete source object[key=%s]\n", srcObject.ObjectKey)</span>
        }

        <span class="cov0" title="0">log.Infoln("MoveObject is finished.")

        return nil</span>
}

func (s *s3Service) copyData(ctx context.Context, srcSd, targetSd driver.StorageDriver, srcObj, targetObj *pb.Object) error <span class="cov0" title="0">{
        log.Infof("copy object data")
        reader, err := srcSd.Get(ctx, srcObj, 0, srcObj.Size-1)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorln("failed to get data. err:", err)
                return err
        }</span>
        <span class="cov0" title="0">limitedDataReader := io.LimitReader(reader, srcObj.Size)
        res, err := targetSd.Put(ctx, limitedDataReader, targetObj)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorln("failed to put data. err:", err)
                return err
        }</span>
        <span class="cov0" title="0">log.Infoln("Successfully copy ", res.Written, " bytes.")

        targetObj.Etag = res.Etag
        targetObj.ObjectId = res.ObjectId
        targetObj.StorageMeta = res.Meta

        return nil</span>
}

func (s *s3Service) checkMoveRequest(ctx context.Context, in *pb.MoveObjectRequest) (err error) <span class="cov0" title="0">{
        log.Infoln("check copy request")

        if in.SrcBucket == "" || in.SrcObject == "" </span><span class="cov0" title="0">{
                log.Errorf("invalid copy source.")
                err = ErrInvalidCopySource
                return
        }</span>

        <span class="cov0" title="0">switch in.MoveType </span>{
        case utils.MoveType_ChangeStorageTier:<span class="cov0" title="0">
                if !validTier(in.TargetTier) </span><span class="cov0" title="0">{
                        log.Error("cannot copy object to it's self.")
                        err = ErrInvalidCopyDest
                }</span>
        case utils.MoveType_ChangeLocation:<span class="cov0" title="0">
                if in.TargetLocation == "" </span><span class="cov0" title="0">{
                        log.Errorf("no target lcoation provided for change location copy")
                        err = ErrInvalidCopyDest
                }</span>
                // in.TargetTier &gt; 0 means need to change storage class
                <span class="cov0" title="0">if in.TargetTier &gt; 0 </span><span class="cov0" title="0">{
                        if !validTier(in.TargetTier) </span><span class="cov0" title="0">{
                                log.Error("cannot copy object to it's self.")
                                err = ErrInvalidCopyDest
                        }</span>
                }
        case utils.MoveType_MoveCrossBuckets:<span class="cov0" title="0"></span>
        default:<span class="cov0" title="0">
                // copy cross buckets as default
                if in.TargetObject == "" || in.TargetBucket == "" </span><span class="cov0" title="0">{
                        log.Errorf("invalid copy target")
                        err = ErrInvalidCopyDest
                        return
                }</span>
                // in.TargetTier &gt; 0 means need to change storage class
                <span class="cov0" title="0">if in.TargetTier &gt; 0 </span><span class="cov0" title="0">{
                        if !validTier(in.TargetTier) </span><span class="cov0" title="0">{
                                log.Error("cannot copy object to it's self.")
                                err = ErrInvalidCopyDest
                        }</span>
                }
        }

        <span class="cov0" title="0">log.Infof("MoveType:%d, srcObject:%v\n", in.MoveType, in.SrcObject)
        return</span>
}

// When bucket versioning is Disabled/Enabled/Suspended, and request versionId is set/unset:
//
// |           |        with versionId        |                   without versionId                    |
// |-----------|------------------------------|--------------------------------------------------------|
// | Disabled  | error                        | remove object                                          |
// | Enabled   | remove corresponding version | add a delete marker                                    |
// | Suspended | remove corresponding version | remove null version object(if exists) and add a        |
// |           |                              | null version delete marker                             |
//
// See http://docs.aws.amazon.com/AmazonS3/latest/dev/Versioning.html
func (s *s3Service) DeleteObject(ctx context.Context, in *pb.DeleteObjectInput, out *pb.DeleteObjectOutput) error <span class="cov0" title="0">{
        log.Infoln("DeleteObject is called in s3 service, bucket:%s, key:%s, version:%s", in.Bucket, in.Key, in.VersioId)

        var err error
        defer func() </span><span class="cov0" title="0">{
                out.ErrorCode = GetErrCode(err)
        }</span>()

        <span class="cov0" title="0">bucket, err := s.MetaStorage.GetBucket(ctx, in.Bucket, true)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorln("get bucket failed with err:", err)
                return nil
        }</span>

        <span class="cov0" title="0">object, err := s.MetaStorage.GetObject(ctx, in.Bucket, in.Key, in.VersioId, true)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorln("failed to get object info from meta storage. err:", err)
                return err
        }</span>
        <span class="cov0" title="0">isAdmin, tenantId, _, err := CheckRights(ctx, object.TenantId)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("no rights to access the object[%s]\n", object.ObjectKey)
                return nil
        }</span>

        // administrator can delete any resource
        <span class="cov0" title="0">if isAdmin == false </span><span class="cov0" title="0">{
                switch bucket.Acl.CannedAcl </span>{
                case "public-read-write":<span class="cov0" title="0">
                        break</span>
                default:<span class="cov0" title="0">
                        if bucket.TenantId != tenantId &amp;&amp; tenantId != "" </span><span class="cov0" title="0">{
                                log.Errorf("delete object failed: tenant[id=%s] has no access right.", tenantId)
                                err = ErrBucketAccessForbidden
                                return nil
                        }</span>
                } // TODO policy and fancy ACL
        }

        <span class="cov0" title="0">switch bucket.Versioning.Status </span>{
        case utils.VersioningDisabled:<span class="cov0" title="0">
                err = s.removeObject(ctx, bucket, object)</span>
        case utils.VersioningEnabled:<span class="cov0" title="0">
                // TODO: versioning
                err = ErrInternalError</span>
        case utils.VersioningSuspended:<span class="cov0" title="0">
                // TODO: versioning
                err = ErrInternalError</span>
        default:<span class="cov0" title="0">
                log.Errorf("versioing of bucket[%s] is invalid:%s\n", bucket.Name, bucket.Versioning)
                err = ErrInternalError</span>
        }

        // TODO: need to refresh cache if it is enabled

        <span class="cov0" title="0">return nil</span>
}

func (s *s3Service) removeObject(ctx context.Context, bucket *meta.Bucket, obj *Object) error <span class="cov0" title="0">{
        if obj == nil </span><span class="cov0" title="0">{
                log.Infof("no need remove")
                return nil
        }</span>
        <span class="cov0" title="0">log.Infof("remove object[%s] from bucket[%s]\n", obj.ObjectKey, bucket.Name)
        backendName := bucket.DefaultLocation
        if obj.Location != "" </span><span class="cov0" title="0">{
                backendName = obj.Location
        }</span>
        <span class="cov0" title="0">backend, err := utils.GetBackend(ctx, s.backendClient, backendName)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorln("failed to get backend with err:", err)
                return err
        }</span>
        <span class="cov0" title="0">sd, err := driver.CreateStorageDriver(backend.Type, backend)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorln("failed to create storage, err:", err)
                return err
        }</span>

        // mark object as deleted
        <span class="cov0" title="0">err = s.MetaStorage.MarkObjectAsDeleted(ctx, obj)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorln("failed to mark object as deleted, err:", err)
                return err
        }</span>

        // delete object data in backend
        <span class="cov0" title="0">err = sd.Delete(ctx, &amp;pb.DeleteObjectInput{Bucket: bucket.Name, Key: obj.ObjectKey, VersioId: obj.VersionId,
                ETag: obj.Etag, StorageMeta: obj.StorageMeta, ObjectId: obj.ObjectId})
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to delete obejct[%s,versionid=%s] from backend storage, err:%v\n", obj.ObjectKey, obj.VersionId, err)
                return err
        }</span> else<span class="cov0" title="0"> {
                log.Infof("delete obejct[%s,versionid=%s] from backend storage successfully.\n", obj.ObjectKey, obj.VersionId)
        }</span>

        // delete object meta data from database
        <span class="cov0" title="0">err = s.MetaStorage.DeleteObject(ctx, obj)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to delete obejct[key=%s,versionid=%s] metadata, err:%v", obj.ObjectKey, obj.VersionId, err)
        }</span> else<span class="cov0" title="0"> {
                log.Infof("delete obejct[key=%s,versionid=%s] metadata successfully.", obj.ObjectKey, obj.VersionId)
        }</span>

        <span class="cov0" title="0">return err</span>
}

func (s *s3Service) ListObjects(ctx context.Context, in *pb.ListObjectsRequest, out *pb.ListObjectsResponse) error <span class="cov8" title="1">{
        log.Infof("ListObject is called in s3 service, bucket is %s.\n", in.Bucket)
        var err error
        defer func() </span><span class="cov8" title="1">{
                out.ErrorCode = GetErrCode(err)
        }</span>()
        // Check ACL
        <span class="cov8" title="1">bucket, err := s.MetaStorage.GetBucket(ctx, in.Bucket, true)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("err:%v\n", err)
                return nil
        }</span>

        <span class="cov8" title="1">isAdmin, tenantId, _, err := util.GetCredentialFromCtx(ctx)
        if err != nil </span><span class="cov0" title="0">{
                log.Error("get tenant id failed")
                err = ErrInternalError
                return nil
        }</span>

        // administrator can get any resource
        <span class="cov8" title="1">if isAdmin == false </span><span class="cov8" title="1">{
                switch bucket.Acl.CannedAcl </span>{
                case "public-read", "public-read-write":<span class="cov0" title="0">
                        break</span>
                default:<span class="cov8" title="1">
                        if bucket.TenantId != tenantId </span><span class="cov0" title="0">{
                                log.Errorf("tenantId(%s) does not much bucket.TenantId(%s)", tenantId, bucket.TenantId)
                                err = ErrBucketAccessForbidden
                                return nil
                        }</span>
                }
                // TODO validate user policy and ACL
        }

        <span class="cov8" title="1">retObjects, appendInfo, err := s.ListObjectsInternal(ctx, in)
        if appendInfo.Truncated &amp;&amp; len(appendInfo.NextMarker) != 0 </span><span class="cov0" title="0">{
                out.NextMarker = appendInfo.NextMarker
        }</span>
        <span class="cov8" title="1">if in.Version == constants.ListObjectsType2Int </span><span class="cov0" title="0">{
                out.NextMarker = util.Encrypt(out.NextMarker)
        }</span>

        <span class="cov8" title="1">objects := make([]*pb.Object, 0, len(retObjects))
        for _, obj := range retObjects </span><span class="cov8" title="1">{
                object := pb.Object{
                        LastModified:     obj.LastModified,
                        Etag:             obj.Etag,
                        Size:             obj.Size,
                        Tier:             obj.Tier,
                        Location:         obj.Location,
                        TenantId:         obj.TenantId,
                        BucketName:       obj.BucketName,
                        VersionId:        obj.VersionId,
                        CustomAttributes: obj.CustomAttributes,
                        ContentType:      obj.ContentType,
                        StorageMeta:      obj.StorageMeta,
                }
                if in.EncodingType != "" </span><span class="cov0" title="0">{ // only support "url" encoding for now
                        object.ObjectKey = url.QueryEscape(obj.ObjectKey)
                }</span> else<span class="cov8" title="1"> {
                        object.ObjectKey = obj.ObjectKey
                }</span>
                <span class="cov8" title="1">object.StorageClass, _ = GetNameFromTier(obj.Tier, utils.OSTYPE_soda)
                objects = append(objects, &amp;object)
                log.Debugf("object:%+v\n", object)</span>
        }
        <span class="cov8" title="1">out.Objects = objects
        out.Prefixes = appendInfo.Prefixes
        out.IsTruncated = appendInfo.Truncated

        if in.EncodingType != "" </span><span class="cov0" title="0">{ // only support "url" encoding for now
                out.Prefixes = helper.Map(out.Prefixes, func(s string) string </span><span class="cov0" title="0">{
                        return url.QueryEscape(s)
                }</span>)
                <span class="cov0" title="0">out.NextMarker = url.QueryEscape(out.NextMarker)</span>
        }

        <span class="cov8" title="1">err = ErrNoErr
        return nil</span>
}

func (s *s3Service) ListObjectsInternal(ctx context.Context, request *pb.ListObjectsRequest) (retObjects []*meta.Object,
        appendInfo utils.ListObjsAppendInfo, err error) <span class="cov8" title="1">{
        log.Infoln("Prefix:", request.Prefix, "Marker:", request.Marker, "MaxKeys:",
                request.MaxKeys, "Delimiter:", request.Delimiter, "Version:", request.Version,
                "keyMarker:", request.KeyMarker, "versionIdMarker:", request.VersionIdMarker)

        filt := make(map[string]string)
        if request.Versioned </span><span class="cov0" title="0">{
                filt[common.KMarker] = request.KeyMarker
                filt[common.KVerMarker] = request.VersionIdMarker
        }</span> else<span class="cov8" title="1"> if request.Version == constants.ListObjectsType2Int </span><span class="cov0" title="0">{
                if request.ContinuationToken != "" </span><span class="cov0" title="0">{
                        var marker string
                        marker, err = util.Decrypt(request.ContinuationToken)
                        if err != nil </span><span class="cov0" title="0">{
                                err = ErrInvalidContinuationToken
                                return
                        }</span>
                        <span class="cov0" title="0">filt[common.KMarker] = marker</span>
                } else<span class="cov0" title="0"> {
                        filt[common.KMarker] = request.StartAfter
                }</span>
        } else<span class="cov8" title="1"> { // version 1
                filt[common.KMarker] = request.Marker
        }</span>

        <span class="cov8" title="1">filt[common.KPrefix] = request.Prefix
        filt[common.KDelimiter] = request.Delimiter
        // currentlly, request.Filter only support filter by 'lastmodified' and 'tier'
        for k, v := range request.Filter </span><span class="cov0" title="0">{
                filt[k] = v
        }</span>

        <span class="cov8" title="1">return s.MetaStorage.Db.ListObjects(ctx, request.Bucket, request.Versioned, int(request.MaxKeys), filt)</span>
}

func (s *s3Service) cleanObject(ctx context.Context, object *Object, sd driver.StorageDriver) error <span class="cov0" title="0">{
        delInput := &amp;pb.DeleteObjectInput{
                Bucket: object.BucketName, Key: object.ObjectKey, ObjectId: object.ObjectId,
                VersioId: object.VersionId, StorageMeta: object.StorageMeta,
        }

        err := sd.Delete(ctx, delInput)
        if err != nil </span><span class="cov0" title="0">{
                log.Warnf("clean object[%v] from backend failed, err:%v\n", err)
                ierr := s.MetaStorage.AddGcobjRecord(ctx, object)
                if ierr != nil </span><span class="cov0" title="0">{
                        log.Warnf("add gc record failed, object:%v, err:%v\n", object, ierr)
                }</span>
        }

        <span class="cov0" title="0">return err</span>
}

func (s *s3Service) PutObjACL(ctx context.Context, in *pb.PutObjACLRequest, out *pb.BaseResponse) error <span class="cov0" title="0">{
        log.Info("PutObjACL is called in s3 service.")
        var err error
        defer func() </span><span class="cov0" title="0">{
                out.ErrorCode = GetErrCode(err)
        }</span>()

        <span class="cov0" title="0">bucket, err := s.MetaStorage.GetBucket(ctx, in.ACLConfig.BucketName, true)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to get bucket meta. err: %v\n", err)
                return err
        }</span>

        <span class="cov0" title="0">isAdmin, tenantId, _, err := util.GetCredentialFromCtx(ctx)
        if err != nil &amp;&amp; isAdmin == false </span><span class="cov0" title="0">{
                log.Error("get tenant id failed")
                err = ErrInternalError
                return nil
        }</span>

        // administrator can get any resource
        <span class="cov0" title="0">if isAdmin == false </span><span class="cov0" title="0">{
                switch bucket.Acl.CannedAcl </span>{
                case "bucket-owner-full-control":<span class="cov0" title="0">
                        if bucket.TenantId != tenantId </span><span class="cov0" title="0">{
                                err = ErrAccessDenied
                                return err
                        }</span>
                default:<span class="cov0" title="0">
                        if bucket.TenantId != tenantId </span><span class="cov0" title="0">{
                                err = ErrAccessDenied
                                return err
                        }</span>
                }
                // TODO validate user policy and ACL
        }

        <span class="cov0" title="0">object, err := s.MetaStorage.GetObject(ctx, in.ACLConfig.BucketName, in.ACLConfig.ObjectKey, "", true)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorln("failed to get object info from meta storage. err:", err)
                return err
        }</span>
        <span class="cov0" title="0">object.Acl = &amp;pb.Acl{CannedAcl: in.ACLConfig.CannedAcl}
        err = s.MetaStorage.UpdateObjectMeta(object)
        if err != nil </span><span class="cov0" title="0">{
                log.Infoln("failed to update object meta. err:", err)
                return err
        }</span>

        <span class="cov0" title="0">log.Infoln("Put object acl successfully.")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file159" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package service

import (
        "context"
        "fmt"
        "github.com/soda/multi-cloud/s3/pkg/utils"
        "os"
        "strconv"

        "github.com/Azure/azure-storage-blob-go/azblob"
        "github.com/micro/go-micro/client"
        "github.com/soda/multi-cloud/api/pkg/utils/obs"
        backend "github.com/soda/multi-cloud/backend/proto"
        . "github.com/soda/multi-cloud/s3/error"
        "github.com/soda/multi-cloud/s3/pkg/db"
        "github.com/soda/multi-cloud/s3/pkg/gc"
        "github.com/soda/multi-cloud/s3/pkg/helper"
        "github.com/soda/multi-cloud/s3/pkg/meta"
        "github.com/soda/multi-cloud/s3/pkg/meta/util"
        . "github.com/soda/multi-cloud/s3/pkg/utils"
        pb "github.com/soda/multi-cloud/s3/proto"
        log "github.com/sirupsen/logrus"
)

type Int2String map[int32]string
type String2Int map[string]int32

// map from cloud vendor name to a map, which is used to map from internal tier to it's storage class name.
var Int2ExtTierMap map[string]*Int2String

// map from cloud vendor name to a map, which is used to map from storage class name to internal tier.
var Ext2IntTierMap map[string]*String2Int

// map from a specific tier to an array of tiers, that means transition can happens from the specific tier to those tiers in the array.
var TransitionMap map[int32][]int32
var SupportedClasses []pb.StorageClass

type s3Service struct {
        MetaStorage   *meta.Meta
        backendClient backend.BackendService
}

func NewS3Service() pb.S3Handler <span class="cov8" title="1">{
        host := os.Getenv("DB_HOST")
        dbstor := Database{Credential: "unkonwn", Driver: "tidb", Endpoint: host}
        db.Init(&amp;dbstor)

        initStorageClass()
        cfg := meta.MetaConfig{
                CacheType: meta.CacheType(helper.CONFIG.MetaCacheType),
                TidbInfo:  helper.CONFIG.TidbInfo,
        }

        ctx, cancelFunc := context.WithCancel(context.Background())
        metaStor := meta.New(cfg)
        gc.Init(ctx, cancelFunc, metaStor)
        return &amp;s3Service{
                MetaStorage:   metaStor,
                backendClient: backend.NewBackendService("backend", client.DefaultClient),
        }
}</span>

func GetNameFromTier(tier int32, backendType string) (string, error) <span class="cov8" title="1">{
        v, ok := Int2ExtTierMap[backendType]
        if !ok </span><span class="cov0" title="0">{
                log.Errorf("get storage class of failed, no such backend type:%s.\n", backendType)
                return "", ErrInternalError
        }</span>

        <span class="cov8" title="1">v2, ok := (*v)[tier]
        if !ok </span><span class="cov0" title="0">{
                log.Errorf("get storage class of tier[%d] failed, backendType=%s.\n", tier, backendType)
                return "", ErrInternalError
        }</span>

        <span class="cov8" title="1">log.Infof("storage class of tier[%d] for backend type[%s] is %s.\n", tier, backendType, v2)
        return v2, nil</span>
}

func loadAWSDefault(i2e *map[string]*Int2String, e2i *map[string]*String2Int) <span class="cov8" title="1">{
        t2n := make(Int2String)
        t2n[Tier1] = AWS_STANDARD
        t2n[Tier99] = AWS_STANDARD_IA
        t2n[Tier999] = AWS_GLACIER
        (*i2e)[OSTYPE_AWS] = &amp;t2n

        n2t := make(String2Int)
        n2t[AWS_STANDARD] = Tier1
        n2t[AWS_STANDARD_IA] = Tier99
        n2t[AWS_GLACIER] = Tier999
        (*e2i)[OSTYPE_AWS] = &amp;n2t
}</span>

func loadsodaDefault(i2e *map[string]*Int2String, e2i *map[string]*String2Int) <span class="cov8" title="1">{
        t2n := make(Int2String)
        t2n[Tier1] = AWS_STANDARD
        t2n[Tier99] = AWS_STANDARD_IA
        t2n[Tier999] = AWS_GLACIER
        (*i2e)[OSTYPE_soda] = &amp;t2n

        n2t := make(String2Int)
        n2t[AWS_STANDARD] = Tier1
        n2t[AWS_STANDARD_IA] = Tier99
        n2t[AWS_GLACIER] = Tier999
        (*e2i)[OSTYPE_soda] = &amp;n2t
}</span>

func loadAzureDefault(i2e *map[string]*Int2String, e2i *map[string]*String2Int) <span class="cov8" title="1">{
        t2n := make(Int2String)
        t2n[Tier1] = string(azblob.AccessTierHot)
        t2n[Tier99] = string(azblob.AccessTierCool)
        t2n[Tier999] = string(azblob.AccessTierArchive)
        (*i2e)[OSTYPE_Azure] = &amp;t2n

        n2t := make(String2Int)
        n2t[string(azblob.AccessTierHot)] = Tier1
        n2t[string(azblob.AccessTierCool)] = Tier99
        n2t[string(string(azblob.AccessTierArchive))] = Tier999
        (*e2i)[OSTYPE_Azure] = &amp;n2t
}</span>

func loadHWDefault(i2e *map[string]*Int2String, e2i *map[string]*String2Int) <span class="cov8" title="1">{
        t2n := make(Int2String)
        t2n[Tier1] = string(obs.StorageClassStandard)
        t2n[Tier99] = string(obs.StorageClassWarm)
        t2n[Tier999] = string(obs.StorageClassCold)
        (*i2e)[OSTYPE_OBS] = &amp;t2n

        n2t := make(String2Int)
        n2t[string(obs.StorageClassStandard)] = Tier1
        n2t[string(obs.StorageClassWarm)] = Tier99
        n2t[string(obs.StorageClassCold)] = Tier999
        (*e2i)[OSTYPE_OBS] = &amp;n2t
}</span>

func loadGCPDefault(i2e *map[string]*Int2String, e2i *map[string]*String2Int) <span class="cov8" title="1">{
        t2n := make(Int2String)
        t2n[Tier1] = GCS_MULTI_REGIONAL
        //t2n[Tier99] = GCS_NEARLINE
        //t2n[Tier999] = GCS_COLDLINE
        (*i2e)[OSTYPE_GCS] = &amp;t2n

        n2t := make(String2Int)
        n2t[GCS_MULTI_REGIONAL] = Tier1
        //n2t[GCS_NEARLINE] = Tier99
        //n2t[GCS_COLDLINE] = Tier999
        (*e2i)[OSTYPE_GCS] = &amp;n2t
}</span>

func loadCephDefault(i2e *map[string]*Int2String, e2i *map[string]*String2Int) <span class="cov8" title="1">{
        t2n := make(Int2String)
        t2n[Tier1] = CEPH_STANDARD
        (*i2e)[OSTYPE_CEPH] = &amp;t2n

        n2t := make(String2Int)
        n2t[CEPH_STANDARD] = Tier1
        (*e2i)[OSTYPE_CEPH] = &amp;n2t
}</span>

func loadFusionStroageDefault(i2e *map[string]*Int2String, e2i *map[string]*String2Int) <span class="cov8" title="1">{
        t2n := make(Int2String)
        t2n[Tier1] = string(obs.StorageClassStandard)
        (*i2e)[OSTYPE_FUSIONSTORAGE] = &amp;t2n

        n2t := make(String2Int)
        n2t[string(obs.StorageClassStandard)] = Tier1
        (*e2i)[OSTYPE_FUSIONSTORAGE] = &amp;n2t
}</span>

func loadDefaultStorageClass() error <span class="cov8" title="1">{
        /* Default storage class definition:
                                                        T1                        T99                                        T999
          AWS S3:                                STANDARD                STANDARD_IA                        GLACIER
          Azure Blob:                        HOT                                COOL                                ARCHIVE
          HW OBS:                                STANDARD                WARM                                COLD
          GCP:                                        Multi-Regional        NearLine                        ColdLine
          Ceph S3:                                STANDARD                -                                        -
          FusinoStorage Object: STANDARD                -                                        -
        */
        /* Lifecycle transition:
                  T1 -&gt; T99:  allowed
                  T1 -&gt; T999: allowed
                  T99 -&gt; T999: allowed
              T99 -&gt; T1:  not allowed
                  T999 -&gt; T1: not allowed
                  T999 -&gt; T99: not allowed
        */

        SupportedClasses = append(SupportedClasses, pb.StorageClass{Name: string(AWS_STANDARD), Tier: int32(Tier1)})
        SupportedClasses = append(SupportedClasses, pb.StorageClass{Name: string(AWS_STANDARD_IA), Tier: int32(Tier99)})
        SupportedClasses = append(SupportedClasses, pb.StorageClass{Name: string(AWS_GLACIER), Tier: int32(Tier999)})

        log.Infof("Supported storage classes:%v\n", SupportedClasses)

        Int2ExtTierMap = make(map[string]*Int2String)
        Ext2IntTierMap = make(map[string]*String2Int)
        loadAWSDefault(&amp;Int2ExtTierMap, &amp;Ext2IntTierMap)
        loadsodaDefault(&amp;Int2ExtTierMap, &amp;Ext2IntTierMap)
        loadAzureDefault(&amp;Int2ExtTierMap, &amp;Ext2IntTierMap)
        loadHWDefault(&amp;Int2ExtTierMap, &amp;Ext2IntTierMap)
        loadGCPDefault(&amp;Int2ExtTierMap, &amp;Ext2IntTierMap)
        loadCephDefault(&amp;Int2ExtTierMap, &amp;Ext2IntTierMap)
        loadFusionStroageDefault(&amp;Int2ExtTierMap, &amp;Ext2IntTierMap)

        log.Infof("Int2ExtTierMap:%v\n", Int2ExtTierMap)
        log.Infof("Ext2IntTierMap:%v\n", Ext2IntTierMap)

        return nil
}</span>

// Currently user defined storage tiers and classes are not supported.
func loadUserDefinedStorageClass() error <span class="cov0" title="0">{
        log.Info("user defined storage class is not supported now")
        return fmt.Errorf("user defined storage class is not supported now")
}</span>

func loadDefaultTransition() error <span class="cov8" title="1">{
        // transition from a tier to the same tier is valid in case cross-cloud transition
        TransitionMap = make(map[int32][]int32)
        TransitionMap[Tier1] = []int32{Tier1}
        TransitionMap[Tier99] = []int32{Tier1, Tier99}
        TransitionMap[Tier999] = []int32{Tier1, Tier99, Tier999}

        log.Infof("loadDefaultTransition:%+v\n", TransitionMap)
        return nil
}</span>

func validTier(tier int32) bool <span class="cov0" title="0">{
        for _, v := range SupportedClasses </span><span class="cov0" title="0">{
                if v.Tier == tier </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

func loadUserDefinedTransition() error <span class="cov0" title="0">{
        log.Info("user defined storage class is not supported now")
        return fmt.Errorf("user defined storage class is not supported now")
}</span>

func initStorageClass() <span class="cov8" title="1">{
        // Check if use the default storage class.
        set := os.Getenv("USE_DEFAULT_STORAGE_CLASS")
        val, err := strconv.ParseInt(set, 10, 64)
        log.Infof("USE_DEFAULT_STORAGE_CLASS:set=%s, val=%d, err=%v.\n", set, val, err)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("invalid USE_DEFAULT_STORAGE_CLASS:%s\n", set)
                panic("init s3service failed")</span>
        }

        // Load storage class definition and transition relationship.
        <span class="cov8" title="1">var err1, err2 error
        if val &gt; 0 </span><span class="cov8" title="1">{
                err1 = loadDefaultStorageClass()
                err2 = loadDefaultTransition()
        }</span> else<span class="cov0" title="0"> {
                err1 = loadUserDefinedStorageClass()
                err2 = loadUserDefinedTransition()
        }</span>
        // Exit if init failed.
        <span class="cov8" title="1">if err1 != nil || err2 != nil </span><span class="cov0" title="0">{
                panic("init s3service failed")</span>
        }
}

func (s *s3Service) GetStorageClasses(ctx context.Context, in *pb.BaseRequest, out *pb.GetStorageClassesResponse) error <span class="cov0" title="0">{
        classes := []*pb.StorageClass{}
        for _, v := range SupportedClasses </span><span class="cov0" title="0">{
                classes = append(classes, &amp;pb.StorageClass{Name: v.Name, Tier: v.Tier})
        }</span>

        <span class="cov0" title="0">out.Classes = classes

        return nil</span>
}

func (s *s3Service) GetTierMap(ctx context.Context, in *pb.BaseRequest, out *pb.GetTierMapResponse) error <span class="cov0" title="0">{
        log.Info("GetTierMap ...")

        // Get map from internal tier to external class name.
        out.Tier2Name = make(map[string]*pb.Tier2ClassName)
        for k, v := range Int2ExtTierMap </span><span class="cov0" title="0">{
                var val pb.Tier2ClassName
                val.Lst = make(map[int32]string)
                for k1, v1 := range *v </span><span class="cov0" title="0">{
                        val.Lst[k1] = v1
                }</span>
                <span class="cov0" title="0">out.Tier2Name[k] = &amp;val</span>
        }

        // Get transition map.
        <span class="cov0" title="0">for k, v := range TransitionMap </span><span class="cov0" title="0">{
                for _, t := range v </span><span class="cov0" title="0">{
                        trans := fmt.Sprintf("%d:%d", t, k)
                        out.Transition = append(out.Transition, trans)
                }</span>
        }

        <span class="cov0" title="0">log.Infof("out.Transition:%v\n", out.Transition)
        return nil</span>
}

func (s *s3Service) UpdateBucket(ctx context.Context, in *pb.Bucket, out *pb.BaseResponse) error <span class="cov8" title="1">{
        log.Info("UpdateBucket is called in s3 service.")

        //update versioning if not nil
        if in.Versioning != nil </span><span class="cov8" title="1">{
                err := s.MetaStorage.Db.UpdateBucketVersioning(ctx, in.Name, in.Versioning.Status)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("get bucket[%s] failed, err:%v\n", in.Name, err)
                        return err
                }</span>
        }
        <span class="cov8" title="1">if in.ServerSideEncryption != nil</span><span class="cov8" title="1">{
                byteArr, keyErr := utils.GetRandom32BitKey()
                if keyErr != nil </span><span class="cov0" title="0">{
                        log.Error("Error generating SSE key", keyErr)
                        return keyErr
                }</span>
                <span class="cov8" title="1">sseErr := s.MetaStorage.Db.UpdateBucketSSE(ctx, in.Name, in.ServerSideEncryption.SseType, byteArr)
                if sseErr != nil </span><span class="cov0" title="0">{
                        log.Error("Error creating SSE entry: ", sseErr)
                        return sseErr
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (s *s3Service) AppendObject(ctx context.Context, in *pb.BaseRequest, out *pb.BaseResponse) error <span class="cov0" title="0">{
        log.Info("UpdateBucket is called in s3 service.")

        return nil
}</span>

func (s *s3Service) PostObject(ctx context.Context, in *pb.BaseRequest, out *pb.BaseResponse) error <span class="cov0" title="0">{
        log.Info("UpdateBucket is called in s3 service.")

        return nil
}</span>

func (s *s3Service) HeadObject(ctx context.Context, in *pb.BaseObjRequest, out *pb.Object) error <span class="cov0" title="0">{
        log.Info("UpdateBucket is called in s3 service.")

        return nil
}</span>

func (s *s3Service) GetObjACL(ctx context.Context, in *pb.BaseObjRequest, out *pb.ObjACL) error <span class="cov0" title="0">{
        log.Info("UpdateBucket is called in s3 service.")

        return nil
}</span>

func (s *s3Service) GetBucketLocation(ctx context.Context, in *pb.BaseRequest, out *pb.BaseResponse) error <span class="cov0" title="0">{
        log.Info("UpdateBucket is called in s3 service.")

        return nil
}</span>

func (s *s3Service) GetBucketVersioning(ctx context.Context, in *pb.BaseBucketRequest, out *pb.BucketVersioning) error <span class="cov0" title="0">{
        log.Info("UpdateBucket is called in s3 service.")

        return nil
}</span>

//TODO Will check whether we need another interface for put bucket version
/*func (s *s3Service) PutBucketVersioning(ctx context.Context, in *pb.PutBucketVersioningRequest, out *pb.BaseResponse) error {
        log.Info("UpdateBucket is called in s3 service.")

        return nil
}

*/

func (s *s3Service) GetBucketACL(ctx context.Context, in *pb.BaseBucketRequest, out *pb.BucketACL) error <span class="cov0" title="0">{
        log.Info("UpdateBucket is called in s3 service.")

        return nil
}</span>

func (s *s3Service) PutBucketCORS(ctx context.Context, in *pb.BaseRequest, out *pb.BaseResponse) error <span class="cov0" title="0">{
        log.Info("UpdateBucket is called in s3 service.")

        return nil
}</span>

func (s *s3Service) GetBucketCORS(ctx context.Context, in *pb.BaseRequest, out *pb.BaseResponse) error <span class="cov0" title="0">{
        log.Info("UpdateBucket is called in s3 service.")

        return nil
}</span>

func (s *s3Service) DeleteBucketCORS(ctx context.Context, in *pb.BaseRequest, out *pb.BaseResponse) error <span class="cov0" title="0">{
        log.Info("UpdateBucket is called in s3 service.")

        return nil
}</span>

func (s *s3Service) PutBucketPolicy(ctx context.Context, in *pb.BaseRequest, out *pb.BaseResponse) error <span class="cov0" title="0">{
        log.Info("UpdateBucket is called in s3 service.")

        return nil
}</span>

func (s *s3Service) GetBucketPolicy(ctx context.Context, in *pb.BaseRequest, out *pb.BaseResponse) error <span class="cov0" title="0">{
        log.Info("UpdateBucket is called in s3 service.")

        return nil
}</span>

func (s *s3Service) DeleteBucketPolicy(ctx context.Context, in *pb.BaseRequest, out *pb.BaseResponse) error <span class="cov0" title="0">{
        log.Info("UpdateBucket is called in s3 service.")

        return nil
}</span>

func (s *s3Service) HeadBucket(ctx context.Context, in *pb.BaseRequest, out *pb.Bucket) error <span class="cov0" title="0">{
        log.Info("UpdateBucket is called in s3 service.")

        return nil
}</span>

func (s *s3Service) UpdateObjMeta(ctx context.Context, in *pb.UpdateObjMetaRequest, out *pb.BaseResponse) error <span class="cov0" title="0">{
        log.Infof("Update meatadata, objkey:%s, lastmodified:%d, setting:%v\n", in.ObjKey, in.LastModified, in.Setting)
        /*valid := make(map[string]struct{})
        valid["tier"] = struct{}{}
        valid["backend"] = struct{}{}
        set, err := CheckReqObjMeta(in.Setting, valid)
        if err.Code != ERR_OK {
                out.ErrorCode = fmt.Sprintf("%s", err.Code)
                out.Msg = err.Description
                return err.Error()
        }

        err = db.DbAdapter.UpdateObjMeta(ctx, &amp;in.ObjKey, &amp;in.BucketName, in.LastModified, set)
        if err.Code != ERR_OK {
                out.ErrorCode = fmt.Sprintf("%s", err.Code)
                out.Msg = err.Description
                return err.Error()
        }

        out.Msg = "update object meta data successfully."
        */
        return nil
}</span>

func (s *s3Service) GetBackendTypeByTier(ctx context.Context, in *pb.GetBackendTypeByTierRequest, out *pb.GetBackendTypeByTierResponse) error <span class="cov0" title="0">{
        for k, v := range Int2ExtTierMap </span><span class="cov0" title="0">{
                for k1, _ := range *v </span><span class="cov0" title="0">{
                        if k1 == in.Tier </span><span class="cov0" title="0">{
                                out.Types = append(out.Types, k)
                        }</span>
                }
        }

        <span class="cov0" title="0">log.Infof("GetBackendTypesByTier, types:%v\n", out.Types)

        return nil</span>
}

func (s *s3Service) AddUploadRecord(ctx context.Context, record *pb.MultipartUploadRecord, out *pb.BaseResponse) error <span class="cov0" title="0">{
        log.Infof("add multipart upload record")

        return nil
}</span>

func (s *s3Service) DeleteUploadRecord(ctx context.Context, record *pb.MultipartUploadRecord, out *pb.BaseResponse) error <span class="cov0" title="0">{
        log.Infof("delete multipart upload record")

        return nil
}</span>

func (s *s3Service) CountObjects(ctx context.Context, in *pb.ListObjectsRequest, out *pb.CountObjectsResponse) error <span class="cov0" title="0">{
        log.Info("Count objects is called in s3 service.")

        rsp, err := s.MetaStorage.Db.CountObjects(ctx, in.Bucket, in.Prefix)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">out.Count = rsp.Count
        out.Size = rsp.Size

        return nil</span>
}

func GetErrCode(err error) (errCode int32) <span class="cov8" title="1">{
        if err == nil </span><span class="cov8" title="1">{
                errCode = int32(ErrNoErr)
                return
        }</span>

        <span class="cov8" title="1">errCode = int32(ErrInternalError)
        s3err, ok := err.(S3ErrorCode)
        if ok </span><span class="cov8" title="1">{
                errCode = int32(s3err)
        }</span>

        <span class="cov8" title="1">return errCode</span>
}

func CheckRights(ctx context.Context, tenantId4Source string) (bool, string, string, error) <span class="cov8" title="1">{
        isAdmin, tenantId, userId, err := util.GetCredentialFromCtx(ctx)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("get credential faied, err:%v\n", err)
                return isAdmin, tenantId, userId, ErrInternalError
        }</span>
        <span class="cov8" title="1">if !isAdmin &amp;&amp; tenantId != tenantId4Source </span><span class="cov0" title="0">{
                log.Errorf("access forbidden, tenantId=%s, tenantId4Source=%s\n", tenantId, tenantId4Source)
                return isAdmin, tenantId, userId, ErrAccessDenied
        }</span>

        <span class="cov8" title="1">return isAdmin, tenantId, userId, nil</span>
}
</pre>
		
		<pre class="file" id="file160" style="display: none">package utils

import (
        "crypto/aes"
        "crypto/cipher"
        "crypto/rand"
        "io"
)
import log "github.com/sirupsen/logrus"

func EncryptWithAES256RandomKey(data []byte, key []byte) (error, []byte) <span class="cov8" title="1">{
        // use the key, get the cipher
        cipherBlock, cipherErr := aes.NewCipher(key)
        if cipherErr != nil </span><span class="cov0" title="0">{
                log.Errorf("Encryption error, cipher not generated")
                return cipherErr, nil
        }</span>
        // use the cipher block to encrypt
        // gcm or Galois/Counter Mode, is a mode of operation
        // for symmetric key cryptographic block ciphers
        // https://en.wikipedia.org/wiki/Galois/Counter_Mode
        <span class="cov8" title="1">aesgcm, gcmErr := cipher.NewGCM(cipherBlock)
        if gcmErr != nil </span><span class="cov0" title="0">{
                log.Errorf("Encryption error, GCM not generated")
                return gcmErr, nil
        }</span>
        // NonceSize is default 12 bytes
        <span class="cov8" title="1">nonce := make([]byte, aesgcm.NonceSize())
        _, nonceErr := io.ReadFull(rand.Reader, nonce)
        if nonceErr != nil </span><span class="cov0" title="0">{
                log.Errorf("Encryption error, GCM nonce not created")
                return nonceErr, nil
        }</span>

        // use the aes gcm to seal the data
        <span class="cov8" title="1">encBytes := aesgcm.Seal(nonce, nonce, data, nil)
        return nil, encBytes</span>
}

func DecryptWithAES256(data []byte, key []byte) (error, []byte) <span class="cov8" title="1">{
        // use the key, get the cipher
        cipherBlock, cipherErr := aes.NewCipher(key)
        if cipherErr != nil </span><span class="cov0" title="0">{
                log.Errorf("Decryption error, cipher not generated")
                return cipherErr, nil
        }</span>
        // use the cipher block to decrypt
        // gcm or Galois/Counter Mode, is a mode of operation
        // for symmetric key cryptographic block ciphers
        // https://en.wikipedia.org/wiki/Galois/Counter_Mode
        <span class="cov8" title="1">aesgcm, gcmErr := cipher.NewGCM(cipherBlock)
        if gcmErr != nil </span><span class="cov0" title="0">{
                log.Errorf("Decryption error, GCM not generated")
                return gcmErr, nil
        }</span>
        <span class="cov8" title="1">nonceSize := aesgcm.NonceSize()
        nonce, ciphertext := data[:nonceSize], data[nonceSize:]
        // use the aes gcm to open the data
        decBytes, decErr := aesgcm.Open(nil, nonce, ciphertext, nil)
        if decErr != nil </span><span class="cov0" title="0">{
                log.Errorf("Decryption error during open %s", decErr)
                return decErr, nil
        }</span>
        <span class="cov8" title="1">return decErr, decBytes</span>
}

func GetRandom32BitKey() ([]byte, error) <span class="cov8" title="1">{
        key := make([]byte, 32)

        _, err := rand.Read(key)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("Error generating random 32 bit key %s", err)
                return nil, err
        }</span>
        <span class="cov8" title="1">log.Infof("Generated random 32 bit key")
        return key, nil</span>
}


</pre>
		
		<pre class="file" id="file161" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package utils

import (
        "context"
        "crypto/md5"
        "encoding/hex"
        "github.com/soda/multi-cloud/backend/proto"
        log "github.com/sirupsen/logrus"
)

type Database struct {
        Credential string `conf:"credential,username:password@tcp(ip:port)/dbname"`
        Driver     string `conf:"driver,mongodb"`
        Endpoint   string `conf:"endpoint,localhost:27017"`
}

// Tier1, Tier99 and Tier999 just like the tiers of hot, warm, cold.
// In the future, we will provide the ability for users to add new storage tiers, if we use 1, 2 and 3, then no space for new storage tiers.
const (
        Tier1   = 1
        Tier99  = 99
        Tier999 = 999
)

const (
        AWS_STANDARD    = "STANDARD"
        AWS_STANDARD_IA = "STANDARD_IA"
        AWS_GLACIER     = "GLACIER"
)

const (
        CEPH_STANDARD = "STDANDARD"
)

const (
        GCS_MULTI_REGIONAL = "MULTI_REGIONAL"
        GCS_REGIONAL       = "REGIONAL"
        GCS_NEARLINE       = "NEARLINE"
        GCS_COLDLINE       = "COLDLINE"
)

//Object Storage Type
const (
        OSTYPE_soda       = "soda"
        OSTYPE_AWS           = "aws-s3"
        OSTYPE_Azure         = "azure-blob"
        OSTYPE_OBS           = "hw-obs"
        OSTYPE_GCS           = "gcp-s3"
        OSTYPE_CEPH          = "ceph-s3"
        OSTYPE_FUSIONSTORAGE = "fusionstorage-object"
)

const (
        DBKEY_DELETEMARKER   = "isdeletemarker"
        DBKEY_INITFLAG       = "initflag"
        DBKEY_OBJECTKEY      = "objectkey"
        DBKEY_UPLOADID       = "uploadid"
        DBKEY_LASTMODIFIED   = "lastmodified"
        DBKEY_SUPPOSEDSTATUS = "supposedstatus"
        DBKEY_LOCKOBJ_OBJKEY = "objkey"
        DBKEY_BUCKET         = "bucket"
        DBKEY_INITTIME       = "inittime"
        DBKEY_NAME           = "name"
        DBKEY_LIFECYCLE      = "lifecycleconfiguration"
        DBKEY_ID             = "id"
)

type ObjsCountInfo struct {
        Size  int64
        Count int64
}

const (
        MaxObjectList  = 1000 // Limit number of objects in a listObjectsResponse.
        MaxUploadsList = 1000 // Limit number of uploads in a listUploadsResponse.
        MaxPartsList   = 1000 // Limit number of parts in a listPartsResponse.
)

const (
        VersioningEnabled   = "Enabled"
        VersioningDisabled  = "Disabled"
        VersioningSuspended = "Suspended"
)

type ListObjsAppendInfo struct {
        Prefixes   []string
        Truncated  bool
        NextMarker string
}

const (
        MoveType_Invalid = iota
        MoveType_MoveCrossBuckets
        MoveType_ChangeLocation
        MoveType_ChangeStorageTier
)

const (
        RequestType_Lifecycle = "lifecycle"
)

func Md5Content(data []byte) string <span class="cov0" title="0">{
        md5Ctx := md5.New()
        md5Ctx.Write(data)
        cipherStr := md5Ctx.Sum(nil)
        //value := base64.StdEncoding.EncodeToString(cipherStr)
        value := hex.EncodeToString(cipherStr)
        return value
}</span>

func GetBackend(ctx context.Context, backedClient backend.BackendService, backendName string) (*backend.BackendDetail,
        error) <span class="cov8" title="1">{
        log.Infof("backendName is %v:\n", backendName)
        backendRep, backendErr := backedClient.ListBackend(ctx, &amp;backend.ListBackendRequest{
                Offset: 0,
                Limit:  1,
                Filter: map[string]string{"name": backendName}})
        log.Infof("backendErr is %v:", backendErr)
        if backendErr != nil </span><span class="cov0" title="0">{
                log.Errorf("get backend %s failed.", backendName)
                return nil, backendErr
        }</span>
        <span class="cov8" title="1">log.Infof("backendRep is %v:", backendRep)
        backend := backendRep.Backends[0]
        return backend, nil</span>
}
</pre>
		
		<pre class="file" id="file162" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// source: s3.proto

package s3

import (
        fmt "fmt"
        proto "github.com/golang/protobuf/proto"
        math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type ListObjectPartsRequest struct {
        BucketName           string   `protobuf:"bytes,1,opt,name=bucketName,proto3" json:"bucketName,omitempty"`
        ObjectKey            string   `protobuf:"bytes,2,opt,name=objectKey,proto3" json:"objectKey,omitempty"`
        EncodingType         string   `protobuf:"bytes,3,opt,name=encodingType,proto3" json:"encodingType,omitempty"`
        UploadId             string   `protobuf:"bytes,4,opt,name=uploadId,proto3" json:"uploadId,omitempty"`
        MaxParts             int64    `protobuf:"varint,5,opt,name=maxParts,proto3" json:"maxParts,omitempty"`
        PartNumberMarker     int64    `protobuf:"varint,6,opt,name=partNumberMarker,proto3" json:"partNumberMarker,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *ListObjectPartsRequest) Reset()         <span class="cov0" title="0">{ *m = ListObjectPartsRequest{} }</span>
func (m *ListObjectPartsRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*ListObjectPartsRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*ListObjectPartsRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_005e34be4304e022, []int{0}
}</span>

func (m *ListObjectPartsRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_ListObjectPartsRequest.Unmarshal(m, b)
}</span>
func (m *ListObjectPartsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_ListObjectPartsRequest.Marshal(b, m, deterministic)
}</span>
func (m *ListObjectPartsRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_ListObjectPartsRequest.Merge(m, src)
}</span>
func (m *ListObjectPartsRequest) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_ListObjectPartsRequest.Size(m)
}</span>
func (m *ListObjectPartsRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_ListObjectPartsRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_ListObjectPartsRequest proto.InternalMessageInfo

func (m *ListObjectPartsRequest) GetBucketName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.BucketName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *ListObjectPartsRequest) GetObjectKey() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ObjectKey
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *ListObjectPartsRequest) GetEncodingType() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.EncodingType
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *ListObjectPartsRequest) GetUploadId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.UploadId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *ListObjectPartsRequest) GetMaxParts() int64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.MaxParts
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *ListObjectPartsRequest) GetPartNumberMarker() int64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.PartNumberMarker
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type Part struct {
        PartNumber           int64    `protobuf:"varint,1,opt,name=PartNumber,proto3" json:"PartNumber,omitempty"`
        ETag                 string   `protobuf:"bytes,2,opt,name=ETag,proto3" json:"ETag,omitempty"`
        LastModified         string   `protobuf:"bytes,3,opt,name=LastModified,proto3" json:"LastModified,omitempty"`
        Size                 int64    `protobuf:"varint,4,opt,name=Size,proto3" json:"Size,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *Part) Reset()         <span class="cov0" title="0">{ *m = Part{} }</span>
func (m *Part) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*Part) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*Part) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_005e34be4304e022, []int{1}
}</span>

func (m *Part) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_Part.Unmarshal(m, b)
}</span>
func (m *Part) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_Part.Marshal(b, m, deterministic)
}</span>
func (m *Part) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_Part.Merge(m, src)
}</span>
func (m *Part) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_Part.Size(m)
}</span>
func (m *Part) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_Part.DiscardUnknown(m)
}</span>

var xxx_messageInfo_Part proto.InternalMessageInfo

func (m *Part) GetPartNumber() int64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.PartNumber
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *Part) GetETag() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ETag
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Part) GetLastModified() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.LastModified
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Part) GetSize() int64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Size
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type ListObjectPartsResponse struct {
        ErrorCode            int32    `protobuf:"varint,1,opt,name=ErrorCode,proto3" json:"ErrorCode,omitempty"`
        Initiator            *Owner   `protobuf:"bytes,2,opt,name=Initiator,proto3" json:"Initiator,omitempty"`
        Owner                *Owner   `protobuf:"bytes,3,opt,name=Owner,proto3" json:"Owner,omitempty"`
        StorageClass         string   `protobuf:"bytes,4,opt,name=StorageClass,proto3" json:"StorageClass,omitempty"`
        PartNumberMarker     int64    `protobuf:"varint,5,opt,name=PartNumberMarker,proto3" json:"PartNumberMarker,omitempty"`
        NextPartNumberMarker int64    `protobuf:"varint,6,opt,name=NextPartNumberMarker,proto3" json:"NextPartNumberMarker,omitempty"`
        MaxParts             int64    `protobuf:"varint,7,opt,name=MaxParts,proto3" json:"MaxParts,omitempty"`
        IsTruncated          bool     `protobuf:"varint,8,opt,name=IsTruncated,proto3" json:"IsTruncated,omitempty"`
        Parts                []*Part  `protobuf:"bytes,9,rep,name=Parts,proto3" json:"Parts,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *ListObjectPartsResponse) Reset()         <span class="cov0" title="0">{ *m = ListObjectPartsResponse{} }</span>
func (m *ListObjectPartsResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*ListObjectPartsResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*ListObjectPartsResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_005e34be4304e022, []int{2}
}</span>

func (m *ListObjectPartsResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_ListObjectPartsResponse.Unmarshal(m, b)
}</span>
func (m *ListObjectPartsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_ListObjectPartsResponse.Marshal(b, m, deterministic)
}</span>
func (m *ListObjectPartsResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_ListObjectPartsResponse.Merge(m, src)
}</span>
func (m *ListObjectPartsResponse) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_ListObjectPartsResponse.Size(m)
}</span>
func (m *ListObjectPartsResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_ListObjectPartsResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_ListObjectPartsResponse proto.InternalMessageInfo

func (m *ListObjectPartsResponse) GetErrorCode() int32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ErrorCode
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *ListObjectPartsResponse) GetInitiator() *Owner <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Initiator
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *ListObjectPartsResponse) GetOwner() *Owner <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Owner
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *ListObjectPartsResponse) GetStorageClass() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.StorageClass
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *ListObjectPartsResponse) GetPartNumberMarker() int64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.PartNumberMarker
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *ListObjectPartsResponse) GetNextPartNumberMarker() int64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.NextPartNumberMarker
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *ListObjectPartsResponse) GetMaxParts() int64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.MaxParts
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *ListObjectPartsResponse) GetIsTruncated() bool <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.IsTruncated
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (m *ListObjectPartsResponse) GetParts() []*Part <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Parts
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type AbortMultipartRequest struct {
        BucketName           string   `protobuf:"bytes,1,opt,name=bucketName,proto3" json:"bucketName,omitempty"`
        ObjectKey            string   `protobuf:"bytes,2,opt,name=objectKey,proto3" json:"objectKey,omitempty"`
        UploadId             string   `protobuf:"bytes,3,opt,name=uploadId,proto3" json:"uploadId,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *AbortMultipartRequest) Reset()         <span class="cov0" title="0">{ *m = AbortMultipartRequest{} }</span>
func (m *AbortMultipartRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*AbortMultipartRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*AbortMultipartRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_005e34be4304e022, []int{3}
}</span>

func (m *AbortMultipartRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_AbortMultipartRequest.Unmarshal(m, b)
}</span>
func (m *AbortMultipartRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_AbortMultipartRequest.Marshal(b, m, deterministic)
}</span>
func (m *AbortMultipartRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_AbortMultipartRequest.Merge(m, src)
}</span>
func (m *AbortMultipartRequest) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_AbortMultipartRequest.Size(m)
}</span>
func (m *AbortMultipartRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_AbortMultipartRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_AbortMultipartRequest proto.InternalMessageInfo

func (m *AbortMultipartRequest) GetBucketName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.BucketName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *AbortMultipartRequest) GetObjectKey() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ObjectKey
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *AbortMultipartRequest) GetUploadId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.UploadId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type CompletePart struct {
        PartNumber           int64    `protobuf:"varint,1,opt,name=partNumber,proto3" json:"partNumber,omitempty"`
        ETag                 string   `protobuf:"bytes,2,opt,name=eTag,proto3" json:"eTag,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *CompletePart) Reset()         <span class="cov0" title="0">{ *m = CompletePart{} }</span>
func (m *CompletePart) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*CompletePart) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*CompletePart) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_005e34be4304e022, []int{4}
}</span>

func (m *CompletePart) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_CompletePart.Unmarshal(m, b)
}</span>
func (m *CompletePart) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_CompletePart.Marshal(b, m, deterministic)
}</span>
func (m *CompletePart) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_CompletePart.Merge(m, src)
}</span>
func (m *CompletePart) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_CompletePart.Size(m)
}</span>
func (m *CompletePart) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_CompletePart.DiscardUnknown(m)
}</span>

var xxx_messageInfo_CompletePart proto.InternalMessageInfo

func (m *CompletePart) GetPartNumber() int64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.PartNumber
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *CompletePart) GetETag() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ETag
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type CompleteMultipartRequest struct {
        BucketName           string          `protobuf:"bytes,1,opt,name=bucketName,proto3" json:"bucketName,omitempty"`
        ObjectKey            string          `protobuf:"bytes,2,opt,name=objectKey,proto3" json:"objectKey,omitempty"`
        UploadId             string          `protobuf:"bytes,3,opt,name=uploadId,proto3" json:"uploadId,omitempty"`
        CompleteParts        []*CompletePart `protobuf:"bytes,4,rep,name=completeParts,proto3" json:"completeParts,omitempty"`
        SourceVersionID      string          `protobuf:"bytes,5,opt,name=sourceVersionID,proto3" json:"sourceVersionID,omitempty"`
        RequestType          string          `protobuf:"bytes,6,opt,name=requestType,proto3" json:"requestType,omitempty"`
        Tier                 int32           `protobuf:"varint,7,opt,name=tier,proto3" json:"tier,omitempty"`
        XXX_NoUnkeyedLiteral struct{}        `json:"-"`
        XXX_unrecognized     []byte          `json:"-"`
        XXX_sizecache        int32           `json:"-"`
}

func (m *CompleteMultipartRequest) Reset()         <span class="cov0" title="0">{ *m = CompleteMultipartRequest{} }</span>
func (m *CompleteMultipartRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*CompleteMultipartRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*CompleteMultipartRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_005e34be4304e022, []int{5}
}</span>

func (m *CompleteMultipartRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_CompleteMultipartRequest.Unmarshal(m, b)
}</span>
func (m *CompleteMultipartRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_CompleteMultipartRequest.Marshal(b, m, deterministic)
}</span>
func (m *CompleteMultipartRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_CompleteMultipartRequest.Merge(m, src)
}</span>
func (m *CompleteMultipartRequest) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_CompleteMultipartRequest.Size(m)
}</span>
func (m *CompleteMultipartRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_CompleteMultipartRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_CompleteMultipartRequest proto.InternalMessageInfo

func (m *CompleteMultipartRequest) GetBucketName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.BucketName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *CompleteMultipartRequest) GetObjectKey() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ObjectKey
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *CompleteMultipartRequest) GetUploadId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.UploadId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *CompleteMultipartRequest) GetCompleteParts() []*CompletePart <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.CompleteParts
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *CompleteMultipartRequest) GetSourceVersionID() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.SourceVersionID
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *CompleteMultipartRequest) GetRequestType() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.RequestType
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *CompleteMultipartRequest) GetTier() int32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Tier
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type CompleteMultipartResponse struct {
        ErrorCode            int32    `protobuf:"varint,1,opt,name=errorCode,proto3" json:"errorCode,omitempty"`
        UploadID             string   `protobuf:"bytes,2,opt,name=uploadID,proto3" json:"uploadID,omitempty"`
        ETag                 string   `protobuf:"bytes,3,opt,name=eTag,proto3" json:"eTag,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *CompleteMultipartResponse) Reset()         <span class="cov0" title="0">{ *m = CompleteMultipartResponse{} }</span>
func (m *CompleteMultipartResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*CompleteMultipartResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*CompleteMultipartResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_005e34be4304e022, []int{6}
}</span>

func (m *CompleteMultipartResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_CompleteMultipartResponse.Unmarshal(m, b)
}</span>
func (m *CompleteMultipartResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_CompleteMultipartResponse.Marshal(b, m, deterministic)
}</span>
func (m *CompleteMultipartResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_CompleteMultipartResponse.Merge(m, src)
}</span>
func (m *CompleteMultipartResponse) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_CompleteMultipartResponse.Size(m)
}</span>
func (m *CompleteMultipartResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_CompleteMultipartResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_CompleteMultipartResponse proto.InternalMessageInfo

func (m *CompleteMultipartResponse) GetErrorCode() int32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ErrorCode
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *CompleteMultipartResponse) GetUploadID() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.UploadID
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *CompleteMultipartResponse) GetETag() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ETag
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type InitMultiPartRequest struct {
        BucketName           string            `protobuf:"bytes,1,opt,name=bucketName,proto3" json:"bucketName,omitempty"`
        ObjectKey            string            `protobuf:"bytes,2,opt,name=objectKey,proto3" json:"objectKey,omitempty"`
        Acl                  *Acl              `protobuf:"bytes,3,opt,name=acl,proto3" json:"acl,omitempty"`
        Tier                 int32             `protobuf:"varint,4,opt,name=tier,proto3" json:"tier,omitempty"`
        Location             string            `protobuf:"bytes,5,opt,name=location,proto3" json:"location,omitempty"`
        Attrs                map[string]string `protobuf:"bytes,6,rep,name=attrs,proto3" json:"attrs,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
        XXX_NoUnkeyedLiteral struct{}          `json:"-"`
        XXX_unrecognized     []byte            `json:"-"`
        XXX_sizecache        int32             `json:"-"`
}

func (m *InitMultiPartRequest) Reset()         <span class="cov0" title="0">{ *m = InitMultiPartRequest{} }</span>
func (m *InitMultiPartRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*InitMultiPartRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*InitMultiPartRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_005e34be4304e022, []int{7}
}</span>

func (m *InitMultiPartRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_InitMultiPartRequest.Unmarshal(m, b)
}</span>
func (m *InitMultiPartRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_InitMultiPartRequest.Marshal(b, m, deterministic)
}</span>
func (m *InitMultiPartRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_InitMultiPartRequest.Merge(m, src)
}</span>
func (m *InitMultiPartRequest) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_InitMultiPartRequest.Size(m)
}</span>
func (m *InitMultiPartRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_InitMultiPartRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_InitMultiPartRequest proto.InternalMessageInfo

func (m *InitMultiPartRequest) GetBucketName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.BucketName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *InitMultiPartRequest) GetObjectKey() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ObjectKey
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *InitMultiPartRequest) GetAcl() *Acl <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Acl
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *InitMultiPartRequest) GetTier() int32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Tier
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *InitMultiPartRequest) GetLocation() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Location
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *InitMultiPartRequest) GetAttrs() map[string]string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Attrs
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type InitMultiPartResponse struct {
        ErrorCode            int32    `protobuf:"varint,1,opt,name=errorCode,proto3" json:"errorCode,omitempty"`
        UploadID             string   `protobuf:"bytes,2,opt,name=uploadID,proto3" json:"uploadID,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *InitMultiPartResponse) Reset()         <span class="cov0" title="0">{ *m = InitMultiPartResponse{} }</span>
func (m *InitMultiPartResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*InitMultiPartResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*InitMultiPartResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_005e34be4304e022, []int{8}
}</span>

func (m *InitMultiPartResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_InitMultiPartResponse.Unmarshal(m, b)
}</span>
func (m *InitMultiPartResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_InitMultiPartResponse.Marshal(b, m, deterministic)
}</span>
func (m *InitMultiPartResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_InitMultiPartResponse.Merge(m, src)
}</span>
func (m *InitMultiPartResponse) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_InitMultiPartResponse.Size(m)
}</span>
func (m *InitMultiPartResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_InitMultiPartResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_InitMultiPartResponse proto.InternalMessageInfo

func (m *InitMultiPartResponse) GetErrorCode() int32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ErrorCode
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *InitMultiPartResponse) GetUploadID() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.UploadID
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type PutDataStream struct {
        Data                 []byte   `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *PutDataStream) Reset()         <span class="cov8" title="1">{ *m = PutDataStream{} }</span>
func (m *PutDataStream) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*PutDataStream) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*PutDataStream) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_005e34be4304e022, []int{9}
}</span>

func (m *PutDataStream) XXX_Unmarshal(b []byte) error <span class="cov8" title="1">{
        return xxx_messageInfo_PutDataStream.Unmarshal(m, b)
}</span>
func (m *PutDataStream) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_PutDataStream.Marshal(b, m, deterministic)
}</span>
func (m *PutDataStream) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_PutDataStream.Merge(m, src)
}</span>
func (m *PutDataStream) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_PutDataStream.Size(m)
}</span>
func (m *PutDataStream) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_PutDataStream.DiscardUnknown(m)
}</span>

var xxx_messageInfo_PutDataStream proto.InternalMessageInfo

func (m *PutDataStream) GetData() []byte <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Data
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type UploadPartRequest struct {
        BucketName           string   `protobuf:"bytes,1,opt,name=bucketName,proto3" json:"bucketName,omitempty"`
        ObjectKey            string   `protobuf:"bytes,2,opt,name=objectKey,proto3" json:"objectKey,omitempty"`
        UploadId             string   `protobuf:"bytes,3,opt,name=uploadId,proto3" json:"uploadId,omitempty"`
        PartId               int32    `protobuf:"varint,4,opt,name=partId,proto3" json:"partId,omitempty"`
        Size                 int64    `protobuf:"varint,5,opt,name=size,proto3" json:"size,omitempty"`
        Md5Hex               string   `protobuf:"bytes,6,opt,name=md5Hex,proto3" json:"md5Hex,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *UploadPartRequest) Reset()         <span class="cov0" title="0">{ *m = UploadPartRequest{} }</span>
func (m *UploadPartRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*UploadPartRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*UploadPartRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_005e34be4304e022, []int{10}
}</span>

func (m *UploadPartRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_UploadPartRequest.Unmarshal(m, b)
}</span>
func (m *UploadPartRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_UploadPartRequest.Marshal(b, m, deterministic)
}</span>
func (m *UploadPartRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_UploadPartRequest.Merge(m, src)
}</span>
func (m *UploadPartRequest) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_UploadPartRequest.Size(m)
}</span>
func (m *UploadPartRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_UploadPartRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_UploadPartRequest proto.InternalMessageInfo

func (m *UploadPartRequest) GetBucketName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.BucketName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *UploadPartRequest) GetObjectKey() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ObjectKey
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *UploadPartRequest) GetUploadId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.UploadId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *UploadPartRequest) GetPartId() int32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.PartId
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *UploadPartRequest) GetSize() int64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Size
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *UploadPartRequest) GetMd5Hex() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Md5Hex
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type UploadPartResponse struct {
        ErrorCode            int32    `protobuf:"varint,1,opt,name=errorCode,proto3" json:"errorCode,omitempty"`
        ETag                 string   `protobuf:"bytes,2,opt,name=eTag,proto3" json:"eTag,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *UploadPartResponse) Reset()         <span class="cov0" title="0">{ *m = UploadPartResponse{} }</span>
func (m *UploadPartResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*UploadPartResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*UploadPartResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_005e34be4304e022, []int{11}
}</span>

func (m *UploadPartResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_UploadPartResponse.Unmarshal(m, b)
}</span>
func (m *UploadPartResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_UploadPartResponse.Marshal(b, m, deterministic)
}</span>
func (m *UploadPartResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_UploadPartResponse.Merge(m, src)
}</span>
func (m *UploadPartResponse) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_UploadPartResponse.Size(m)
}</span>
func (m *UploadPartResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_UploadPartResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_UploadPartResponse proto.InternalMessageInfo

func (m *UploadPartResponse) GetErrorCode() int32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ErrorCode
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *UploadPartResponse) GetETag() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ETag
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type CopyObjectRequest struct {
        SrcBucketName        string   `protobuf:"bytes,1,opt,name=srcBucketName,proto3" json:"srcBucketName,omitempty"`
        TargetBucketName     string   `protobuf:"bytes,2,opt,name=targetBucketName,proto3" json:"targetBucketName,omitempty"`
        SrcObjectName        string   `protobuf:"bytes,3,opt,name=srcObjectName,proto3" json:"srcObjectName,omitempty"`
        TargetObjectName     string   `protobuf:"bytes,4,opt,name=targetObjectName,proto3" json:"targetObjectName,omitempty"`
        TargetBackend        string   `protobuf:"bytes,5,opt,name=targetBackend,proto3" json:"targetBackend,omitempty"`
        TargetTier           int32    `protobuf:"varint,6,opt,name=targetTier,proto3" json:"targetTier,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *CopyObjectRequest) Reset()         <span class="cov0" title="0">{ *m = CopyObjectRequest{} }</span>
func (m *CopyObjectRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*CopyObjectRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*CopyObjectRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_005e34be4304e022, []int{12}
}</span>

func (m *CopyObjectRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_CopyObjectRequest.Unmarshal(m, b)
}</span>
func (m *CopyObjectRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_CopyObjectRequest.Marshal(b, m, deterministic)
}</span>
func (m *CopyObjectRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_CopyObjectRequest.Merge(m, src)
}</span>
func (m *CopyObjectRequest) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_CopyObjectRequest.Size(m)
}</span>
func (m *CopyObjectRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_CopyObjectRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_CopyObjectRequest proto.InternalMessageInfo

func (m *CopyObjectRequest) GetSrcBucketName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.SrcBucketName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *CopyObjectRequest) GetTargetBucketName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.TargetBucketName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *CopyObjectRequest) GetSrcObjectName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.SrcObjectName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *CopyObjectRequest) GetTargetObjectName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.TargetObjectName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *CopyObjectRequest) GetTargetBackend() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.TargetBackend
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *CopyObjectRequest) GetTargetTier() int32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.TargetTier
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type CopyObjectResponse struct {
        ErrorCode            int32    `protobuf:"varint,1,opt,name=errorCode,proto3" json:"errorCode,omitempty"`
        Md5                  string   `protobuf:"bytes,2,opt,name=md5,proto3" json:"md5,omitempty"`
        LastModified         int64    `protobuf:"varint,3,opt,name=lastModified,proto3" json:"lastModified,omitempty"`
        VersionId            string   `protobuf:"bytes,4,opt,name=versionId,proto3" json:"versionId,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *CopyObjectResponse) Reset()         <span class="cov0" title="0">{ *m = CopyObjectResponse{} }</span>
func (m *CopyObjectResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*CopyObjectResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*CopyObjectResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_005e34be4304e022, []int{13}
}</span>

func (m *CopyObjectResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_CopyObjectResponse.Unmarshal(m, b)
}</span>
func (m *CopyObjectResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_CopyObjectResponse.Marshal(b, m, deterministic)
}</span>
func (m *CopyObjectResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_CopyObjectResponse.Merge(m, src)
}</span>
func (m *CopyObjectResponse) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_CopyObjectResponse.Size(m)
}</span>
func (m *CopyObjectResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_CopyObjectResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_CopyObjectResponse proto.InternalMessageInfo

func (m *CopyObjectResponse) GetErrorCode() int32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ErrorCode
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *CopyObjectResponse) GetMd5() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Md5
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *CopyObjectResponse) GetLastModified() int64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.LastModified
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *CopyObjectResponse) GetVersionId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.VersionId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type MoveObjectRequest struct {
        SrcObject            string   `protobuf:"bytes,1,opt,name=srcObject,proto3" json:"srcObject,omitempty"`
        TargetObject         string   `protobuf:"bytes,2,opt,name=targetObject,proto3" json:"targetObject,omitempty"`
        SrcBucket            string   `protobuf:"bytes,3,opt,name=srcBucket,proto3" json:"srcBucket,omitempty"`
        TargetBucket         string   `protobuf:"bytes,4,opt,name=targetBucket,proto3" json:"targetBucket,omitempty"`
        TargetLocation       string   `protobuf:"bytes,5,opt,name=targetLocation,proto3" json:"targetLocation,omitempty"`
        TargetTier           int32    `protobuf:"varint,6,opt,name=targetTier,proto3" json:"targetTier,omitempty"`
        MoveType             int32    `protobuf:"varint,7,opt,name=moveType,proto3" json:"moveType,omitempty"`
        SrcObjectVersion     string   `protobuf:"bytes,8,opt,name=srcObjectVersion,proto3" json:"srcObjectVersion,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *MoveObjectRequest) Reset()         <span class="cov0" title="0">{ *m = MoveObjectRequest{} }</span>
func (m *MoveObjectRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*MoveObjectRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*MoveObjectRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_005e34be4304e022, []int{14}
}</span>

func (m *MoveObjectRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_MoveObjectRequest.Unmarshal(m, b)
}</span>
func (m *MoveObjectRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_MoveObjectRequest.Marshal(b, m, deterministic)
}</span>
func (m *MoveObjectRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_MoveObjectRequest.Merge(m, src)
}</span>
func (m *MoveObjectRequest) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_MoveObjectRequest.Size(m)
}</span>
func (m *MoveObjectRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_MoveObjectRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_MoveObjectRequest proto.InternalMessageInfo

func (m *MoveObjectRequest) GetSrcObject() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.SrcObject
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *MoveObjectRequest) GetTargetObject() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.TargetObject
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *MoveObjectRequest) GetSrcBucket() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.SrcBucket
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *MoveObjectRequest) GetTargetBucket() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.TargetBucket
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *MoveObjectRequest) GetTargetLocation() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.TargetLocation
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *MoveObjectRequest) GetTargetTier() int32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.TargetTier
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *MoveObjectRequest) GetMoveType() int32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.MoveType
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *MoveObjectRequest) GetSrcObjectVersion() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.SrcObjectVersion
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type MoveObjectResponse struct {
        ObjMeta              *Object  `protobuf:"bytes,1,opt,name=objMeta,proto3" json:"objMeta,omitempty"`
        Status               string   `protobuf:"bytes,2,opt,name=status,proto3" json:"status,omitempty"`
        Md5                  string   `protobuf:"bytes,3,opt,name=md5,proto3" json:"md5,omitempty"`
        VersionId            string   `protobuf:"bytes,4,opt,name=versionId,proto3" json:"versionId,omitempty"`
        LastModified         int64    `protobuf:"varint,5,opt,name=lastModified,proto3" json:"lastModified,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *MoveObjectResponse) Reset()         <span class="cov0" title="0">{ *m = MoveObjectResponse{} }</span>
func (m *MoveObjectResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*MoveObjectResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*MoveObjectResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_005e34be4304e022, []int{15}
}</span>

func (m *MoveObjectResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_MoveObjectResponse.Unmarshal(m, b)
}</span>
func (m *MoveObjectResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_MoveObjectResponse.Marshal(b, m, deterministic)
}</span>
func (m *MoveObjectResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_MoveObjectResponse.Merge(m, src)
}</span>
func (m *MoveObjectResponse) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_MoveObjectResponse.Size(m)
}</span>
func (m *MoveObjectResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_MoveObjectResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_MoveObjectResponse proto.InternalMessageInfo

func (m *MoveObjectResponse) GetObjMeta() *Object <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ObjMeta
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *MoveObjectResponse) GetStatus() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Status
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *MoveObjectResponse) GetMd5() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Md5
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *MoveObjectResponse) GetVersionId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.VersionId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *MoveObjectResponse) GetLastModified() int64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.LastModified
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type PutObjectRequest struct {
        BucketName           string            `protobuf:"bytes,1,opt,name=BucketName,proto3" json:"BucketName,omitempty"`
        ObjectKey            string            `protobuf:"bytes,2,opt,name=ObjectKey,proto3" json:"ObjectKey,omitempty"`
        Acl                  *Acl              `protobuf:"bytes,3,opt,name=Acl,proto3" json:"Acl,omitempty"`
        Attrs                map[string]string `protobuf:"bytes,4,rep,name=attrs,proto3" json:"attrs,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
        Location             string            `protobuf:"bytes,5,opt,name=location,proto3" json:"location,omitempty"`
        Size                 int64             `protobuf:"varint,6,opt,name=size,proto3" json:"size,omitempty"`
        ContentType          string            `protobuf:"bytes,7,opt,name=contentType,proto3" json:"contentType,omitempty"`
        XXX_NoUnkeyedLiteral struct{}          `json:"-"`
        XXX_unrecognized     []byte            `json:"-"`
        XXX_sizecache        int32             `json:"-"`
}

func (m *PutObjectRequest) Reset()         <span class="cov8" title="1">{ *m = PutObjectRequest{} }</span>
func (m *PutObjectRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*PutObjectRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*PutObjectRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_005e34be4304e022, []int{16}
}</span>

func (m *PutObjectRequest) XXX_Unmarshal(b []byte) error <span class="cov8" title="1">{
        return xxx_messageInfo_PutObjectRequest.Unmarshal(m, b)
}</span>
func (m *PutObjectRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_PutObjectRequest.Marshal(b, m, deterministic)
}</span>
func (m *PutObjectRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_PutObjectRequest.Merge(m, src)
}</span>
func (m *PutObjectRequest) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_PutObjectRequest.Size(m)
}</span>
func (m *PutObjectRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_PutObjectRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_PutObjectRequest proto.InternalMessageInfo

func (m *PutObjectRequest) GetBucketName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.BucketName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *PutObjectRequest) GetObjectKey() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ObjectKey
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *PutObjectRequest) GetAcl() *Acl <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Acl
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *PutObjectRequest) GetAttrs() map[string]string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Attrs
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *PutObjectRequest) GetLocation() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Location
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *PutObjectRequest) GetSize() int64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Size
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *PutObjectRequest) GetContentType() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ContentType
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type GetObjectResponse struct {
        ErrorCode            int32    `protobuf:"varint,1,opt,name=errorCode,proto3" json:"errorCode,omitempty"`
        Data                 []byte   `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *GetObjectResponse) Reset()         <span class="cov0" title="0">{ *m = GetObjectResponse{} }</span>
func (m *GetObjectResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*GetObjectResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*GetObjectResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_005e34be4304e022, []int{17}
}</span>

func (m *GetObjectResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_GetObjectResponse.Unmarshal(m, b)
}</span>
func (m *GetObjectResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov8" title="1">{
        return xxx_messageInfo_GetObjectResponse.Marshal(b, m, deterministic)
}</span>
func (m *GetObjectResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_GetObjectResponse.Merge(m, src)
}</span>
func (m *GetObjectResponse) XXX_Size() int <span class="cov8" title="1">{
        return xxx_messageInfo_GetObjectResponse.Size(m)
}</span>
func (m *GetObjectResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_GetObjectResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_GetObjectResponse proto.InternalMessageInfo

func (m *GetObjectResponse) GetErrorCode() int32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ErrorCode
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *GetObjectResponse) GetData() []byte <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Data
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type GetObjectMetaResult struct {
        ErrorCode            int32    `protobuf:"varint,1,opt,name=errorCode,proto3" json:"errorCode,omitempty"`
        Object               *Object  `protobuf:"bytes,2,opt,name=object,proto3" json:"object,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *GetObjectMetaResult) Reset()         <span class="cov0" title="0">{ *m = GetObjectMetaResult{} }</span>
func (m *GetObjectMetaResult) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*GetObjectMetaResult) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*GetObjectMetaResult) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_005e34be4304e022, []int{18}
}</span>

func (m *GetObjectMetaResult) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_GetObjectMetaResult.Unmarshal(m, b)
}</span>
func (m *GetObjectMetaResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov8" title="1">{
        return xxx_messageInfo_GetObjectMetaResult.Marshal(b, m, deterministic)
}</span>
func (m *GetObjectMetaResult) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_GetObjectMetaResult.Merge(m, src)
}</span>
func (m *GetObjectMetaResult) XXX_Size() int <span class="cov8" title="1">{
        return xxx_messageInfo_GetObjectMetaResult.Size(m)
}</span>
func (m *GetObjectMetaResult) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_GetObjectMetaResult.DiscardUnknown(m)
}</span>

var xxx_messageInfo_GetObjectMetaResult proto.InternalMessageInfo

func (m *GetObjectMetaResult) GetErrorCode() int32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ErrorCode
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *GetObjectMetaResult) GetObject() *Object <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Object
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type PutObjectResponse struct {
        ErrorCode            int32    `protobuf:"varint,1,opt,name=errorCode,proto3" json:"errorCode,omitempty"`
        ObjMeta              *Object  `protobuf:"bytes,2,opt,name=objMeta,proto3" json:"objMeta,omitempty"`
        Status               string   `protobuf:"bytes,3,opt,name=status,proto3" json:"status,omitempty"`
        Md5                  string   `protobuf:"bytes,4,opt,name=md5,proto3" json:"md5,omitempty"`
        VersionId            string   `protobuf:"bytes,5,opt,name=versionId,proto3" json:"versionId,omitempty"`
        LastModified         int64    `protobuf:"varint,6,opt,name=lastModified,proto3" json:"lastModified,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *PutObjectResponse) Reset()         <span class="cov0" title="0">{ *m = PutObjectResponse{} }</span>
func (m *PutObjectResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*PutObjectResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*PutObjectResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_005e34be4304e022, []int{19}
}</span>

func (m *PutObjectResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_PutObjectResponse.Unmarshal(m, b)
}</span>
func (m *PutObjectResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov8" title="1">{
        return xxx_messageInfo_PutObjectResponse.Marshal(b, m, deterministic)
}</span>
func (m *PutObjectResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_PutObjectResponse.Merge(m, src)
}</span>
func (m *PutObjectResponse) XXX_Size() int <span class="cov8" title="1">{
        return xxx_messageInfo_PutObjectResponse.Size(m)
}</span>
func (m *PutObjectResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_PutObjectResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_PutObjectResponse proto.InternalMessageInfo

func (m *PutObjectResponse) GetErrorCode() int32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ErrorCode
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *PutObjectResponse) GetObjMeta() *Object <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ObjMeta
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *PutObjectResponse) GetStatus() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Status
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *PutObjectResponse) GetMd5() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Md5
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *PutObjectResponse) GetVersionId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.VersionId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *PutObjectResponse) GetLastModified() int64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.LastModified
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type PutBucketACLRequest struct {
        ACLConfig            *BucketACL `protobuf:"bytes,1,opt,name=ACLConfig,proto3" json:"ACLConfig,omitempty"`
        XXX_NoUnkeyedLiteral struct{}   `json:"-"`
        XXX_unrecognized     []byte     `json:"-"`
        XXX_sizecache        int32      `json:"-"`
}

func (m *PutBucketACLRequest) Reset()         <span class="cov0" title="0">{ *m = PutBucketACLRequest{} }</span>
func (m *PutBucketACLRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*PutBucketACLRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*PutBucketACLRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_005e34be4304e022, []int{20}
}</span>

func (m *PutBucketACLRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_PutBucketACLRequest.Unmarshal(m, b)
}</span>
func (m *PutBucketACLRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_PutBucketACLRequest.Marshal(b, m, deterministic)
}</span>
func (m *PutBucketACLRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_PutBucketACLRequest.Merge(m, src)
}</span>
func (m *PutBucketACLRequest) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_PutBucketACLRequest.Size(m)
}</span>
func (m *PutBucketACLRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_PutBucketACLRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_PutBucketACLRequest proto.InternalMessageInfo

func (m *PutBucketACLRequest) GetACLConfig() *BucketACL <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ACLConfig
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type BucketACL struct {
        BucketName           string   `protobuf:"bytes,1,opt,name=BucketName,proto3" json:"BucketName,omitempty"`
        CannedAcl            string   `protobuf:"bytes,2,opt,name=CannedAcl,proto3" json:"CannedAcl,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *BucketACL) Reset()         <span class="cov0" title="0">{ *m = BucketACL{} }</span>
func (m *BucketACL) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*BucketACL) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*BucketACL) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_005e34be4304e022, []int{21}
}</span>

func (m *BucketACL) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_BucketACL.Unmarshal(m, b)
}</span>
func (m *BucketACL) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_BucketACL.Marshal(b, m, deterministic)
}</span>
func (m *BucketACL) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_BucketACL.Merge(m, src)
}</span>
func (m *BucketACL) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_BucketACL.Size(m)
}</span>
func (m *BucketACL) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_BucketACL.DiscardUnknown(m)
}</span>

var xxx_messageInfo_BucketACL proto.InternalMessageInfo

func (m *BucketACL) GetBucketName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.BucketName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *BucketACL) GetCannedAcl() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.CannedAcl
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type BucketVersioning struct {
        Status               string   `protobuf:"bytes,1,opt,name=Status,proto3" json:"Status,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *BucketVersioning) Reset()         <span class="cov0" title="0">{ *m = BucketVersioning{} }</span>
func (m *BucketVersioning) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*BucketVersioning) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*BucketVersioning) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_005e34be4304e022, []int{22}
}</span>

func (m *BucketVersioning) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_BucketVersioning.Unmarshal(m, b)
}</span>
func (m *BucketVersioning) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_BucketVersioning.Marshal(b, m, deterministic)
}</span>
func (m *BucketVersioning) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_BucketVersioning.Merge(m, src)
}</span>
func (m *BucketVersioning) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_BucketVersioning.Size(m)
}</span>
func (m *BucketVersioning) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_BucketVersioning.DiscardUnknown(m)
}</span>

var xxx_messageInfo_BucketVersioning proto.InternalMessageInfo

func (m *BucketVersioning) GetStatus() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Status
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type ObjACL struct {
        BucketName           string   `protobuf:"bytes,1,opt,name=BucketName,proto3" json:"BucketName,omitempty"`
        ObjectKey            string   `protobuf:"bytes,2,opt,name=ObjectKey,proto3" json:"ObjectKey,omitempty"`
        CannedAcl            string   `protobuf:"bytes,3,opt,name=CannedAcl,proto3" json:"CannedAcl,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *ObjACL) Reset()         <span class="cov0" title="0">{ *m = ObjACL{} }</span>
func (m *ObjACL) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*ObjACL) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*ObjACL) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_005e34be4304e022, []int{23}
}</span>

func (m *ObjACL) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_ObjACL.Unmarshal(m, b)
}</span>
func (m *ObjACL) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_ObjACL.Marshal(b, m, deterministic)
}</span>
func (m *ObjACL) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_ObjACL.Merge(m, src)
}</span>
func (m *ObjACL) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_ObjACL.Size(m)
}</span>
func (m *ObjACL) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_ObjACL.DiscardUnknown(m)
}</span>

var xxx_messageInfo_ObjACL proto.InternalMessageInfo

func (m *ObjACL) GetBucketName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.BucketName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *ObjACL) GetObjectKey() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ObjectKey
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *ObjACL) GetCannedAcl() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.CannedAcl
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type PutObjACLRequest struct {
        Context              string   `protobuf:"bytes,1,opt,name=Context,proto3" json:"Context,omitempty"`
        ACLConfig            *ObjACL  `protobuf:"bytes,2,opt,name=ACLConfig,proto3" json:"ACLConfig,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *PutObjACLRequest) Reset()         <span class="cov0" title="0">{ *m = PutObjACLRequest{} }</span>
func (m *PutObjACLRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*PutObjACLRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*PutObjACLRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_005e34be4304e022, []int{24}
}</span>

func (m *PutObjACLRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_PutObjACLRequest.Unmarshal(m, b)
}</span>
func (m *PutObjACLRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_PutObjACLRequest.Marshal(b, m, deterministic)
}</span>
func (m *PutObjACLRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_PutObjACLRequest.Merge(m, src)
}</span>
func (m *PutObjACLRequest) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_PutObjACLRequest.Size(m)
}</span>
func (m *PutObjACLRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_PutObjACLRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_PutObjACLRequest proto.InternalMessageInfo

func (m *PutObjACLRequest) GetContext() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Context
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *PutObjACLRequest) GetACLConfig() *ObjACL <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ACLConfig
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type BaseBucketRequest struct {
        Context              string   `protobuf:"bytes,1,opt,name=Context,proto3" json:"Context,omitempty"`
        BucketName           string   `protobuf:"bytes,2,opt,name=BucketName,proto3" json:"BucketName,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *BaseBucketRequest) Reset()         <span class="cov0" title="0">{ *m = BaseBucketRequest{} }</span>
func (m *BaseBucketRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*BaseBucketRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*BaseBucketRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_005e34be4304e022, []int{25}
}</span>

func (m *BaseBucketRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_BaseBucketRequest.Unmarshal(m, b)
}</span>
func (m *BaseBucketRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_BaseBucketRequest.Marshal(b, m, deterministic)
}</span>
func (m *BaseBucketRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_BaseBucketRequest.Merge(m, src)
}</span>
func (m *BaseBucketRequest) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_BaseBucketRequest.Size(m)
}</span>
func (m *BaseBucketRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_BaseBucketRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_BaseBucketRequest proto.InternalMessageInfo

func (m *BaseBucketRequest) GetContext() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Context
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *BaseBucketRequest) GetBucketName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.BucketName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type BaseObjRequest struct {
        Context              string   `protobuf:"bytes,1,opt,name=Context,proto3" json:"Context,omitempty"`
        BucketName           string   `protobuf:"bytes,2,opt,name=BucketName,proto3" json:"BucketName,omitempty"`
        ObjectKey            string   `protobuf:"bytes,3,opt,name=ObjectKey,proto3" json:"ObjectKey,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *BaseObjRequest) Reset()         <span class="cov0" title="0">{ *m = BaseObjRequest{} }</span>
func (m *BaseObjRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*BaseObjRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*BaseObjRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_005e34be4304e022, []int{26}
}</span>

func (m *BaseObjRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_BaseObjRequest.Unmarshal(m, b)
}</span>
func (m *BaseObjRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_BaseObjRequest.Marshal(b, m, deterministic)
}</span>
func (m *BaseObjRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_BaseObjRequest.Merge(m, src)
}</span>
func (m *BaseObjRequest) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_BaseObjRequest.Size(m)
}</span>
func (m *BaseObjRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_BaseObjRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_BaseObjRequest proto.InternalMessageInfo

func (m *BaseObjRequest) GetContext() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Context
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *BaseObjRequest) GetBucketName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.BucketName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *BaseObjRequest) GetObjectKey() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ObjectKey
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type CopyObjPartRequest struct {
        SourceBucket         string   `protobuf:"bytes,1,opt,name=SourceBucket,proto3" json:"SourceBucket,omitempty"`
        SourceObject         string   `protobuf:"bytes,2,opt,name=SourceObject,proto3" json:"SourceObject,omitempty"`
        TargetBucket         string   `protobuf:"bytes,3,opt,name=TargetBucket,proto3" json:"TargetBucket,omitempty"`
        TargetObject         string   `protobuf:"bytes,4,opt,name=TargetObject,proto3" json:"TargetObject,omitempty"`
        TargetLocation       string   `protobuf:"bytes,5,opt,name=TargetLocation,proto3" json:"TargetLocation,omitempty"`
        UploadID             string   `protobuf:"bytes,6,opt,name=UploadID,proto3" json:"UploadID,omitempty"`
        PartID               int64    `protobuf:"varint,7,opt,name=PartID,proto3" json:"PartID,omitempty"`
        ReadOffset           int64    `protobuf:"varint,8,opt,name=ReadOffset,proto3" json:"ReadOffset,omitempty"`
        ReadLength           int64    `protobuf:"varint,9,opt,name=ReadLength,proto3" json:"ReadLength,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *CopyObjPartRequest) Reset()         <span class="cov0" title="0">{ *m = CopyObjPartRequest{} }</span>
func (m *CopyObjPartRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*CopyObjPartRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*CopyObjPartRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_005e34be4304e022, []int{27}
}</span>

func (m *CopyObjPartRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_CopyObjPartRequest.Unmarshal(m, b)
}</span>
func (m *CopyObjPartRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_CopyObjPartRequest.Marshal(b, m, deterministic)
}</span>
func (m *CopyObjPartRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_CopyObjPartRequest.Merge(m, src)
}</span>
func (m *CopyObjPartRequest) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_CopyObjPartRequest.Size(m)
}</span>
func (m *CopyObjPartRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_CopyObjPartRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_CopyObjPartRequest proto.InternalMessageInfo

func (m *CopyObjPartRequest) GetSourceBucket() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.SourceBucket
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *CopyObjPartRequest) GetSourceObject() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.SourceObject
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *CopyObjPartRequest) GetTargetBucket() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.TargetBucket
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *CopyObjPartRequest) GetTargetObject() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.TargetObject
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *CopyObjPartRequest) GetTargetLocation() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.TargetLocation
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *CopyObjPartRequest) GetUploadID() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.UploadID
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *CopyObjPartRequest) GetPartID() int64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.PartID
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *CopyObjPartRequest) GetReadOffset() int64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ReadOffset
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *CopyObjPartRequest) GetReadLength() int64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ReadLength
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type CopyObjPartResponse struct {
        ErrorCode            int32    `protobuf:"varint,1,opt,name=ErrorCode,proto3" json:"ErrorCode,omitempty"`
        LastModified         int64    `protobuf:"varint,2,opt,name=LastModified,proto3" json:"LastModified,omitempty"`
        Etag                 string   `protobuf:"bytes,3,opt,name=Etag,proto3" json:"Etag,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *CopyObjPartResponse) Reset()         <span class="cov0" title="0">{ *m = CopyObjPartResponse{} }</span>
func (m *CopyObjPartResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*CopyObjPartResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*CopyObjPartResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_005e34be4304e022, []int{28}
}</span>

func (m *CopyObjPartResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_CopyObjPartResponse.Unmarshal(m, b)
}</span>
func (m *CopyObjPartResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_CopyObjPartResponse.Marshal(b, m, deterministic)
}</span>
func (m *CopyObjPartResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_CopyObjPartResponse.Merge(m, src)
}</span>
func (m *CopyObjPartResponse) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_CopyObjPartResponse.Size(m)
}</span>
func (m *CopyObjPartResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_CopyObjPartResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_CopyObjPartResponse proto.InternalMessageInfo

func (m *CopyObjPartResponse) GetErrorCode() int32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ErrorCode
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *CopyObjPartResponse) GetLastModified() int64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.LastModified
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *CopyObjPartResponse) GetEtag() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Etag
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type ServerSideEncryption struct {
        SseType              string   `protobuf:"bytes,1,opt,name=sseType,proto3" json:"sseType,omitempty"`
        EncryptionKey        []byte   `protobuf:"bytes,2,opt,name=encryptionKey,proto3" json:"encryptionKey,omitempty"`
        InitilizationVector  []byte   `protobuf:"bytes,3,opt,name=initilizationVector,proto3" json:"initilizationVector,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *ServerSideEncryption) Reset()         <span class="cov0" title="0">{ *m = ServerSideEncryption{} }</span>
func (m *ServerSideEncryption) String() string <span class="cov8" title="1">{ return proto.CompactTextString(m) }</span>
func (*ServerSideEncryption) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*ServerSideEncryption) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_005e34be4304e022, []int{29}
}</span>

func (m *ServerSideEncryption) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_ServerSideEncryption.Unmarshal(m, b)
}</span>
func (m *ServerSideEncryption) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_ServerSideEncryption.Marshal(b, m, deterministic)
}</span>
func (m *ServerSideEncryption) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_ServerSideEncryption.Merge(m, src)
}</span>
func (m *ServerSideEncryption) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_ServerSideEncryption.Size(m)
}</span>
func (m *ServerSideEncryption) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_ServerSideEncryption.DiscardUnknown(m)
}</span>

var xxx_messageInfo_ServerSideEncryption proto.InternalMessageInfo

func (m *ServerSideEncryption) GetSseType() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.SseType
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *ServerSideEncryption) GetEncryptionKey() []byte <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.EncryptionKey
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *ServerSideEncryption) GetInitilizationVector() []byte <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.InitilizationVector
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type RedirectAllRequestsTo struct {
        HostName             string   `protobuf:"bytes,1,opt,name=hostName,proto3" json:"hostName,omitempty"`
        Protocol             []string `protobuf:"bytes,2,rep,name=protocol,proto3" json:"protocol,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *RedirectAllRequestsTo) Reset()         <span class="cov0" title="0">{ *m = RedirectAllRequestsTo{} }</span>
func (m *RedirectAllRequestsTo) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*RedirectAllRequestsTo) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*RedirectAllRequestsTo) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_005e34be4304e022, []int{30}
}</span>

func (m *RedirectAllRequestsTo) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_RedirectAllRequestsTo.Unmarshal(m, b)
}</span>
func (m *RedirectAllRequestsTo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_RedirectAllRequestsTo.Marshal(b, m, deterministic)
}</span>
func (m *RedirectAllRequestsTo) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_RedirectAllRequestsTo.Merge(m, src)
}</span>
func (m *RedirectAllRequestsTo) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_RedirectAllRequestsTo.Size(m)
}</span>
func (m *RedirectAllRequestsTo) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_RedirectAllRequestsTo.DiscardUnknown(m)
}</span>

var xxx_messageInfo_RedirectAllRequestsTo proto.InternalMessageInfo

func (m *RedirectAllRequestsTo) GetHostName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.HostName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *RedirectAllRequestsTo) GetProtocol() []string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Protocol
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type Redirect struct {
        Protocol             string   `protobuf:"bytes,1,opt,name=protocol,proto3" json:"protocol,omitempty"`
        HostName             string   `protobuf:"bytes,2,opt,name=hostName,proto3" json:"hostName,omitempty"`
        ReplaceKeyPrefixWith string   `protobuf:"bytes,3,opt,name=replaceKeyPrefixWith,proto3" json:"replaceKeyPrefixWith,omitempty"`
        ReplaceKeyWith       string   `protobuf:"bytes,4,opt,name=replaceKeyWith,proto3" json:"replaceKeyWith,omitempty"`
        HttpRedirectCode     string   `protobuf:"bytes,5,opt,name=httpRedirectCode,proto3" json:"httpRedirectCode,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *Redirect) Reset()         <span class="cov0" title="0">{ *m = Redirect{} }</span>
func (m *Redirect) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*Redirect) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*Redirect) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_005e34be4304e022, []int{31}
}</span>

func (m *Redirect) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_Redirect.Unmarshal(m, b)
}</span>
func (m *Redirect) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_Redirect.Marshal(b, m, deterministic)
}</span>
func (m *Redirect) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_Redirect.Merge(m, src)
}</span>
func (m *Redirect) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_Redirect.Size(m)
}</span>
func (m *Redirect) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_Redirect.DiscardUnknown(m)
}</span>

var xxx_messageInfo_Redirect proto.InternalMessageInfo

func (m *Redirect) GetProtocol() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Protocol
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Redirect) GetHostName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.HostName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Redirect) GetReplaceKeyPrefixWith() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ReplaceKeyPrefixWith
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Redirect) GetReplaceKeyWith() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ReplaceKeyWith
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Redirect) GetHttpRedirectCode() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.HttpRedirectCode
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type Condition struct {
        KeyPrefixEquals             string   `protobuf:"bytes,1,opt,name=keyPrefixEquals,proto3" json:"keyPrefixEquals,omitempty"`
        HttpErrorCodeReturnedEquals string   `protobuf:"bytes,2,opt,name=httpErrorCodeReturnedEquals,proto3" json:"httpErrorCodeReturnedEquals,omitempty"`
        XXX_NoUnkeyedLiteral        struct{} `json:"-"`
        XXX_unrecognized            []byte   `json:"-"`
        XXX_sizecache               int32    `json:"-"`
}

func (m *Condition) Reset()         <span class="cov0" title="0">{ *m = Condition{} }</span>
func (m *Condition) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*Condition) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*Condition) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_005e34be4304e022, []int{32}
}</span>

func (m *Condition) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_Condition.Unmarshal(m, b)
}</span>
func (m *Condition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_Condition.Marshal(b, m, deterministic)
}</span>
func (m *Condition) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_Condition.Merge(m, src)
}</span>
func (m *Condition) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_Condition.Size(m)
}</span>
func (m *Condition) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_Condition.DiscardUnknown(m)
}</span>

var xxx_messageInfo_Condition proto.InternalMessageInfo

func (m *Condition) GetKeyPrefixEquals() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.KeyPrefixEquals
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Condition) GetHttpErrorCodeReturnedEquals() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.HttpErrorCodeReturnedEquals
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type RoutingRules struct {
        Redirect             *Redirect  `protobuf:"bytes,1,opt,name=redirect,proto3" json:"redirect,omitempty"`
        Condition            *Condition `protobuf:"bytes,2,opt,name=condition,proto3" json:"condition,omitempty"`
        XXX_NoUnkeyedLiteral struct{}   `json:"-"`
        XXX_unrecognized     []byte     `json:"-"`
        XXX_sizecache        int32      `json:"-"`
}

func (m *RoutingRules) Reset()         <span class="cov0" title="0">{ *m = RoutingRules{} }</span>
func (m *RoutingRules) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*RoutingRules) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*RoutingRules) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_005e34be4304e022, []int{33}
}</span>

func (m *RoutingRules) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_RoutingRules.Unmarshal(m, b)
}</span>
func (m *RoutingRules) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_RoutingRules.Marshal(b, m, deterministic)
}</span>
func (m *RoutingRules) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_RoutingRules.Merge(m, src)
}</span>
func (m *RoutingRules) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_RoutingRules.Size(m)
}</span>
func (m *RoutingRules) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_RoutingRules.DiscardUnknown(m)
}</span>

var xxx_messageInfo_RoutingRules proto.InternalMessageInfo

func (m *RoutingRules) GetRedirect() *Redirect <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Redirect
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *RoutingRules) GetCondition() *Condition <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Condition
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type WebsiteConfiguration struct {
        IndexDocument         string                 `protobuf:"bytes,1,opt,name=indexDocument,proto3" json:"indexDocument,omitempty"`
        ErrorDocument         string                 `protobuf:"bytes,2,opt,name=errorDocument,proto3" json:"errorDocument,omitempty"`
        RedirectAllRequestsTo *RedirectAllRequestsTo `protobuf:"bytes,3,opt,name=redirectAllRequestsTo,proto3" json:"redirectAllRequestsTo,omitempty"`
        RoutingRules          []*RoutingRules        `protobuf:"bytes,4,rep,name=routingRules,proto3" json:"routingRules,omitempty"`
        XXX_NoUnkeyedLiteral  struct{}               `json:"-"`
        XXX_unrecognized      []byte                 `json:"-"`
        XXX_sizecache         int32                  `json:"-"`
}

func (m *WebsiteConfiguration) Reset()         <span class="cov0" title="0">{ *m = WebsiteConfiguration{} }</span>
func (m *WebsiteConfiguration) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*WebsiteConfiguration) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*WebsiteConfiguration) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_005e34be4304e022, []int{34}
}</span>

func (m *WebsiteConfiguration) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_WebsiteConfiguration.Unmarshal(m, b)
}</span>
func (m *WebsiteConfiguration) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_WebsiteConfiguration.Marshal(b, m, deterministic)
}</span>
func (m *WebsiteConfiguration) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_WebsiteConfiguration.Merge(m, src)
}</span>
func (m *WebsiteConfiguration) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_WebsiteConfiguration.Size(m)
}</span>
func (m *WebsiteConfiguration) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_WebsiteConfiguration.DiscardUnknown(m)
}</span>

var xxx_messageInfo_WebsiteConfiguration proto.InternalMessageInfo

func (m *WebsiteConfiguration) GetIndexDocument() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.IndexDocument
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *WebsiteConfiguration) GetErrorDocument() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ErrorDocument
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *WebsiteConfiguration) GetRedirectAllRequestsTo() *RedirectAllRequestsTo <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.RedirectAllRequestsTo
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *WebsiteConfiguration) GetRoutingRules() []*RoutingRules <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.RoutingRules
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type CORSConfiguration struct {
        Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
        AllowedMethods       string   `protobuf:"bytes,2,opt,name=allowedMethods,proto3" json:"allowedMethods,omitempty"`
        AllowedOrigins       string   `protobuf:"bytes,3,opt,name=allowedOrigins,proto3" json:"allowedOrigins,omitempty"`
        AllowedHeaders       string   `protobuf:"bytes,4,opt,name=allowedHeaders,proto3" json:"allowedHeaders,omitempty"`
        MaxAgeSeconds        string   `protobuf:"bytes,5,opt,name=maxAgeSeconds,proto3" json:"maxAgeSeconds,omitempty"`
        ExposedHeaders       string   `protobuf:"bytes,6,opt,name=exposedHeaders,proto3" json:"exposedHeaders,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *CORSConfiguration) Reset()         <span class="cov0" title="0">{ *m = CORSConfiguration{} }</span>
func (m *CORSConfiguration) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*CORSConfiguration) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*CORSConfiguration) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_005e34be4304e022, []int{35}
}</span>

func (m *CORSConfiguration) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_CORSConfiguration.Unmarshal(m, b)
}</span>
func (m *CORSConfiguration) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_CORSConfiguration.Marshal(b, m, deterministic)
}</span>
func (m *CORSConfiguration) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_CORSConfiguration.Merge(m, src)
}</span>
func (m *CORSConfiguration) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_CORSConfiguration.Size(m)
}</span>
func (m *CORSConfiguration) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_CORSConfiguration.DiscardUnknown(m)
}</span>

var xxx_messageInfo_CORSConfiguration proto.InternalMessageInfo

func (m *CORSConfiguration) GetId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *CORSConfiguration) GetAllowedMethods() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.AllowedMethods
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *CORSConfiguration) GetAllowedOrigins() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.AllowedOrigins
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *CORSConfiguration) GetAllowedHeaders() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.AllowedHeaders
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *CORSConfiguration) GetMaxAgeSeconds() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.MaxAgeSeconds
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *CORSConfiguration) GetExposedHeaders() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ExposedHeaders
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type Destination struct {
        Bucket               string   `protobuf:"bytes,1,opt,name=bucket,proto3" json:"bucket,omitempty"`
        StorageClass         string   `protobuf:"bytes,2,opt,name=storageClass,proto3" json:"storageClass,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *Destination) Reset()         <span class="cov0" title="0">{ *m = Destination{} }</span>
func (m *Destination) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*Destination) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*Destination) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_005e34be4304e022, []int{36}
}</span>

func (m *Destination) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_Destination.Unmarshal(m, b)
}</span>
func (m *Destination) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_Destination.Marshal(b, m, deterministic)
}</span>
func (m *Destination) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_Destination.Merge(m, src)
}</span>
func (m *Destination) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_Destination.Size(m)
}</span>
func (m *Destination) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_Destination.DiscardUnknown(m)
}</span>

var xxx_messageInfo_Destination proto.InternalMessageInfo

func (m *Destination) GetBucket() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Bucket
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Destination) GetStorageClass() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.StorageClass
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type ReplicationRole struct {
        Id                   string       `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
        Prefix               string       `protobuf:"bytes,2,opt,name=prefix,proto3" json:"prefix,omitempty"`
        Enabled              bool         `protobuf:"varint,3,opt,name=enabled,proto3" json:"enabled,omitempty"`
        Destination          *Destination `protobuf:"bytes,4,opt,name=destination,proto3" json:"destination,omitempty"`
        XXX_NoUnkeyedLiteral struct{}     `json:"-"`
        XXX_unrecognized     []byte       `json:"-"`
        XXX_sizecache        int32        `json:"-"`
}

func (m *ReplicationRole) Reset()         <span class="cov0" title="0">{ *m = ReplicationRole{} }</span>
func (m *ReplicationRole) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*ReplicationRole) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*ReplicationRole) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_005e34be4304e022, []int{37}
}</span>

func (m *ReplicationRole) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_ReplicationRole.Unmarshal(m, b)
}</span>
func (m *ReplicationRole) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_ReplicationRole.Marshal(b, m, deterministic)
}</span>
func (m *ReplicationRole) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_ReplicationRole.Merge(m, src)
}</span>
func (m *ReplicationRole) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_ReplicationRole.Size(m)
}</span>
func (m *ReplicationRole) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_ReplicationRole.DiscardUnknown(m)
}</span>

var xxx_messageInfo_ReplicationRole proto.InternalMessageInfo

func (m *ReplicationRole) GetId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *ReplicationRole) GetPrefix() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Prefix
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *ReplicationRole) GetEnabled() bool <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Enabled
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (m *ReplicationRole) GetDestination() *Destination <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Destination
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type ReplicationConfiguration struct {
        Role                 string             `protobuf:"bytes,1,opt,name=role,proto3" json:"role,omitempty"`
        Rules                []*ReplicationRole `protobuf:"bytes,2,rep,name=rules,proto3" json:"rules,omitempty"`
        XXX_NoUnkeyedLiteral struct{}           `json:"-"`
        XXX_unrecognized     []byte             `json:"-"`
        XXX_sizecache        int32              `json:"-"`
}

func (m *ReplicationConfiguration) Reset()         <span class="cov0" title="0">{ *m = ReplicationConfiguration{} }</span>
func (m *ReplicationConfiguration) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*ReplicationConfiguration) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*ReplicationConfiguration) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_005e34be4304e022, []int{38}
}</span>

func (m *ReplicationConfiguration) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_ReplicationConfiguration.Unmarshal(m, b)
}</span>
func (m *ReplicationConfiguration) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_ReplicationConfiguration.Marshal(b, m, deterministic)
}</span>
func (m *ReplicationConfiguration) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_ReplicationConfiguration.Merge(m, src)
}</span>
func (m *ReplicationConfiguration) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_ReplicationConfiguration.Size(m)
}</span>
func (m *ReplicationConfiguration) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_ReplicationConfiguration.DiscardUnknown(m)
}</span>

var xxx_messageInfo_ReplicationConfiguration proto.InternalMessageInfo

func (m *ReplicationConfiguration) GetRole() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Role
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *ReplicationConfiguration) GetRules() []*ReplicationRole <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Rules
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type Tag struct {
        Key                  string   `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
        Val                  string   `protobuf:"bytes,2,opt,name=val,proto3" json:"val,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *Tag) Reset()         <span class="cov0" title="0">{ *m = Tag{} }</span>
func (m *Tag) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*Tag) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*Tag) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_005e34be4304e022, []int{39}
}</span>

func (m *Tag) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_Tag.Unmarshal(m, b)
}</span>
func (m *Tag) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_Tag.Marshal(b, m, deterministic)
}</span>
func (m *Tag) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_Tag.Merge(m, src)
}</span>
func (m *Tag) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_Tag.Size(m)
}</span>
func (m *Tag) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_Tag.DiscardUnknown(m)
}</span>

var xxx_messageInfo_Tag proto.InternalMessageInfo

func (m *Tag) GetKey() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Key
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Tag) GetVal() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Val
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type LifecycleFilter struct {
        //Object prefix for lifecycle filter
        Prefix               string   `protobuf:"bytes,1,opt,name=prefix,proto3" json:"prefix,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *LifecycleFilter) Reset()         <span class="cov0" title="0">{ *m = LifecycleFilter{} }</span>
func (m *LifecycleFilter) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*LifecycleFilter) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*LifecycleFilter) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_005e34be4304e022, []int{40}
}</span>

func (m *LifecycleFilter) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_LifecycleFilter.Unmarshal(m, b)
}</span>
func (m *LifecycleFilter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_LifecycleFilter.Marshal(b, m, deterministic)
}</span>
func (m *LifecycleFilter) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_LifecycleFilter.Merge(m, src)
}</span>
func (m *LifecycleFilter) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_LifecycleFilter.Size(m)
}</span>
func (m *LifecycleFilter) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_LifecycleFilter.DiscardUnknown(m)
}</span>

var xxx_messageInfo_LifecycleFilter proto.InternalMessageInfo

func (m *LifecycleFilter) GetPrefix() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Prefix
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type Action struct {
        //Name of the action transition/expiration
        Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
        //Days after creation of object
        Days int32 `protobuf:"varint,2,opt,name=days,proto3" json:"days,omitempty"`
        //Delete marker in case of expiration for versioned bucket
        DeleteMarker string `protobuf:"bytes,3,opt,name=deleteMarker,proto3" json:"deleteMarker,omitempty"`
        //Storage class tier of the object where object is to be transitioned
        Tier int32 `protobuf:"varint,4,opt,name=tier,proto3" json:"tier,omitempty"`
        // Destination backend of the object/bucket for Cross-cloud transition
        Backend              string   `protobuf:"bytes,5,opt,name=backend,proto3" json:"backend,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *Action) Reset()         <span class="cov0" title="0">{ *m = Action{} }</span>
func (m *Action) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*Action) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*Action) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_005e34be4304e022, []int{41}
}</span>

func (m *Action) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_Action.Unmarshal(m, b)
}</span>
func (m *Action) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_Action.Marshal(b, m, deterministic)
}</span>
func (m *Action) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_Action.Merge(m, src)
}</span>
func (m *Action) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_Action.Size(m)
}</span>
func (m *Action) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_Action.DiscardUnknown(m)
}</span>

var xxx_messageInfo_Action proto.InternalMessageInfo

func (m *Action) GetName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Action) GetDays() int32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Days
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *Action) GetDeleteMarker() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.DeleteMarker
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Action) GetTier() int32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Tier
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *Action) GetBackend() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Backend
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type AbortMultipartUpload struct {
        //Days after which the abort operation will be performed on incomplete upload
        DaysAfterInitiation  int32    `protobuf:"varint,1,opt,name=daysAfterInitiation,proto3" json:"daysAfterInitiation,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *AbortMultipartUpload) Reset()         <span class="cov0" title="0">{ *m = AbortMultipartUpload{} }</span>
func (m *AbortMultipartUpload) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*AbortMultipartUpload) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*AbortMultipartUpload) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_005e34be4304e022, []int{42}
}</span>

func (m *AbortMultipartUpload) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_AbortMultipartUpload.Unmarshal(m, b)
}</span>
func (m *AbortMultipartUpload) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_AbortMultipartUpload.Marshal(b, m, deterministic)
}</span>
func (m *AbortMultipartUpload) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_AbortMultipartUpload.Merge(m, src)
}</span>
func (m *AbortMultipartUpload) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_AbortMultipartUpload.Size(m)
}</span>
func (m *AbortMultipartUpload) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_AbortMultipartUpload.DiscardUnknown(m)
}</span>

var xxx_messageInfo_AbortMultipartUpload proto.InternalMessageInfo

func (m *AbortMultipartUpload) GetDaysAfterInitiation() int32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.DaysAfterInitiation
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type LifecycleRule struct {
        Id                             string                `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
        Status                         string                `protobuf:"bytes,2,opt,name=status,proto3" json:"status,omitempty"`
        Filter                         *LifecycleFilter      `protobuf:"bytes,3,opt,name=filter,proto3" json:"filter,omitempty"`
        Actions                        []*Action             `protobuf:"bytes,4,rep,name=actions,proto3" json:"actions,omitempty"`
        AbortIncompleteMultipartUpload *AbortMultipartUpload `protobuf:"bytes,5,opt,name=abortIncompleteMultipartUpload,proto3" json:"abortIncompleteMultipartUpload,omitempty"`
        XXX_NoUnkeyedLiteral           struct{}              `json:"-"`
        XXX_unrecognized               []byte                `json:"-"`
        XXX_sizecache                  int32                 `json:"-"`
}

func (m *LifecycleRule) Reset()         <span class="cov0" title="0">{ *m = LifecycleRule{} }</span>
func (m *LifecycleRule) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*LifecycleRule) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*LifecycleRule) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_005e34be4304e022, []int{43}
}</span>

func (m *LifecycleRule) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_LifecycleRule.Unmarshal(m, b)
}</span>
func (m *LifecycleRule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_LifecycleRule.Marshal(b, m, deterministic)
}</span>
func (m *LifecycleRule) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_LifecycleRule.Merge(m, src)
}</span>
func (m *LifecycleRule) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_LifecycleRule.Size(m)
}</span>
func (m *LifecycleRule) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_LifecycleRule.DiscardUnknown(m)
}</span>

var xxx_messageInfo_LifecycleRule proto.InternalMessageInfo

func (m *LifecycleRule) GetId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *LifecycleRule) GetStatus() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Status
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *LifecycleRule) GetFilter() *LifecycleFilter <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Filter
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *LifecycleRule) GetActions() []*Action <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Actions
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *LifecycleRule) GetAbortIncompleteMultipartUpload() *AbortMultipartUpload <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.AbortIncompleteMultipartUpload
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type PutBucketLifecycleRequest struct {
        BucketName           string           `protobuf:"bytes,1,opt,name=bucketName,proto3" json:"bucketName,omitempty"`
        Lc                   []*LifecycleRule `protobuf:"bytes,2,rep,name=lc,proto3" json:"lc,omitempty"`
        XXX_NoUnkeyedLiteral struct{}         `json:"-"`
        XXX_unrecognized     []byte           `json:"-"`
        XXX_sizecache        int32            `json:"-"`
}

func (m *PutBucketLifecycleRequest) Reset()         <span class="cov0" title="0">{ *m = PutBucketLifecycleRequest{} }</span>
func (m *PutBucketLifecycleRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*PutBucketLifecycleRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*PutBucketLifecycleRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_005e34be4304e022, []int{44}
}</span>

func (m *PutBucketLifecycleRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_PutBucketLifecycleRequest.Unmarshal(m, b)
}</span>
func (m *PutBucketLifecycleRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_PutBucketLifecycleRequest.Marshal(b, m, deterministic)
}</span>
func (m *PutBucketLifecycleRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_PutBucketLifecycleRequest.Merge(m, src)
}</span>
func (m *PutBucketLifecycleRequest) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_PutBucketLifecycleRequest.Size(m)
}</span>
func (m *PutBucketLifecycleRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_PutBucketLifecycleRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_PutBucketLifecycleRequest proto.InternalMessageInfo

func (m *PutBucketLifecycleRequest) GetBucketName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.BucketName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *PutBucketLifecycleRequest) GetLc() []*LifecycleRule <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Lc
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type GetBucketLifecycleResponse struct {
        ErrorCode            int32            `protobuf:"varint,1,opt,name=errorCode,proto3" json:"errorCode,omitempty"`
        Lc                   []*LifecycleRule `protobuf:"bytes,2,rep,name=lc,proto3" json:"lc,omitempty"`
        XXX_NoUnkeyedLiteral struct{}         `json:"-"`
        XXX_unrecognized     []byte           `json:"-"`
        XXX_sizecache        int32            `json:"-"`
}

func (m *GetBucketLifecycleResponse) Reset()         <span class="cov0" title="0">{ *m = GetBucketLifecycleResponse{} }</span>
func (m *GetBucketLifecycleResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*GetBucketLifecycleResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*GetBucketLifecycleResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_005e34be4304e022, []int{45}
}</span>

func (m *GetBucketLifecycleResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_GetBucketLifecycleResponse.Unmarshal(m, b)
}</span>
func (m *GetBucketLifecycleResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov8" title="1">{
        return xxx_messageInfo_GetBucketLifecycleResponse.Marshal(b, m, deterministic)
}</span>
func (m *GetBucketLifecycleResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_GetBucketLifecycleResponse.Merge(m, src)
}</span>
func (m *GetBucketLifecycleResponse) XXX_Size() int <span class="cov8" title="1">{
        return xxx_messageInfo_GetBucketLifecycleResponse.Size(m)
}</span>
func (m *GetBucketLifecycleResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_GetBucketLifecycleResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_GetBucketLifecycleResponse proto.InternalMessageInfo

func (m *GetBucketLifecycleResponse) GetErrorCode() int32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ErrorCode
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *GetBucketLifecycleResponse) GetLc() []*LifecycleRule <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Lc
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type ReplicationInfo struct {
        Status               string   `protobuf:"bytes,1,opt,name=status,proto3" json:"status,omitempty"`
        Backend              string   `protobuf:"bytes,2,opt,name=backend,proto3" json:"backend,omitempty"`
        StorageClass         string   `protobuf:"bytes,3,opt,name=storageClass,proto3" json:"storageClass,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *ReplicationInfo) Reset()         <span class="cov0" title="0">{ *m = ReplicationInfo{} }</span>
func (m *ReplicationInfo) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*ReplicationInfo) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*ReplicationInfo) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_005e34be4304e022, []int{46}
}</span>

func (m *ReplicationInfo) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_ReplicationInfo.Unmarshal(m, b)
}</span>
func (m *ReplicationInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_ReplicationInfo.Marshal(b, m, deterministic)
}</span>
func (m *ReplicationInfo) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_ReplicationInfo.Merge(m, src)
}</span>
func (m *ReplicationInfo) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_ReplicationInfo.Size(m)
}</span>
func (m *ReplicationInfo) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_ReplicationInfo.DiscardUnknown(m)
}</span>

var xxx_messageInfo_ReplicationInfo proto.InternalMessageInfo

func (m *ReplicationInfo) GetStatus() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Status
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *ReplicationInfo) GetBackend() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Backend
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *ReplicationInfo) GetStorageClass() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.StorageClass
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type Acl struct {
        CannedAcl            string   `protobuf:"bytes,1,opt,name=cannedAcl,proto3" json:"cannedAcl,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *Acl) Reset()         <span class="cov0" title="0">{ *m = Acl{} }</span>
func (m *Acl) String() string <span class="cov8" title="1">{ return proto.CompactTextString(m) }</span>
func (*Acl) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*Acl) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_005e34be4304e022, []int{47}
}</span>

func (m *Acl) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_Acl.Unmarshal(m, b)
}</span>
func (m *Acl) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_Acl.Marshal(b, m, deterministic)
}</span>
func (m *Acl) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_Acl.Merge(m, src)
}</span>
func (m *Acl) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_Acl.Size(m)
}</span>
func (m *Acl) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_Acl.DiscardUnknown(m)
}</span>

var xxx_messageInfo_Acl proto.InternalMessageInfo

func (m *Acl) GetCannedAcl() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.CannedAcl
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type GetBucketResponse struct {
        ErrorCode            int32    `protobuf:"varint,1,opt,name=errorCode,proto3" json:"errorCode,omitempty"`
        BucketMeta           *Bucket  `protobuf:"bytes,2,opt,name=bucketMeta,proto3" json:"bucketMeta,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *GetBucketResponse) Reset()         <span class="cov0" title="0">{ *m = GetBucketResponse{} }</span>
func (m *GetBucketResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*GetBucketResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*GetBucketResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_005e34be4304e022, []int{48}
}</span>

func (m *GetBucketResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_GetBucketResponse.Unmarshal(m, b)
}</span>
func (m *GetBucketResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov8" title="1">{
        return xxx_messageInfo_GetBucketResponse.Marshal(b, m, deterministic)
}</span>
func (m *GetBucketResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_GetBucketResponse.Merge(m, src)
}</span>
func (m *GetBucketResponse) XXX_Size() int <span class="cov8" title="1">{
        return xxx_messageInfo_GetBucketResponse.Size(m)
}</span>
func (m *GetBucketResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_GetBucketResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_GetBucketResponse proto.InternalMessageInfo

func (m *GetBucketResponse) GetErrorCode() int32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ErrorCode
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *GetBucketResponse) GetBucketMeta() *Bucket <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.BucketMeta
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type Bucket struct {
        Name                     string                    `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
        TenantId                 string                    `protobuf:"bytes,2,opt,name=tenantId,proto3" json:"tenantId,omitempty"`
        UserId                   string                    `protobuf:"bytes,3,opt,name=userId,proto3" json:"userId,omitempty"`
        Acl                      *Acl                      `protobuf:"bytes,4,opt,name=acl,proto3" json:"acl,omitempty"`
        CreateTime               int64                     `protobuf:"varint,5,opt,name=createTime,proto3" json:"createTime,omitempty"`
        Id                       string                    `protobuf:"bytes,6,opt,name=id,proto3" json:"id,omitempty"`
        Deleted                  bool                      `protobuf:"varint,7,opt,name=deleted,proto3" json:"deleted,omitempty"`
        ServerSideEncryption     *ServerSideEncryption     `protobuf:"bytes,8,opt,name=serverSideEncryption,proto3" json:"serverSideEncryption,omitempty"`
        Versioning               *BucketVersioning         `protobuf:"bytes,9,opt,name=versioning,proto3" json:"versioning,omitempty"`
        DefaultLocation          string                    `protobuf:"bytes,10,opt,name=defaultLocation,proto3" json:"defaultLocation,omitempty"`
        WebsiteConfiguration     *WebsiteConfiguration     `protobuf:"bytes,11,opt,name=websiteConfiguration,proto3" json:"websiteConfiguration,omitempty"`
        Cors                     *CORSConfiguration        `protobuf:"bytes,12,opt,name=cors,proto3" json:"cors,omitempty"`
        ReplicationConfiguration *ReplicationConfiguration `protobuf:"bytes,13,opt,name=replicationConfiguration,proto3" json:"replicationConfiguration,omitempty"`
        LifecycleConfiguration   []*LifecycleRule          `protobuf:"bytes,14,rep,name=lifecycleConfiguration,proto3" json:"lifecycleConfiguration,omitempty"`
        BucketPolicy             string                    `protobuf:"bytes,15,opt,name=bucketPolicy,proto3" json:"bucketPolicy,omitempty"`
        Usages                   int64                     `protobuf:"varint,16,opt,name=usages,proto3" json:"usages,omitempty"`
        Tier                     int32                     `protobuf:"varint,17,opt,name=tier,proto3" json:"tier,omitempty"`
        ReplicationInfo          []*ReplicationInfo        `protobuf:"bytes,18,rep,name=replicationInfo,proto3" json:"replicationInfo,omitempty"`
        XXX_NoUnkeyedLiteral     struct{}                  `json:"-"`
        XXX_unrecognized         []byte                    `json:"-"`
        XXX_sizecache            int32                     `json:"-"`
}

func (m *Bucket) Reset()         <span class="cov8" title="1">{ *m = Bucket{} }</span>
func (m *Bucket) String() string <span class="cov8" title="1">{ return proto.CompactTextString(m) }</span>
func (*Bucket) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*Bucket) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_005e34be4304e022, []int{49}
}</span>

func (m *Bucket) XXX_Unmarshal(b []byte) error <span class="cov8" title="1">{
        return xxx_messageInfo_Bucket.Unmarshal(m, b)
}</span>
func (m *Bucket) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_Bucket.Marshal(b, m, deterministic)
}</span>
func (m *Bucket) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_Bucket.Merge(m, src)
}</span>
func (m *Bucket) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_Bucket.Size(m)
}</span>
func (m *Bucket) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_Bucket.DiscardUnknown(m)
}</span>

var xxx_messageInfo_Bucket proto.InternalMessageInfo

func (m *Bucket) GetName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Bucket) GetTenantId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.TenantId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Bucket) GetUserId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.UserId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Bucket) GetAcl() *Acl <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Acl
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *Bucket) GetCreateTime() int64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.CreateTime
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *Bucket) GetId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Bucket) GetDeleted() bool <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Deleted
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (m *Bucket) GetServerSideEncryption() *ServerSideEncryption <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ServerSideEncryption
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *Bucket) GetVersioning() *BucketVersioning <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Versioning
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *Bucket) GetDefaultLocation() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.DefaultLocation
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Bucket) GetWebsiteConfiguration() *WebsiteConfiguration <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.WebsiteConfiguration
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *Bucket) GetCors() *CORSConfiguration <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Cors
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *Bucket) GetReplicationConfiguration() *ReplicationConfiguration <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ReplicationConfiguration
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *Bucket) GetLifecycleConfiguration() []*LifecycleRule <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.LifecycleConfiguration
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *Bucket) GetBucketPolicy() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.BucketPolicy
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Bucket) GetUsages() int64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Usages
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *Bucket) GetTier() int32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Tier
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *Bucket) GetReplicationInfo() []*ReplicationInfo <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ReplicationInfo
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type Partion struct {
        Key                  string   `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
        PartNumber           int64    `protobuf:"varint,2,opt,name=partNumber,proto3" json:"partNumber,omitempty"`
        Size                 int64    `protobuf:"varint,3,opt,name=size,proto3" json:"size,omitempty"`
        Etag                 string   `protobuf:"bytes,4,opt,name=etag,proto3" json:"etag,omitempty"`
        LastModified         int64    `protobuf:"varint,5,opt,name=lastModified,proto3" json:"lastModified,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *Partion) Reset()         <span class="cov0" title="0">{ *m = Partion{} }</span>
func (m *Partion) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*Partion) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*Partion) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_005e34be4304e022, []int{50}
}</span>

func (m *Partion) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_Partion.Unmarshal(m, b)
}</span>
func (m *Partion) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_Partion.Marshal(b, m, deterministic)
}</span>
func (m *Partion) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_Partion.Merge(m, src)
}</span>
func (m *Partion) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_Partion.Size(m)
}</span>
func (m *Partion) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_Partion.DiscardUnknown(m)
}</span>

var xxx_messageInfo_Partion proto.InternalMessageInfo

func (m *Partion) GetKey() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Key
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Partion) GetPartNumber() int64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.PartNumber
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *Partion) GetSize() int64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Size
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *Partion) GetEtag() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Etag
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Partion) GetLastModified() int64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.LastModified
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type Version struct {
        Versionid            string   `protobuf:"bytes,1,opt,name=versionid,proto3" json:"versionid,omitempty"`
        Etag                 string   `protobuf:"bytes,2,opt,name=etag,proto3" json:"etag,omitempty"`
        IsLatest             string   `protobuf:"bytes,3,opt,name=isLatest,proto3" json:"isLatest,omitempty"`
        LastModified         int64    `protobuf:"varint,4,opt,name=lastModified,proto3" json:"lastModified,omitempty"`
        Size                 int64    `protobuf:"varint,5,opt,name=size,proto3" json:"size,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *Version) Reset()         <span class="cov0" title="0">{ *m = Version{} }</span>
func (m *Version) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*Version) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*Version) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_005e34be4304e022, []int{51}
}</span>

func (m *Version) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_Version.Unmarshal(m, b)
}</span>
func (m *Version) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_Version.Marshal(b, m, deterministic)
}</span>
func (m *Version) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_Version.Merge(m, src)
}</span>
func (m *Version) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_Version.Size(m)
}</span>
func (m *Version) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_Version.DiscardUnknown(m)
}</span>

var xxx_messageInfo_Version proto.InternalMessageInfo

func (m *Version) GetVersionid() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Versionid
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Version) GetEtag() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Etag
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Version) GetIsLatest() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.IsLatest
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Version) GetLastModified() int64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.LastModified
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *Version) GetSize() int64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Size
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type Object struct {
        ObjectKey               string                `protobuf:"bytes,1,opt,name=objectKey,proto3" json:"objectKey,omitempty"`
        BucketName              string                `protobuf:"bytes,2,opt,name=bucketName,proto3" json:"bucketName,omitempty"`
        TenantId                string                `protobuf:"bytes,3,opt,name=tenantId,proto3" json:"tenantId,omitempty"`
        UserId                  string                `protobuf:"bytes,4,opt,name=userId,proto3" json:"userId,omitempty"`
        VersionId               string                `protobuf:"bytes,5,opt,name=versionId,proto3" json:"versionId,omitempty"`
        ObjectId                string                `protobuf:"bytes,6,opt,name=objectId,proto3" json:"objectId,omitempty"`
        ContentType             string                `protobuf:"bytes,7,opt,name=contentType,proto3" json:"contentType,omitempty"`
        ContentMd5              string                `protobuf:"bytes,8,opt,name=contentMd5,proto3" json:"contentMd5,omitempty"`
        Versions                []*Version            `protobuf:"bytes,9,rep,name=versions,proto3" json:"versions,omitempty"`
        StorageClass            string                `protobuf:"bytes,10,opt,name=storageClass,proto3" json:"storageClass,omitempty"`
        ServerSideEncryption    *ServerSideEncryption `protobuf:"bytes,11,opt,name=serverSideEncryption,proto3" json:"serverSideEncryption,omitempty"`
        WebsiteRedirectLocation string                `protobuf:"bytes,12,opt,name=websiteRedirectLocation,proto3" json:"websiteRedirectLocation,omitempty"`
        Acl                     *Acl                  `protobuf:"bytes,13,opt,name=acl,proto3" json:"acl,omitempty"`
        Location                string                `protobuf:"bytes,14,opt,name=location,proto3" json:"location,omitempty"`
        IsNull                  bool                  `protobuf:"varint,15,opt,name=isNull,proto3" json:"isNull,omitempty"`
        DeleteMarker            bool                  `protobuf:"varint,16,opt,name=deleteMarker,proto3" json:"deleteMarker,omitempty"`
        Size                    int64                 `protobuf:"varint,17,opt,name=size,proto3" json:"size,omitempty"`
        Tags                    []*Tag                `protobuf:"bytes,18,rep,name=tags,proto3" json:"tags,omitempty"`
        LastModified            int64                 `protobuf:"varint,19,opt,name=lastModified,proto3" json:"lastModified,omitempty"`
        Etag                    string                `protobuf:"bytes,20,opt,name=etag,proto3" json:"etag,omitempty"`
        Tier                    int32                 `protobuf:"varint,21,opt,name=tier,proto3" json:"tier,omitempty"`
        Type                    int32                 `protobuf:"varint,22,opt,name=type,proto3" json:"type,omitempty"`
        NullVersion             bool                  `protobuf:"varint,23,opt,name=nullVersion,proto3" json:"nullVersion,omitempty"`
        CustomAttributes        map[string]string     `protobuf:"bytes,24,rep,name=customAttributes,proto3" json:"customAttributes,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
        StorageMeta             string                `protobuf:"bytes,25,opt,name=storageMeta,proto3" json:"storageMeta,omitempty"`
        EncSize                 int64                 `protobuf:"varint,26,opt,name=encSize,proto3" json:"encSize,omitempty"`
        XXX_NoUnkeyedLiteral    struct{}              `json:"-"`
        XXX_unrecognized        []byte                `json:"-"`
        XXX_sizecache           int32                 `json:"-"`
}

func (m *Object) Reset()         <span class="cov8" title="1">{ *m = Object{} }</span>
func (m *Object) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*Object) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*Object) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_005e34be4304e022, []int{52}
}</span>

func (m *Object) XXX_Unmarshal(b []byte) error <span class="cov8" title="1">{
        return xxx_messageInfo_Object.Unmarshal(m, b)
}</span>
func (m *Object) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_Object.Marshal(b, m, deterministic)
}</span>
func (m *Object) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_Object.Merge(m, src)
}</span>
func (m *Object) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_Object.Size(m)
}</span>
func (m *Object) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_Object.DiscardUnknown(m)
}</span>

var xxx_messageInfo_Object proto.InternalMessageInfo

func (m *Object) GetObjectKey() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ObjectKey
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Object) GetBucketName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.BucketName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Object) GetTenantId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.TenantId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Object) GetUserId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.UserId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Object) GetVersionId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.VersionId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Object) GetObjectId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ObjectId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Object) GetContentType() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ContentType
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Object) GetContentMd5() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ContentMd5
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Object) GetVersions() []*Version <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Versions
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *Object) GetStorageClass() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.StorageClass
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Object) GetServerSideEncryption() *ServerSideEncryption <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ServerSideEncryption
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *Object) GetWebsiteRedirectLocation() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.WebsiteRedirectLocation
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Object) GetAcl() *Acl <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Acl
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *Object) GetLocation() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Location
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Object) GetIsNull() bool <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.IsNull
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (m *Object) GetDeleteMarker() bool <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.DeleteMarker
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (m *Object) GetSize() int64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Size
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *Object) GetTags() []*Tag <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Tags
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *Object) GetLastModified() int64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.LastModified
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *Object) GetEtag() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Etag
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Object) GetTier() int32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Tier
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *Object) GetType() int32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Type
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *Object) GetNullVersion() bool <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.NullVersion
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (m *Object) GetCustomAttributes() map[string]string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.CustomAttributes
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *Object) GetStorageMeta() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.StorageMeta
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Object) GetEncSize() int64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.EncSize
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type ListBucketsResponse struct {
        ErrorCode            int32     `protobuf:"varint,1,opt,name=errorCode,proto3" json:"errorCode,omitempty"`
        Buckets              []*Bucket `protobuf:"bytes,2,rep,name=buckets,proto3" json:"buckets,omitempty"`
        XXX_NoUnkeyedLiteral struct{}  `json:"-"`
        XXX_unrecognized     []byte    `json:"-"`
        XXX_sizecache        int32     `json:"-"`
}

func (m *ListBucketsResponse) Reset()         <span class="cov0" title="0">{ *m = ListBucketsResponse{} }</span>
func (m *ListBucketsResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*ListBucketsResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*ListBucketsResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_005e34be4304e022, []int{53}
}</span>

func (m *ListBucketsResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_ListBucketsResponse.Unmarshal(m, b)
}</span>
func (m *ListBucketsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov8" title="1">{
        return xxx_messageInfo_ListBucketsResponse.Marshal(b, m, deterministic)
}</span>
func (m *ListBucketsResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_ListBucketsResponse.Merge(m, src)
}</span>
func (m *ListBucketsResponse) XXX_Size() int <span class="cov8" title="1">{
        return xxx_messageInfo_ListBucketsResponse.Size(m)
}</span>
func (m *ListBucketsResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_ListBucketsResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_ListBucketsResponse proto.InternalMessageInfo

func (m *ListBucketsResponse) GetErrorCode() int32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ErrorCode
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *ListBucketsResponse) GetBuckets() []*Bucket <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Buckets
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type BaseResponse struct {
        ErrorCode            int32    `protobuf:"varint,1,opt,name=errorCode,proto3" json:"errorCode,omitempty"`
        Msg                  string   `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *BaseResponse) Reset()         <span class="cov0" title="0">{ *m = BaseResponse{} }</span>
func (m *BaseResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*BaseResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*BaseResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_005e34be4304e022, []int{54}
}</span>

func (m *BaseResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_BaseResponse.Unmarshal(m, b)
}</span>
func (m *BaseResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov8" title="1">{
        return xxx_messageInfo_BaseResponse.Marshal(b, m, deterministic)
}</span>
func (m *BaseResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_BaseResponse.Merge(m, src)
}</span>
func (m *BaseResponse) XXX_Size() int <span class="cov8" title="1">{
        return xxx_messageInfo_BaseResponse.Size(m)
}</span>
func (m *BaseResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_BaseResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_BaseResponse proto.InternalMessageInfo

func (m *BaseResponse) GetErrorCode() int32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ErrorCode
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *BaseResponse) GetMsg() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Msg
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type BaseRequest struct {
        Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *BaseRequest) Reset()         <span class="cov8" title="1">{ *m = BaseRequest{} }</span>
func (m *BaseRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*BaseRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*BaseRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_005e34be4304e022, []int{55}
}</span>

func (m *BaseRequest) XXX_Unmarshal(b []byte) error <span class="cov8" title="1">{
        return xxx_messageInfo_BaseRequest.Unmarshal(m, b)
}</span>
func (m *BaseRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_BaseRequest.Marshal(b, m, deterministic)
}</span>
func (m *BaseRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_BaseRequest.Merge(m, src)
}</span>
func (m *BaseRequest) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_BaseRequest.Size(m)
}</span>
func (m *BaseRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_BaseRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_BaseRequest proto.InternalMessageInfo

func (m *BaseRequest) GetId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type ListObjectsRequest struct {
        Bucket       string `protobuf:"bytes,1,opt,name=bucket,proto3" json:"bucket,omitempty"`
        Versioned    bool   `protobuf:"varint,2,opt,name=versioned,proto3" json:"versioned,omitempty"`
        Version      int32  `protobuf:"varint,3,opt,name=version,proto3" json:"version,omitempty"`
        Delimiter    string `protobuf:"bytes,4,opt,name=delimiter,proto3" json:"delimiter,omitempty"`
        EncodingType string `protobuf:"bytes,5,opt,name=encodingType,proto3" json:"encodingType,omitempty"`
        MaxKeys      int32  `protobuf:"varint,6,opt,name=maxKeys,proto3" json:"maxKeys,omitempty"`
        Prefix       string `protobuf:"bytes,7,opt,name=prefix,proto3" json:"prefix,omitempty"`
        // v1 specific
        Marker string `protobuf:"bytes,8,opt,name=marker,proto3" json:"marker,omitempty"`
        // v2 specific
        ContinuationToken string `protobuf:"bytes,9,opt,name=continuationToken,proto3" json:"continuationToken,omitempty"`
        StartAfter        string `protobuf:"bytes,10,opt,name=startAfter,proto3" json:"startAfter,omitempty"`
        FetchOwner        bool   `protobuf:"varint,11,opt,name=fetchOwner,proto3" json:"fetchOwner,omitempty"`
        // versioned specific
        KeyMarker       string `protobuf:"bytes,12,opt,name=keyMarker,proto3" json:"keyMarker,omitempty"`
        VersionIdMarker string `protobuf:"bytes,13,opt,name=versionIdMarker,proto3" json:"versionIdMarker,omitempty"`
        // for internal use, for example, lifecycle management may need to filter objects by tier, or create time.
        Filter               map[string]string `protobuf:"bytes,14,rep,name=filter,proto3" json:"filter,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
        XXX_NoUnkeyedLiteral struct{}          `json:"-"`
        XXX_unrecognized     []byte            `json:"-"`
        XXX_sizecache        int32             `json:"-"`
}

func (m *ListObjectsRequest) Reset()         <span class="cov8" title="1">{ *m = ListObjectsRequest{} }</span>
func (m *ListObjectsRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*ListObjectsRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*ListObjectsRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_005e34be4304e022, []int{56}
}</span>

func (m *ListObjectsRequest) XXX_Unmarshal(b []byte) error <span class="cov8" title="1">{
        return xxx_messageInfo_ListObjectsRequest.Unmarshal(m, b)
}</span>
func (m *ListObjectsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_ListObjectsRequest.Marshal(b, m, deterministic)
}</span>
func (m *ListObjectsRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_ListObjectsRequest.Merge(m, src)
}</span>
func (m *ListObjectsRequest) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_ListObjectsRequest.Size(m)
}</span>
func (m *ListObjectsRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_ListObjectsRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_ListObjectsRequest proto.InternalMessageInfo

func (m *ListObjectsRequest) GetBucket() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Bucket
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *ListObjectsRequest) GetVersioned() bool <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Versioned
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (m *ListObjectsRequest) GetVersion() int32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Version
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *ListObjectsRequest) GetDelimiter() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Delimiter
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *ListObjectsRequest) GetEncodingType() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.EncodingType
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *ListObjectsRequest) GetMaxKeys() int32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.MaxKeys
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *ListObjectsRequest) GetPrefix() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Prefix
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *ListObjectsRequest) GetMarker() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Marker
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *ListObjectsRequest) GetContinuationToken() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ContinuationToken
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *ListObjectsRequest) GetStartAfter() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.StartAfter
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *ListObjectsRequest) GetFetchOwner() bool <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.FetchOwner
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (m *ListObjectsRequest) GetKeyMarker() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.KeyMarker
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *ListObjectsRequest) GetVersionIdMarker() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.VersionIdMarker
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *ListObjectsRequest) GetFilter() map[string]string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Filter
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type ListObjectsResponse struct {
        ErrorCode int32 `protobuf:"varint,1,opt,name=errorCode,proto3" json:"errorCode,omitempty"`
        // Indicates whether the returned list objects response is truncated. A
        // value of true indicates that the list was truncated. The list can be truncated
        // if the number of objects exceeds the limit allowed or specified
        // by max keys.
        IsTruncated bool `protobuf:"varint,2,opt,name=isTruncated,proto3" json:"isTruncated,omitempty"`
        // When response is truncated (the IsTruncated element value in the response
        // is true), you can use the key name in this field as marker in the subsequent
        // request to get next set of objects.
        //
        // NOTE: This element is returned only if you have delimiter request parameter
        // specified.
        NextMarker string `protobuf:"bytes,3,opt,name=nextMarker,proto3" json:"nextMarker,omitempty"`
        // List of prefixes for this request.
        Prefixes []string `protobuf:"bytes,4,rep,name=Prefixes,proto3" json:"Prefixes,omitempty"`
        // List of objects info for this request.
        Objects              []*Object `protobuf:"bytes,5,rep,name=objects,proto3" json:"objects,omitempty"`
        XXX_NoUnkeyedLiteral struct{}  `json:"-"`
        XXX_unrecognized     []byte    `json:"-"`
        XXX_sizecache        int32     `json:"-"`
}

func (m *ListObjectsResponse) Reset()         <span class="cov0" title="0">{ *m = ListObjectsResponse{} }</span>
func (m *ListObjectsResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*ListObjectsResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*ListObjectsResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_005e34be4304e022, []int{57}
}</span>

func (m *ListObjectsResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_ListObjectsResponse.Unmarshal(m, b)
}</span>
func (m *ListObjectsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov8" title="1">{
        return xxx_messageInfo_ListObjectsResponse.Marshal(b, m, deterministic)
}</span>
func (m *ListObjectsResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_ListObjectsResponse.Merge(m, src)
}</span>
func (m *ListObjectsResponse) XXX_Size() int <span class="cov8" title="1">{
        return xxx_messageInfo_ListObjectsResponse.Size(m)
}</span>
func (m *ListObjectsResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_ListObjectsResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_ListObjectsResponse proto.InternalMessageInfo

func (m *ListObjectsResponse) GetErrorCode() int32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ErrorCode
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *ListObjectsResponse) GetIsTruncated() bool <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.IsTruncated
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (m *ListObjectsResponse) GetNextMarker() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.NextMarker
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *ListObjectsResponse) GetPrefixes() []string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Prefixes
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *ListObjectsResponse) GetObjects() []*Object <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Objects
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type CountObjectsResponse struct {
        Count                int64    `protobuf:"varint,1,opt,name=Count,proto3" json:"Count,omitempty"`
        Size                 int64    `protobuf:"varint,2,opt,name=Size,proto3" json:"Size,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *CountObjectsResponse) Reset()         <span class="cov0" title="0">{ *m = CountObjectsResponse{} }</span>
func (m *CountObjectsResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*CountObjectsResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*CountObjectsResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_005e34be4304e022, []int{58}
}</span>

func (m *CountObjectsResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_CountObjectsResponse.Unmarshal(m, b)
}</span>
func (m *CountObjectsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_CountObjectsResponse.Marshal(b, m, deterministic)
}</span>
func (m *CountObjectsResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_CountObjectsResponse.Merge(m, src)
}</span>
func (m *CountObjectsResponse) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_CountObjectsResponse.Size(m)
}</span>
func (m *CountObjectsResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_CountObjectsResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_CountObjectsResponse proto.InternalMessageInfo

func (m *CountObjectsResponse) GetCount() int64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Count
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *CountObjectsResponse) GetSize() int64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Size
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type DeleteObjectInput struct {
        Bucket               string   `protobuf:"bytes,1,opt,name=bucket,proto3" json:"bucket,omitempty"`
        Key                  string   `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
        VersioId             string   `protobuf:"bytes,3,opt,name=versioId,proto3" json:"versioId,omitempty"`
        StorageMeta          string   `protobuf:"bytes,4,opt,name=storageMeta,proto3" json:"storageMeta,omitempty"`
        ETag                 string   `protobuf:"bytes,5,opt,name=eTag,proto3" json:"eTag,omitempty"`
        ObjectId             string   `protobuf:"bytes,6,opt,name=objectId,proto3" json:"objectId,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteObjectInput) Reset()         <span class="cov0" title="0">{ *m = DeleteObjectInput{} }</span>
func (m *DeleteObjectInput) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*DeleteObjectInput) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*DeleteObjectInput) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_005e34be4304e022, []int{59}
}</span>

func (m *DeleteObjectInput) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_DeleteObjectInput.Unmarshal(m, b)
}</span>
func (m *DeleteObjectInput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_DeleteObjectInput.Marshal(b, m, deterministic)
}</span>
func (m *DeleteObjectInput) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_DeleteObjectInput.Merge(m, src)
}</span>
func (m *DeleteObjectInput) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_DeleteObjectInput.Size(m)
}</span>
func (m *DeleteObjectInput) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_DeleteObjectInput.DiscardUnknown(m)
}</span>

var xxx_messageInfo_DeleteObjectInput proto.InternalMessageInfo

func (m *DeleteObjectInput) GetBucket() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Bucket
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *DeleteObjectInput) GetKey() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Key
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *DeleteObjectInput) GetVersioId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.VersioId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *DeleteObjectInput) GetStorageMeta() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.StorageMeta
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *DeleteObjectInput) GetETag() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ETag
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *DeleteObjectInput) GetObjectId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ObjectId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type DeleteObjectOutput struct {
        ErrorCode            int32    `protobuf:"varint,1,opt,name=errorCode,proto3" json:"errorCode,omitempty"`
        DeleteMarker         bool     `protobuf:"varint,2,opt,name=deleteMarker,proto3" json:"deleteMarker,omitempty"`
        VersionId            string   `protobuf:"bytes,3,opt,name=versionId,proto3" json:"versionId,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteObjectOutput) Reset()         <span class="cov0" title="0">{ *m = DeleteObjectOutput{} }</span>
func (m *DeleteObjectOutput) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*DeleteObjectOutput) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*DeleteObjectOutput) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_005e34be4304e022, []int{60}
}</span>

func (m *DeleteObjectOutput) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_DeleteObjectOutput.Unmarshal(m, b)
}</span>
func (m *DeleteObjectOutput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_DeleteObjectOutput.Marshal(b, m, deterministic)
}</span>
func (m *DeleteObjectOutput) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_DeleteObjectOutput.Merge(m, src)
}</span>
func (m *DeleteObjectOutput) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_DeleteObjectOutput.Size(m)
}</span>
func (m *DeleteObjectOutput) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_DeleteObjectOutput.DiscardUnknown(m)
}</span>

var xxx_messageInfo_DeleteObjectOutput proto.InternalMessageInfo

func (m *DeleteObjectOutput) GetErrorCode() int32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ErrorCode
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *DeleteObjectOutput) GetDeleteMarker() bool <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.DeleteMarker
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (m *DeleteObjectOutput) GetVersionId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.VersionId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type GetObjectInput struct {
        Bucket               string   `protobuf:"bytes,1,opt,name=Bucket,proto3" json:"Bucket,omitempty"`
        Key                  string   `protobuf:"bytes,2,opt,name=Key,proto3" json:"Key,omitempty"`
        VersionId            string   `protobuf:"bytes,3,opt,name=VersionId,proto3" json:"VersionId,omitempty"`
        Offset               int64    `protobuf:"varint,4,opt,name=Offset,proto3" json:"Offset,omitempty"`
        Length               int64    `protobuf:"varint,5,opt,name=Length,proto3" json:"Length,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *GetObjectInput) Reset()         <span class="cov8" title="1">{ *m = GetObjectInput{} }</span>
func (m *GetObjectInput) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*GetObjectInput) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*GetObjectInput) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_005e34be4304e022, []int{61}
}</span>

func (m *GetObjectInput) XXX_Unmarshal(b []byte) error <span class="cov8" title="1">{
        return xxx_messageInfo_GetObjectInput.Unmarshal(m, b)
}</span>
func (m *GetObjectInput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_GetObjectInput.Marshal(b, m, deterministic)
}</span>
func (m *GetObjectInput) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_GetObjectInput.Merge(m, src)
}</span>
func (m *GetObjectInput) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_GetObjectInput.Size(m)
}</span>
func (m *GetObjectInput) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_GetObjectInput.DiscardUnknown(m)
}</span>

var xxx_messageInfo_GetObjectInput proto.InternalMessageInfo

func (m *GetObjectInput) GetBucket() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Bucket
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *GetObjectInput) GetKey() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Key
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *GetObjectInput) GetVersionId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.VersionId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *GetObjectInput) GetOffset() int64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Offset
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *GetObjectInput) GetLength() int64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Length
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type MultipartUpload struct {
        Bucket               string   `protobuf:"bytes,1,opt,name=bucket,proto3" json:"bucket,omitempty"`
        Key                  string   `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
        UploadId             string   `protobuf:"bytes,3,opt,name=uploadId,proto3" json:"uploadId,omitempty"`
        ObjectId             string   `protobuf:"bytes,4,opt,name=objectId,proto3" json:"objectId,omitempty"`
        Location             string   `protobuf:"bytes,5,opt,name=location,proto3" json:"location,omitempty"`
        Tier                 int32    `protobuf:"varint,6,opt,name=tier,proto3" json:"tier,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *MultipartUpload) Reset()         <span class="cov0" title="0">{ *m = MultipartUpload{} }</span>
func (m *MultipartUpload) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*MultipartUpload) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*MultipartUpload) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_005e34be4304e022, []int{62}
}</span>

func (m *MultipartUpload) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_MultipartUpload.Unmarshal(m, b)
}</span>
func (m *MultipartUpload) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_MultipartUpload.Marshal(b, m, deterministic)
}</span>
func (m *MultipartUpload) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_MultipartUpload.Merge(m, src)
}</span>
func (m *MultipartUpload) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_MultipartUpload.Size(m)
}</span>
func (m *MultipartUpload) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_MultipartUpload.DiscardUnknown(m)
}</span>

var xxx_messageInfo_MultipartUpload proto.InternalMessageInfo

func (m *MultipartUpload) GetBucket() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Bucket
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *MultipartUpload) GetKey() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Key
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *MultipartUpload) GetUploadId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.UploadId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *MultipartUpload) GetObjectId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ObjectId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *MultipartUpload) GetLocation() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Location
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *MultipartUpload) GetTier() int32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Tier
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type ListParts struct {
        Bucket               string   `protobuf:"bytes,1,opt,name=Bucket,proto3" json:"Bucket,omitempty"`
        Key                  string   `protobuf:"bytes,2,opt,name=Key,proto3" json:"Key,omitempty"`
        UploadId             string   `protobuf:"bytes,3,opt,name=uploadId,proto3" json:"uploadId,omitempty"`
        MaxParts             int64    `protobuf:"varint,4,opt,name=MaxParts,proto3" json:"MaxParts,omitempty"`
        PartNumberMarker     int64    `protobuf:"varint,5,opt,name=PartNumberMarker,proto3" json:"PartNumberMarker,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *ListParts) Reset()         <span class="cov0" title="0">{ *m = ListParts{} }</span>
func (m *ListParts) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*ListParts) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*ListParts) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_005e34be4304e022, []int{63}
}</span>

func (m *ListParts) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_ListParts.Unmarshal(m, b)
}</span>
func (m *ListParts) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_ListParts.Marshal(b, m, deterministic)
}</span>
func (m *ListParts) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_ListParts.Merge(m, src)
}</span>
func (m *ListParts) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_ListParts.Size(m)
}</span>
func (m *ListParts) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_ListParts.DiscardUnknown(m)
}</span>

var xxx_messageInfo_ListParts proto.InternalMessageInfo

func (m *ListParts) GetBucket() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Bucket
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *ListParts) GetKey() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Key
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *ListParts) GetUploadId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.UploadId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *ListParts) GetMaxParts() int64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.MaxParts
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *ListParts) GetPartNumberMarker() int64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.PartNumberMarker
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type TList struct {
        Tier                 []int32  `protobuf:"varint,1,rep,packed,name=Tier,proto3" json:"Tier,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *TList) Reset()         <span class="cov0" title="0">{ *m = TList{} }</span>
func (m *TList) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*TList) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*TList) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_005e34be4304e022, []int{64}
}</span>

func (m *TList) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_TList.Unmarshal(m, b)
}</span>
func (m *TList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_TList.Marshal(b, m, deterministic)
}</span>
func (m *TList) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_TList.Merge(m, src)
}</span>
func (m *TList) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_TList.Size(m)
}</span>
func (m *TList) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_TList.DiscardUnknown(m)
}</span>

var xxx_messageInfo_TList proto.InternalMessageInfo

func (m *TList) GetTier() []int32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Tier
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type Tier2ClassName struct {
        Lst                  map[int32]string `protobuf:"bytes,1,rep,name=lst,proto3" json:"lst,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
        XXX_NoUnkeyedLiteral struct{}         `json:"-"`
        XXX_unrecognized     []byte           `json:"-"`
        XXX_sizecache        int32            `json:"-"`
}

func (m *Tier2ClassName) Reset()         <span class="cov0" title="0">{ *m = Tier2ClassName{} }</span>
func (m *Tier2ClassName) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*Tier2ClassName) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*Tier2ClassName) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_005e34be4304e022, []int{65}
}</span>

func (m *Tier2ClassName) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_Tier2ClassName.Unmarshal(m, b)
}</span>
func (m *Tier2ClassName) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_Tier2ClassName.Marshal(b, m, deterministic)
}</span>
func (m *Tier2ClassName) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_Tier2ClassName.Merge(m, src)
}</span>
func (m *Tier2ClassName) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_Tier2ClassName.Size(m)
}</span>
func (m *Tier2ClassName) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_Tier2ClassName.DiscardUnknown(m)
}</span>

var xxx_messageInfo_Tier2ClassName proto.InternalMessageInfo

func (m *Tier2ClassName) GetLst() map[int32]string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Lst
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type GetTierMapResponse struct {
        Transition           []string                   `protobuf:"bytes,1,rep,name=Transition,proto3" json:"Transition,omitempty"`
        Tier2Name            map[string]*Tier2ClassName `protobuf:"bytes,2,rep,name=Tier2Name,proto3" json:"Tier2Name,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
        XXX_NoUnkeyedLiteral struct{}                   `json:"-"`
        XXX_unrecognized     []byte                     `json:"-"`
        XXX_sizecache        int32                      `json:"-"`
}

func (m *GetTierMapResponse) Reset()         <span class="cov0" title="0">{ *m = GetTierMapResponse{} }</span>
func (m *GetTierMapResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*GetTierMapResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*GetTierMapResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_005e34be4304e022, []int{66}
}</span>

func (m *GetTierMapResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_GetTierMapResponse.Unmarshal(m, b)
}</span>
func (m *GetTierMapResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_GetTierMapResponse.Marshal(b, m, deterministic)
}</span>
func (m *GetTierMapResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_GetTierMapResponse.Merge(m, src)
}</span>
func (m *GetTierMapResponse) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_GetTierMapResponse.Size(m)
}</span>
func (m *GetTierMapResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_GetTierMapResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_GetTierMapResponse proto.InternalMessageInfo

func (m *GetTierMapResponse) GetTransition() []string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Transition
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *GetTierMapResponse) GetTier2Name() map[string]*Tier2ClassName <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Tier2Name
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type UpdateObjMetaRequest struct {
        ObjKey               string            `protobuf:"bytes,1,opt,name=ObjKey,proto3" json:"ObjKey,omitempty"`
        BucketName           string            `protobuf:"bytes,2,opt,name=BucketName,proto3" json:"BucketName,omitempty"`
        LastModified         int64             `protobuf:"varint,3,opt,name=LastModified,proto3" json:"LastModified,omitempty"`
        Setting              map[string]string `protobuf:"bytes,4,rep,name=Setting,proto3" json:"Setting,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
        XXX_NoUnkeyedLiteral struct{}          `json:"-"`
        XXX_unrecognized     []byte            `json:"-"`
        XXX_sizecache        int32             `json:"-"`
}

func (m *UpdateObjMetaRequest) Reset()         <span class="cov0" title="0">{ *m = UpdateObjMetaRequest{} }</span>
func (m *UpdateObjMetaRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*UpdateObjMetaRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*UpdateObjMetaRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_005e34be4304e022, []int{67}
}</span>

func (m *UpdateObjMetaRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_UpdateObjMetaRequest.Unmarshal(m, b)
}</span>
func (m *UpdateObjMetaRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_UpdateObjMetaRequest.Marshal(b, m, deterministic)
}</span>
func (m *UpdateObjMetaRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_UpdateObjMetaRequest.Merge(m, src)
}</span>
func (m *UpdateObjMetaRequest) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_UpdateObjMetaRequest.Size(m)
}</span>
func (m *UpdateObjMetaRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_UpdateObjMetaRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_UpdateObjMetaRequest proto.InternalMessageInfo

func (m *UpdateObjMetaRequest) GetObjKey() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ObjKey
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *UpdateObjMetaRequest) GetBucketName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.BucketName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *UpdateObjMetaRequest) GetLastModified() int64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.LastModified
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *UpdateObjMetaRequest) GetSetting() map[string]string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Setting
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type StorageClass struct {
        Name                 string   `protobuf:"bytes,1,opt,name=Name,proto3" json:"Name,omitempty"`
        Tier                 int32    `protobuf:"varint,2,opt,name=Tier,proto3" json:"Tier,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *StorageClass) Reset()         <span class="cov0" title="0">{ *m = StorageClass{} }</span>
func (m *StorageClass) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*StorageClass) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*StorageClass) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_005e34be4304e022, []int{68}
}</span>

func (m *StorageClass) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_StorageClass.Unmarshal(m, b)
}</span>
func (m *StorageClass) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_StorageClass.Marshal(b, m, deterministic)
}</span>
func (m *StorageClass) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_StorageClass.Merge(m, src)
}</span>
func (m *StorageClass) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_StorageClass.Size(m)
}</span>
func (m *StorageClass) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_StorageClass.DiscardUnknown(m)
}</span>

var xxx_messageInfo_StorageClass proto.InternalMessageInfo

func (m *StorageClass) GetName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *StorageClass) GetTier() int32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Tier
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type GetStorageClassesResponse struct {
        Classes              []*StorageClass `protobuf:"bytes,1,rep,name=classes,proto3" json:"classes,omitempty"`
        XXX_NoUnkeyedLiteral struct{}        `json:"-"`
        XXX_unrecognized     []byte          `json:"-"`
        XXX_sizecache        int32           `json:"-"`
}

func (m *GetStorageClassesResponse) Reset()         <span class="cov0" title="0">{ *m = GetStorageClassesResponse{} }</span>
func (m *GetStorageClassesResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*GetStorageClassesResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*GetStorageClassesResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_005e34be4304e022, []int{69}
}</span>

func (m *GetStorageClassesResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_GetStorageClassesResponse.Unmarshal(m, b)
}</span>
func (m *GetStorageClassesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_GetStorageClassesResponse.Marshal(b, m, deterministic)
}</span>
func (m *GetStorageClassesResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_GetStorageClassesResponse.Merge(m, src)
}</span>
func (m *GetStorageClassesResponse) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_GetStorageClassesResponse.Size(m)
}</span>
func (m *GetStorageClassesResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_GetStorageClassesResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_GetStorageClassesResponse proto.InternalMessageInfo

func (m *GetStorageClassesResponse) GetClasses() []*StorageClass <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Classes
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type GetBackendTypeByTierRequest struct {
        Tier                 int32    `protobuf:"varint,1,opt,name=Tier,proto3" json:"Tier,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *GetBackendTypeByTierRequest) Reset()         <span class="cov0" title="0">{ *m = GetBackendTypeByTierRequest{} }</span>
func (m *GetBackendTypeByTierRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*GetBackendTypeByTierRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*GetBackendTypeByTierRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_005e34be4304e022, []int{70}
}</span>

func (m *GetBackendTypeByTierRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_GetBackendTypeByTierRequest.Unmarshal(m, b)
}</span>
func (m *GetBackendTypeByTierRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_GetBackendTypeByTierRequest.Marshal(b, m, deterministic)
}</span>
func (m *GetBackendTypeByTierRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_GetBackendTypeByTierRequest.Merge(m, src)
}</span>
func (m *GetBackendTypeByTierRequest) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_GetBackendTypeByTierRequest.Size(m)
}</span>
func (m *GetBackendTypeByTierRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_GetBackendTypeByTierRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_GetBackendTypeByTierRequest proto.InternalMessageInfo

func (m *GetBackendTypeByTierRequest) GetTier() int32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Tier
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type GetBackendTypeByTierResponse struct {
        Types                []string `protobuf:"bytes,1,rep,name=Types,proto3" json:"Types,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *GetBackendTypeByTierResponse) Reset()         <span class="cov0" title="0">{ *m = GetBackendTypeByTierResponse{} }</span>
func (m *GetBackendTypeByTierResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*GetBackendTypeByTierResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*GetBackendTypeByTierResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_005e34be4304e022, []int{71}
}</span>

func (m *GetBackendTypeByTierResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_GetBackendTypeByTierResponse.Unmarshal(m, b)
}</span>
func (m *GetBackendTypeByTierResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_GetBackendTypeByTierResponse.Marshal(b, m, deterministic)
}</span>
func (m *GetBackendTypeByTierResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_GetBackendTypeByTierResponse.Merge(m, src)
}</span>
func (m *GetBackendTypeByTierResponse) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_GetBackendTypeByTierResponse.Size(m)
}</span>
func (m *GetBackendTypeByTierResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_GetBackendTypeByTierResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_GetBackendTypeByTierResponse proto.InternalMessageInfo

func (m *GetBackendTypeByTierResponse) GetTypes() []string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Types
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type MultipartUploadRecord struct {
        ObjectKey            string   `protobuf:"bytes,1,opt,name=ObjectKey,proto3" json:"ObjectKey,omitempty"`
        Bucket               string   `protobuf:"bytes,2,opt,name=Bucket,proto3" json:"Bucket,omitempty"`
        Backend              string   `protobuf:"bytes,3,opt,name=Backend,proto3" json:"Backend,omitempty"`
        UploadId             string   `protobuf:"bytes,4,opt,name=UploadId,proto3" json:"UploadId,omitempty"`
        InitTime             int64    `protobuf:"varint,5,opt,name=InitTime,proto3" json:"InitTime,omitempty"`
        TenantId             string   `protobuf:"bytes,6,opt,name=tenantId,proto3" json:"tenantId,omitempty"`
        UserId               string   `protobuf:"bytes,7,opt,name=userId,proto3" json:"userId,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *MultipartUploadRecord) Reset()         <span class="cov0" title="0">{ *m = MultipartUploadRecord{} }</span>
func (m *MultipartUploadRecord) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*MultipartUploadRecord) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*MultipartUploadRecord) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_005e34be4304e022, []int{72}
}</span>

func (m *MultipartUploadRecord) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_MultipartUploadRecord.Unmarshal(m, b)
}</span>
func (m *MultipartUploadRecord) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_MultipartUploadRecord.Marshal(b, m, deterministic)
}</span>
func (m *MultipartUploadRecord) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_MultipartUploadRecord.Merge(m, src)
}</span>
func (m *MultipartUploadRecord) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_MultipartUploadRecord.Size(m)
}</span>
func (m *MultipartUploadRecord) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_MultipartUploadRecord.DiscardUnknown(m)
}</span>

var xxx_messageInfo_MultipartUploadRecord proto.InternalMessageInfo

func (m *MultipartUploadRecord) GetObjectKey() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ObjectKey
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *MultipartUploadRecord) GetBucket() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Bucket
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *MultipartUploadRecord) GetBackend() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Backend
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *MultipartUploadRecord) GetUploadId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.UploadId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *MultipartUploadRecord) GetInitTime() int64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.InitTime
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *MultipartUploadRecord) GetTenantId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.TenantId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *MultipartUploadRecord) GetUserId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.UserId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type ListBucketUploadRequest struct {
        BucketName           string   `protobuf:"bytes,1,opt,name=bucketName,proto3" json:"bucketName,omitempty"`
        Delimiter            string   `protobuf:"bytes,2,opt,name=delimiter,proto3" json:"delimiter,omitempty"`
        EncodingType         string   `protobuf:"bytes,3,opt,name=encodingType,proto3" json:"encodingType,omitempty"`
        MaxUploads           int32    `protobuf:"varint,4,opt,name=maxUploads,proto3" json:"maxUploads,omitempty"`
        KeyMarker            string   `protobuf:"bytes,5,opt,name=keyMarker,proto3" json:"keyMarker,omitempty"`
        Prefix               string   `protobuf:"bytes,6,opt,name=prefix,proto3" json:"prefix,omitempty"`
        UploadIdMarker       string   `protobuf:"bytes,7,opt,name=uploadIdMarker,proto3" json:"uploadIdMarker,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *ListBucketUploadRequest) Reset()         <span class="cov0" title="0">{ *m = ListBucketUploadRequest{} }</span>
func (m *ListBucketUploadRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*ListBucketUploadRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*ListBucketUploadRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_005e34be4304e022, []int{73}
}</span>

func (m *ListBucketUploadRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_ListBucketUploadRequest.Unmarshal(m, b)
}</span>
func (m *ListBucketUploadRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_ListBucketUploadRequest.Marshal(b, m, deterministic)
}</span>
func (m *ListBucketUploadRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_ListBucketUploadRequest.Merge(m, src)
}</span>
func (m *ListBucketUploadRequest) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_ListBucketUploadRequest.Size(m)
}</span>
func (m *ListBucketUploadRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_ListBucketUploadRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_ListBucketUploadRequest proto.InternalMessageInfo

func (m *ListBucketUploadRequest) GetBucketName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.BucketName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *ListBucketUploadRequest) GetDelimiter() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Delimiter
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *ListBucketUploadRequest) GetEncodingType() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.EncodingType
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *ListBucketUploadRequest) GetMaxUploads() int32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.MaxUploads
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *ListBucketUploadRequest) GetKeyMarker() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.KeyMarker
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *ListBucketUploadRequest) GetPrefix() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Prefix
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *ListBucketUploadRequest) GetUploadIdMarker() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.UploadIdMarker
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type Owner struct {
        Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
        DisplayName          string   `protobuf:"bytes,2,opt,name=displayName,proto3" json:"displayName,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *Owner) Reset()         <span class="cov0" title="0">{ *m = Owner{} }</span>
func (m *Owner) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*Owner) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*Owner) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_005e34be4304e022, []int{74}
}</span>

func (m *Owner) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_Owner.Unmarshal(m, b)
}</span>
func (m *Owner) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_Owner.Marshal(b, m, deterministic)
}</span>
func (m *Owner) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_Owner.Merge(m, src)
}</span>
func (m *Owner) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_Owner.Size(m)
}</span>
func (m *Owner) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_Owner.DiscardUnknown(m)
}</span>

var xxx_messageInfo_Owner proto.InternalMessageInfo

func (m *Owner) GetId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Owner) GetDisplayName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.DisplayName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type Upload struct {
        Key                  string   `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
        UploadId             string   `protobuf:"bytes,2,opt,name=uploadId,proto3" json:"uploadId,omitempty"`
        Initiator            *Owner   `protobuf:"bytes,3,opt,name=initiator,proto3" json:"initiator,omitempty"`
        Owner                *Owner   `protobuf:"bytes,4,opt,name=owner,proto3" json:"owner,omitempty"`
        StorageClass         string   `protobuf:"bytes,5,opt,name=storageClass,proto3" json:"storageClass,omitempty"`
        Initiated            string   `protobuf:"bytes,6,opt,name=initiated,proto3" json:"initiated,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *Upload) Reset()         <span class="cov0" title="0">{ *m = Upload{} }</span>
func (m *Upload) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*Upload) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*Upload) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_005e34be4304e022, []int{75}
}</span>

func (m *Upload) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_Upload.Unmarshal(m, b)
}</span>
func (m *Upload) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_Upload.Marshal(b, m, deterministic)
}</span>
func (m *Upload) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_Upload.Merge(m, src)
}</span>
func (m *Upload) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_Upload.Size(m)
}</span>
func (m *Upload) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_Upload.DiscardUnknown(m)
}</span>

var xxx_messageInfo_Upload proto.InternalMessageInfo

func (m *Upload) GetKey() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Key
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Upload) GetUploadId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.UploadId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Upload) GetInitiator() *Owner <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Initiator
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *Upload) GetOwner() *Owner <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Owner
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *Upload) GetStorageClass() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.StorageClass
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Upload) GetInitiated() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Initiated
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type ListBucketUploadResult struct {
        IsTruncated          bool      `protobuf:"varint,1,opt,name=isTruncated,proto3" json:"isTruncated,omitempty"`
        NextKeyMarker        string    `protobuf:"bytes,2,opt,name=nextKeyMarker,proto3" json:"nextKeyMarker,omitempty"`
        NextUploadIdMarker   string    `protobuf:"bytes,3,opt,name=nextUploadIdMarker,proto3" json:"nextUploadIdMarker,omitempty"`
        CommonPrefix         []string  `protobuf:"bytes,4,rep,name=commonPrefix,proto3" json:"commonPrefix,omitempty"`
        Uploads              []*Upload `protobuf:"bytes,5,rep,name=uploads,proto3" json:"uploads,omitempty"`
        XXX_NoUnkeyedLiteral struct{}  `json:"-"`
        XXX_unrecognized     []byte    `json:"-"`
        XXX_sizecache        int32     `json:"-"`
}

func (m *ListBucketUploadResult) Reset()         <span class="cov0" title="0">{ *m = ListBucketUploadResult{} }</span>
func (m *ListBucketUploadResult) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*ListBucketUploadResult) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*ListBucketUploadResult) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_005e34be4304e022, []int{76}
}</span>

func (m *ListBucketUploadResult) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_ListBucketUploadResult.Unmarshal(m, b)
}</span>
func (m *ListBucketUploadResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_ListBucketUploadResult.Marshal(b, m, deterministic)
}</span>
func (m *ListBucketUploadResult) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_ListBucketUploadResult.Merge(m, src)
}</span>
func (m *ListBucketUploadResult) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_ListBucketUploadResult.Size(m)
}</span>
func (m *ListBucketUploadResult) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_ListBucketUploadResult.DiscardUnknown(m)
}</span>

var xxx_messageInfo_ListBucketUploadResult proto.InternalMessageInfo

func (m *ListBucketUploadResult) GetIsTruncated() bool <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.IsTruncated
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (m *ListBucketUploadResult) GetNextKeyMarker() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.NextKeyMarker
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *ListBucketUploadResult) GetNextUploadIdMarker() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.NextUploadIdMarker
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *ListBucketUploadResult) GetCommonPrefix() []string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.CommonPrefix
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *ListBucketUploadResult) GetUploads() []*Upload <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Uploads
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type ListBucketUploadResponse struct {
        ErrorCode            int32                   `protobuf:"varint,1,opt,name=errorCode,proto3" json:"errorCode,omitempty"`
        Result               *ListBucketUploadResult `protobuf:"bytes,2,opt,name=result,proto3" json:"result,omitempty"`
        XXX_NoUnkeyedLiteral struct{}                `json:"-"`
        XXX_unrecognized     []byte                  `json:"-"`
        XXX_sizecache        int32                   `json:"-"`
}

func (m *ListBucketUploadResponse) Reset()         <span class="cov0" title="0">{ *m = ListBucketUploadResponse{} }</span>
func (m *ListBucketUploadResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*ListBucketUploadResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*ListBucketUploadResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_005e34be4304e022, []int{77}
}</span>

func (m *ListBucketUploadResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_ListBucketUploadResponse.Unmarshal(m, b)
}</span>
func (m *ListBucketUploadResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_ListBucketUploadResponse.Marshal(b, m, deterministic)
}</span>
func (m *ListBucketUploadResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_ListBucketUploadResponse.Merge(m, src)
}</span>
func (m *ListBucketUploadResponse) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_ListBucketUploadResponse.Size(m)
}</span>
func (m *ListBucketUploadResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_ListBucketUploadResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_ListBucketUploadResponse proto.InternalMessageInfo

func (m *ListBucketUploadResponse) GetErrorCode() int32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ErrorCode
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *ListBucketUploadResponse) GetResult() *ListBucketUploadResult <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Result
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func init() <span class="cov8" title="1">{
        proto.RegisterType((*ListObjectPartsRequest)(nil), "ListObjectPartsRequest")
        proto.RegisterType((*Part)(nil), "Part")
        proto.RegisterType((*ListObjectPartsResponse)(nil), "ListObjectPartsResponse")
        proto.RegisterType((*AbortMultipartRequest)(nil), "AbortMultipartRequest")
        proto.RegisterType((*CompletePart)(nil), "CompletePart")
        proto.RegisterType((*CompleteMultipartRequest)(nil), "CompleteMultipartRequest")
        proto.RegisterType((*CompleteMultipartResponse)(nil), "CompleteMultipartResponse")
        proto.RegisterType((*InitMultiPartRequest)(nil), "InitMultiPartRequest")
        proto.RegisterMapType((map[string]string)(nil), "InitMultiPartRequest.AttrsEntry")
        proto.RegisterType((*InitMultiPartResponse)(nil), "InitMultiPartResponse")
        proto.RegisterType((*PutDataStream)(nil), "PutDataStream")
        proto.RegisterType((*UploadPartRequest)(nil), "UploadPartRequest")
        proto.RegisterType((*UploadPartResponse)(nil), "UploadPartResponse")
        proto.RegisterType((*CopyObjectRequest)(nil), "CopyObjectRequest")
        proto.RegisterType((*CopyObjectResponse)(nil), "CopyObjectResponse")
        proto.RegisterType((*MoveObjectRequest)(nil), "MoveObjectRequest")
        proto.RegisterType((*MoveObjectResponse)(nil), "MoveObjectResponse")
        proto.RegisterType((*PutObjectRequest)(nil), "PutObjectRequest")
        proto.RegisterMapType((map[string]string)(nil), "PutObjectRequest.AttrsEntry")
        proto.RegisterType((*GetObjectResponse)(nil), "GetObjectResponse")
        proto.RegisterType((*GetObjectMetaResult)(nil), "GetObjectMetaResult")
        proto.RegisterType((*PutObjectResponse)(nil), "PutObjectResponse")
        proto.RegisterType((*PutBucketACLRequest)(nil), "PutBucketACLRequest")
        proto.RegisterType((*BucketACL)(nil), "BucketACL")
        proto.RegisterType((*BucketVersioning)(nil), "BucketVersioning")
        proto.RegisterType((*ObjACL)(nil), "ObjACL")
        proto.RegisterType((*PutObjACLRequest)(nil), "PutObjACLRequest")
        proto.RegisterType((*BaseBucketRequest)(nil), "BaseBucketRequest")
        proto.RegisterType((*BaseObjRequest)(nil), "BaseObjRequest")
        proto.RegisterType((*CopyObjPartRequest)(nil), "CopyObjPartRequest")
        proto.RegisterType((*CopyObjPartResponse)(nil), "CopyObjPartResponse")
        proto.RegisterType((*ServerSideEncryption)(nil), "ServerSideEncryption")
        proto.RegisterType((*RedirectAllRequestsTo)(nil), "RedirectAllRequestsTo")
        proto.RegisterType((*Redirect)(nil), "Redirect")
        proto.RegisterType((*Condition)(nil), "Condition")
        proto.RegisterType((*RoutingRules)(nil), "RoutingRules")
        proto.RegisterType((*WebsiteConfiguration)(nil), "WebsiteConfiguration")
        proto.RegisterType((*CORSConfiguration)(nil), "CORSConfiguration")
        proto.RegisterType((*Destination)(nil), "Destination")
        proto.RegisterType((*ReplicationRole)(nil), "ReplicationRole")
        proto.RegisterType((*ReplicationConfiguration)(nil), "ReplicationConfiguration")
        proto.RegisterType((*Tag)(nil), "Tag")
        proto.RegisterType((*LifecycleFilter)(nil), "LifecycleFilter")
        proto.RegisterType((*Action)(nil), "Action")
        proto.RegisterType((*AbortMultipartUpload)(nil), "AbortMultipartUpload")
        proto.RegisterType((*LifecycleRule)(nil), "LifecycleRule")
        proto.RegisterType((*PutBucketLifecycleRequest)(nil), "PutBucketLifecycleRequest")
        proto.RegisterType((*GetBucketLifecycleResponse)(nil), "GetBucketLifecycleResponse")
        proto.RegisterType((*ReplicationInfo)(nil), "ReplicationInfo")
        proto.RegisterType((*Acl)(nil), "Acl")
        proto.RegisterType((*GetBucketResponse)(nil), "GetBucketResponse")
        proto.RegisterType((*Bucket)(nil), "Bucket")
        proto.RegisterType((*Partion)(nil), "Partion")
        proto.RegisterType((*Version)(nil), "Version")
        proto.RegisterType((*Object)(nil), "Object")
        proto.RegisterMapType((map[string]string)(nil), "Object.CustomAttributesEntry")
        proto.RegisterType((*ListBucketsResponse)(nil), "ListBucketsResponse")
        proto.RegisterType((*BaseResponse)(nil), "BaseResponse")
        proto.RegisterType((*BaseRequest)(nil), "BaseRequest")
        proto.RegisterType((*ListObjectsRequest)(nil), "ListObjectsRequest")
        proto.RegisterMapType((map[string]string)(nil), "ListObjectsRequest.FilterEntry")
        proto.RegisterType((*ListObjectsResponse)(nil), "ListObjectsResponse")
        proto.RegisterType((*CountObjectsResponse)(nil), "CountObjectsResponse")
        proto.RegisterType((*DeleteObjectInput)(nil), "DeleteObjectInput")
        proto.RegisterType((*DeleteObjectOutput)(nil), "DeleteObjectOutput")
        proto.RegisterType((*GetObjectInput)(nil), "GetObjectInput")
        proto.RegisterType((*MultipartUpload)(nil), "MultipartUpload")
        proto.RegisterType((*ListParts)(nil), "ListParts")
        proto.RegisterType((*TList)(nil), "TList")
        proto.RegisterType((*Tier2ClassName)(nil), "Tier2ClassName")
        proto.RegisterMapType((map[int32]string)(nil), "Tier2ClassName.LstEntry")
        proto.RegisterType((*GetTierMapResponse)(nil), "GetTierMapResponse")
        proto.RegisterMapType((map[string]*Tier2ClassName)(nil), "GetTierMapResponse.Tier2NameEntry")
        proto.RegisterType((*UpdateObjMetaRequest)(nil), "UpdateObjMetaRequest")
        proto.RegisterMapType((map[string]string)(nil), "UpdateObjMetaRequest.SettingEntry")
        proto.RegisterType((*StorageClass)(nil), "StorageClass")
        proto.RegisterType((*GetStorageClassesResponse)(nil), "GetStorageClassesResponse")
        proto.RegisterType((*GetBackendTypeByTierRequest)(nil), "GetBackendTypeByTierRequest")
        proto.RegisterType((*GetBackendTypeByTierResponse)(nil), "GetBackendTypeByTierResponse")
        proto.RegisterType((*MultipartUploadRecord)(nil), "MultipartUploadRecord")
        proto.RegisterType((*ListBucketUploadRequest)(nil), "ListBucketUploadRequest")
        proto.RegisterType((*Owner)(nil), "Owner")
        proto.RegisterType((*Upload)(nil), "Upload")
        proto.RegisterType((*ListBucketUploadResult)(nil), "ListBucketUploadResult")
        proto.RegisterType((*ListBucketUploadResponse)(nil), "ListBucketUploadResponse")
}</span>

func init() <span class="cov8" title="1">{ proto.RegisterFile("s3.proto", fileDescriptor_005e34be4304e022) }</span>

var fileDescriptor_005e34be4304e022 = []byte{
        // 4309 bytes of a gzipped FileDescriptorProto
        0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x3b, 0x4d, 0x6f, 0x1c, 0xc9,
        0x75, 0xec, 0xf9, 0x22, 0xe7, 0x0d, 0x3f, 0x8b, 0x1f, 0x1a, 0x8d, 0xb4, 0x32, 0x53, 0xd6, 0x6a,
        0xe9, 0x4d, 0x52, 0x96, 0x28, 0xef, 0x7a, 0x57, 0x71, 0xec, 0xa5, 0x46, 0x1f, 0x4b, 0x2c, 0xb9,
        0x64, 0x9a, 0x94, 0x0c, 0x38, 0x08, 0x82, 0x66, 0x77, 0x91, 0x6a, 0xa9, 0xd9, 0x3d, 0xdb, 0x5d,
        0xa3, 0x25, 0x7d, 0x4c, 0x80, 0xc4, 0xb9, 0x24, 0xe7, 0xe4, 0xea, 0x43, 0x02, 0xe4, 0x64, 0x20,
        0xc7, 0x1c, 0x7c, 0xc9, 0x25, 0xd7, 0x1c, 0x02, 0xe4, 0x90, 0x4b, 0x4e, 0x01, 0xf2, 0x03, 0x9c,
        0x43, 0x80, 0xa0, 0x3e, 0xbb, 0xfa, 0x63, 0x38, 0x94, 0xd7, 0xf0, 0x69, 0xba, 0x5e, 0xbd, 0xaa,
        0x7a, 0xef, 0xd5, 0x7b, 0xaf, 0x5e, 0xbd, 0x7a, 0x03, 0x73, 0xd9, 0x43, 0x32, 0x4a, 0x13, 0x96,
        0xe0, 0xff, 0x74, 0x60, 0x63, 0x2f, 0xcc, 0xd8, 0xc1, 0xc9, 0x6b, 0xea, 0xb3, 0x43, 0x2f, 0x65,
        0x99, 0x4b, 0xbf, 0x1a, 0xd3, 0x8c, 0xa1, 0x3b, 0x00, 0x27, 0x63, 0xff, 0x0d, 0x65, 0x5f, 0x7a,
        0xe7, 0xb4, 0xef, 0x6c, 0x3a, 0x5b, 0x5d, 0xd7, 0x82, 0xa0, 0xdb, 0xd0, 0x4d, 0xc4, 0xa8, 0x2f,
        0xe8, 0x65, 0xbf, 0x21, 0xba, 0x73, 0x00, 0xc2, 0x30, 0x4f, 0x63, 0x3f, 0x09, 0xc2, 0xf8, 0xec,
        0xf8, 0x72, 0x44, 0xfb, 0x4d, 0x81, 0x50, 0x80, 0xa1, 0x01, 0xcc, 0x8d, 0x47, 0x51, 0xe2, 0x05,
        0xbb, 0x41, 0xbf, 0x25, 0xfa, 0x4d, 0x9b, 0xf7, 0x9d, 0x7b, 0x17, 0x82, 0xa0, 0x7e, 0x7b, 0xd3,
        0xd9, 0x6a, 0xba, 0xa6, 0x8d, 0x3e, 0x84, 0xe5, 0x91, 0x97, 0xb2, 0x2f, 0xc7, 0xe7, 0x27, 0x34,
        0xdd, 0xf7, 0xd2, 0x37, 0x34, 0xed, 0x77, 0x04, 0x4e, 0x05, 0x8e, 0x53, 0x68, 0xf1, 0x41, 0x9c,
        0x9b, 0x43, 0xd3, 0x27, 0xb8, 0x69, 0xba, 0x16, 0x04, 0x21, 0x68, 0x3d, 0x3d, 0xf6, 0xce, 0x14,
        0x23, 0xe2, 0x9b, 0xf3, 0xb0, 0xe7, 0x65, 0x6c, 0x3f, 0x09, 0xc2, 0xd3, 0x90, 0x06, 0x9a, 0x07,
        0x1b, 0xc6, 0xc7, 0x1d, 0x85, 0x3f, 0xa5, 0x82, 0xfe, 0xa6, 0x2b, 0xbe, 0xf1, 0x7f, 0x34, 0xe0,
        0x46, 0x45, 0xa8, 0xd9, 0x28, 0x89, 0x33, 0x21, 0xb5, 0xa7, 0x69, 0x9a, 0xa4, 0xc3, 0x24, 0x90,
        0x42, 0x6d, 0xbb, 0x39, 0x00, 0xdd, 0x85, 0xee, 0x6e, 0x1c, 0xb2, 0xd0, 0x63, 0x49, 0x2a, 0x48,
        0xe9, 0x6d, 0x77, 0xc8, 0xc1, 0xd7, 0x31, 0x4d, 0xdd, 0xbc, 0x03, 0xdd, 0x86, 0xb6, 0x80, 0x09,
        0x82, 0x72, 0x0c, 0x09, 0xe4, 0x54, 0x1f, 0xb1, 0x24, 0xf5, 0xce, 0xe8, 0x30, 0xf2, 0xb2, 0x4c,
        0x49, 0xb6, 0x00, 0xe3, 0x12, 0x3c, 0x2c, 0x4b, 0x50, 0x4a, 0xb9, 0x02, 0x47, 0xdb, 0xb0, 0xf6,
        0x25, 0xbd, 0x60, 0x87, 0xf5, 0x12, 0xaf, 0xed, 0xe3, 0xbb, 0xb7, 0xaf, 0x77, 0x6f, 0x56, 0xee,
        0x9e, 0x6e, 0xa3, 0x4d, 0xe8, 0xed, 0x66, 0xc7, 0xe9, 0x38, 0xf6, 0x3d, 0x46, 0x83, 0xfe, 0xdc,
        0xa6, 0xb3, 0x35, 0xe7, 0xda, 0x20, 0x74, 0x0b, 0xda, 0x72, 0x68, 0x77, 0xb3, 0xb9, 0xd5, 0xdb,
        0x6e, 0x13, 0xde, 0x72, 0x25, 0x0c, 0x7f, 0x05, 0xeb, 0x3b, 0x27, 0x49, 0xca, 0xf6, 0xc7, 0x11,
        0x0b, 0xf9, 0x76, 0xff, 0x66, 0xf4, 0xd5, 0xd6, 0xc5, 0x66, 0x51, 0x17, 0xf1, 0x63, 0x98, 0x1f,
        0x26, 0xe7, 0xa3, 0x88, 0x32, 0xaa, 0x75, 0x69, 0x54, 0xd1, 0xa5, 0x51, 0x41, 0x97, 0xa8, 0xa5,
        0x4b, 0xfc, 0x1b, 0xff, 0x55, 0x03, 0xfa, 0x7a, 0x92, 0xdf, 0x1e, 0xe9, 0xe8, 0x21, 0x2c, 0xf8,
        0x16, 0xe9, 0x5c, 0x1b, 0xb8, 0x48, 0x17, 0x88, 0xcd, 0x90, 0x5b, 0xc4, 0x41, 0x5b, 0xb0, 0x94,
        0x25, 0xe3, 0xd4, 0xa7, 0x2f, 0x69, 0x9a, 0x85, 0x49, 0xbc, 0xfb, 0x44, 0x28, 0x47, 0xd7, 0x2d,
        0x83, 0xf9, 0x5e, 0xa6, 0x92, 0x07, 0x61, 0xe4, 0x1d, 0x81, 0x65, 0x83, 0xb8, 0x2c, 0x58, 0x48,
        0x53, 0xa1, 0x05, 0x6d, 0x57, 0x7c, 0xe3, 0x10, 0x6e, 0xd6, 0x88, 0x22, 0x37, 0x10, 0x5a, 0x36,
        0x10, 0x03, 0xb0, 0x78, 0x7d, 0xa2, 0x04, 0x61, 0xda, 0x46, 0xec, 0x4d, 0x4b, 0xec, 0x7f, 0xdd,
        0x80, 0x35, 0x6e, 0x38, 0x62, 0x9d, 0xc3, 0xdf, 0x98, 0xc8, 0x37, 0xa0, 0xe9, 0xf9, 0x91, 0xb2,
        0xbf, 0x16, 0xd9, 0xf1, 0x23, 0x97, 0x03, 0x0c, 0xb7, 0xad, 0x9c, 0x5b, 0x4e, 0x72, 0x94, 0xf8,
        0x1e, 0x0b, 0x93, 0x58, 0x89, 0xd1, 0xb4, 0xd1, 0xc7, 0xd0, 0xf6, 0x18, 0x4b, 0xb3, 0x7e, 0x47,
        0x6c, 0xcb, 0x26, 0xa9, 0xa3, 0x95, 0xec, 0x70, 0x94, 0xa7, 0x31, 0x4b, 0x2f, 0x5d, 0x89, 0x3e,
        0xf8, 0x04, 0x20, 0x07, 0xa2, 0x65, 0x68, 0xbe, 0xa1, 0x97, 0x8a, 0x09, 0xfe, 0x89, 0xd6, 0xa0,
        0xfd, 0xd6, 0x8b, 0xc6, 0x54, 0x51, 0x2e, 0x1b, 0x8f, 0x1a, 0x9f, 0x38, 0xf8, 0x8f, 0x60, 0xbd,
        0xb4, 0xc6, 0x37, 0x95, 0x3b, 0xfe, 0x36, 0x2c, 0x1c, 0x8e, 0xd9, 0x13, 0x8f, 0x79, 0x47, 0x2c,
        0xa5, 0xde, 0x39, 0x97, 0x42, 0xe0, 0x31, 0x4f, 0xcc, 0x32, 0xef, 0x8a, 0x6f, 0xfc, 0x0b, 0x07,
        0x56, 0x5e, 0x88, 0x11, 0x87, 0xbf, 0x15, 0xc5, 0xdf, 0x80, 0x0e, 0x57, 0x2b, 0x75, 0xb2, 0xb4,
        0x5d, 0xd5, 0xe2, 0xb4, 0x65, 0xdc, 0x5f, 0x4b, 0x6f, 0x27, 0xbe, 0x39, 0xee, 0x79, 0xf0, 0xd1,
        0xe7, 0xf4, 0x42, 0x29, 0xb0, 0x6a, 0xe1, 0x67, 0x80, 0x6c, 0x92, 0xaf, 0x25, 0xa8, 0x3a, 0xdb,
        0xff, 0x3f, 0x07, 0x56, 0x86, 0xc9, 0xe8, 0x52, 0x9e, 0x07, 0x9a, 0xf7, 0xbb, 0xb0, 0x90, 0xa5,
        0xfe, 0xe3, 0x32, 0xfb, 0x45, 0x20, 0xf7, 0xd4, 0xcc, 0x4b, 0xcf, 0x28, 0xb3, 0x10, 0xe5, 0xdc,
        0x15, 0xb8, 0x9a, 0x51, 0xae, 0x22, 0x10, 0x9b, 0x66, 0xc6, 0x1c, 0x98, 0xcf, 0x68, 0x21, 0xb6,
        0xec, 0x19, 0x2d, 0xdc, 0xbb, 0xb0, 0xa0, 0x56, 0xf1, 0xfc, 0x37, 0x34, 0x0e, 0x94, 0x02, 0x17,
        0x81, 0x7c, 0x17, 0x25, 0xe0, 0x38, 0x54, 0xe7, 0x42, 0xdb, 0xb5, 0x20, 0xf8, 0x2f, 0x1c, 0x40,
        0x36, 0xff, 0xd7, 0x12, 0xe4, 0x32, 0x34, 0xcf, 0x83, 0x8f, 0x14, 0xaf, 0xfc, 0x93, 0x1f, 0x6c,
        0x51, 0xf9, 0x38, 0x6e, 0xba, 0x05, 0x18, 0x9f, 0xf3, 0xad, 0xf2, 0x4e, 0x3a, 0xa6, 0xc8, 0x01,
        0xf8, 0xef, 0x1b, 0xb0, 0xb2, 0x9f, 0xbc, 0xa5, 0xc5, 0x8d, 0xb8, 0x0d, 0x5d, 0x23, 0x21, 0xb5,
        0x09, 0x39, 0x80, 0xaf, 0x6a, 0x8b, 0x45, 0x11, 0x54, 0x80, 0xa9, 0x19, 0xe4, 0x4e, 0x28, 0xa1,
        0xe7, 0x80, 0x7c, 0x06, 0x85, 0xd0, 0xb2, 0x67, 0x50, 0x38, 0xf7, 0x60, 0x51, 0xb6, 0xf7, 0x8a,
        0xae, 0xa2, 0x04, 0x9d, 0x26, 0x6a, 0x11, 0x36, 0x25, 0x6f, 0xa9, 0xf0, 0xc6, 0xd2, 0xe5, 0x9a,
        0x36, 0xdf, 0x78, 0xc3, 0x96, 0x72, 0xe1, 0xe2, 0xf4, 0xed, 0xba, 0x15, 0x38, 0xfe, 0xb9, 0x03,
        0xc8, 0x96, 0x94, 0xda, 0xb2, 0xdf, 0x81, 0xd9, 0xe4, 0xe4, 0xf5, 0x3e, 0x55, 0xc6, 0xdd, 0xdb,
        0x9e, 0x25, 0x0a, 0x43, 0xc3, 0xb9, 0x31, 0x65, 0xcc, 0x63, 0xe3, 0x4c, 0x49, 0x4a, 0xb5, 0xf4,
        0x7e, 0x36, 0xf3, 0xfd, 0xbc, 0x72, 0xaf, 0x2a, 0xbb, 0xdd, 0xae, 0xee, 0x36, 0xfe, 0x87, 0x06,
        0x2c, 0x1f, 0x8e, 0x59, 0x71, 0x3b, 0xef, 0x00, 0x54, 0x8c, 0xca, 0x82, 0xf0, 0x65, 0x0f, 0xca,
        0x3e, 0xe5, 0xc0, 0xf6, 0xec, 0x3b, 0x65, 0xcf, 0xbe, 0xe3, 0x47, 0x68, 0x5b, 0x7b, 0x6a, 0x79,
        0x80, 0xde, 0x26, 0xe5, 0x75, 0xab, 0x5e, 0xfa, 0x4a, 0xcf, 0xaf, 0xfd, 0x50, 0xc7, 0xf2, 0x43,
        0x9b, 0xd0, 0xf3, 0x93, 0x98, 0xd1, 0x98, 0x99, 0xfd, 0xeb, 0xba, 0x36, 0xe8, 0x1b, 0xf8, 0xfd,
        0xa7, 0xb0, 0xf2, 0x9c, 0xb2, 0x77, 0xb2, 0x40, 0xed, 0xc6, 0x1b, 0x96, 0x1b, 0x3f, 0x86, 0x55,
        0x33, 0x0d, 0xdf, 0x6e, 0x97, 0x66, 0xe3, 0x88, 0x4d, 0x99, 0xe8, 0x5b, 0xd0, 0x49, 0x72, 0xe3,
        0xb1, 0x94, 0x46, 0x81, 0xf1, 0x2f, 0x1d, 0x58, 0xb1, 0xe4, 0x79, 0x2d, 0xea, 0x2c, 0x55, 0x6c,
        0x4c, 0x55, 0xc5, 0x66, 0x9d, 0x2a, 0xb6, 0x26, 0xa8, 0x62, 0x7b, 0x9a, 0x2a, 0x76, 0x6a, 0x54,
        0xf1, 0x47, 0xb0, 0x7a, 0x38, 0x56, 0xd6, 0xbc, 0x33, 0xdc, 0xd3, 0xca, 0xb8, 0x05, 0xdd, 0x9d,
        0xe1, 0xde, 0x30, 0x89, 0x4f, 0xc3, 0x33, 0x65, 0x32, 0x40, 0x72, 0xac, 0xbc, 0x13, 0xef, 0x42,
        0xd7, 0xc0, 0xaf, 0xa3, 0xc3, 0x43, 0x2f, 0x8e, 0x69, 0xc0, 0x75, 0x55, 0xe9, 0xb0, 0x01, 0xe0,
        0x0f, 0x61, 0x59, 0xe2, 0x2a, 0x6b, 0x0e, 0xe3, 0x33, 0x2e, 0x8b, 0x23, 0x29, 0x0b, 0x39, 0x9b,
        0x6a, 0xe1, 0x00, 0x3a, 0x07, 0x27, 0xaf, 0xaf, 0xb9, 0xe6, 0x15, 0x76, 0x53, 0xa0, 0xa8, 0x59,
        0xa6, 0xe8, 0x48, 0xdb, 0xa9, 0x25, 0x9a, 0x3e, 0xcc, 0x0e, 0xb9, 0x6a, 0x5f, 0x68, 0xa7, 0xab,
        0x9b, 0xe8, 0x7d, 0x5b, 0x68, 0xd6, 0xe6, 0x96, 0x24, 0xb6, 0x0f, 0x2b, 0x8f, 0xbd, 0x8c, 0x4a,
        0x12, 0xa7, 0xcf, 0x5a, 0xe4, 0xaf, 0x51, 0xe6, 0x0f, 0xbf, 0x82, 0x45, 0x3e, 0xdd, 0xc1, 0xc9,
        0xeb, 0x6f, 0x3c, 0x57, 0x51, 0x56, 0xcd, 0x92, 0xac, 0xf0, 0x2f, 0x1b, 0xe6, 0x3c, 0xb4, 0x83,
        0x21, 0x7e, 0x71, 0x13, 0xf1, 0xb5, 0x3a, 0x27, 0x1c, 0x75, 0x71, 0xb3, 0x60, 0x39, 0x4e, 0xf1,
        0x34, 0xb2, 0x61, 0x1c, 0xe7, 0xd8, 0x3e, 0x6f, 0xd4, 0xb5, 0xd5, 0x86, 0xe5, 0x38, 0x6a, 0x9e,
        0x96, 0x8d, 0xa3, 0xe6, 0xb9, 0x07, 0x8b, 0xc7, 0xb5, 0x67, 0x52, 0x11, 0xca, 0xdd, 0xdc, 0x0b,
        0x1d, 0x1b, 0xca, 0x00, 0xca, 0xb4, 0xb9, 0xda, 0x71, 0x16, 0x77, 0x9f, 0xa8, 0x6b, 0xa0, 0x6a,
        0x71, 0x01, 0xba, 0xd4, 0x0b, 0x0e, 0x4e, 0x4f, 0x33, 0xca, 0xc4, 0x29, 0xd4, 0x74, 0x2d, 0x88,
        0xee, 0xdf, 0xa3, 0xf1, 0x19, 0x7b, 0xd5, 0xef, 0xe6, 0xfd, 0x12, 0x82, 0xdf, 0xc0, 0x6a, 0x41,
        0x82, 0xd7, 0xba, 0x5d, 0x97, 0xef, 0xf3, 0x0d, 0x69, 0xc7, 0xe5, 0xfb, 0xfc, 0x53, 0x96, 0x5f,
        0x22, 0xf8, 0x37, 0xfe, 0x99, 0x03, 0x6b, 0x47, 0x34, 0x7d, 0x4b, 0xd3, 0xa3, 0x30, 0xa0, 0x4f,
        0x63, 0x3f, 0xbd, 0x1c, 0x09, 0xce, 0xfb, 0x30, 0x9b, 0x65, 0xf2, 0xb0, 0x55, 0x0a, 0xa2, 0x9a,
        0x3c, 0x70, 0xa2, 0x06, 0x4f, 0x1b, 0xcc, 0xbc, 0x5b, 0x04, 0xa2, 0xfb, 0xb0, 0x1a, 0xf2, 0x5b,
        0x7d, 0x14, 0xfe, 0x54, 0x88, 0xf2, 0x25, 0xf5, 0xf9, 0xc5, 0xbf, 0x29, 0x70, 0xeb, 0xba, 0xf0,
        0x01, 0xac, 0xbb, 0x34, 0x08, 0x53, 0xea, 0xb3, 0x9d, 0x28, 0x52, 0x9a, 0x93, 0x1d, 0x27, 0x7c,
        0x13, 0x5e, 0x25, 0x99, 0x6d, 0xbb, 0xa6, 0xcd, 0xfb, 0x44, 0xb6, 0xc7, 0x4f, 0xb8, 0xb3, 0x68,
        0xf2, 0x3e, 0xdd, 0xc6, 0xff, 0xea, 0xc0, 0x9c, 0x9e, 0xb1, 0x80, 0xa8, 0x26, 0xd1, 0xed, 0xc2,
        0x02, 0x8d, 0xd2, 0x02, 0xdb, 0xb0, 0x96, 0xd2, 0x51, 0xe4, 0xf9, 0xf4, 0x0b, 0x7a, 0x79, 0x98,
        0xd2, 0xd3, 0xf0, 0xe2, 0xc7, 0x21, 0x7b, 0xa5, 0x84, 0x58, 0xdb, 0xc7, 0xb5, 0x2b, 0x87, 0x0b,
        0x6c, 0xa9, 0x83, 0x25, 0x28, 0x8f, 0x5a, 0x5e, 0x31, 0x36, 0xd2, 0x34, 0x8a, 0x9d, 0x95, 0x7a,
        0x58, 0x81, 0xe3, 0xaf, 0xa1, 0x3b, 0x4c, 0xe2, 0x20, 0x14, 0x9b, 0xb3, 0x05, 0x4b, 0x6f, 0xf4,
        0x8a, 0x4f, 0xbf, 0x1a, 0x7b, 0x91, 0x76, 0x7d, 0x65, 0x30, 0xfa, 0x0c, 0x6e, 0xf1, 0xa9, 0x8c,
        0xa2, 0xb8, 0x94, 0x8d, 0xd3, 0x98, 0x06, 0x6a, 0x94, 0xe4, 0xf6, 0x2a, 0x14, 0xfc, 0xa7, 0x30,
        0xef, 0x26, 0x63, 0x16, 0xc6, 0x67, 0xee, 0x38, 0xa2, 0x19, 0x7a, 0x1f, 0xe6, 0x52, 0x45, 0x98,
        0xf2, 0xfa, 0x5d, 0xa2, 0x29, 0x75, 0x4d, 0x17, 0x3f, 0x1d, 0x7c, 0x4d, 0xaf, 0x72, 0x74, 0x40,
        0x0c, 0x07, 0x6e, 0xde, 0x89, 0xff, 0xcb, 0x81, 0xb5, 0x1f, 0xd3, 0x93, 0x2c, 0x64, 0x54, 0x7a,
        0xbf, 0x71, 0x2a, 0x8d, 0xef, 0x2e, 0x2c, 0x84, 0x71, 0x40, 0x2f, 0x9e, 0x24, 0xfe, 0xf8, 0x9c,
        0xc6, 0xda, 0x6b, 0x14, 0x81, 0x42, 0x1d, 0x39, 0xe9, 0x06, 0x4b, 0xf2, 0x54, 0x04, 0xa2, 0x3d,
        0x58, 0x4f, 0xeb, 0x94, 0x4b, 0x45, 0x43, 0x1b, 0xa4, 0x56, 0xf5, 0xdc, 0xfa, 0x41, 0xe8, 0x01,
        0xcc, 0xa7, 0x96, 0x4c, 0x4c, 0xe6, 0xc1, 0x16, 0x94, 0x5b, 0x40, 0xc1, 0xff, 0xcd, 0x2f, 0x4a,
        0x07, 0xee, 0x51, 0x91, 0xc5, 0x45, 0x68, 0x84, 0x81, 0xe2, 0xab, 0x11, 0x06, 0x5c, 0x73, 0xbc,
        0x28, 0x4a, 0xbe, 0xa6, 0xc1, 0x3e, 0x65, 0xaf, 0x92, 0x40, 0xef, 0x50, 0x09, 0x6a, 0xe1, 0x1d,
        0xa4, 0xe1, 0x59, 0x18, 0xeb, 0x30, 0xa0, 0x04, 0xb5, 0xf0, 0x3e, 0xa7, 0x5e, 0x40, 0x53, 0x9d,
        0x32, 0x2b, 0x41, 0xb9, 0x10, 0xcf, 0xbd, 0x8b, 0x9d, 0x33, 0x7a, 0x44, 0xf9, 0xc6, 0x64, 0xfa,
        0x32, 0x54, 0x00, 0xf2, 0xd9, 0xe8, 0xc5, 0x28, 0xc9, 0xf2, 0xd9, 0xa4, 0x4f, 0x2c, 0x41, 0xf1,
        0x2e, 0xf4, 0x9e, 0xd0, 0x8c, 0x85, 0xb1, 0x64, 0x72, 0x03, 0x3a, 0x27, 0xb6, 0xdb, 0x57, 0x2d,
        0xee, 0xb3, 0x32, 0x3b, 0x9b, 0xa7, 0x1c, 0xbe, 0x0d, 0xc3, 0x7f, 0xee, 0xc0, 0x92, 0x4b, 0x47,
        0x51, 0x28, 0x1d, 0xb2, 0x9b, 0x44, 0xb4, 0x22, 0x34, 0x7e, 0x1f, 0x16, 0x3a, 0xaf, 0xc3, 0x72,
        0xd9, 0xe2, 0x2e, 0x8c, 0xc6, 0xde, 0x49, 0xa4, 0xee, 0x53, 0x73, 0xae, 0x6e, 0x22, 0x02, 0xbd,
        0x20, 0x27, 0x50, 0xc8, 0xa4, 0xb7, 0x3d, 0x4f, 0x2c, 0xa2, 0x5d, 0x1b, 0x01, 0xbf, 0x84, 0xbe,
        0x45, 0x44, 0x71, 0x0b, 0x11, 0xb4, 0xd2, 0x24, 0xd2, 0x9e, 0x49, 0x7c, 0xa3, 0x7b, 0xd0, 0x4e,
        0x85, 0x62, 0x34, 0x84, 0x62, 0x2c, 0x93, 0x12, 0x0b, 0xae, 0xec, 0xc6, 0xdf, 0x81, 0xe6, 0xb1,
        0x77, 0x56, 0x13, 0xec, 0x2e, 0x43, 0xf3, 0xad, 0xa7, 0xc3, 0x1f, 0xfe, 0x89, 0xbf, 0x03, 0x4b,
        0x7b, 0xe1, 0x29, 0xf5, 0x2f, 0xfd, 0x88, 0x3e, 0x0b, 0x23, 0x46, 0x53, 0x8b, 0x6f, 0xc7, 0xe6,
        0x1b, 0xff, 0x99, 0x03, 0x9d, 0x1d, 0x5f, 0x13, 0x17, 0xe7, 0x6e, 0x53, 0x7c, 0xcb, 0xd8, 0xf7,
        0x52, 0x8a, 0xbb, 0xed, 0x8a, 0x6f, 0xbe, 0x15, 0x01, 0x15, 0x49, 0x2b, 0x99, 0x00, 0x55, 0xe7,
        0xaa, 0x0d, 0xab, 0x4d, 0x00, 0xf5, 0x61, 0xf6, 0xa4, 0x70, 0x7d, 0xd6, 0x4d, 0xfc, 0x39, 0xac,
        0x15, 0x73, 0x99, 0xf2, 0xdc, 0xe4, 0xe7, 0x02, 0x5f, 0x71, 0xe7, 0x94, 0xd1, 0x54, 0xa5, 0x7d,
        0xf9, 0x16, 0xc8, 0x03, 0xad, 0xae, 0x8b, 0xfb, 0x87, 0x05, 0xc3, 0x3a, 0x37, 0xa6, 0x3a, 0x05,
        0xa8, 0xbd, 0x97, 0x6d, 0x41, 0xe7, 0x54, 0x88, 0x4a, 0x59, 0xf9, 0x32, 0x29, 0x89, 0xd0, 0x55,
        0xfd, 0x3c, 0xe2, 0xf6, 0x84, 0xc4, 0xb4, 0x2d, 0xcf, 0x12, 0x29, 0x41, 0x57, 0xc3, 0xd1, 0x9f,
        0xc0, 0x1d, 0x8f, 0x33, 0xb4, 0x1b, 0xfb, 0xe5, 0x04, 0x9f, 0x64, 0x4d, 0x48, 0xa0, 0xb7, 0xbd,
        0x4e, 0xea, 0xf8, 0x76, 0xa7, 0x0c, 0xc6, 0x7f, 0x0c, 0x37, 0x4d, 0x90, 0x9d, 0x73, 0x7b, 0xcd,
        0x5c, 0xd2, 0x1d, 0x68, 0x44, 0xbe, 0x52, 0xb6, 0x45, 0x52, 0x10, 0x96, 0xdb, 0x88, 0x7c, 0xfc,
        0x13, 0x18, 0x3c, 0xa7, 0xd5, 0xc9, 0xaf, 0x75, 0x19, 0x99, 0x36, 0xf7, 0x59, 0xc1, 0x40, 0x77,
        0xe3, 0xd3, 0xc4, 0xda, 0x0f, 0xa7, 0xb0, 0x1f, 0x96, 0xb6, 0x34, 0x0a, 0xda, 0x52, 0x71, 0x05,
        0xcd, 0x1a, 0x57, 0xf0, 0x6d, 0x71, 0x7d, 0xe5, 0xd4, 0xfa, 0x26, 0x1a, 0x57, 0x29, 0x0d, 0x03,
        0xc0, 0x3f, 0x11, 0x77, 0x41, 0x1d, 0x37, 0x5f, 0x8b, 0xc1, 0x0f, 0xb4, 0x70, 0x0b, 0x17, 0x2e,
        0x35, 0x85, 0xd5, 0x85, 0x7f, 0xd5, 0x86, 0x8e, 0x8a, 0x31, 0xeb, 0xec, 0x6a, 0x00, 0x73, 0x8c,
        0xc6, 0x5e, 0xcc, 0x76, 0x35, 0x7b, 0xa6, 0xcd, 0x25, 0x32, 0xce, 0x68, 0x6a, 0x92, 0x79, 0xaa,
        0xa5, 0x93, 0xad, 0xad, 0x72, 0xb2, 0xf5, 0x0e, 0x80, 0x9f, 0x52, 0x8f, 0xd1, 0xe3, 0xf0, 0x5c,
        0x27, 0xf4, 0x2c, 0x88, 0xb2, 0x80, 0x8e, 0xb1, 0x80, 0x3e, 0xcc, 0x4a, 0x5b, 0x0d, 0x44, 0x30,
        0x3a, 0xe7, 0xea, 0x26, 0xda, 0x85, 0xb5, 0xac, 0x26, 0xbe, 0x13, 0x71, 0x29, 0x57, 0xd6, 0xba,
        0xe0, 0xcf, 0xad, 0x1d, 0x82, 0x1e, 0x00, 0xbc, 0x35, 0xb7, 0x2e, 0x11, 0xb8, 0xf6, 0xb6, 0x57,
        0x48, 0xf9, 0x3a, 0xe6, 0x5a, 0x48, 0x3c, 0x50, 0x09, 0xe8, 0xa9, 0x37, 0x8e, 0xf2, 0x40, 0x1b,
        0x64, 0xa0, 0x52, 0x02, 0x73, 0x3a, 0xbf, 0xae, 0x09, 0x02, 0xfa, 0x3d, 0x45, 0x67, 0x5d, 0x84,
        0xe0, 0xd6, 0x0e, 0x41, 0xf7, 0xa0, 0xe5, 0x27, 0x69, 0xd6, 0x9f, 0x17, 0x43, 0x11, 0xa9, 0x1c,
        0xbb, 0xae, 0xe8, 0x47, 0x2f, 0xa0, 0x9f, 0x4e, 0xf0, 0xea, 0xfd, 0x05, 0x31, 0xf6, 0x26, 0x99,
        0xe4, 0xf6, 0xdd, 0x89, 0x43, 0xd1, 0x33, 0xd8, 0x88, 0xb4, 0x95, 0x14, 0x27, 0x5d, 0xac, 0x35,
        0xa2, 0x09, 0xd8, 0xdc, 0x26, 0xa4, 0xf2, 0x1d, 0x26, 0x51, 0xe8, 0x5f, 0xf6, 0x97, 0xa4, 0x4d,
        0xd8, 0x30, 0xa9, 0x57, 0xde, 0x19, 0xcd, 0xfa, 0xcb, 0xf2, 0x0e, 0x22, 0x5b, 0xc6, 0x57, 0xaf,
        0x58, 0xbe, 0xfa, 0x11, 0x2c, 0xa5, 0x45, 0x43, 0xed, 0xa3, 0xea, 0xf1, 0xc4, 0xe1, 0x6e, 0x19,
        0x11, 0xff, 0xa5, 0x03, 0xb3, 0xfc, 0x36, 0xc2, 0xe9, 0xaa, 0x9e, 0x56, 0xc5, 0x47, 0xa3, 0x46,
        0xdd, 0xa3, 0x91, 0x48, 0x08, 0x35, 0xad, 0x84, 0x10, 0x82, 0x16, 0xe5, 0x97, 0x91, 0x96, 0x4a,
        0x26, 0x33, 0xf9, 0x28, 0x39, 0x35, 0x2f, 0xf6, 0x37, 0x0e, 0xcc, 0x2a, 0x65, 0xb3, 0x52, 0x1b,
        0xe6, 0x38, 0xc8, 0x01, 0x66, 0x85, 0x86, 0xb5, 0xc2, 0x00, 0xe6, 0xc2, 0x6c, 0xcf, 0x63, 0x34,
        0xd3, 0x77, 0x47, 0xd3, 0xae, 0xac, 0xde, 0xaa, 0xc9, 0xc1, 0xd6, 0xa4, 0xd8, 0xf1, 0x2f, 0x66,
        0x45, 0x9e, 0x41, 0x25, 0x4b, 0xf3, 0x9c, 0xbe, 0x53, 0xce, 0xe9, 0x17, 0xbd, 0x78, 0xa3, 0xe2,
        0xc5, 0x6d, 0x07, 0xd2, 0x9c, 0xe8, 0x40, 0x5a, 0x05, 0x07, 0x72, 0x75, 0x76, 0x67, 0x00, 0x73,
        0x72, 0xf9, 0x5d, 0xed, 0x2c, 0x4c, 0x7b, 0x7a, 0x46, 0x4e, 0x38, 0x21, 0xd9, 0xdc, 0x0f, 0x3e,
        0x52, 0xe9, 0x54, 0x0b, 0x82, 0xee, 0xc2, 0x9c, 0x5a, 0x4a, 0x3f, 0x67, 0xce, 0x11, 0xb5, 0x35,
        0xae, 0xe9, 0xa9, 0xb8, 0x76, 0xa8, 0xba, 0xf6, 0x89, 0x4e, 0xaa, 0xf7, 0xee, 0x4e, 0xea, 0x13,
        0xb8, 0xa1, 0x9c, 0x82, 0x8e, 0xe8, 0x8d, 0xe7, 0x99, 0x17, 0x2b, 0x4f, 0xea, 0xd6, 0xbe, 0x78,
        0xa1, 0xec, 0x8b, 0xed, 0x54, 0xe7, 0x62, 0x29, 0xd5, 0xb9, 0x01, 0x9d, 0x30, 0xfb, 0x72, 0x1c,
        0x45, 0xc2, 0x3a, 0xe7, 0x5c, 0xd5, 0xaa, 0xc4, 0x53, 0xcb, 0xa2, 0xb7, 0x12, 0x4f, 0x09, 0x5d,
        0x5a, 0xb1, 0xac, 0xa2, 0x0f, 0x2d, 0xe6, 0x9d, 0x65, 0xca, 0x30, 0x5b, 0xe4, 0xd8, 0x3b, 0x73,
        0x05, 0xa4, 0xa2, 0x9d, 0xab, 0xf5, 0xda, 0x29, 0x34, 0x7e, 0xcd, 0xd2, 0x78, 0xed, 0x09, 0xd6,
        0x2d, 0x4f, 0xc0, 0x61, 0x7c, 0xcf, 0x37, 0x14, 0x8c, 0x6f, 0xf6, 0x26, 0xf4, 0xe2, 0x71, 0x14,
        0xe9, 0xe4, 0xf9, 0x0d, 0xf9, 0x74, 0x6d, 0x81, 0xd0, 0x2e, 0x2c, 0xfb, 0xe3, 0x8c, 0x25, 0xe7,
        0x3b, 0x8c, 0xa5, 0xe1, 0xc9, 0x98, 0xd1, 0xac, 0xdf, 0x17, 0x74, 0xbe, 0xa7, 0xd2, 0x93, 0x64,
        0x58, 0xea, 0x97, 0x29, 0xe3, 0xca, 0x30, 0xbe, 0x98, 0xda, 0x7f, 0x71, 0xe6, 0xde, 0x94, 0xba,
        0x67, 0x81, 0x64, 0xec, 0xee, 0x8b, 0xf2, 0x83, 0x81, 0xe0, 0x54, 0x37, 0x07, 0x43, 0x58, 0xaf,
        0x5d, 0xe6, 0x9d, 0x52, 0xc6, 0x2f, 0x61, 0x75, 0x2f, 0xcc, 0x54, 0x9c, 0x90, 0x5d, 0x3f, 0x2d,
        0x2b, 0xad, 0x55, 0xc7, 0xf5, 0x26, 0x4a, 0xd0, 0x70, 0xfc, 0x43, 0x98, 0x7f, 0xec, 0x65, 0xf4,
        0x1d, 0xde, 0x81, 0xb2, 0x33, 0xf3, 0x0e, 0x94, 0x9d, 0xe1, 0xf7, 0xa0, 0x27, 0xc7, 0xcb, 0xb8,
        0xaf, 0x14, 0xe8, 0xe2, 0xbf, 0x6b, 0x01, 0xca, 0xab, 0x2f, 0x4c, 0x39, 0xcb, 0xa4, 0x0b, 0x56,
        0xee, 0x1c, 0x54, 0x46, 0x68, 0xce, 0xcd, 0x01, 0x5c, 0xc4, 0xaa, 0x21, 0xbc, 0x4d, 0xdb, 0xd5,
        0x4d, 0x3e, 0x2e, 0xa0, 0x51, 0x78, 0x1e, 0x32, 0x15, 0xee, 0x77, 0xdd, 0x1c, 0x50, 0x29, 0x7f,
        0x69, 0xd7, 0x94, 0xbf, 0xf4, 0x61, 0xf6, 0xdc, 0xbb, 0xf8, 0x82, 0x5e, 0x66, 0xea, 0x21, 0x47,
        0x37, 0xad, 0x4b, 0xcb, 0x6c, 0xe1, 0xb2, 0xb6, 0x01, 0x9d, 0x73, 0x69, 0x2b, 0x73, 0xea, 0xa1,
        0x52, 0x5a, 0xc9, 0xef, 0xc1, 0x0a, 0x77, 0x39, 0x61, 0x3c, 0x16, 0x16, 0x77, 0x9c, 0xbc, 0xa1,
        0xb1, 0x88, 0x3d, 0xba, 0x6e, 0xb5, 0x83, 0xbb, 0xac, 0x8c, 0x79, 0x29, 0x13, 0x77, 0x08, 0xe5,
        0x6a, 0x2c, 0x08, 0xef, 0x3f, 0xa5, 0xcc, 0x7f, 0x25, 0x6b, 0x4c, 0x7a, 0x42, 0x24, 0x16, 0x84,
        0x73, 0xfe, 0x86, 0x5e, 0x2a, 0xa3, 0x95, 0xfe, 0x22, 0x07, 0xf0, 0x68, 0xc6, 0xf8, 0x56, 0x85,
        0xb3, 0x20, 0xa3, 0x99, 0x12, 0x18, 0x7d, 0xdf, 0xdc, 0x3c, 0xe4, 0x99, 0xff, 0x2d, 0x52, 0xdd,
        0x36, 0x22, 0xef, 0x20, 0xd2, 0x46, 0x14, 0xfa, 0xe0, 0x53, 0xe8, 0x59, 0xe0, 0x77, 0xd2, 0xe9,
        0x7f, 0x72, 0xa4, 0x52, 0x9b, 0x55, 0xae, 0xa5, 0x83, 0x9b, 0xd0, 0x0b, 0xad, 0x92, 0x15, 0xa9,
        0x25, 0x36, 0x88, 0xcb, 0x2c, 0xa6, 0x17, 0xac, 0x70, 0x33, 0xb4, 0x20, 0xdc, 0x3f, 0xca, 0x94,
        0x93, 0x4a, 0x84, 0x74, 0x5d, 0xd3, 0x56, 0x2f, 0x19, 0x9c, 0x9c, 0x7e, 0x5b, 0x99, 0x8c, 0xf5,
        0x92, 0xc1, 0xe1, 0xf8, 0x33, 0x58, 0x1b, 0x26, 0xe3, 0xb8, 0x42, 0xf6, 0x1a, 0xb4, 0x05, 0x5c,
        0x15, 0xa1, 0xc8, 0x86, 0xa9, 0x49, 0x6a, 0x58, 0x35, 0x49, 0xff, 0xe8, 0xc0, 0xca, 0x13, 0xe1,
        0x59, 0xe5, 0x1c, 0xbb, 0xf1, 0x68, 0x3c, 0xd9, 0x28, 0x94, 0x48, 0x1b, 0xb9, 0x48, 0x07, 0xfa,
        0x1c, 0xcb, 0xcf, 0x5d, 0xdd, 0x2e, 0x7b, 0xaa, 0x56, 0xd5, 0x53, 0xe9, 0x57, 0xf1, 0x76, 0xfe,
        0x2a, 0x7e, 0xd5, 0xb9, 0x8b, 0x19, 0x20, 0x9b, 0xd8, 0x83, 0x31, 0xe3, 0xd4, 0x5e, 0xbd, 0x49,
        0xe5, 0xe3, 0xa4, 0x51, 0x73, 0x9c, 0x14, 0x22, 0x81, 0x66, 0xf9, 0x79, 0xf8, 0x67, 0x0e, 0x2c,
        0x9a, 0xd7, 0x2d, 0x23, 0xa0, 0x42, 0x36, 0x5e, 0xdf, 0x6d, 0x96, 0xa1, 0x99, 0x3f, 0x83, 0x34,
        0xd5, 0x03, 0xc8, 0xcb, 0xf2, 0xd4, 0x06, 0xc0, 0xe7, 0x51, 0xb9, 0x6e, 0x19, 0x31, 0xa9, 0x16,
        0x87, 0xab, 0x1c, 0xb7, 0x8c, 0x96, 0x54, 0x0b, 0xff, 0xdc, 0x81, 0xa5, 0x72, 0x56, 0xe0, 0x9d,
        0x36, 0x6b, 0x62, 0x61, 0x84, 0x2d, 0xf6, 0x56, 0x29, 0xdc, 0x99, 0xf2, 0x60, 0xc9, 0xf2, 0x37,
        0x67, 0x59, 0xc8, 0xf3, 0xb7, 0x0e, 0x74, 0xb9, 0x35, 0xc9, 0xb2, 0xa1, 0xeb, 0xcb, 0x6a, 0x0a,
        0x7d, 0xa6, 0x74, 0xac, 0x55, 0x2a, 0x1d, 0x7b, 0x87, 0xb2, 0x35, 0x7c, 0x0b, 0xda, 0xc7, 0x9c,
        0x36, 0x4e, 0xb8, 0x78, 0x2c, 0x77, 0x36, 0x9b, 0x9c, 0x70, 0x51, 0x91, 0xc0, 0x60, 0x91, 0xff,
        0x6e, 0x8b, 0xc8, 0x4a, 0x55, 0x45, 0x34, 0xa3, 0x8c, 0x09, 0xa4, 0xde, 0x76, 0x9f, 0x14, 0x7b,
        0xc9, 0x5e, 0xc6, 0xa4, 0x0b, 0xe2, 0x48, 0x83, 0x8f, 0x61, 0x4e, 0x03, 0x6c, 0xe7, 0xd3, 0x9e,
        0xe6, 0x7c, 0xfe, 0xc5, 0x01, 0xf4, 0x5c, 0x3e, 0xd4, 0xef, 0x7b, 0x23, 0x63, 0xc4, 0x77, 0x00,
        0x8e, 0x53, 0x2f, 0xce, 0x42, 0x95, 0xe4, 0xe1, 0xde, 0xc1, 0x82, 0xa0, 0xcf, 0xa0, 0x2b, 0xc8,
        0x51, 0x11, 0x31, 0x27, 0x10, 0x93, 0xea, 0x3c, 0xc4, 0x20, 0x49, 0x52, 0xf3, 0x41, 0x83, 0x7d,
        0xc5, 0xae, 0xe9, 0xac, 0xf1, 0x99, 0xef, 0xdb, 0x64, 0xf7, 0xb6, 0x97, 0x4a, 0x22, 0xb0, 0xf9,
        0xf8, 0x1f, 0x07, 0xd6, 0x5e, 0x8c, 0x02, 0x4f, 0x98, 0xa7, 0x7c, 0x05, 0x36, 0x67, 0xec, 0xc1,
        0xc9, 0xeb, 0x3c, 0xae, 0x57, 0xad, 0xa9, 0xcf, 0x65, 0x75, 0x85, 0x96, 0xe5, 0x87, 0x99, 0x1f,
        0xc0, 0xec, 0x11, 0x65, 0x8c, 0xdf, 0xaa, 0x5b, 0x4a, 0x06, 0x75, 0x34, 0x10, 0x85, 0x24, 0x65,
        0xa0, 0x87, 0x0c, 0x1e, 0xc1, 0xbc, 0xdd, 0xf1, 0x4e, 0x67, 0xc6, 0xc7, 0xc5, 0x82, 0x4a, 0xae,
        0x50, 0x56, 0x8a, 0x49, 0x7c, 0x1b, 0x25, 0x53, 0xf9, 0x42, 0xa1, 0x64, 0x4f, 0xe0, 0xe6, 0x73,
        0xca, 0xec, 0xa1, 0x34, 0xf7, 0xdc, 0x1f, 0xc0, 0xac, 0x2f, 0x41, 0x4a, 0xe7, 0x16, 0x88, 0x8d,
        0xe9, 0xea, 0x5e, 0xfc, 0x00, 0x6e, 0x3d, 0x37, 0xa5, 0x36, 0x3c, 0x6e, 0x78, 0x7c, 0xc9, 0x67,
        0xd7, 0x22, 0xcf, 0xb5, 0x3b, 0x5f, 0xf8, 0x7b, 0x70, 0xbb, 0x7e, 0x48, 0x7e, 0x6a, 0x70, 0x68,
        0xa6, 0x74, 0x4d, 0x36, 0xf0, 0xbf, 0x39, 0xb0, 0x5e, 0x4e, 0xc8, 0x51, 0x3f, 0x49, 0x83, 0xe2,
        0x6b, 0xa6, 0x53, 0xad, 0x98, 0xd0, 0x66, 0xdf, 0x28, 0x98, 0x7d, 0x1f, 0x66, 0x75, 0xd5, 0x90,
        0xb4, 0x71, 0xdd, 0xb4, 0x1e, 0x0c, 0x8d, 0x0b, 0x7a, 0x61, 0x99, 0xff, 0x6e, 0x1c, 0x32, 0x2b,
        0xa5, 0x63, 0xda, 0x85, 0xbb, 0x5f, 0x67, 0xe2, 0xdd, 0x6f, 0xd6, 0xbe, 0xfb, 0xe1, 0xff, 0x75,
        0x64, 0x2d, 0xae, 0x24, 0x4a, 0xb3, 0x75, 0xed, 0xea, 0xb3, 0x3c, 0xc4, 0x6b, 0x4c, 0x0b, 0xf1,
        0xea, 0x2a, 0x9c, 0xef, 0x00, 0x9c, 0x7b, 0x17, 0x72, 0xd5, 0x4c, 0x25, 0x85, 0x2d, 0x48, 0x31,
        0x94, 0x6a, 0x97, 0x43, 0xa9, 0x3c, 0x0c, 0xec, 0x14, 0xc2, 0xc0, 0x7b, 0xb0, 0xa8, 0xdd, 0xa5,
        0x1a, 0x2a, 0x79, 0x2e, 0x41, 0xf1, 0xa7, 0xaa, 0x4e, 0xb8, 0x92, 0x0b, 0xde, 0x84, 0x5e, 0x10,
        0x66, 0xa3, 0xc8, 0xbb, 0xb4, 0x0c, 0xd2, 0x06, 0xe1, 0x7f, 0x76, 0xa0, 0xa3, 0x8e, 0x9d, 0xaa,
        0xa9, 0xd8, 0xee, 0xbb, 0x51, 0x72, 0xdf, 0x77, 0xa1, 0x1b, 0x9a, 0x0a, 0xe6, 0x62, 0x7d, 0x72,
        0xde, 0x81, 0x6e, 0x43, 0x3b, 0x11, 0xd1, 0x65, 0xab, 0x58, 0xc1, 0x9c, 0xe8, 0x0a, 0xe6, 0xc2,
        0x6d, 0xb8, 0x5d, 0x73, 0x1b, 0xbe, 0x6d, 0xd6, 0xa1, 0x5a, 0x19, 0x72, 0x00, 0xfe, 0x77, 0x55,
        0xd6, 0x5e, 0xdc, 0x75, 0x51, 0xaa, 0x52, 0x8a, 0xe5, 0x9c, 0x6a, 0x2c, 0x77, 0x17, 0x16, 0x78,
        0xe4, 0xf6, 0x85, 0xd9, 0x18, 0xf5, 0x58, 0x56, 0x00, 0x22, 0x02, 0x88, 0x03, 0x5e, 0x14, 0x37,
        0x42, 0x2a, 0x41, 0x4d, 0x0f, 0x67, 0xca, 0x4f, 0xce, 0xcf, 0x93, 0x58, 0xc6, 0x7d, 0x2a, 0x0a,
        0x2c, 0xc0, 0x78, 0x24, 0x38, 0x56, 0xba, 0xa2, 0x23, 0x41, 0x45, 0xbb, 0x86, 0xe3, 0x10, 0xfa,
        0x35, 0x8c, 0x5d, 0x27, 0x88, 0xfd, 0x2e, 0x74, 0x52, 0x21, 0x02, 0xe5, 0xe1, 0x6f, 0x90, 0x7a,
        0x09, 0xb9, 0x0a, 0x6d, 0xfb, 0x57, 0x6b, 0xd0, 0x38, 0x7a, 0x88, 0x1e, 0x42, 0xcf, 0xba, 0x06,
        0xa2, 0x79, 0x62, 0x5d, 0xbe, 0x06, 0x6b, 0xa4, 0xe6, 0x8a, 0x88, 0x67, 0xd0, 0x16, 0xcc, 0x0f,
        0x45, 0x26, 0x56, 0x39, 0x03, 0x7d, 0x0b, 0x1c, 0x2c, 0x10, 0xfb, 0xee, 0x27, 0x31, 0x65, 0xa8,
        0x37, 0x15, 0xf3, 0x43, 0xe8, 0x9a, 0xb4, 0x75, 0x8e, 0x86, 0x48, 0x25, 0x97, 0x8d, 0x67, 0xd0,
        0x7d, 0x58, 0x28, 0xd4, 0x29, 0x21, 0x1d, 0x53, 0x0f, 0xd6, 0x48, 0x4d, 0x01, 0x13, 0x9e, 0x41,
        0x0f, 0x60, 0xd9, 0x9c, 0x27, 0x95, 0x41, 0x88, 0x54, 0xca, 0x93, 0xf0, 0x0c, 0x7a, 0x24, 0x25,
        0xa3, 0x82, 0x72, 0xb4, 0x5a, 0x73, 0x7f, 0x51, 0x02, 0x2a, 0xc5, 0xed, 0x78, 0x06, 0xfd, 0x00,
        0xe6, 0xed, 0x88, 0xbe, 0x7e, 0xf0, 0x3a, 0xa9, 0x8b, 0xfa, 0xf1, 0x0c, 0x7a, 0x08, 0x5d, 0x43,
        0x10, 0x5a, 0x24, 0x85, 0xf2, 0xdb, 0x7a, 0x62, 0xb7, 0x1c, 0x2e, 0x69, 0x9b, 0xc3, 0x9c, 0xbb,
        0x8a, 0xa4, 0xbf, 0x27, 0x24, 0xad, 0xd0, 0x96, 0x48, 0x31, 0x26, 0x96, 0x12, 0x2f, 0xcf, 0x7f,
        0xdf, 0x41, 0x9f, 0xea, 0x9d, 0x54, 0x03, 0x11, 0xa9, 0x5c, 0x38, 0x06, 0xab, 0xa4, 0x1a, 0xd7,
        0x0b, 0xe1, 0x43, 0x1e, 0xd0, 0x94, 0x54, 0x6c, 0xb5, 0x26, 0xd6, 0xc1, 0x33, 0xe8, 0xfb, 0xb0,
        0x50, 0x38, 0xff, 0xd1, 0x7a, 0x6d, 0x3c, 0x50, 0x65, 0xee, 0x47, 0xe2, 0xf5, 0xa3, 0x78, 0x2c,
        0x97, 0x96, 0x1c, 0x90, 0x89, 0x07, 0x37, 0x9e, 0x41, 0x2f, 0x60, 0xad, 0xee, 0x78, 0x45, 0xb7,
        0xc9, 0x15, 0x07, 0xf5, 0xe0, 0x3d, 0x72, 0xd5, 0x99, 0x8c, 0x67, 0xd0, 0xc7, 0xb0, 0x6e, 0x1b,
        0x82, 0xc9, 0x7f, 0x97, 0x68, 0xab, 0xf0, 0xb3, 0x03, 0xa8, 0xfa, 0x28, 0x86, 0x06, 0x64, 0xe2,
        0x4b, 0x59, 0xed, 0x14, 0xd5, 0xa7, 0xaf, 0xd2, 0xba, 0xb7, 0xc8, 0xe4, 0xd7, 0x31, 0x3c, 0x83,
        0xfe, 0xc0, 0x4e, 0x16, 0x4d, 0x9a, 0xe3, 0x0a, 0x6f, 0x21, 0xf7, 0x6e, 0xaa, 0x0f, 0x38, 0xac,
        0x3b, 0xcd, 0x79, 0x90, 0x92, 0xa1, 0x3e, 0x99, 0x70, 0xce, 0x0f, 0x6e, 0x92, 0x49, 0x2e, 0x13,
        0xcf, 0xa0, 0x67, 0xb0, 0x6a, 0x0a, 0xe2, 0xad, 0xcb, 0xd6, 0x7a, 0x6d, 0x29, 0xfe, 0x60, 0x83,
        0xd4, 0x56, 0xcf, 0x0b, 0xb5, 0xaa, 0x7f, 0xcb, 0xdd, 0x20, 0xb5, 0x7f, 0x57, 0xa9, 0xb2, 0xe6,
        0xc2, 0x8d, 0x61, 0xfd, 0xbb, 0x27, 0xba, 0x49, 0x26, 0xfd, 0x75, 0x64, 0x30, 0x20, 0x13, 0xff,
        0x4a, 0x81, 0x67, 0xd0, 0x47, 0x00, 0x79, 0x05, 0x7b, 0xc5, 0x51, 0xac, 0x92, 0x6a, 0x79, 0xbb,
        0xf0, 0x14, 0xcf, 0x60, 0xa9, 0xf4, 0xff, 0x25, 0x74, 0x83, 0xd4, 0xff, 0x4d, 0x6c, 0xd0, 0x27,
        0x13, 0xfe, 0xea, 0x84, 0x67, 0xd0, 0xef, 0xc3, 0xfc, 0xce, 0x68, 0x44, 0xe3, 0x40, 0x79, 0x84,
        0x29, 0x9a, 0xfc, 0xbb, 0x00, 0x87, 0x89, 0x9e, 0x6b, 0x1a, 0xf2, 0x23, 0x58, 0xda, 0x09, 0x82,
        0x42, 0x9c, 0xba, 0x41, 0x6a, 0xe3, 0xd7, 0xea, 0xd8, 0x3f, 0xd4, 0xe9, 0x85, 0x5f, 0x6f, 0xf8,
        0x16, 0xc0, 0xe7, 0xd4, 0x0b, 0x8c, 0x7f, 0x2c, 0x96, 0x0d, 0x0e, 0xb4, 0x5f, 0x15, 0x4e, 0x0a,
        0xf2, 0x2a, 0x6a, 0x84, 0x48, 0xa5, 0xf8, 0x7c, 0xb0, 0x4a, 0xaa, 0x65, 0xd6, 0x72, 0x60, 0x5e,
        0x31, 0x8f, 0x10, 0xa9, 0xfc, 0x7d, 0x60, 0xb0, 0x4a, 0xaa, 0x25, 0xf5, 0xf2, 0x4c, 0xb2, 0x0a,
        0xe3, 0x90, 0xc1, 0xb2, 0x95, 0x78, 0x8d, 0xd4, 0xd4, 0xce, 0xe1, 0x19, 0xf4, 0x5d, 0x7d, 0xaa,
        0xec, 0x0c, 0xf7, 0xd0, 0x0a, 0x29, 0x57, 0x6c, 0x56, 0x05, 0xf1, 0x81, 0x3e, 0x27, 0xf8, 0x80,
        0x7a, 0x39, 0xec, 0x0c, 0xf7, 0xf0, 0x0c, 0xda, 0xb6, 0x5e, 0x9c, 0xcd, 0x5b, 0xc2, 0x94, 0x0d,
        0xfe, 0xa1, 0x28, 0x35, 0xae, 0x14, 0xb2, 0x22, 0x52, 0x29, 0xfa, 0x1c, 0x54, 0x1f, 0x58, 0x85,
        0xee, 0xcf, 0xdb, 0x15, 0xb9, 0x68, 0x8d, 0xd4, 0x14, 0xe8, 0x56, 0x97, 0xbd, 0x0f, 0xf3, 0x66,
        0x59, 0x3e, 0xac, 0x6e, 0x3d, 0xab, 0x84, 0x17, 0xcf, 0x20, 0x22, 0xfe, 0xff, 0x22, 0x21, 0xc3,
        0x03, 0xf7, 0x68, 0x1a, 0x63, 0x44, 0xc4, 0x26, 0xd7, 0xc7, 0x7f, 0x00, 0xcb, 0xf6, 0xc1, 0x70,
        0x9d, 0x21, 0xf7, 0x61, 0xc9, 0x90, 0xa4, 0x5e, 0x41, 0xa7, 0x8f, 0x30, 0x44, 0x5d, 0x6f, 0xc4,
        0x43, 0x6d, 0x44, 0xef, 0x32, 0xe8, 0x7d, 0x69, 0x3a, 0xca, 0xcf, 0x17, 0x91, 0xb5, 0xd7, 0xc7,
        0x33, 0x27, 0x1d, 0x51, 0x76, 0xf8, 0xf0, 0xff, 0x03, 0x00, 0x00, 0xff, 0xff, 0x02, 0x1b, 0x52,
        0xd9, 0xa9, 0x3a, 0x00, 0x00,
}
</pre>
		
		<pre class="file" id="file163" style="display: none">// Code generated by protoc-gen-micro. DO NOT EDIT.
// source: s3.proto

package s3

import (
        fmt "fmt"
        proto "github.com/golang/protobuf/proto"
        math "math"
)

import (
        context "context"
        client "github.com/micro/go-micro/client"
        server "github.com/micro/go-micro/server"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ client.Option
var _ server.Option

// Client API for S3 service

type S3Service interface {
        ListBuckets(ctx context.Context, in *BaseRequest, opts ...client.CallOption) (*ListBucketsResponse, error)
        CreateBucket(ctx context.Context, in *Bucket, opts ...client.CallOption) (*BaseResponse, error)
        DeleteBucket(ctx context.Context, in *Bucket, opts ...client.CallOption) (*BaseResponse, error)
        GetBucket(ctx context.Context, in *Bucket, opts ...client.CallOption) (*GetBucketResponse, error)
        GetObjectMeta(ctx context.Context, in *Object, opts ...client.CallOption) (*GetObjectMetaResult, error)
        UpdateObjectMeta(ctx context.Context, in *Object, opts ...client.CallOption) (*PutObjectResponse, error)
        ListObjects(ctx context.Context, in *ListObjectsRequest, opts ...client.CallOption) (*ListObjectsResponse, error)
        CountObjects(ctx context.Context, in *ListObjectsRequest, opts ...client.CallOption) (*CountObjectsResponse, error)
        PutObject(ctx context.Context, opts ...client.CallOption) (S3_PutObjectService, error)
        UpdateObject(ctx context.Context, in *Object, opts ...client.CallOption) (*BaseResponse, error)
        GetObject(ctx context.Context, in *GetObjectInput, opts ...client.CallOption) (S3_GetObjectService, error)
        DeleteObject(ctx context.Context, in *DeleteObjectInput, opts ...client.CallOption) (*DeleteObjectOutput, error)
        GetTierMap(ctx context.Context, in *BaseRequest, opts ...client.CallOption) (*GetTierMapResponse, error)
        UpdateObjMeta(ctx context.Context, in *UpdateObjMetaRequest, opts ...client.CallOption) (*BaseResponse, error)
        GetStorageClasses(ctx context.Context, in *BaseRequest, opts ...client.CallOption) (*GetStorageClassesResponse, error)
        GetBackendTypeByTier(ctx context.Context, in *GetBackendTypeByTierRequest, opts ...client.CallOption) (*GetBackendTypeByTierResponse, error)
        DeleteBucketLifecycle(ctx context.Context, in *BaseRequest, opts ...client.CallOption) (*BaseResponse, error)
        PutBucketLifecycle(ctx context.Context, in *PutBucketLifecycleRequest, opts ...client.CallOption) (*BaseResponse, error)
        GetBucketLifecycle(ctx context.Context, in *BaseRequest, opts ...client.CallOption) (*GetBucketLifecycleResponse, error)
        ListBucketLifecycle(ctx context.Context, in *BaseRequest, opts ...client.CallOption) (*ListBucketsResponse, error)
        UpdateBucket(ctx context.Context, in *Bucket, opts ...client.CallOption) (*BaseResponse, error)
        ListBucketUploadRecords(ctx context.Context, in *ListBucketUploadRequest, opts ...client.CallOption) (*ListBucketUploadResponse, error)
        InitMultipartUpload(ctx context.Context, in *InitMultiPartRequest, opts ...client.CallOption) (*InitMultiPartResponse, error)
        AbortMultipartUpload(ctx context.Context, in *AbortMultipartRequest, opts ...client.CallOption) (*BaseResponse, error)
        CompleteMultipartUpload(ctx context.Context, in *CompleteMultipartRequest, opts ...client.CallOption) (*CompleteMultipartResponse, error)
        UploadPart(ctx context.Context, opts ...client.CallOption) (S3_UploadPartService, error)
        ListObjectParts(ctx context.Context, in *ListObjectPartsRequest, opts ...client.CallOption) (*ListObjectPartsResponse, error)
        AppendObject(ctx context.Context, in *BaseRequest, opts ...client.CallOption) (*BaseResponse, error)
        PostObject(ctx context.Context, in *BaseRequest, opts ...client.CallOption) (*BaseResponse, error)
        // For lifecycle, may need some change.
        AddUploadRecord(ctx context.Context, in *MultipartUploadRecord, opts ...client.CallOption) (*BaseResponse, error)
        DeleteUploadRecord(ctx context.Context, in *MultipartUploadRecord, opts ...client.CallOption) (*BaseResponse, error)
        HeadObject(ctx context.Context, in *BaseObjRequest, opts ...client.CallOption) (*Object, error)
        MoveObject(ctx context.Context, in *MoveObjectRequest, opts ...client.CallOption) (*MoveObjectResponse, error)
        CopyObject(ctx context.Context, in *CopyObjectRequest, opts ...client.CallOption) (*CopyObjectResponse, error)
        CopyObjPart(ctx context.Context, in *CopyObjPartRequest, opts ...client.CallOption) (*CopyObjPartResponse, error)
        PutObjACL(ctx context.Context, in *PutObjACLRequest, opts ...client.CallOption) (*BaseResponse, error)
        GetObjACL(ctx context.Context, in *BaseObjRequest, opts ...client.CallOption) (*ObjACL, error)
        GetBucketLocation(ctx context.Context, in *BaseRequest, opts ...client.CallOption) (*BaseResponse, error)
        GetBucketVersioning(ctx context.Context, in *BaseBucketRequest, opts ...client.CallOption) (*BucketVersioning, error)
        PutBucketACL(ctx context.Context, in *PutBucketACLRequest, opts ...client.CallOption) (*BaseResponse, error)
        GetBucketACL(ctx context.Context, in *BaseBucketRequest, opts ...client.CallOption) (*BucketACL, error)
        PutBucketCORS(ctx context.Context, in *BaseRequest, opts ...client.CallOption) (*BaseResponse, error)
        GetBucketCORS(ctx context.Context, in *BaseRequest, opts ...client.CallOption) (*BaseResponse, error)
        DeleteBucketCORS(ctx context.Context, in *BaseRequest, opts ...client.CallOption) (*BaseResponse, error)
        PutBucketPolicy(ctx context.Context, in *BaseRequest, opts ...client.CallOption) (*BaseResponse, error)
        GetBucketPolicy(ctx context.Context, in *BaseRequest, opts ...client.CallOption) (*BaseResponse, error)
        DeleteBucketPolicy(ctx context.Context, in *BaseRequest, opts ...client.CallOption) (*BaseResponse, error)
        HeadBucket(ctx context.Context, in *BaseRequest, opts ...client.CallOption) (*Bucket, error)
}

type s3Service struct {
        c    client.Client
        name string
}

func NewS3Service(name string, c client.Client) S3Service <span class="cov0" title="0">{
        if c == nil </span><span class="cov0" title="0">{
                c = client.NewClient()
        }</span>
        <span class="cov0" title="0">if len(name) == 0 </span><span class="cov0" title="0">{
                name = "s3"
        }</span>
        <span class="cov0" title="0">return &amp;s3Service{
                c:    c,
                name: name,
        }</span>
}

func (c *s3Service) ListBuckets(ctx context.Context, in *BaseRequest, opts ...client.CallOption) (*ListBucketsResponse, error) <span class="cov0" title="0">{
        req := c.c.NewRequest(c.name, "S3.ListBuckets", in)
        out := new(ListBucketsResponse)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *s3Service) CreateBucket(ctx context.Context, in *Bucket, opts ...client.CallOption) (*BaseResponse, error) <span class="cov0" title="0">{
        req := c.c.NewRequest(c.name, "S3.CreateBucket", in)
        out := new(BaseResponse)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *s3Service) DeleteBucket(ctx context.Context, in *Bucket, opts ...client.CallOption) (*BaseResponse, error) <span class="cov0" title="0">{
        req := c.c.NewRequest(c.name, "S3.DeleteBucket", in)
        out := new(BaseResponse)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *s3Service) GetBucket(ctx context.Context, in *Bucket, opts ...client.CallOption) (*GetBucketResponse, error) <span class="cov0" title="0">{
        req := c.c.NewRequest(c.name, "S3.GetBucket", in)
        out := new(GetBucketResponse)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *s3Service) GetObjectMeta(ctx context.Context, in *Object, opts ...client.CallOption) (*GetObjectMetaResult, error) <span class="cov0" title="0">{
        req := c.c.NewRequest(c.name, "S3.GetObjectMeta", in)
        out := new(GetObjectMetaResult)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *s3Service) UpdateObjectMeta(ctx context.Context, in *Object, opts ...client.CallOption) (*PutObjectResponse, error) <span class="cov0" title="0">{
        req := c.c.NewRequest(c.name, "S3.UpdateObjectMeta", in)
        out := new(PutObjectResponse)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *s3Service) ListObjects(ctx context.Context, in *ListObjectsRequest, opts ...client.CallOption) (*ListObjectsResponse, error) <span class="cov0" title="0">{
        req := c.c.NewRequest(c.name, "S3.ListObjects", in)
        out := new(ListObjectsResponse)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *s3Service) CountObjects(ctx context.Context, in *ListObjectsRequest, opts ...client.CallOption) (*CountObjectsResponse, error) <span class="cov0" title="0">{
        req := c.c.NewRequest(c.name, "S3.CountObjects", in)
        out := new(CountObjectsResponse)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *s3Service) PutObject(ctx context.Context, opts ...client.CallOption) (S3_PutObjectService, error) <span class="cov0" title="0">{
        req := c.c.NewRequest(c.name, "S3.PutObject", &amp;PutDataStream{})
        stream, err := c.c.Stream(ctx, req, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;s3ServicePutObject{stream}, nil</span>
}

type S3_PutObjectService interface {
        SendMsg(interface{}) error
        RecvMsg(interface{}) error
        Close() error
        Send(*PutDataStream) error
}

type s3ServicePutObject struct {
        stream client.Stream
}

func (x *s3ServicePutObject) Close() error <span class="cov0" title="0">{
        return x.stream.Close()
}</span>

func (x *s3ServicePutObject) SendMsg(m interface{}) error <span class="cov0" title="0">{
        return x.stream.Send(m)
}</span>

func (x *s3ServicePutObject) RecvMsg(m interface{}) error <span class="cov0" title="0">{
        return x.stream.Recv(m)
}</span>

func (x *s3ServicePutObject) Send(m *PutDataStream) error <span class="cov0" title="0">{
        return x.stream.Send(m)
}</span>

func (c *s3Service) UpdateObject(ctx context.Context, in *Object, opts ...client.CallOption) (*BaseResponse, error) <span class="cov0" title="0">{
        req := c.c.NewRequest(c.name, "S3.UpdateObject", in)
        out := new(BaseResponse)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *s3Service) GetObject(ctx context.Context, in *GetObjectInput, opts ...client.CallOption) (S3_GetObjectService, error) <span class="cov0" title="0">{
        req := c.c.NewRequest(c.name, "S3.GetObject", &amp;GetObjectInput{})
        stream, err := c.c.Stream(ctx, req, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if err := stream.Send(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;s3ServiceGetObject{stream}, nil</span>
}

type S3_GetObjectService interface {
        SendMsg(interface{}) error
        RecvMsg(interface{}) error
        Close() error
        Recv() (*GetObjectResponse, error)
}

type s3ServiceGetObject struct {
        stream client.Stream
}

func (x *s3ServiceGetObject) Close() error <span class="cov0" title="0">{
        return x.stream.Close()
}</span>

func (x *s3ServiceGetObject) SendMsg(m interface{}) error <span class="cov0" title="0">{
        return x.stream.Send(m)
}</span>

func (x *s3ServiceGetObject) RecvMsg(m interface{}) error <span class="cov0" title="0">{
        return x.stream.Recv(m)
}</span>

func (x *s3ServiceGetObject) Recv() (*GetObjectResponse, error) <span class="cov0" title="0">{
        m := new(GetObjectResponse)
        err := x.stream.Recv(m)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return m, nil</span>
}

func (c *s3Service) DeleteObject(ctx context.Context, in *DeleteObjectInput, opts ...client.CallOption) (*DeleteObjectOutput, error) <span class="cov0" title="0">{
        req := c.c.NewRequest(c.name, "S3.DeleteObject", in)
        out := new(DeleteObjectOutput)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *s3Service) GetTierMap(ctx context.Context, in *BaseRequest, opts ...client.CallOption) (*GetTierMapResponse, error) <span class="cov0" title="0">{
        req := c.c.NewRequest(c.name, "S3.GetTierMap", in)
        out := new(GetTierMapResponse)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *s3Service) UpdateObjMeta(ctx context.Context, in *UpdateObjMetaRequest, opts ...client.CallOption) (*BaseResponse, error) <span class="cov0" title="0">{
        req := c.c.NewRequest(c.name, "S3.UpdateObjMeta", in)
        out := new(BaseResponse)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *s3Service) GetStorageClasses(ctx context.Context, in *BaseRequest, opts ...client.CallOption) (*GetStorageClassesResponse, error) <span class="cov0" title="0">{
        req := c.c.NewRequest(c.name, "S3.GetStorageClasses", in)
        out := new(GetStorageClassesResponse)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *s3Service) GetBackendTypeByTier(ctx context.Context, in *GetBackendTypeByTierRequest, opts ...client.CallOption) (*GetBackendTypeByTierResponse, error) <span class="cov0" title="0">{
        req := c.c.NewRequest(c.name, "S3.GetBackendTypeByTier", in)
        out := new(GetBackendTypeByTierResponse)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *s3Service) DeleteBucketLifecycle(ctx context.Context, in *BaseRequest, opts ...client.CallOption) (*BaseResponse, error) <span class="cov0" title="0">{
        req := c.c.NewRequest(c.name, "S3.DeleteBucketLifecycle", in)
        out := new(BaseResponse)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *s3Service) PutBucketLifecycle(ctx context.Context, in *PutBucketLifecycleRequest, opts ...client.CallOption) (*BaseResponse, error) <span class="cov0" title="0">{
        req := c.c.NewRequest(c.name, "S3.PutBucketLifecycle", in)
        out := new(BaseResponse)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *s3Service) GetBucketLifecycle(ctx context.Context, in *BaseRequest, opts ...client.CallOption) (*GetBucketLifecycleResponse, error) <span class="cov0" title="0">{
        req := c.c.NewRequest(c.name, "S3.GetBucketLifecycle", in)
        out := new(GetBucketLifecycleResponse)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *s3Service) ListBucketLifecycle(ctx context.Context, in *BaseRequest, opts ...client.CallOption) (*ListBucketsResponse, error) <span class="cov0" title="0">{
        req := c.c.NewRequest(c.name, "S3.ListBucketLifecycle", in)
        out := new(ListBucketsResponse)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *s3Service) UpdateBucket(ctx context.Context, in *Bucket, opts ...client.CallOption) (*BaseResponse, error) <span class="cov0" title="0">{
        req := c.c.NewRequest(c.name, "S3.UpdateBucket", in)
        out := new(BaseResponse)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *s3Service) ListBucketUploadRecords(ctx context.Context, in *ListBucketUploadRequest, opts ...client.CallOption) (*ListBucketUploadResponse, error) <span class="cov0" title="0">{
        req := c.c.NewRequest(c.name, "S3.ListBucketUploadRecords", in)
        out := new(ListBucketUploadResponse)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *s3Service) InitMultipartUpload(ctx context.Context, in *InitMultiPartRequest, opts ...client.CallOption) (*InitMultiPartResponse, error) <span class="cov0" title="0">{
        req := c.c.NewRequest(c.name, "S3.InitMultipartUpload", in)
        out := new(InitMultiPartResponse)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *s3Service) AbortMultipartUpload(ctx context.Context, in *AbortMultipartRequest, opts ...client.CallOption) (*BaseResponse, error) <span class="cov0" title="0">{
        req := c.c.NewRequest(c.name, "S3.AbortMultipartUpload", in)
        out := new(BaseResponse)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *s3Service) CompleteMultipartUpload(ctx context.Context, in *CompleteMultipartRequest, opts ...client.CallOption) (*CompleteMultipartResponse, error) <span class="cov0" title="0">{
        req := c.c.NewRequest(c.name, "S3.CompleteMultipartUpload", in)
        out := new(CompleteMultipartResponse)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *s3Service) UploadPart(ctx context.Context, opts ...client.CallOption) (S3_UploadPartService, error) <span class="cov0" title="0">{
        req := c.c.NewRequest(c.name, "S3.UploadPart", &amp;PutDataStream{})
        stream, err := c.c.Stream(ctx, req, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;s3ServiceUploadPart{stream}, nil</span>
}

type S3_UploadPartService interface {
        SendMsg(interface{}) error
        RecvMsg(interface{}) error
        Close() error
        Send(*PutDataStream) error
}

type s3ServiceUploadPart struct {
        stream client.Stream
}

func (x *s3ServiceUploadPart) Close() error <span class="cov0" title="0">{
        return x.stream.Close()
}</span>

func (x *s3ServiceUploadPart) SendMsg(m interface{}) error <span class="cov0" title="0">{
        return x.stream.Send(m)
}</span>

func (x *s3ServiceUploadPart) RecvMsg(m interface{}) error <span class="cov0" title="0">{
        return x.stream.Recv(m)
}</span>

func (x *s3ServiceUploadPart) Send(m *PutDataStream) error <span class="cov0" title="0">{
        return x.stream.Send(m)
}</span>

func (c *s3Service) ListObjectParts(ctx context.Context, in *ListObjectPartsRequest, opts ...client.CallOption) (*ListObjectPartsResponse, error) <span class="cov0" title="0">{
        req := c.c.NewRequest(c.name, "S3.ListObjectParts", in)
        out := new(ListObjectPartsResponse)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *s3Service) AppendObject(ctx context.Context, in *BaseRequest, opts ...client.CallOption) (*BaseResponse, error) <span class="cov0" title="0">{
        req := c.c.NewRequest(c.name, "S3.AppendObject", in)
        out := new(BaseResponse)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *s3Service) PostObject(ctx context.Context, in *BaseRequest, opts ...client.CallOption) (*BaseResponse, error) <span class="cov0" title="0">{
        req := c.c.NewRequest(c.name, "S3.PostObject", in)
        out := new(BaseResponse)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *s3Service) AddUploadRecord(ctx context.Context, in *MultipartUploadRecord, opts ...client.CallOption) (*BaseResponse, error) <span class="cov0" title="0">{
        req := c.c.NewRequest(c.name, "S3.AddUploadRecord", in)
        out := new(BaseResponse)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *s3Service) DeleteUploadRecord(ctx context.Context, in *MultipartUploadRecord, opts ...client.CallOption) (*BaseResponse, error) <span class="cov0" title="0">{
        req := c.c.NewRequest(c.name, "S3.DeleteUploadRecord", in)
        out := new(BaseResponse)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *s3Service) HeadObject(ctx context.Context, in *BaseObjRequest, opts ...client.CallOption) (*Object, error) <span class="cov0" title="0">{
        req := c.c.NewRequest(c.name, "S3.HeadObject", in)
        out := new(Object)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *s3Service) MoveObject(ctx context.Context, in *MoveObjectRequest, opts ...client.CallOption) (*MoveObjectResponse, error) <span class="cov0" title="0">{
        req := c.c.NewRequest(c.name, "S3.MoveObject", in)
        out := new(MoveObjectResponse)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *s3Service) CopyObject(ctx context.Context, in *CopyObjectRequest, opts ...client.CallOption) (*CopyObjectResponse, error) <span class="cov0" title="0">{
        req := c.c.NewRequest(c.name, "S3.CopyObject", in)
        out := new(CopyObjectResponse)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *s3Service) CopyObjPart(ctx context.Context, in *CopyObjPartRequest, opts ...client.CallOption) (*CopyObjPartResponse, error) <span class="cov0" title="0">{
        req := c.c.NewRequest(c.name, "S3.CopyObjPart", in)
        out := new(CopyObjPartResponse)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *s3Service) PutObjACL(ctx context.Context, in *PutObjACLRequest, opts ...client.CallOption) (*BaseResponse, error) <span class="cov0" title="0">{
        req := c.c.NewRequest(c.name, "S3.PutObjACL", in)
        out := new(BaseResponse)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *s3Service) GetObjACL(ctx context.Context, in *BaseObjRequest, opts ...client.CallOption) (*ObjACL, error) <span class="cov0" title="0">{
        req := c.c.NewRequest(c.name, "S3.GetObjACL", in)
        out := new(ObjACL)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *s3Service) GetBucketLocation(ctx context.Context, in *BaseRequest, opts ...client.CallOption) (*BaseResponse, error) <span class="cov0" title="0">{
        req := c.c.NewRequest(c.name, "S3.GetBucketLocation", in)
        out := new(BaseResponse)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *s3Service) GetBucketVersioning(ctx context.Context, in *BaseBucketRequest, opts ...client.CallOption) (*BucketVersioning, error) <span class="cov0" title="0">{
        req := c.c.NewRequest(c.name, "S3.GetBucketVersioning", in)
        out := new(BucketVersioning)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *s3Service) PutBucketACL(ctx context.Context, in *PutBucketACLRequest, opts ...client.CallOption) (*BaseResponse, error) <span class="cov0" title="0">{
        req := c.c.NewRequest(c.name, "S3.PutBucketACL", in)
        out := new(BaseResponse)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *s3Service) GetBucketACL(ctx context.Context, in *BaseBucketRequest, opts ...client.CallOption) (*BucketACL, error) <span class="cov0" title="0">{
        req := c.c.NewRequest(c.name, "S3.GetBucketACL", in)
        out := new(BucketACL)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *s3Service) PutBucketCORS(ctx context.Context, in *BaseRequest, opts ...client.CallOption) (*BaseResponse, error) <span class="cov0" title="0">{
        req := c.c.NewRequest(c.name, "S3.PutBucketCORS", in)
        out := new(BaseResponse)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *s3Service) GetBucketCORS(ctx context.Context, in *BaseRequest, opts ...client.CallOption) (*BaseResponse, error) <span class="cov0" title="0">{
        req := c.c.NewRequest(c.name, "S3.GetBucketCORS", in)
        out := new(BaseResponse)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *s3Service) DeleteBucketCORS(ctx context.Context, in *BaseRequest, opts ...client.CallOption) (*BaseResponse, error) <span class="cov0" title="0">{
        req := c.c.NewRequest(c.name, "S3.DeleteBucketCORS", in)
        out := new(BaseResponse)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *s3Service) PutBucketPolicy(ctx context.Context, in *BaseRequest, opts ...client.CallOption) (*BaseResponse, error) <span class="cov0" title="0">{
        req := c.c.NewRequest(c.name, "S3.PutBucketPolicy", in)
        out := new(BaseResponse)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *s3Service) GetBucketPolicy(ctx context.Context, in *BaseRequest, opts ...client.CallOption) (*BaseResponse, error) <span class="cov0" title="0">{
        req := c.c.NewRequest(c.name, "S3.GetBucketPolicy", in)
        out := new(BaseResponse)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *s3Service) DeleteBucketPolicy(ctx context.Context, in *BaseRequest, opts ...client.CallOption) (*BaseResponse, error) <span class="cov0" title="0">{
        req := c.c.NewRequest(c.name, "S3.DeleteBucketPolicy", in)
        out := new(BaseResponse)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *s3Service) HeadBucket(ctx context.Context, in *BaseRequest, opts ...client.CallOption) (*Bucket, error) <span class="cov0" title="0">{
        req := c.c.NewRequest(c.name, "S3.HeadBucket", in)
        out := new(Bucket)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// Server API for S3 service

type S3Handler interface {
        ListBuckets(context.Context, *BaseRequest, *ListBucketsResponse) error
        CreateBucket(context.Context, *Bucket, *BaseResponse) error
        DeleteBucket(context.Context, *Bucket, *BaseResponse) error
        GetBucket(context.Context, *Bucket, *GetBucketResponse) error
        GetObjectMeta(context.Context, *Object, *GetObjectMetaResult) error
        UpdateObjectMeta(context.Context, *Object, *PutObjectResponse) error
        ListObjects(context.Context, *ListObjectsRequest, *ListObjectsResponse) error
        CountObjects(context.Context, *ListObjectsRequest, *CountObjectsResponse) error
        PutObject(context.Context, S3_PutObjectStream) error
        UpdateObject(context.Context, *Object, *BaseResponse) error
        GetObject(context.Context, *GetObjectInput, S3_GetObjectStream) error
        DeleteObject(context.Context, *DeleteObjectInput, *DeleteObjectOutput) error
        GetTierMap(context.Context, *BaseRequest, *GetTierMapResponse) error
        UpdateObjMeta(context.Context, *UpdateObjMetaRequest, *BaseResponse) error
        GetStorageClasses(context.Context, *BaseRequest, *GetStorageClassesResponse) error
        GetBackendTypeByTier(context.Context, *GetBackendTypeByTierRequest, *GetBackendTypeByTierResponse) error
        DeleteBucketLifecycle(context.Context, *BaseRequest, *BaseResponse) error
        PutBucketLifecycle(context.Context, *PutBucketLifecycleRequest, *BaseResponse) error
        GetBucketLifecycle(context.Context, *BaseRequest, *GetBucketLifecycleResponse) error
        ListBucketLifecycle(context.Context, *BaseRequest, *ListBucketsResponse) error
        UpdateBucket(context.Context, *Bucket, *BaseResponse) error
        ListBucketUploadRecords(context.Context, *ListBucketUploadRequest, *ListBucketUploadResponse) error
        InitMultipartUpload(context.Context, *InitMultiPartRequest, *InitMultiPartResponse) error
        AbortMultipartUpload(context.Context, *AbortMultipartRequest, *BaseResponse) error
        CompleteMultipartUpload(context.Context, *CompleteMultipartRequest, *CompleteMultipartResponse) error
        UploadPart(context.Context, S3_UploadPartStream) error
        ListObjectParts(context.Context, *ListObjectPartsRequest, *ListObjectPartsResponse) error
        AppendObject(context.Context, *BaseRequest, *BaseResponse) error
        PostObject(context.Context, *BaseRequest, *BaseResponse) error
        // For lifecycle, may need some change.
        AddUploadRecord(context.Context, *MultipartUploadRecord, *BaseResponse) error
        DeleteUploadRecord(context.Context, *MultipartUploadRecord, *BaseResponse) error
        HeadObject(context.Context, *BaseObjRequest, *Object) error
        MoveObject(context.Context, *MoveObjectRequest, *MoveObjectResponse) error
        CopyObject(context.Context, *CopyObjectRequest, *CopyObjectResponse) error
        CopyObjPart(context.Context, *CopyObjPartRequest, *CopyObjPartResponse) error
        PutObjACL(context.Context, *PutObjACLRequest, *BaseResponse) error
        GetObjACL(context.Context, *BaseObjRequest, *ObjACL) error
        GetBucketLocation(context.Context, *BaseRequest, *BaseResponse) error
        GetBucketVersioning(context.Context, *BaseBucketRequest, *BucketVersioning) error
        PutBucketACL(context.Context, *PutBucketACLRequest, *BaseResponse) error
        GetBucketACL(context.Context, *BaseBucketRequest, *BucketACL) error
        PutBucketCORS(context.Context, *BaseRequest, *BaseResponse) error
        GetBucketCORS(context.Context, *BaseRequest, *BaseResponse) error
        DeleteBucketCORS(context.Context, *BaseRequest, *BaseResponse) error
        PutBucketPolicy(context.Context, *BaseRequest, *BaseResponse) error
        GetBucketPolicy(context.Context, *BaseRequest, *BaseResponse) error
        DeleteBucketPolicy(context.Context, *BaseRequest, *BaseResponse) error
        HeadBucket(context.Context, *BaseRequest, *Bucket) error
}

func RegisterS3Handler(s server.Server, hdlr S3Handler, opts ...server.HandlerOption) error <span class="cov8" title="1">{
        type s3 interface {
                ListBuckets(ctx context.Context, in *BaseRequest, out *ListBucketsResponse) error
                CreateBucket(ctx context.Context, in *Bucket, out *BaseResponse) error
                DeleteBucket(ctx context.Context, in *Bucket, out *BaseResponse) error
                GetBucket(ctx context.Context, in *Bucket, out *GetBucketResponse) error
                GetObjectMeta(ctx context.Context, in *Object, out *GetObjectMetaResult) error
                UpdateObjectMeta(ctx context.Context, in *Object, out *PutObjectResponse) error
                ListObjects(ctx context.Context, in *ListObjectsRequest, out *ListObjectsResponse) error
                CountObjects(ctx context.Context, in *ListObjectsRequest, out *CountObjectsResponse) error
                PutObject(ctx context.Context, stream server.Stream) error
                UpdateObject(ctx context.Context, in *Object, out *BaseResponse) error
                GetObject(ctx context.Context, stream server.Stream) error
                DeleteObject(ctx context.Context, in *DeleteObjectInput, out *DeleteObjectOutput) error
                GetTierMap(ctx context.Context, in *BaseRequest, out *GetTierMapResponse) error
                UpdateObjMeta(ctx context.Context, in *UpdateObjMetaRequest, out *BaseResponse) error
                GetStorageClasses(ctx context.Context, in *BaseRequest, out *GetStorageClassesResponse) error
                GetBackendTypeByTier(ctx context.Context, in *GetBackendTypeByTierRequest, out *GetBackendTypeByTierResponse) error
                DeleteBucketLifecycle(ctx context.Context, in *BaseRequest, out *BaseResponse) error
                PutBucketLifecycle(ctx context.Context, in *PutBucketLifecycleRequest, out *BaseResponse) error
                GetBucketLifecycle(ctx context.Context, in *BaseRequest, out *GetBucketLifecycleResponse) error
                ListBucketLifecycle(ctx context.Context, in *BaseRequest, out *ListBucketsResponse) error
                UpdateBucket(ctx context.Context, in *Bucket, out *BaseResponse) error
                ListBucketUploadRecords(ctx context.Context, in *ListBucketUploadRequest, out *ListBucketUploadResponse) error
                InitMultipartUpload(ctx context.Context, in *InitMultiPartRequest, out *InitMultiPartResponse) error
                AbortMultipartUpload(ctx context.Context, in *AbortMultipartRequest, out *BaseResponse) error
                CompleteMultipartUpload(ctx context.Context, in *CompleteMultipartRequest, out *CompleteMultipartResponse) error
                UploadPart(ctx context.Context, stream server.Stream) error
                ListObjectParts(ctx context.Context, in *ListObjectPartsRequest, out *ListObjectPartsResponse) error
                AppendObject(ctx context.Context, in *BaseRequest, out *BaseResponse) error
                PostObject(ctx context.Context, in *BaseRequest, out *BaseResponse) error
                AddUploadRecord(ctx context.Context, in *MultipartUploadRecord, out *BaseResponse) error
                DeleteUploadRecord(ctx context.Context, in *MultipartUploadRecord, out *BaseResponse) error
                HeadObject(ctx context.Context, in *BaseObjRequest, out *Object) error
                MoveObject(ctx context.Context, in *MoveObjectRequest, out *MoveObjectResponse) error
                CopyObject(ctx context.Context, in *CopyObjectRequest, out *CopyObjectResponse) error
                CopyObjPart(ctx context.Context, in *CopyObjPartRequest, out *CopyObjPartResponse) error
                PutObjACL(ctx context.Context, in *PutObjACLRequest, out *BaseResponse) error
                GetObjACL(ctx context.Context, in *BaseObjRequest, out *ObjACL) error
                GetBucketLocation(ctx context.Context, in *BaseRequest, out *BaseResponse) error
                GetBucketVersioning(ctx context.Context, in *BaseBucketRequest, out *BucketVersioning) error
                PutBucketACL(ctx context.Context, in *PutBucketACLRequest, out *BaseResponse) error
                GetBucketACL(ctx context.Context, in *BaseBucketRequest, out *BucketACL) error
                PutBucketCORS(ctx context.Context, in *BaseRequest, out *BaseResponse) error
                GetBucketCORS(ctx context.Context, in *BaseRequest, out *BaseResponse) error
                DeleteBucketCORS(ctx context.Context, in *BaseRequest, out *BaseResponse) error
                PutBucketPolicy(ctx context.Context, in *BaseRequest, out *BaseResponse) error
                GetBucketPolicy(ctx context.Context, in *BaseRequest, out *BaseResponse) error
                DeleteBucketPolicy(ctx context.Context, in *BaseRequest, out *BaseResponse) error
                HeadBucket(ctx context.Context, in *BaseRequest, out *Bucket) error
        }
        type S3 struct {
                s3
        }
        h := &amp;s3Handler{hdlr}
        return s.Handle(s.NewHandler(&amp;S3{h}, opts...))
}</span>

type s3Handler struct {
        S3Handler
}

func (h *s3Handler) ListBuckets(ctx context.Context, in *BaseRequest, out *ListBucketsResponse) error <span class="cov8" title="1">{
        return h.S3Handler.ListBuckets(ctx, in, out)
}</span>

func (h *s3Handler) CreateBucket(ctx context.Context, in *Bucket, out *BaseResponse) error <span class="cov8" title="1">{
        return h.S3Handler.CreateBucket(ctx, in, out)
}</span>

func (h *s3Handler) DeleteBucket(ctx context.Context, in *Bucket, out *BaseResponse) error <span class="cov0" title="0">{
        return h.S3Handler.DeleteBucket(ctx, in, out)
}</span>

func (h *s3Handler) GetBucket(ctx context.Context, in *Bucket, out *GetBucketResponse) error <span class="cov8" title="1">{
        return h.S3Handler.GetBucket(ctx, in, out)
}</span>

func (h *s3Handler) GetObjectMeta(ctx context.Context, in *Object, out *GetObjectMetaResult) error <span class="cov8" title="1">{
        return h.S3Handler.GetObjectMeta(ctx, in, out)
}</span>

func (h *s3Handler) UpdateObjectMeta(ctx context.Context, in *Object, out *PutObjectResponse) error <span class="cov0" title="0">{
        return h.S3Handler.UpdateObjectMeta(ctx, in, out)
}</span>

func (h *s3Handler) ListObjects(ctx context.Context, in *ListObjectsRequest, out *ListObjectsResponse) error <span class="cov8" title="1">{
        return h.S3Handler.ListObjects(ctx, in, out)
}</span>

func (h *s3Handler) CountObjects(ctx context.Context, in *ListObjectsRequest, out *CountObjectsResponse) error <span class="cov0" title="0">{
        return h.S3Handler.CountObjects(ctx, in, out)
}</span>

func (h *s3Handler) PutObject(ctx context.Context, stream server.Stream) error <span class="cov8" title="1">{
        return h.S3Handler.PutObject(ctx, &amp;s3PutObjectStream{stream})
}</span>

type S3_PutObjectStream interface {
        SendMsg(interface{}) error
        RecvMsg(interface{}) error
        Close() error
        Recv() (*PutDataStream, error)
}

type s3PutObjectStream struct {
        stream server.Stream
}

func (x *s3PutObjectStream) Close() error <span class="cov0" title="0">{
        return x.stream.Close()
}</span>

func (x *s3PutObjectStream) SendMsg(m interface{}) error <span class="cov8" title="1">{
        return x.stream.Send(m)
}</span>

func (x *s3PutObjectStream) RecvMsg(m interface{}) error <span class="cov8" title="1">{
        return x.stream.Recv(m)
}</span>

func (x *s3PutObjectStream) Recv() (*PutDataStream, error) <span class="cov8" title="1">{
        m := new(PutDataStream)
        if err := x.stream.Recv(m); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return m, nil</span>
}

func (h *s3Handler) UpdateObject(ctx context.Context, in *Object, out *BaseResponse) error <span class="cov0" title="0">{
        return h.S3Handler.UpdateObject(ctx, in, out)
}</span>

func (h *s3Handler) GetObject(ctx context.Context, stream server.Stream) error <span class="cov8" title="1">{
        m := new(GetObjectInput)
        if err := stream.Recv(m); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return h.S3Handler.GetObject(ctx, m, &amp;s3GetObjectStream{stream})</span>
}

type S3_GetObjectStream interface {
        SendMsg(interface{}) error
        RecvMsg(interface{}) error
        Close() error
        Send(*GetObjectResponse) error
}

type s3GetObjectStream struct {
        stream server.Stream
}

func (x *s3GetObjectStream) Close() error <span class="cov0" title="0">{
        return x.stream.Close()
}</span>

func (x *s3GetObjectStream) SendMsg(m interface{}) error <span class="cov8" title="1">{
        return x.stream.Send(m)
}</span>

func (x *s3GetObjectStream) RecvMsg(m interface{}) error <span class="cov0" title="0">{
        return x.stream.Recv(m)
}</span>

func (x *s3GetObjectStream) Send(m *GetObjectResponse) error <span class="cov8" title="1">{
        return x.stream.Send(m)
}</span>

func (h *s3Handler) DeleteObject(ctx context.Context, in *DeleteObjectInput, out *DeleteObjectOutput) error <span class="cov0" title="0">{
        return h.S3Handler.DeleteObject(ctx, in, out)
}</span>

func (h *s3Handler) GetTierMap(ctx context.Context, in *BaseRequest, out *GetTierMapResponse) error <span class="cov0" title="0">{
        return h.S3Handler.GetTierMap(ctx, in, out)
}</span>

func (h *s3Handler) UpdateObjMeta(ctx context.Context, in *UpdateObjMetaRequest, out *BaseResponse) error <span class="cov0" title="0">{
        return h.S3Handler.UpdateObjMeta(ctx, in, out)
}</span>

func (h *s3Handler) GetStorageClasses(ctx context.Context, in *BaseRequest, out *GetStorageClassesResponse) error <span class="cov0" title="0">{
        return h.S3Handler.GetStorageClasses(ctx, in, out)
}</span>

func (h *s3Handler) GetBackendTypeByTier(ctx context.Context, in *GetBackendTypeByTierRequest, out *GetBackendTypeByTierResponse) error <span class="cov0" title="0">{
        return h.S3Handler.GetBackendTypeByTier(ctx, in, out)
}</span>

func (h *s3Handler) DeleteBucketLifecycle(ctx context.Context, in *BaseRequest, out *BaseResponse) error <span class="cov0" title="0">{
        return h.S3Handler.DeleteBucketLifecycle(ctx, in, out)
}</span>

func (h *s3Handler) PutBucketLifecycle(ctx context.Context, in *PutBucketLifecycleRequest, out *BaseResponse) error <span class="cov0" title="0">{
        return h.S3Handler.PutBucketLifecycle(ctx, in, out)
}</span>

func (h *s3Handler) GetBucketLifecycle(ctx context.Context, in *BaseRequest, out *GetBucketLifecycleResponse) error <span class="cov8" title="1">{
        return h.S3Handler.GetBucketLifecycle(ctx, in, out)
}</span>

func (h *s3Handler) ListBucketLifecycle(ctx context.Context, in *BaseRequest, out *ListBucketsResponse) error <span class="cov0" title="0">{
        return h.S3Handler.ListBucketLifecycle(ctx, in, out)
}</span>

func (h *s3Handler) UpdateBucket(ctx context.Context, in *Bucket, out *BaseResponse) error <span class="cov8" title="1">{
        return h.S3Handler.UpdateBucket(ctx, in, out)
}</span>

func (h *s3Handler) ListBucketUploadRecords(ctx context.Context, in *ListBucketUploadRequest, out *ListBucketUploadResponse) error <span class="cov0" title="0">{
        return h.S3Handler.ListBucketUploadRecords(ctx, in, out)
}</span>

func (h *s3Handler) InitMultipartUpload(ctx context.Context, in *InitMultiPartRequest, out *InitMultiPartResponse) error <span class="cov0" title="0">{
        return h.S3Handler.InitMultipartUpload(ctx, in, out)
}</span>

func (h *s3Handler) AbortMultipartUpload(ctx context.Context, in *AbortMultipartRequest, out *BaseResponse) error <span class="cov0" title="0">{
        return h.S3Handler.AbortMultipartUpload(ctx, in, out)
}</span>

func (h *s3Handler) CompleteMultipartUpload(ctx context.Context, in *CompleteMultipartRequest, out *CompleteMultipartResponse) error <span class="cov0" title="0">{
        return h.S3Handler.CompleteMultipartUpload(ctx, in, out)
}</span>

func (h *s3Handler) UploadPart(ctx context.Context, stream server.Stream) error <span class="cov0" title="0">{
        return h.S3Handler.UploadPart(ctx, &amp;s3UploadPartStream{stream})
}</span>

type S3_UploadPartStream interface {
        SendMsg(interface{}) error
        RecvMsg(interface{}) error
        Close() error
        Recv() (*PutDataStream, error)
}

type s3UploadPartStream struct {
        stream server.Stream
}

func (x *s3UploadPartStream) Close() error <span class="cov0" title="0">{
        return x.stream.Close()
}</span>

func (x *s3UploadPartStream) SendMsg(m interface{}) error <span class="cov0" title="0">{
        return x.stream.Send(m)
}</span>

func (x *s3UploadPartStream) RecvMsg(m interface{}) error <span class="cov0" title="0">{
        return x.stream.Recv(m)
}</span>

func (x *s3UploadPartStream) Recv() (*PutDataStream, error) <span class="cov0" title="0">{
        m := new(PutDataStream)
        if err := x.stream.Recv(m); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return m, nil</span>
}

func (h *s3Handler) ListObjectParts(ctx context.Context, in *ListObjectPartsRequest, out *ListObjectPartsResponse) error <span class="cov0" title="0">{
        return h.S3Handler.ListObjectParts(ctx, in, out)
}</span>

func (h *s3Handler) AppendObject(ctx context.Context, in *BaseRequest, out *BaseResponse) error <span class="cov0" title="0">{
        return h.S3Handler.AppendObject(ctx, in, out)
}</span>

func (h *s3Handler) PostObject(ctx context.Context, in *BaseRequest, out *BaseResponse) error <span class="cov0" title="0">{
        return h.S3Handler.PostObject(ctx, in, out)
}</span>

func (h *s3Handler) AddUploadRecord(ctx context.Context, in *MultipartUploadRecord, out *BaseResponse) error <span class="cov0" title="0">{
        return h.S3Handler.AddUploadRecord(ctx, in, out)
}</span>

func (h *s3Handler) DeleteUploadRecord(ctx context.Context, in *MultipartUploadRecord, out *BaseResponse) error <span class="cov0" title="0">{
        return h.S3Handler.DeleteUploadRecord(ctx, in, out)
}</span>

func (h *s3Handler) HeadObject(ctx context.Context, in *BaseObjRequest, out *Object) error <span class="cov0" title="0">{
        return h.S3Handler.HeadObject(ctx, in, out)
}</span>

func (h *s3Handler) MoveObject(ctx context.Context, in *MoveObjectRequest, out *MoveObjectResponse) error <span class="cov0" title="0">{
        return h.S3Handler.MoveObject(ctx, in, out)
}</span>

func (h *s3Handler) CopyObject(ctx context.Context, in *CopyObjectRequest, out *CopyObjectResponse) error <span class="cov0" title="0">{
        return h.S3Handler.CopyObject(ctx, in, out)
}</span>

func (h *s3Handler) CopyObjPart(ctx context.Context, in *CopyObjPartRequest, out *CopyObjPartResponse) error <span class="cov0" title="0">{
        return h.S3Handler.CopyObjPart(ctx, in, out)
}</span>

func (h *s3Handler) PutObjACL(ctx context.Context, in *PutObjACLRequest, out *BaseResponse) error <span class="cov0" title="0">{
        return h.S3Handler.PutObjACL(ctx, in, out)
}</span>

func (h *s3Handler) GetObjACL(ctx context.Context, in *BaseObjRequest, out *ObjACL) error <span class="cov0" title="0">{
        return h.S3Handler.GetObjACL(ctx, in, out)
}</span>

func (h *s3Handler) GetBucketLocation(ctx context.Context, in *BaseRequest, out *BaseResponse) error <span class="cov0" title="0">{
        return h.S3Handler.GetBucketLocation(ctx, in, out)
}</span>

func (h *s3Handler) GetBucketVersioning(ctx context.Context, in *BaseBucketRequest, out *BucketVersioning) error <span class="cov0" title="0">{
        return h.S3Handler.GetBucketVersioning(ctx, in, out)
}</span>

func (h *s3Handler) PutBucketACL(ctx context.Context, in *PutBucketACLRequest, out *BaseResponse) error <span class="cov0" title="0">{
        return h.S3Handler.PutBucketACL(ctx, in, out)
}</span>

func (h *s3Handler) GetBucketACL(ctx context.Context, in *BaseBucketRequest, out *BucketACL) error <span class="cov0" title="0">{
        return h.S3Handler.GetBucketACL(ctx, in, out)
}</span>

func (h *s3Handler) PutBucketCORS(ctx context.Context, in *BaseRequest, out *BaseResponse) error <span class="cov0" title="0">{
        return h.S3Handler.PutBucketCORS(ctx, in, out)
}</span>

func (h *s3Handler) GetBucketCORS(ctx context.Context, in *BaseRequest, out *BaseResponse) error <span class="cov0" title="0">{
        return h.S3Handler.GetBucketCORS(ctx, in, out)
}</span>

func (h *s3Handler) DeleteBucketCORS(ctx context.Context, in *BaseRequest, out *BaseResponse) error <span class="cov0" title="0">{
        return h.S3Handler.DeleteBucketCORS(ctx, in, out)
}</span>

func (h *s3Handler) PutBucketPolicy(ctx context.Context, in *BaseRequest, out *BaseResponse) error <span class="cov0" title="0">{
        return h.S3Handler.PutBucketPolicy(ctx, in, out)
}</span>

func (h *s3Handler) GetBucketPolicy(ctx context.Context, in *BaseRequest, out *BaseResponse) error <span class="cov0" title="0">{
        return h.S3Handler.GetBucketPolicy(ctx, in, out)
}</span>

func (h *s3Handler) DeleteBucketPolicy(ctx context.Context, in *BaseRequest, out *BaseResponse) error <span class="cov0" title="0">{
        return h.S3Handler.DeleteBucketPolicy(ctx, in, out)
}</span>

func (h *s3Handler) HeadBucket(ctx context.Context, in *BaseRequest, out *Bucket) error <span class="cov0" title="0">{
        return h.S3Handler.HeadBucket(ctx, in, out)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
