
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">

				<option value="file0">github.com/soda/multi-cloud/api/pkg/common/common.go (0.0%)</option>

				<option value="file1">github.com/soda/multi-cloud/api/pkg/context/context.go (0.0%)</option>

				<option value="file2">github.com/soda/multi-cloud/api/pkg/utils/obs/auth.go (0.0%)</option>

				<option value="file3">github.com/soda/multi-cloud/api/pkg/utils/obs/client.go (0.0%)</option>

				<option value="file4">github.com/soda/multi-cloud/api/pkg/utils/obs/conf.go (0.0%)</option>

				<option value="file5">github.com/soda/multi-cloud/api/pkg/utils/obs/convert.go (0.0%)</option>

				<option value="file6">github.com/soda/multi-cloud/api/pkg/utils/obs/error.go (0.0%)</option>

				<option value="file7">github.com/soda/multi-cloud/api/pkg/utils/obs/http.go (0.0%)</option>

				<option value="file8">github.com/soda/multi-cloud/api/pkg/utils/obs/log.go (87.1%)</option>

				<option value="file9">github.com/soda/multi-cloud/api/pkg/utils/obs/temporary.go (0.0%)</option>

				<option value="file10">github.com/soda/multi-cloud/api/pkg/utils/obs/trait.go (0.0%)</option>

				<option value="file11">github.com/soda/multi-cloud/api/pkg/utils/obs/util.go (0.0%)</option>

				<option value="file12">github.com/soda/multi-cloud/backend/cmd/main.go (88.9%)</option>

				<option value="file13">github.com/soda/multi-cloud/backend/pkg/db/db.go (57.1%)</option>

				<option value="file14">github.com/soda/multi-cloud/backend/pkg/db/drivers/mongo/mongo.go (41.0%)</option>

				<option value="file15">github.com/soda/multi-cloud/backend/pkg/service/service.go (35.6%)</option>

				<option value="file16">github.com/soda/multi-cloud/backend/proto/backend.micro.go (11.8%)</option>

				<option value="file17">github.com/soda/multi-cloud/backend/proto/backend.pb.go (11.7%)</option>

				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>

				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>

			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package common

import (
        "context"
        "fmt"
        "strconv"
        "strings"

        "github.com/emicklei/go-restful"
        "github.com/micro/go-micro/metadata"
        c "github.com/soda/multi-cloud/api/pkg/context"
        log "github.com/sirupsen/logrus"
)

const (
        MaxPaginationLimit      = 1000
        DefaultPaginationLimit  = MaxPaginationLimit
        DefaultPaginationOffset = 0
        MaxObjectSize           = 5 * 1024 * 1024 * 1024 // 5GB
        SortDirectionAsc        = "asc"
        SortDirectionDesc       = "desc"
)

const (
        KLimit        = "limit"
        KOffset       = "offset"
        KSort         = "sort"
        KLastModified = "lastmodified"
        KObjKey       = "objkey"
        KStorageTier  = "tier"
        KPrefix       = "prefix"
        KMarker       = "marker"
        KDelimiter    = "delimiter"
        KVerMarker    = "verMarker"
)

const (
        CTX_KEY_TENANT_ID   = "Tenantid"
        CTX_KEY_USER_ID     = "Userid"
        CTX_KEY_IS_ADMIN    = "Isadmin"
        CTX_VAL_TRUE        = "true"
        CTX_KEY_OBJECT_KEY  = "ObjectKey"
        CTX_KEY_BUCKET_NAME = "BucketName"
        CTX_KEY_SIZE        = "ObjectSize"
        CTX_KEY_LOCATION    = "Location"
)

const (
        REQUEST_PATH_BUCKET_NAME         = "bucketName"
        REQUEST_PATH_OBJECT_KEY          = "objectKey"
        REQUEST_HEADER_CONTENT_LENGTH    = "Content-Length"
        REQUEST_HEADER_STORAGE_CLASS     = "x-amz-storage-class"
        REQUEST_HEADER_COPY_SOURCE       = "X-Amz-Copy-Source"
        REQUEST_HEADER_COPY_SOURCE_RANGE = "X-Amz-Copy-Source-Range"
        REQUEST_HEADER_ACL               = "X-Amz-Acl"
        REQUEST_HEADER_CONTENT_MD5       = "Content-Md5"
        REQUEST_HEADER_CONTENT_TYPE      = "Content-Type"
)

const (
        REQUEST_FORM_KEY    = "Key"
        REQUEST_FORM_BUCKET = "Bucket"
)

func GetPaginationParam(request *restful.Request) (int32, int32, error) <span class="cov0" title="0">{
        limit := int32(DefaultPaginationLimit)
        offset := int32(DefaultPaginationOffset)

        if request.QueryParameter(KLimit) != "" </span><span class="cov0" title="0">{
                limitVal, err := strconv.Atoi(request.QueryParameter("limit"))
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("limit is invalid: %v", err)
                        return limit, offset, err
                }</span>
                <span class="cov0" title="0">if limit &gt; int32(limitVal) </span><span class="cov0" title="0">{
                        limit = int32(limitVal)
                }</span>
        }

        <span class="cov0" title="0">if request.QueryParameter(KOffset) != "" </span><span class="cov0" title="0">{
                offsetVal, err := strconv.Atoi(request.QueryParameter("offset"))
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("offset is invalid: %v", err)
                        return limit, offset, err
                }</span>
                <span class="cov0" title="0">offset = int32(offsetVal)</span>
        }
        <span class="cov0" title="0">return limit, offset, nil</span>
}

// An example of sort key parameter will be like this: sort=key1:asc,key2:desc
func GetSortParam(request *restful.Request) (sortKeys []string, sortDirs []string, err error) <span class="cov0" title="0">{
        sortStr := request.QueryParameter(KSort)
        if sortStr != "" </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">sortStr = strings.TrimSpace(sortStr)
        for _, sort := range strings.Split(sortStr, ",") </span><span class="cov0" title="0">{
                parts := strings.Split(sort, ":")
                switch </span>{
                case len(parts) &gt; 2:<span class="cov0" title="0">
                        err = fmt.Errorf("invalid sort value %s", sort)
                        return</span>
                case len(parts) == 1:<span class="cov0" title="0">
                        parts = append(parts, SortDirectionAsc)</span>
                }
                <span class="cov0" title="0">sortKeys = append(sortKeys, parts[0])
                sortDirs = append(sortDirs, parts[1])</span>
        }
        <span class="cov0" title="0">return</span>
}

func GetFilter(request *restful.Request, filterOpts []string) (map[string]string, error) <span class="cov0" title="0">{

        filter := make(map[string]string)
        for _, opt := range filterOpts </span><span class="cov0" title="0">{
                v := request.QueryParameter(opt)
                if v == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">filter[opt] = v</span>
        }
        <span class="cov0" title="0">return filter, nil</span>
}

func InitCtxWithAuthInfo(request *restful.Request) context.Context <span class="cov0" title="0">{
        actx := request.Attribute(c.KContext).(*c.Context)
        ctx := metadata.NewContext(context.Background(), map[string]string{
                CTX_KEY_USER_ID:   actx.UserId,
                CTX_KEY_TENANT_ID: actx.TenantId,
                CTX_KEY_IS_ADMIN:  strconv.FormatBool(actx.IsAdmin),
        })

        return ctx
}</span>

func InitCtxWithVal(request *restful.Request, md map[string]string) context.Context <span class="cov0" title="0">{
        actx := request.Attribute(c.KContext).(*c.Context)
        md[CTX_KEY_USER_ID] = actx.UserId
        md[CTX_KEY_TENANT_ID] = actx.TenantId
        md[CTX_KEY_IS_ADMIN] = strconv.FormatBool(actx.IsAdmin)

        return metadata.NewContext(context.Background(), md)
}</span>
</pre>

		<pre class="file" id="file1" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may
// not use this file except in compliance with the License. You may obtain
// a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations
// under the License.

// This is self defined context which is stored in context.Input.data.
// It is used to transport data in the pipe line.

package context

import (
        "encoding/json"
        "reflect"

        "github.com/emicklei/go-restful"
        log "github.com/sirupsen/logrus"
)

const (
        KContext = "context"
)

const (
        DefaultTenantId     = "tenantId"
        DefaultUserId       = "userId"
        NoAuthAdminTenantId = "adminTenantId"
)

func NewAdminContext() *Context <span class="cov0" title="0">{
        return &amp;Context{
                TenantId: NoAuthAdminTenantId,
                IsAdmin:  true,
                UserId:   "unknown",
        }
}</span>

func NewContext() *Context <span class="cov0" title="0">{
        return &amp;Context{
                TenantId: DefaultTenantId,
                IsAdmin:  false,
                UserId:   DefaultUserId,
        }
}</span>

func NewContextFromJson(s string) *Context <span class="cov0" title="0">{
        ctx := &amp;Context{}
        err := json.Unmarshal([]byte(s), ctx)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("Unmarshal json to context failed, reason: %v", err)
        }</span>
        <span class="cov0" title="0">return ctx</span>
}

func NewInternalTenantContext(tenantId, userId string, isAdmin bool) *Context <span class="cov0" title="0">{
        return &amp;Context{
                TenantId: tenantId,
                UserId:   userId,
                IsAdmin:  isAdmin,
        }
}</span>

func GetContext(req *restful.Request) *Context <span class="cov0" title="0">{
        ctx, _ := req.Attribute("context").(*Context)
        if ctx == nil </span><span class="cov0" title="0">{
                ctx = &amp;Context{}
        }</span>
        <span class="cov0" title="0">return ctx</span>
}

type Context struct {
        IsAdmin           bool     `policy:"true" json:"is_admin"`
        AuthToken         string   `policy:"true" json:"auth_token"`
        UserId            string   `policy:"true" json:"user_id"`
        TenantId          string   `policy:"true" json:"tenant_id"`
        DomainId          string   `policy:"true" json:"domain_id"`
        UserDomainId      string   `policy:"true" json:"user_domain_id"`
        ProjectDomainId   string   `policy:"true" json:"project_domain_id"`
        Roles             []string `policy:"true" json:"roles"`
        UserName          string   `policy:"true" json:"user_name"`
        ProjectName       string   `policy:"true" json:"project_name"`
        DomainName        string   `policy:"true" json:"domain_name"`
        UserDomainName    string   `policy:"true" json:"user_domain_name"`
        ProjectDomainName string   `policy:"true" json:"project_domain_name"`
        IsAdminTenant     bool     `policy:"true" json:"is_admin_tenant"`
}

func (ctx *Context) ToPolicyValue() map[string]interface{} <span class="cov0" title="0">{
        ctxMap := map[string]interface{}{}
        t := reflect.TypeOf(ctx).Elem()
        v := reflect.ValueOf(ctx).Elem()

        for i := 0; i &lt; t.NumField(); i++ </span><span class="cov0" title="0">{
                field := v.Field(i)
                name := t.Field(i).Tag.Get("json")
                if t.Field(i).Tag.Get("policy") == "false" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if field.Kind() == reflect.String &amp;&amp; field.String() == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if field.Kind() == reflect.Slice &amp;&amp; field.Len() == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if field.Kind() == reflect.Map &amp;&amp; field.Len() == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">ctxMap[name] = field.Interface()</span>
        }
        <span class="cov0" title="0">return ctxMap</span>
}

func (ctx *Context) ToJson() string <span class="cov0" title="0">{
        b, err := json.Marshal(ctx)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("Context convert to json failed, reason: %v", err)
        }</span>
        <span class="cov0" title="0">return string(b)</span>
}
</pre>

		<pre class="file" id="file2" style="display: none">package obs

import (
        "fmt"
        "net/url"
        "sort"
        "strings"
        "time"

        log "github.com/sirupsen/logrus"
)

func (obsClient ObsClient) doAuthTemporary(method, bucketName, objectKey string, params map[string]string,
        headers map[string][]string, expires int64) (requestUrl string, err error) <span class="cov0" title="0">{

        requestUrl, canonicalizedUrl := obsClient.conf.formatUrls(bucketName, objectKey, params, true)
        parsedRequestUrl, err := url.Parse(requestUrl)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">encodeHeaders(headers)
        hostName := parsedRequestUrl.Host

        isV4 := obsClient.conf.signature == SignatureV4
        prepareHostAndDate(headers, hostName, isV4)

        if obsClient.conf.securityProvider == nil || obsClient.conf.securityProvider.ak == "" || obsClient.conf.securityProvider.sk == "" </span><span class="cov0" title="0">{
                log.Warn("No ak/sk provided, skip to construct authorization")
        }</span> else<span class="cov0" title="0"> {
                if obsClient.conf.securityProvider.securityToken != "" </span><span class="cov0" title="0">{
                        params[HEADER_STS_TOKEN_AMZ] = obsClient.conf.securityProvider.securityToken
                }</span>

                <span class="cov0" title="0">if isV4 </span><span class="cov0" title="0">{
                        date, _ := time.Parse(RFC1123_FORMAT, headers[HEADER_DATE_CAMEL][0])
                        delete(headers, HEADER_DATE_CAMEL)
                        shortDate := date.Format(SHORT_DATE_FORMAT)
                        longDate := date.Format(LONG_DATE_FORMAT)

                        signedHeaders, _headers := getSignedHeaders(headers)

                        credential, scope := getCredential(obsClient.conf.securityProvider.ak, obsClient.conf.region, shortDate)
                        params[PARAM_ALGORITHM_AMZ_CAMEL] = V4_HASH_PREFIX
                        params[PARAM_CREDENTIAL_AMZ_CAMEL] = credential
                        params[PARAM_DATE_AMZ_CAMEL] = longDate
                        params[PARAM_EXPIRES_AMZ_CAMEL] = Int64ToString(expires)
                        params[PARAM_SIGNEDHEADERS_AMZ_CAMEL] = strings.Join(signedHeaders, ";")

                        requestUrl, canonicalizedUrl = obsClient.conf.formatUrls(bucketName, objectKey, params, true)
                        parsedRequestUrl, _ = url.Parse(requestUrl)
                        stringToSign := getV4StringToSign(method, canonicalizedUrl, parsedRequestUrl.RawQuery, scope, longDate, UNSIGNED_PAYLOAD, signedHeaders, _headers)
                        signature := getSignature(stringToSign, obsClient.conf.securityProvider.sk, obsClient.conf.region, shortDate)

                        requestUrl += fmt.Sprintf("&amp;%s=%s", PARAM_SIGNATURE_AMZ_CAMEL, UrlEncode(signature, false))

                }</span> else<span class="cov0" title="0"> {
                        originDate := headers[HEADER_DATE_CAMEL][0]
                        date, _ := time.Parse(RFC1123_FORMAT, originDate)
                        expires += date.Unix()
                        headers[HEADER_DATE_CAMEL] = []string{Int64ToString(expires)}

                        stringToSign := getV2StringToSign(method, canonicalizedUrl, headers)
                        signature := UrlEncode(Base64Encode(HmacSha1([]byte(obsClient.conf.securityProvider.sk), []byte(stringToSign))), false)
                        if strings.Index(requestUrl, "?") &lt; 0 </span><span class="cov0" title="0">{
                                requestUrl += "?"
                        }</span> else<span class="cov0" title="0"> {
                                requestUrl += "&amp;"
                        }</span>
                        <span class="cov0" title="0">delete(headers, HEADER_DATE_CAMEL)
                        requestUrl += fmt.Sprintf("AWSAccessKeyId=%s&amp;Expires=%d&amp;Signature=%s", UrlEncode(obsClient.conf.securityProvider.ak, false),
                                expires, signature)</span>
                }
        }

        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) doAuth(method, bucketName, objectKey string, params map[string]string,
        headers map[string][]string, hostName string) (requestUrl string, err error) <span class="cov0" title="0">{

        requestUrl, canonicalizedUrl := obsClient.conf.formatUrls(bucketName, objectKey, params, true)
        parsedRequestUrl, err := url.Parse(requestUrl)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">encodeHeaders(headers)

        if hostName == "" </span><span class="cov0" title="0">{
                hostName = parsedRequestUrl.Host
        }</span>

        <span class="cov0" title="0">isV4 := obsClient.conf.signature == SignatureV4
        prepareHostAndDate(headers, hostName, isV4)

        if obsClient.conf.securityProvider == nil || obsClient.conf.securityProvider.ak == "" || obsClient.conf.securityProvider.sk == "" </span><span class="cov0" title="0">{
                log.Warn("No ak/sk provided, skip to construct authorization")
        }</span> else<span class="cov0" title="0"> {
                if obsClient.conf.securityProvider.securityToken != "" </span><span class="cov0" title="0">{
                        headers[HEADER_STS_TOKEN_AMZ] = []string{obsClient.conf.securityProvider.securityToken}
                }</span>
                <span class="cov0" title="0">ak := obsClient.conf.securityProvider.ak
                sk := obsClient.conf.securityProvider.sk
                var authorization string
                if isV4 </span><span class="cov0" title="0">{
                        headers[HEADER_CONTENT_SHA256_AMZ] = []string{EMPTY_CONTENT_SHA256}
                        ret := v4Auth(ak, sk, obsClient.conf.region, method, canonicalizedUrl, parsedRequestUrl.RawQuery, headers)
                        authorization = fmt.Sprintf("%s Credential=%s,SignedHeaders=%s,Signature=%s", V4_HASH_PREFIX, ret["Credential"], ret["SignedHeaders"], ret["Signature"])
                }</span> else<span class="cov0" title="0"> {
                        ret := v2Auth(ak, sk, method, canonicalizedUrl, headers)
                        authorization = fmt.Sprintf("%s %s:%s", V2_HASH_PREFIX, ak, ret["Signature"])
                }</span>
                <span class="cov0" title="0">headers[HEADER_AUTH_CAMEL] = []string{authorization}</span>
        }

        <span class="cov0" title="0">return</span>
}

func prepareHostAndDate(headers map[string][]string, hostName string, isV4 bool) <span class="cov0" title="0">{
        headers[HEADER_HOST_CAMEL] = []string{hostName}
        if date, ok := headers[HEADER_DATE_AMZ]; ok </span><span class="cov0" title="0">{
                flag := false
                if len(date) == 1 </span><span class="cov0" title="0">{
                        if isV4 </span><span class="cov0" title="0">{
                                if t, err := time.Parse(LONG_DATE_FORMAT, date[0]); err == nil </span><span class="cov0" title="0">{
                                        headers[HEADER_DATE_CAMEL] = []string{FormatUtcToRfc1123(t)}
                                        flag = true
                                }</span>
                        } else<span class="cov0" title="0"> {
                                if strings.HasSuffix(date[0], "GMT") </span><span class="cov0" title="0">{
                                        headers[HEADER_DATE_CAMEL] = []string{date[0]}
                                        flag = true
                                }</span>
                        }
                }
                <span class="cov0" title="0">if !flag </span><span class="cov0" title="0">{
                        delete(headers, HEADER_DATE_AMZ)
                }</span>
        }
        <span class="cov0" title="0">if _, ok := headers[HEADER_DATE_CAMEL]; !ok </span><span class="cov0" title="0">{
                headers[HEADER_DATE_CAMEL] = []string{FormatUtcToRfc1123(time.Now().UTC())}
        }</span>
}

func encodeHeaders(headers map[string][]string) <span class="cov0" title="0">{
        for key, values := range headers </span><span class="cov0" title="0">{
                for index, value := range values </span><span class="cov0" title="0">{
                        values[index] = UrlEncode(value, true)
                }</span>
                <span class="cov0" title="0">headers[key] = values</span>
        }
}

func attachHeaders(headers map[string][]string) string <span class="cov0" title="0">{
        length := len(headers)
        _headers := make(map[string][]string, length)
        keys := make([]string, 0, length)

        for key, value := range headers </span><span class="cov0" title="0">{
                _key := strings.ToLower(strings.TrimSpace(key))
                if _key != "" </span><span class="cov0" title="0">{
                        if _key == "content-md5" || _key == "content-type" || _key == "date" || strings.HasPrefix(_key, HEADER_PREFIX) </span><span class="cov0" title="0">{
                                keys = append(keys, _key)
                                _headers[_key] = value
                        }</span>
                } else<span class="cov0" title="0"> {
                        delete(headers, key)
                }</span>
        }

        <span class="cov0" title="0">for _, interestedHeader := range interested_headers </span><span class="cov0" title="0">{
                if _, ok := _headers[interestedHeader]; !ok </span><span class="cov0" title="0">{
                        _headers[interestedHeader] = []string{""}
                        keys = append(keys, interestedHeader)
                }</span>
        }

        <span class="cov0" title="0">if _, ok := _headers[HEADER_DATE_CAMEL]; ok </span><span class="cov0" title="0">{
                if _, ok := _headers[HEADER_DATE_AMZ]; ok </span><span class="cov0" title="0">{
                        _headers[HEADER_DATE_CAMEL] = []string{""}
                }</span> else<span class="cov0" title="0"> if _, ok := headers[PARAM_DATE_AMZ_CAMEL]; ok </span><span class="cov0" title="0">{
                        _headers[HEADER_DATE_CAMEL] = []string{""}
                }</span>
        } else<span class="cov0" title="0"> if _, ok := _headers[strings.ToLower(HEADER_DATE_CAMEL)]; ok </span><span class="cov0" title="0">{
                if _, ok := _headers[HEADER_DATE_AMZ]; ok </span><span class="cov0" title="0">{
                        _headers[HEADER_DATE_CAMEL] = []string{""}
                }</span> else<span class="cov0" title="0"> if _, ok := headers[PARAM_DATE_AMZ_CAMEL]; ok </span><span class="cov0" title="0">{
                        _headers[HEADER_DATE_CAMEL] = []string{""}
                }</span>
        }

        <span class="cov0" title="0">sort.Strings(keys)

        stringToSign := make([]string, 0, len(keys))
        for _, key := range keys </span><span class="cov0" title="0">{
                var value string
                if strings.HasPrefix(key, HEADER_PREFIX) </span><span class="cov0" title="0">{
                        if strings.HasPrefix(key, HEADER_PREFIX_META) </span><span class="cov0" title="0">{
                                for index, v := range _headers[key] </span><span class="cov0" title="0">{
                                        value += strings.TrimSpace(v)
                                        if index != len(_headers[key])-1 </span><span class="cov0" title="0">{
                                                value += ","
                                        }</span>
                                }
                        } else<span class="cov0" title="0"> {
                                value = strings.Join(_headers[key], ",")
                        }</span>
                        <span class="cov0" title="0">value = fmt.Sprintf("%s:%s", key, value)</span>
                } else<span class="cov0" title="0"> {
                        value = strings.Join(_headers[key], ",")
                }</span>
                <span class="cov0" title="0">stringToSign = append(stringToSign, value)</span>
        }
        <span class="cov0" title="0">return strings.Join(stringToSign, "\n")</span>
}

func getV2StringToSign(method, canonicalizedUrl string, headers map[string][]string) string <span class="cov0" title="0">{
        stringToSign := strings.Join([]string{method, "\n", attachHeaders(headers), "\n", canonicalizedUrl}, "")
        log.Debug("The v2 auth stringToSign:\n%s", stringToSign)
        return stringToSign
}</span>

func v2Auth(ak, sk, method, canonicalizedUrl string, headers map[string][]string) map[string]string <span class="cov0" title="0">{
        stringToSign := getV2StringToSign(method, canonicalizedUrl, headers)
        return map[string]string{"Signature": Base64Encode(HmacSha1([]byte(sk), []byte(stringToSign)))}
}</span>

func getScope(region, shortDate string) string <span class="cov0" title="0">{
        return fmt.Sprintf("%s/%s/%s/%s", shortDate, region, V4_SERVICE_NAME, V4_SERVICE_SUFFIX)
}</span>

func getCredential(ak, region, shortDate string) (string, string) <span class="cov0" title="0">{
        scope := getScope(region, shortDate)
        return fmt.Sprintf("%s/%s", ak, scope), scope
}</span>

func getV4StringToSign(method, canonicalizedUrl, queryUrl, scope, longDate, payload string, signedHeaders []string, headers map[string][]string) string <span class="cov0" title="0">{
        canonicalRequest := make([]string, 0, 10+len(signedHeaders)*4)
        canonicalRequest = append(canonicalRequest, method)
        canonicalRequest = append(canonicalRequest, "\n")
        canonicalRequest = append(canonicalRequest, canonicalizedUrl)
        canonicalRequest = append(canonicalRequest, "\n")
        canonicalRequest = append(canonicalRequest, queryUrl)
        canonicalRequest = append(canonicalRequest, "\n")

        for _, signedHeader := range signedHeaders </span><span class="cov0" title="0">{
                values, _ := headers[signedHeader]
                for _, value := range values </span><span class="cov0" title="0">{
                        canonicalRequest = append(canonicalRequest, signedHeader)
                        canonicalRequest = append(canonicalRequest, ":")
                        canonicalRequest = append(canonicalRequest, value)
                        canonicalRequest = append(canonicalRequest, "\n")
                }</span>
        }
        <span class="cov0" title="0">canonicalRequest = append(canonicalRequest, "\n")
        canonicalRequest = append(canonicalRequest, strings.Join(signedHeaders, ";"))
        canonicalRequest = append(canonicalRequest, "\n")
        canonicalRequest = append(canonicalRequest, payload)

        _canonicalRequest := strings.Join(canonicalRequest, "")
        log.Debug("The v4 auth canonicalRequest:\n%s", _canonicalRequest)

        stringToSign := make([]string, 0, 7)
        stringToSign = append(stringToSign, V4_HASH_PREFIX)
        stringToSign = append(stringToSign, "\n")
        stringToSign = append(stringToSign, longDate)
        stringToSign = append(stringToSign, "\n")
        stringToSign = append(stringToSign, scope)
        stringToSign = append(stringToSign, "\n")
        stringToSign = append(stringToSign, HexSha256([]byte(_canonicalRequest)))

        _stringToSign := strings.Join(stringToSign, "")

        log.Debug("The v4 auth stringToSign:\n%s", _stringToSign)
        return _stringToSign</span>
}

func getSignedHeaders(headers map[string][]string) ([]string, map[string][]string) <span class="cov0" title="0">{
        length := len(headers)
        _headers := make(map[string][]string, length)
        signedHeaders := make([]string, 0, length)
        for key, value := range headers </span><span class="cov0" title="0">{
                _key := strings.ToLower(strings.TrimSpace(key))
                if _key != "" </span><span class="cov0" title="0">{
                        signedHeaders = append(signedHeaders, _key)
                        _headers[_key] = value
                }</span> else<span class="cov0" title="0"> {
                        delete(headers, key)
                }</span>
        }
        <span class="cov0" title="0">sort.Strings(signedHeaders)
        return signedHeaders, _headers</span>
}

func getSignature(stringToSign, sk, region, shortDate string) string <span class="cov0" title="0">{
        key := HmacSha256([]byte(V4_HASH_PRE+sk), []byte(shortDate))
        key = HmacSha256(key, []byte(region))
        key = HmacSha256(key, []byte(V4_SERVICE_NAME))
        key = HmacSha256(key, []byte(V4_SERVICE_SUFFIX))
        return Hex(HmacSha256(key, []byte(stringToSign)))
}</span>

func V4Auth(ak, sk, region, method, canonicalizedUrl, queryUrl string, headers map[string][]string) map[string]string <span class="cov0" title="0">{
        return v4Auth(ak, sk, region, method, canonicalizedUrl, queryUrl, headers)
}</span>

func v4Auth(ak, sk, region, method, canonicalizedUrl, queryUrl string, headers map[string][]string) map[string]string <span class="cov0" title="0">{
        var t time.Time

        if val, ok := headers[HEADER_DATE_AMZ]; ok </span><span class="cov0" title="0">{
                var err error
                t, err = time.Parse(LONG_DATE_FORMAT, val[0])
                if err != nil </span><span class="cov0" title="0">{
                        t = time.Now().UTC()
                }</span>
        } else<span class="cov0" title="0"> if val, ok := headers[PARAM_DATE_AMZ_CAMEL]; ok </span><span class="cov0" title="0">{
                var err error
                t, err = time.Parse(LONG_DATE_FORMAT, val[0])
                if err != nil </span><span class="cov0" title="0">{
                        t = time.Now().UTC()
                }</span>
        } else<span class="cov0" title="0"> if val, ok := headers[HEADER_DATE_CAMEL]; ok </span><span class="cov0" title="0">{
                var err error
                t, err = time.Parse(RFC1123_FORMAT, val[0])
                if err != nil </span><span class="cov0" title="0">{
                        t = time.Now().UTC()
                }</span>
        } else<span class="cov0" title="0"> if val, ok := headers[strings.ToLower(HEADER_DATE_CAMEL)]; ok </span><span class="cov0" title="0">{
                var err error
                t, err = time.Parse(RFC1123_FORMAT, val[0])
                if err != nil </span><span class="cov0" title="0">{
                        t = time.Now().UTC()
                }</span>
        } else<span class="cov0" title="0"> {
                t = time.Now().UTC()
        }</span>
        <span class="cov0" title="0">shortDate := t.Format(SHORT_DATE_FORMAT)
        longDate := t.Format(LONG_DATE_FORMAT)

        signedHeaders, _headers := getSignedHeaders(headers)

        credential, scope := getCredential(ak, region, shortDate)

        stringToSign := getV4StringToSign(method, canonicalizedUrl, queryUrl, scope, longDate, EMPTY_CONTENT_SHA256, signedHeaders, _headers)

        signature := getSignature(stringToSign, sk, region, shortDate)

        ret := make(map[string]string, 3)
        ret["Credential"] = credential
        ret["SignedHeaders"] = strings.Join(signedHeaders, ";")
        ret["Signature"] = signature
        return ret</span>
}
</pre>

		<pre class="file" id="file3" style="display: none">package obs

import (
        "errors"
        "fmt"
        "io"
        "net/http"
        "os"
        "sort"
        "strings"

        log "github.com/sirupsen/logrus"
)

type ObsClient struct {
        conf       *config
        httpClient *http.Client
        transport  *http.Transport
}

func New(ak, sk, endpoint string, configurers ...configurer) (*ObsClient, error) <span class="cov0" title="0">{
        conf := &amp;config{securityProvider: &amp;securityProvider{ak: ak, sk: sk}, endpoint: endpoint}
        conf.maxRetryCount = -1
        for _, configurer := range configurers </span><span class="cov0" title="0">{
                configurer(conf)
        }</span>

        <span class="cov0" title="0">if err := conf.initConfigWithDefault(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">transport, err := conf.getTransport()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">info := make([]string, 3)
        info[0] = fmt.Sprintf("[OBS SDK Version=%s", obs_sdk_version)
        info[1] = fmt.Sprintf("Endpoint=%s", conf.endpoint)
        accessMode := "Virtual Hosting"
        if conf.pathStyle </span><span class="cov0" title="0">{
                accessMode = "Path"
        }</span>
        <span class="cov0" title="0">info[2] = fmt.Sprintf("Access Mode=%s]", accessMode)
        log.Warn(strings.Join(info, "];["))

        log.Debug("Create obsclient with config:\n%s\n", conf)
        obsClient := &amp;ObsClient{conf: conf, httpClient: &amp;http.Client{Transport: transport, CheckRedirect: checkRedirectFunc}, transport: transport}
        return obsClient, nil</span>
}

func (obsClient ObsClient) Refresh(ak, sk, securityToken string) <span class="cov0" title="0">{
        sp := &amp;securityProvider{ak: strings.TrimSpace(ak), sk: strings.TrimSpace(sk), securityToken: strings.TrimSpace(securityToken)}
        obsClient.conf.securityProvider = sp
}</span>

func (obsClient ObsClient) Close() <span class="cov0" title="0">{
        obsClient.transport.CloseIdleConnections()
        obsClient.transport = nil
        obsClient.httpClient = nil
        obsClient.conf = nil
}</span>

func (obsClient ObsClient) ListBuckets(input *ListBucketsInput) (output *ListBucketsOutput, err error) <span class="cov0" title="0">{
        if input == nil </span><span class="cov0" title="0">{
                input = &amp;ListBucketsInput{}
        }</span>
        <span class="cov0" title="0">output = &amp;ListBucketsOutput{}
        err = obsClient.doActionWithoutBucket("ListBuckets", HTTP_GET, input, output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) CreateBucket(input *CreateBucketInput) (output *BaseModel, err error) <span class="cov0" title="0">{
        if input == nil </span><span class="cov0" title="0">{
                return nil, errors.New("CreateBucketInput is nil")
        }</span>
        <span class="cov0" title="0">output = &amp;BaseModel{}
        err = obsClient.doActionWithBucket("CreateBucket", HTTP_PUT, input.Bucket, input, output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) DeleteBucket(bucketName string) (output *BaseModel, err error) <span class="cov0" title="0">{
        output = &amp;BaseModel{}
        err = obsClient.doActionWithBucket("DeleteBucket", HTTP_DELETE, bucketName, defaultSerializable, output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) SetBucketStoragePolicy(input *SetBucketStoragePolicyInput) (output *BaseModel, err error) <span class="cov0" title="0">{
        if input == nil </span><span class="cov0" title="0">{
                return nil, errors.New("SetBucketStoragePolicyInput is nil")
        }</span>
        <span class="cov0" title="0">output = &amp;BaseModel{}
        err = obsClient.doActionWithBucket("SetBucketStoragePolicy", HTTP_PUT, input.Bucket, input, output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) GetBucketStoragePolicy(bucketName string) (output *GetBucketStoragePolicyOutput, err error) <span class="cov0" title="0">{
        output = &amp;GetBucketStoragePolicyOutput{}
        err = obsClient.doActionWithBucket("GetBucketStoragePolicy", HTTP_GET, bucketName, newSubResourceSerial(SubResourceStoragePolicy), output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) ListObjects(input *ListObjectsInput) (output *ListObjectsOutput, err error) <span class="cov0" title="0">{
        if input == nil </span><span class="cov0" title="0">{
                return nil, errors.New("ListObjectsInput is nil")
        }</span>
        <span class="cov0" title="0">output = &amp;ListObjectsOutput{}
        err = obsClient.doActionWithBucket("ListObjects", HTTP_GET, input.Bucket, input, output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span> else<span class="cov0" title="0"> {
                if location, ok := output.ResponseHeaders[HEADER_BUCKET_REGION]; ok </span><span class="cov0" title="0">{
                        output.Location = location[0]
                }</span>
        }
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) ListVersions(input *ListVersionsInput) (output *ListVersionsOutput, err error) <span class="cov0" title="0">{
        if input == nil </span><span class="cov0" title="0">{
                return nil, errors.New("ListVersionsInput is nil")
        }</span>
        <span class="cov0" title="0">output = &amp;ListVersionsOutput{}
        err = obsClient.doActionWithBucket("ListVersions", HTTP_GET, input.Bucket, input, output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span> else<span class="cov0" title="0"> {
                if location, ok := output.ResponseHeaders[HEADER_BUCKET_REGION]; ok </span><span class="cov0" title="0">{
                        output.Location = location[0]
                }</span>
        }
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) ListMultipartUploads(input *ListMultipartUploadsInput) (output *ListMultipartUploadsOutput, err error) <span class="cov0" title="0">{
        if input == nil </span><span class="cov0" title="0">{
                return nil, errors.New("ListMultipartUploadsInput is nil")
        }</span>
        <span class="cov0" title="0">output = &amp;ListMultipartUploadsOutput{}
        err = obsClient.doActionWithBucket("ListMultipartUploads", HTTP_GET, input.Bucket, input, output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) SetBucketQuota(input *SetBucketQuotaInput) (output *BaseModel, err error) <span class="cov0" title="0">{
        if input == nil </span><span class="cov0" title="0">{
                return nil, errors.New("SetBucketQuotaInput is nil")
        }</span>
        <span class="cov0" title="0">output = &amp;BaseModel{}
        err = obsClient.doActionWithBucket("SetBucketQuota", HTTP_PUT, input.Bucket, input, output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) GetBucketQuota(bucketName string) (output *GetBucketQuotaOutput, err error) <span class="cov0" title="0">{
        output = &amp;GetBucketQuotaOutput{}
        err = obsClient.doActionWithBucket("GetBucketQuota", HTTP_GET, bucketName, newSubResourceSerial(SubResourceQuota), output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) HeadBucket(bucketName string) (output *BaseModel, err error) <span class="cov0" title="0">{
        output = &amp;BaseModel{}
        err = obsClient.doActionWithBucket("HeadBucket", HTTP_HEAD, bucketName, defaultSerializable, output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) GetBucketMetadata(input *GetBucketMetadataInput) (output *GetBucketMetadataOutput, err error) <span class="cov0" title="0">{
        output = &amp;GetBucketMetadataOutput{}
        err = obsClient.doActionWithBucket("GetBucketMetadata", HTTP_HEAD, input.Bucket, input, output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span> else<span class="cov0" title="0"> {
                ParseGetBucketMetadataOutput(output)
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) GetBucketStorageInfo(bucketName string) (output *GetBucketStorageInfoOutput, err error) <span class="cov0" title="0">{
        output = &amp;GetBucketStorageInfoOutput{}
        err = obsClient.doActionWithBucket("GetBucketStorageInfo", HTTP_GET, bucketName, newSubResourceSerial(SubResourceStorageInfo), output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) GetBucketLocation(bucketName string) (output *GetBucketLocationOutput, err error) <span class="cov0" title="0">{
        output = &amp;GetBucketLocationOutput{}
        err = obsClient.doActionWithBucket("GetBucketLocation", HTTP_GET, bucketName, newSubResourceSerial(SubResourceLocation), output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) SetBucketAcl(input *SetBucketAclInput) (output *BaseModel, err error) <span class="cov0" title="0">{
        if input == nil </span><span class="cov0" title="0">{
                return nil, errors.New("SetBucketAclInput is nil")
        }</span>
        <span class="cov0" title="0">output = &amp;BaseModel{}
        err = obsClient.doActionWithBucket("SetBucketAcl", HTTP_PUT, input.Bucket, input, output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) GetBucketAcl(bucketName string) (output *GetBucketAclOutput, err error) <span class="cov0" title="0">{
        output = &amp;GetBucketAclOutput{}
        err = obsClient.doActionWithBucket("GetBucketAcl", HTTP_GET, bucketName, newSubResourceSerial(SubResourceAcl), output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) SetBucketPolicy(input *SetBucketPolicyInput) (output *BaseModel, err error) <span class="cov0" title="0">{
        if input == nil </span><span class="cov0" title="0">{
                return nil, errors.New("SetBucketPolicy is nil")
        }</span>
        <span class="cov0" title="0">output = &amp;BaseModel{}
        err = obsClient.doActionWithBucket("SetBucketPolicy", HTTP_PUT, input.Bucket, input, output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) GetBucketPolicy(bucketName string) (output *GetBucketPolicyOutput, err error) <span class="cov0" title="0">{
        output = &amp;GetBucketPolicyOutput{}
        err = obsClient.doActionWithBucketV2("GetBucketPolicy", HTTP_GET, bucketName, newSubResourceSerial(SubResourcePolicy), output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) DeleteBucketPolicy(bucketName string) (output *BaseModel, err error) <span class="cov0" title="0">{
        output = &amp;BaseModel{}
        err = obsClient.doActionWithBucket("DeleteBucketPolicy", HTTP_DELETE, bucketName, newSubResourceSerial(SubResourcePolicy), output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) SetBucketCors(input *SetBucketCorsInput) (output *BaseModel, err error) <span class="cov0" title="0">{
        if input == nil </span><span class="cov0" title="0">{
                return nil, errors.New("SetBucketCorsInput is nil")
        }</span>
        <span class="cov0" title="0">output = &amp;BaseModel{}
        err = obsClient.doActionWithBucket("SetBucketCors", HTTP_PUT, input.Bucket, input, output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) GetBucketCors(bucketName string) (output *GetBucketCorsOutput, err error) <span class="cov0" title="0">{
        output = &amp;GetBucketCorsOutput{}
        err = obsClient.doActionWithBucket("GetBucketCors", HTTP_GET, bucketName, newSubResourceSerial(SubResourceCors), output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) DeleteBucketCors(bucketName string) (output *BaseModel, err error) <span class="cov0" title="0">{
        output = &amp;BaseModel{}
        err = obsClient.doActionWithBucket("DeleteBucketCors", HTTP_DELETE, bucketName, newSubResourceSerial(SubResourceCors), output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) SetBucketVersioning(input *SetBucketVersioningInput) (output *BaseModel, err error) <span class="cov0" title="0">{
        if input == nil </span><span class="cov0" title="0">{
                return nil, errors.New("SetBucketVersioningInput is nil")
        }</span>
        <span class="cov0" title="0">output = &amp;BaseModel{}
        err = obsClient.doActionWithBucket("SetBucketVersioning", HTTP_PUT, input.Bucket, input, output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) GetBucketVersioning(bucketName string) (output *GetBucketVersioningOutput, err error) <span class="cov0" title="0">{
        output = &amp;GetBucketVersioningOutput{}
        err = obsClient.doActionWithBucket("GetBucketVersioning", HTTP_GET, bucketName, newSubResourceSerial(SubResourceVersioning), output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) SetBucketWebsiteConfiguration(input *SetBucketWebsiteConfigurationInput) (output *BaseModel, err error) <span class="cov0" title="0">{
        if input == nil </span><span class="cov0" title="0">{
                return nil, errors.New("SetBucketWebsiteConfigurationInput is nil")
        }</span>
        <span class="cov0" title="0">output = &amp;BaseModel{}
        err = obsClient.doActionWithBucket("SetBucketWebsiteConfiguration", HTTP_PUT, input.Bucket, input, output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) GetBucketWebsiteConfiguration(bucketName string) (output *GetBucketWebsiteConfigurationOutput, err error) <span class="cov0" title="0">{
        output = &amp;GetBucketWebsiteConfigurationOutput{}
        err = obsClient.doActionWithBucket("GetBucketWebsiteConfiguration", HTTP_GET, bucketName, newSubResourceSerial(SubResourceWebsite), output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) DeleteBucketWebsiteConfiguration(bucketName string) (output *BaseModel, err error) <span class="cov0" title="0">{
        output = &amp;BaseModel{}
        err = obsClient.doActionWithBucket("DeleteBucketWebsiteConfiguration", HTTP_DELETE, bucketName, newSubResourceSerial(SubResourceWebsite), output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) SetBucketLoggingConfiguration(input *SetBucketLoggingConfigurationInput) (output *BaseModel, err error) <span class="cov0" title="0">{
        if input == nil </span><span class="cov0" title="0">{
                return nil, errors.New("SetBucketLoggingConfigurationInput is nil")
        }</span>
        <span class="cov0" title="0">output = &amp;BaseModel{}
        err = obsClient.doActionWithBucket("SetBucketLoggingConfiguration", HTTP_PUT, input.Bucket, input, output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) GetBucketLoggingConfiguration(bucketName string) (output *GetBucketLoggingConfigurationOutput, err error) <span class="cov0" title="0">{
        output = &amp;GetBucketLoggingConfigurationOutput{}
        err = obsClient.doActionWithBucket("GetBucketLoggingConfiguration", HTTP_GET, bucketName, newSubResourceSerial(SubResourceLogging), output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) SetBucketLifecycleConfiguration(input *SetBucketLifecycleConfigurationInput) (output *BaseModel, err error) <span class="cov0" title="0">{
        if input == nil </span><span class="cov0" title="0">{
                return nil, errors.New("SetBucketLifecycleConfigurationInput is nil")
        }</span>
        <span class="cov0" title="0">output = &amp;BaseModel{}
        err = obsClient.doActionWithBucket("SetBucketLifecycleConfiguration", HTTP_PUT, input.Bucket, input, output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) GetBucketLifecycleConfiguration(bucketName string) (output *GetBucketLifecycleConfigurationOutput, err error) <span class="cov0" title="0">{
        output = &amp;GetBucketLifecycleConfigurationOutput{}
        err = obsClient.doActionWithBucket("GetBucketLifecycleConfiguration", HTTP_GET, bucketName, newSubResourceSerial(SubResourceLifecycle), output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) DeleteBucketLifecycleConfiguration(bucketName string) (output *BaseModel, err error) <span class="cov0" title="0">{
        output = &amp;BaseModel{}
        err = obsClient.doActionWithBucket("DeleteBucketLifecycleConfiguration", HTTP_DELETE, bucketName, newSubResourceSerial(SubResourceLifecycle), output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) SetBucketTagging(input *SetBucketTaggingInput) (output *BaseModel, err error) <span class="cov0" title="0">{
        if input == nil </span><span class="cov0" title="0">{
                return nil, errors.New("SetBucketTaggingInput is nil")
        }</span>
        <span class="cov0" title="0">output = &amp;BaseModel{}
        err = obsClient.doActionWithBucket("SetBucketTagging", HTTP_PUT, input.Bucket, input, output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) GetBucketTagging(bucketName string) (output *GetBucketTaggingOutput, err error) <span class="cov0" title="0">{
        output = &amp;GetBucketTaggingOutput{}
        err = obsClient.doActionWithBucket("GetBucketTagging", HTTP_GET, bucketName, newSubResourceSerial(SubResourceTagging), output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) DeleteBucketTagging(bucketName string) (output *BaseModel, err error) <span class="cov0" title="0">{
        output = &amp;BaseModel{}
        err = obsClient.doActionWithBucket("DeleteBucketTagging", HTTP_DELETE, bucketName, newSubResourceSerial(SubResourceTagging), output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) SetBucketNotification(input *SetBucketNotificationInput) (output *BaseModel, err error) <span class="cov0" title="0">{
        if input == nil </span><span class="cov0" title="0">{
                return nil, errors.New("SetBucketNotificationInput is nil")
        }</span>
        <span class="cov0" title="0">output = &amp;BaseModel{}
        err = obsClient.doActionWithBucket("SetBucketNotification", HTTP_PUT, input.Bucket, input, output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) GetBucketNotification(bucketName string) (output *GetBucketNotificationOutput, err error) <span class="cov0" title="0">{
        output = &amp;GetBucketNotificationOutput{}
        err = obsClient.doActionWithBucket("GetBucketNotification", HTTP_GET, bucketName, newSubResourceSerial(SubResourceNotification), output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) DeleteObject(input *DeleteObjectInput) (output *DeleteObjectOutput, err error) <span class="cov0" title="0">{
        if input == nil </span><span class="cov0" title="0">{
                return nil, errors.New("DeleteObjectInput is nil")
        }</span>
        <span class="cov0" title="0">output = &amp;DeleteObjectOutput{}
        err = obsClient.doActionWithBucketAndKey("DeleteObject", HTTP_DELETE, input.Bucket, input.Key, input, output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span> else<span class="cov0" title="0"> {
                ParseDeleteObjectOutput(output)
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) DeleteObjects(input *DeleteObjectsInput) (output *DeleteObjectsOutput, err error) <span class="cov0" title="0">{
        if input == nil </span><span class="cov0" title="0">{
                return nil, errors.New("DeleteObjectsInput is nil")
        }</span>
        <span class="cov0" title="0">output = &amp;DeleteObjectsOutput{}
        err = obsClient.doActionWithBucket("DeleteObjects", HTTP_POST, input.Bucket, input, output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) SetObjectAcl(input *SetObjectAclInput) (output *BaseModel, err error) <span class="cov0" title="0">{
        if input == nil </span><span class="cov0" title="0">{
                return nil, errors.New("SetObjectAclInput is nil")
        }</span>
        <span class="cov0" title="0">output = &amp;BaseModel{}
        err = obsClient.doActionWithBucketAndKey("SetObjectAcl", HTTP_PUT, input.Bucket, input.Key, input, output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) GetObjectAcl(input *GetObjectAclInput) (output *GetObjectAclOutput, err error) <span class="cov0" title="0">{
        if input == nil </span><span class="cov0" title="0">{
                return nil, errors.New("GetObjectAclInput is nil")
        }</span>
        <span class="cov0" title="0">output = &amp;GetObjectAclOutput{}
        err = obsClient.doActionWithBucketAndKey("GetObjectAcl", HTTP_GET, input.Bucket, input.Key, input, output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span> else<span class="cov0" title="0"> {
                if versionId, ok := output.ResponseHeaders[HEADER_VERSION_ID]; ok </span><span class="cov0" title="0">{
                        output.VersionId = versionId[0]
                }</span>
        }
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) RestoreObject(input *RestoreObjectInput) (output *BaseModel, err error) <span class="cov0" title="0">{
        if input == nil </span><span class="cov0" title="0">{
                return nil, errors.New("RestoreObjectInput is nil")
        }</span>
        <span class="cov0" title="0">output = &amp;BaseModel{}
        err = obsClient.doActionWithBucketAndKey("RestoreObject", HTTP_POST, input.Bucket, input.Key, input, output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) GetObjectMetadata(input *GetObjectMetadataInput) (output *GetObjectMetadataOutput, err error) <span class="cov0" title="0">{
        if input == nil </span><span class="cov0" title="0">{
                return nil, errors.New("GetObjectMetadataInput is nil")
        }</span>
        <span class="cov0" title="0">output = &amp;GetObjectMetadataOutput{}
        err = obsClient.doActionWithBucketAndKey("GetObjectMetadata", HTTP_HEAD, input.Bucket, input.Key, input, output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span> else<span class="cov0" title="0"> {
                ParseGetObjectMetadataOutput(output)
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) GetObject(input *GetObjectInput) (output *GetObjectOutput, err error) <span class="cov0" title="0">{
        if input == nil </span><span class="cov0" title="0">{
                return nil, errors.New("GetObjectInput is nil")
        }</span>
        <span class="cov0" title="0">output = &amp;GetObjectOutput{}
        err = obsClient.doActionWithBucketAndKey("GetObject", HTTP_GET, input.Bucket, input.Key, input, output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span> else<span class="cov0" title="0"> {
                ParseGetObjectOutput(output)
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) PutObject(input *PutObjectInput) (output *PutObjectOutput, err error) <span class="cov0" title="0">{
        if input == nil </span><span class="cov0" title="0">{
                return nil, errors.New("PutObjectInput is nil")
        }</span>

        <span class="cov0" title="0">if input.ContentType == "" &amp;&amp; input.Key != "" </span><span class="cov0" title="0">{
                if contentType, ok := mime_types[input.Key[strings.LastIndex(input.Key, ".")+1:]]; ok </span><span class="cov0" title="0">{
                        input.ContentType = contentType
                }</span>
        }

        <span class="cov0" title="0">output = &amp;PutObjectOutput{}
        var repeatable bool
        if input.Body != nil </span><span class="cov0" title="0">{
                _, repeatable = input.Body.(*strings.Reader)
                if input.ContentLength &gt; 0 </span><span class="cov0" title="0">{
                        input.Body = &amp;readerWrapper{reader: input.Body, totalCount: input.ContentLength}
                }</span>
        }
        <span class="cov0" title="0">if repeatable </span><span class="cov0" title="0">{
                err = obsClient.doActionWithBucketAndKey("PutObject", HTTP_PUT, input.Bucket, input.Key, input, output)
        }</span> else<span class="cov0" title="0"> {
                err = obsClient.doActionWithBucketAndKeyUnRepeatable("PutObject", HTTP_PUT, input.Bucket, input.Key, input, output)
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span> else<span class="cov0" title="0"> {
                ParsePutObjectOutput(output)
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) PutFile(input *PutFileInput) (output *PutObjectOutput, err error) <span class="cov0" title="0">{
        if input == nil </span><span class="cov0" title="0">{
                return nil, errors.New("PutFileInput is nil")
        }</span>

        <span class="cov0" title="0">var body io.Reader
        sourceFile := strings.TrimSpace(input.SourceFile)
        if sourceFile != "" </span><span class="cov0" title="0">{
                fd, err := os.Open(sourceFile)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">defer fd.Close()

                stat, err := fd.Stat()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">fileReaderWrapper := &amp;fileReaderWrapper{filePath: sourceFile}
                fileReaderWrapper.reader = fd
                if input.ContentLength &gt; 0 </span><span class="cov0" title="0">{
                        if input.ContentLength &gt; stat.Size() </span><span class="cov0" title="0">{
                                input.ContentLength = stat.Size()
                        }</span>
                        <span class="cov0" title="0">fileReaderWrapper.totalCount = input.ContentLength</span>
                } else<span class="cov0" title="0"> {
                        fileReaderWrapper.totalCount = stat.Size()
                }</span>
                <span class="cov0" title="0">body = fileReaderWrapper</span>
        }

        <span class="cov0" title="0">_input := &amp;PutObjectInput{}
        _input.PutObjectBasicInput = input.PutObjectBasicInput
        _input.Body = body

        if _input.ContentType == "" &amp;&amp; _input.Key != "" </span><span class="cov0" title="0">{
                if contentType, ok := mime_types[_input.Key[strings.LastIndex(_input.Key, ".")+1:]]; ok </span><span class="cov0" title="0">{
                        _input.ContentType = contentType
                }</span> else<span class="cov0" title="0"> if contentType, ok := mime_types[sourceFile[strings.LastIndex(sourceFile, ".")+1:]]; ok </span><span class="cov0" title="0">{
                        _input.ContentType = contentType
                }</span>
        }

        <span class="cov0" title="0">output = &amp;PutObjectOutput{}
        err = obsClient.doActionWithBucketAndKey("PutFile", HTTP_PUT, _input.Bucket, _input.Key, _input, output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span> else<span class="cov0" title="0"> {
                ParsePutObjectOutput(output)
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) CopyObject(input *CopyObjectInput) (output *CopyObjectOutput, err error) <span class="cov0" title="0">{
        if input == nil </span><span class="cov0" title="0">{
                return nil, errors.New("CopyObjectInput is nil")
        }</span>

        <span class="cov0" title="0">if strings.TrimSpace(input.CopySourceBucket) == "" </span><span class="cov0" title="0">{
                return nil, errors.New("Source bucket is empty")
        }</span>
        <span class="cov0" title="0">if strings.TrimSpace(input.CopySourceKey) == "" </span><span class="cov0" title="0">{
                return nil, errors.New("Source key is empty")
        }</span>

        <span class="cov0" title="0">output = &amp;CopyObjectOutput{}
        err = obsClient.doActionWithBucketAndKey("CopyObject", HTTP_PUT, input.Bucket, input.Key, input, output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span> else<span class="cov0" title="0"> {
                ParseCopyObjectOutput(output)
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) AbortMultipartUpload(input *AbortMultipartUploadInput) (output *BaseModel, err error) <span class="cov0" title="0">{
        if input == nil </span><span class="cov0" title="0">{
                return nil, errors.New("AbortMultipartUploadInput is nil")
        }</span>
        <span class="cov0" title="0">if input.UploadId == "" </span><span class="cov0" title="0">{
                return nil, errors.New("UploadId is empty")
        }</span>
        <span class="cov0" title="0">output = &amp;BaseModel{}
        err = obsClient.doActionWithBucketAndKey("AbortMultipartUpload", HTTP_DELETE, input.Bucket, input.Key, input, output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) InitiateMultipartUpload(input *InitiateMultipartUploadInput) (output *InitiateMultipartUploadOutput, err error) <span class="cov0" title="0">{
        if input == nil </span><span class="cov0" title="0">{
                return nil, errors.New("InitiateMultipartUploadInput is nil")
        }</span>

        <span class="cov0" title="0">if input.ContentType == "" &amp;&amp; input.Key != "" </span><span class="cov0" title="0">{
                if contentType, ok := mime_types[input.Key[strings.LastIndex(input.Key, ".")+1:]]; ok </span><span class="cov0" title="0">{
                        input.ContentType = contentType
                }</span>
        }

        <span class="cov0" title="0">output = &amp;InitiateMultipartUploadOutput{}
        err = obsClient.doActionWithBucketAndKey("InitiateMultipartUpload", HTTP_POST, input.Bucket, input.Key, input, output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span> else<span class="cov0" title="0"> {
                ParseInitiateMultipartUploadOutput(output)
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) UploadPart(input *UploadPartInput) (output *UploadPartOutput, err error) <span class="cov0" title="0">{
        if input == nil </span><span class="cov0" title="0">{
                return nil, errors.New("UploadPartInput is nil")
        }</span>

        <span class="cov0" title="0">if input.UploadId == "" </span><span class="cov0" title="0">{
                return nil, errors.New("UploadId is empty")
        }</span>

        <span class="cov0" title="0">output = &amp;UploadPartOutput{}
        var repeatable bool
        if input.Body != nil </span><span class="cov0" title="0">{
                _, repeatable = input.Body.(*strings.Reader)
                if input.PartSize &gt; 0 </span><span class="cov0" title="0">{
                        input.Body = &amp;readerWrapper{reader: input.Body, totalCount: input.PartSize}
                }</span>
        } else<span class="cov0" title="0"> if sourceFile := strings.TrimSpace(input.SourceFile); sourceFile != "" </span><span class="cov0" title="0">{
                fd, err := os.Open(sourceFile)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">defer fd.Close()

                stat, err := fd.Stat()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">fileSize := stat.Size()
                fileReaderWrapper := &amp;fileReaderWrapper{filePath: sourceFile}
                fileReaderWrapper.reader = fd

                if input.Offset &lt; 0 || input.Offset &gt; fileSize </span><span class="cov0" title="0">{
                        input.Offset = 0
                }</span>

                <span class="cov0" title="0">if input.PartSize &lt;= 0 || input.PartSize &gt; (fileSize-input.Offset) </span><span class="cov0" title="0">{
                        input.PartSize = fileSize - input.Offset
                }</span>
                <span class="cov0" title="0">fileReaderWrapper.totalCount = input.PartSize
                fd.Seek(input.Offset, 0)
                input.Body = fileReaderWrapper
                repeatable = true</span>
        }
        <span class="cov0" title="0">if repeatable </span><span class="cov0" title="0">{
                err = obsClient.doActionWithBucketAndKey("UploadPart", HTTP_PUT, input.Bucket, input.Key, input, output)
        }</span> else<span class="cov0" title="0"> {
                err = obsClient.doActionWithBucketAndKeyUnRepeatable("UploadPart", HTTP_PUT, input.Bucket, input.Key, input, output)
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span> else<span class="cov0" title="0"> {
                ParseUploadPartOutput(output)
                output.PartNumber = input.PartNumber
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) CompleteMultipartUpload(input *CompleteMultipartUploadInput) (output *CompleteMultipartUploadOutput, err error) <span class="cov0" title="0">{
        if input == nil </span><span class="cov0" title="0">{
                return nil, errors.New("CompleteMultipartUploadInput is nil")
        }</span>

        <span class="cov0" title="0">if input.UploadId == "" </span><span class="cov0" title="0">{
                return nil, errors.New("UploadId is empty")
        }</span>

        <span class="cov0" title="0">var parts partSlice = input.Parts
        sort.Sort(parts)

        output = &amp;CompleteMultipartUploadOutput{}
        err = obsClient.doActionWithBucketAndKey("CompleteMultipartUpload", HTTP_POST, input.Bucket, input.Key, input, output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span> else<span class="cov0" title="0"> {
                ParseCompleteMultipartUploadOutput(output)
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) ListParts(input *ListPartsInput) (output *ListPartsOutput, err error) <span class="cov0" title="0">{
        if input == nil </span><span class="cov0" title="0">{
                return nil, errors.New("ListPartsInput is nil")
        }</span>
        <span class="cov0" title="0">if input.UploadId == "" </span><span class="cov0" title="0">{
                return nil, errors.New("UploadId is empty")
        }</span>
        <span class="cov0" title="0">output = &amp;ListPartsOutput{}
        err = obsClient.doActionWithBucketAndKey("ListParts", HTTP_GET, input.Bucket, input.Key, input, output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) CopyPart(input *CopyPartInput) (output *CopyPartOutput, err error) <span class="cov0" title="0">{
        if input == nil </span><span class="cov0" title="0">{
                return nil, errors.New("CopyPartInput is nil")
        }</span>
        <span class="cov0" title="0">if input.UploadId == "" </span><span class="cov0" title="0">{
                return nil, errors.New("UploadId is empty")
        }</span>
        <span class="cov0" title="0">if strings.TrimSpace(input.CopySourceBucket) == "" </span><span class="cov0" title="0">{
                return nil, errors.New("Source bucket is empty")
        }</span>
        <span class="cov0" title="0">if strings.TrimSpace(input.CopySourceKey) == "" </span><span class="cov0" title="0">{
                return nil, errors.New("Source key is empty")
        }</span>

        <span class="cov0" title="0">output = &amp;CopyPartOutput{}
        err = obsClient.doActionWithBucketAndKey("CopyPart", HTTP_PUT, input.Bucket, input.Key, input, output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span> else<span class="cov0" title="0"> {
                ParseCopyPartOutput(output)
                output.PartNumber = input.PartNumber
        }</span>
        <span class="cov0" title="0">return</span>
}
</pre>

		<pre class="file" id="file4" style="display: none">package obs

import (
        "crypto/tls"
        "crypto/x509"
        "errors"
        "fmt"
        "net"
        "net/http"
        "net/url"
        "sort"
        "strconv"
        "strings"
        "time"
)

type securityProvider struct {
        ak            string
        sk            string
        securityToken string
}

type urlHolder struct {
        scheme string
        host   string
        port   int
}

type config struct {
        securityProvider *securityProvider
        urlHolder        *urlHolder
        endpoint         string
        signature        SignatureType
        pathStyle        bool
        region           string
        connectTimeout   int
        socketTimeout    int
        headerTimeout    int
        idleConnTimeout  int
        finalTimeout     int
        maxRetryCount    int
        proxyUrl         string
        maxConnsPerHost  int
        sslVerify        bool
        pemCerts         []byte
}

func (conf config) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("[endpoint:%s, signature:%s, pathStyle:%v, region:%s"+
                "\nconnectTimeout:%d, socketTimeout:%dheaderTimeout:%d, idleConnTimeout:%d"+
                "\nmaxRetryCount:%d, maxConnsPerHost:%d, sslVerify:%v, proxyUrl:%s]",
                conf.endpoint, conf.signature, conf.pathStyle, conf.region,
                conf.connectTimeout, conf.socketTimeout, conf.headerTimeout, conf.idleConnTimeout,
                conf.maxRetryCount, conf.maxConnsPerHost, conf.sslVerify, conf.proxyUrl,
        )
}</span>

type configurer func(conf *config)

func WithSslVerify(sslVerify bool) configurer <span class="cov0" title="0">{
        return WithSslVerifyAndPemCerts(sslVerify, nil)
}</span>

func WithSslVerifyAndPemCerts(sslVerify bool, pemCerts []byte) configurer <span class="cov0" title="0">{
        return func(conf *config) </span><span class="cov0" title="0">{
                conf.sslVerify = sslVerify
                conf.pemCerts = pemCerts
        }</span>
}

func WithHeaderTimeout(headerTimeout int) configurer <span class="cov0" title="0">{
        return func(conf *config) </span><span class="cov0" title="0">{
                conf.headerTimeout = headerTimeout
        }</span>
}

func WithProxyUrl(proxyUrl string) configurer <span class="cov0" title="0">{
        return func(conf *config) </span><span class="cov0" title="0">{
                conf.proxyUrl = proxyUrl
        }</span>
}

func WithMaxConnections(maxConnsPerHost int) configurer <span class="cov0" title="0">{
        return func(conf *config) </span><span class="cov0" title="0">{
                conf.maxConnsPerHost = maxConnsPerHost
        }</span>
}

func WithPathStyle(pathStyle bool) configurer <span class="cov0" title="0">{
        return func(conf *config) </span><span class="cov0" title="0">{
                conf.pathStyle = pathStyle
        }</span>
}

func WithSignature(signature SignatureType) configurer <span class="cov0" title="0">{
        return func(conf *config) </span><span class="cov0" title="0">{
                conf.signature = signature
        }</span>
}

func WithRegion(region string) configurer <span class="cov0" title="0">{
        return func(conf *config) </span><span class="cov0" title="0">{
                conf.region = region
        }</span>
}

func WithConnectTimeout(connectTimeout int) configurer <span class="cov0" title="0">{
        return func(conf *config) </span><span class="cov0" title="0">{
                conf.connectTimeout = connectTimeout
        }</span>
}

func WithSocketTimeout(socketTimeout int) configurer <span class="cov0" title="0">{
        return func(conf *config) </span><span class="cov0" title="0">{
                conf.socketTimeout = socketTimeout
        }</span>
}

func WithIdleConnTimeout(idleConnTimeout int) configurer <span class="cov0" title="0">{
        return func(conf *config) </span><span class="cov0" title="0">{
                conf.idleConnTimeout = idleConnTimeout
        }</span>
}

func WithMaxRetryCount(maxRetryCount int) configurer <span class="cov0" title="0">{
        return func(conf *config) </span><span class="cov0" title="0">{
                conf.maxRetryCount = maxRetryCount
        }</span>
}

func WithSecurityToken(securityToken string) configurer <span class="cov0" title="0">{
        return func(conf *config) </span><span class="cov0" title="0">{
                conf.securityProvider.securityToken = securityToken
        }</span>
}

func (conf *config) initConfigWithDefault() error <span class="cov0" title="0">{
        conf.securityProvider.ak = strings.TrimSpace(conf.securityProvider.ak)
        conf.securityProvider.sk = strings.TrimSpace(conf.securityProvider.sk)
        conf.securityProvider.securityToken = strings.TrimSpace(conf.securityProvider.securityToken)
        conf.endpoint = strings.TrimSpace(conf.endpoint)
        if conf.endpoint == "" </span><span class="cov0" title="0">{
                return errors.New("endpoint is not set")
        }</span>

        <span class="cov0" title="0">if index := strings.Index(conf.endpoint, "?"); index &gt; 0 </span><span class="cov0" title="0">{
                conf.endpoint = conf.endpoint[:index]
        }</span>

        <span class="cov0" title="0">for strings.LastIndex(conf.endpoint, "/") == len(conf.endpoint)-1 </span><span class="cov0" title="0">{
                conf.endpoint = conf.endpoint[:len(conf.endpoint)-1]
        }</span>

        <span class="cov0" title="0">if conf.signature == "" </span><span class="cov0" title="0">{
                conf.signature = DEFAULT_SIGNATURE
        }</span>

        <span class="cov0" title="0">urlHolder := &amp;urlHolder{}
        var address string
        if strings.HasPrefix(conf.endpoint, "https://") </span><span class="cov0" title="0">{
                urlHolder.scheme = "https"
                address = conf.endpoint[len("https://"):]
        }</span> else<span class="cov0" title="0"> if strings.HasPrefix(conf.endpoint, "http://") </span><span class="cov0" title="0">{
                urlHolder.scheme = "http"
                address = conf.endpoint[len("http://"):]
        }</span> else<span class="cov0" title="0"> {
                urlHolder.scheme = "http"
                address = conf.endpoint
        }</span>

        <span class="cov0" title="0">addr := strings.Split(address, ":")
        if len(addr) == 2 </span><span class="cov0" title="0">{
                if port, err := strconv.Atoi(addr[1]); err == nil </span><span class="cov0" title="0">{
                        urlHolder.port = port
                }</span>
        }
        <span class="cov0" title="0">urlHolder.host = addr[0]
        if urlHolder.port == 0 </span><span class="cov0" title="0">{
                if urlHolder.scheme == "https" </span><span class="cov0" title="0">{
                        urlHolder.port = 443
                }</span> else<span class="cov0" title="0"> {
                        urlHolder.port = 80
                }</span>
        }

        <span class="cov0" title="0">if IsIP(urlHolder.host) </span><span class="cov0" title="0">{
                conf.pathStyle = true
        }</span>

        <span class="cov0" title="0">conf.urlHolder = urlHolder

        conf.region = strings.TrimSpace(conf.region)
        if conf.region == "" </span><span class="cov0" title="0">{
                conf.region = DEFAULT_REGION
        }</span>

        <span class="cov0" title="0">if conf.connectTimeout &lt;= 0 </span><span class="cov0" title="0">{
                conf.connectTimeout = DEFAULT_CONNECT_TIMEOUT
        }</span>

        <span class="cov0" title="0">if conf.socketTimeout &lt;= 0 </span><span class="cov0" title="0">{
                conf.socketTimeout = DEFAULT_SOCKET_TIMEOUT
        }</span>

        <span class="cov0" title="0">conf.finalTimeout = conf.socketTimeout * 10

        if conf.headerTimeout &lt;= 0 </span><span class="cov0" title="0">{
                conf.headerTimeout = DEFAULT_HEADER_TIMEOUT
        }</span>

        <span class="cov0" title="0">if conf.idleConnTimeout &lt; 0 </span><span class="cov0" title="0">{
                conf.idleConnTimeout = DEFAULT_IDLE_CONN_TIMEOUT
        }</span>

        <span class="cov0" title="0">if conf.maxRetryCount &lt; 0 </span><span class="cov0" title="0">{
                conf.maxRetryCount = DEFAULT_MAX_RETRY_COUNT
        }</span>

        <span class="cov0" title="0">if conf.maxConnsPerHost &lt;= 0 </span><span class="cov0" title="0">{
                conf.maxConnsPerHost = DEFAULT_MAX_CONN_PER_HOST
        }</span>

        <span class="cov0" title="0">conf.proxyUrl = strings.TrimSpace(conf.proxyUrl)
        return nil</span>
}

func (conf *config) getTransport() (*http.Transport, error) <span class="cov0" title="0">{
        transport := &amp;http.Transport{
                Dial: func(network, addr string) (net.Conn, error) </span><span class="cov0" title="0">{
                        conn, err := net.DialTimeout(network, addr, time.Second*time.Duration(conf.connectTimeout))
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">return getConnDelegate(conn, conf.socketTimeout, conf.finalTimeout), nil</span>
                },
                MaxIdleConns:          conf.maxConnsPerHost,
                MaxIdleConnsPerHost:   conf.maxConnsPerHost,
                ResponseHeaderTimeout: time.Second * time.Duration(conf.headerTimeout),
                IdleConnTimeout:       time.Second * time.Duration(conf.idleConnTimeout),
        }

        <span class="cov0" title="0">if conf.proxyUrl != "" </span><span class="cov0" title="0">{
                proxyUrl, err := url.Parse(conf.proxyUrl)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">transport.Proxy = http.ProxyURL(proxyUrl)</span>
        }

        <span class="cov0" title="0">tlsConfig := &amp;tls.Config{InsecureSkipVerify: !conf.sslVerify}
        if conf.sslVerify &amp;&amp; conf.pemCerts != nil </span><span class="cov0" title="0">{
                pool := x509.NewCertPool()
                pool.AppendCertsFromPEM(conf.pemCerts)
                tlsConfig.RootCAs = pool
        }</span>
        <span class="cov0" title="0">transport.TLSClientConfig = tlsConfig

        return transport, nil</span>
}

func checkRedirectFunc(req *http.Request, via []*http.Request) error <span class="cov0" title="0">{
        return http.ErrUseLastResponse
}</span>

func DummyQueryEscape(s string) string <span class="cov0" title="0">{
        return s
}</span>

func (conf *config) formatUrls(bucketName, objectKey string, params map[string]string, escape bool) (requestUrl string, canonicalizedUrl string) <span class="cov0" title="0">{

        urlHolder := conf.urlHolder

        if bucketName == "" </span><span class="cov0" title="0">{
                requestUrl = fmt.Sprintf("%s://%s:%d", urlHolder.scheme, urlHolder.host, urlHolder.port)
                canonicalizedUrl = "/"
        }</span> else<span class="cov0" title="0"> {
                if conf.pathStyle </span><span class="cov0" title="0">{
                        requestUrl = fmt.Sprintf("%s://%s:%d/%s", urlHolder.scheme, urlHolder.host, urlHolder.port, bucketName)
                        canonicalizedUrl = "/" + bucketName
                }</span> else<span class="cov0" title="0"> {
                        requestUrl = fmt.Sprintf("%s://%s.%s:%d", urlHolder.scheme, bucketName, urlHolder.host, urlHolder.port)
                        if conf.signature == "v2" </span><span class="cov0" title="0">{
                                canonicalizedUrl = "/" + bucketName + "/"
                        }</span> else<span class="cov0" title="0"> {
                                canonicalizedUrl = "/"
                        }</span>
                }
        }
        <span class="cov0" title="0">var escapeFunc func(s string) string
        if escape </span><span class="cov0" title="0">{
                escapeFunc = url.QueryEscape
        }</span> else<span class="cov0" title="0"> {
                escapeFunc = DummyQueryEscape
        }</span>

        <span class="cov0" title="0">if objectKey != "" </span><span class="cov0" title="0">{
                encodeObjectKey := escapeFunc(objectKey)
                requestUrl += "/" + encodeObjectKey
                if !strings.HasSuffix(canonicalizedUrl, "/") </span><span class="cov0" title="0">{
                        canonicalizedUrl += "/"
                }</span>
                <span class="cov0" title="0">canonicalizedUrl += encodeObjectKey</span>
        }

        <span class="cov0" title="0">keys := make([]string, 0, len(params))
        for key, _ := range params </span><span class="cov0" title="0">{
                keys = append(keys, strings.TrimSpace(key))
        }</span>
        <span class="cov0" title="0">sort.Strings(keys)
        i := 0

        for index, key := range keys </span><span class="cov0" title="0">{
                if index == 0 </span><span class="cov0" title="0">{
                        requestUrl += "?"
                }</span> else<span class="cov0" title="0"> {
                        requestUrl += "&amp;"
                }</span>
                <span class="cov0" title="0">_key := url.QueryEscape(key)
                requestUrl += _key

                _value := params[key]

                if conf.signature == "v4" </span><span class="cov0" title="0">{
                        requestUrl += "=" + url.QueryEscape(_value)
                }</span> else<span class="cov0" title="0"> {
                        if _value != "" </span><span class="cov0" title="0">{
                                requestUrl += "=" + url.QueryEscape(_value)
                                _value = "=" + _value
                        }</span> else<span class="cov0" title="0"> {
                                _value = ""
                        }</span>
                        <span class="cov0" title="0">lowerKey := strings.ToLower(key)
                        _, ok := allowed_resource_parameter_names[lowerKey]
                        ok = ok || strings.HasPrefix(lowerKey, HEADER_PREFIX)
                        if ok </span><span class="cov0" title="0">{
                                if i == 0 </span><span class="cov0" title="0">{
                                        canonicalizedUrl += "?"
                                }</span> else<span class="cov0" title="0"> {
                                        canonicalizedUrl += "&amp;"
                                }</span>
                                <span class="cov0" title="0">canonicalizedUrl += getQueryUrl(_key, _value)
                                i++</span>
                        }
                }
        }
        <span class="cov0" title="0">return</span>
}

func getQueryUrl(key, value string) string <span class="cov0" title="0">{
        queryUrl := ""
        queryUrl += key
        queryUrl += value
        return queryUrl
}</span>
</pre>

		<pre class="file" id="file5" style="display: none">package obs

import (
        "bytes"
        "fmt"
        "io"
        "io/ioutil"
        "net/http"
        "reflect"
        "strings"
        "time"

        log "github.com/sirupsen/logrus"
)

func cleanHeaderPrefix(header http.Header) map[string][]string <span class="cov0" title="0">{
        responseHeaders := make(map[string][]string)
        for key, value := range header </span><span class="cov0" title="0">{
                if len(value) &gt; 0 </span><span class="cov0" title="0">{
                        key = strings.ToLower(key)
                        if strings.HasPrefix(key, HEADER_PREFIX) </span><span class="cov0" title="0">{
                                key = key[len(HEADER_PREFIX):]
                        }</span>
                        <span class="cov0" title="0">responseHeaders[key] = value</span>
                }
        }
        <span class="cov0" title="0">return responseHeaders</span>
}

func ParseStringToStorageClassType(value string) (ret StorageClassType) <span class="cov0" title="0">{
        switch value </span>{
        case "STANDARD":<span class="cov0" title="0">
                ret = StorageClassStandard</span>
        case "STANDARD_IA":<span class="cov0" title="0">
                ret = StorageClassWarm</span>
        case "GLACIER":<span class="cov0" title="0">
                ret = StorageClassCold</span>
        default:<span class="cov0" title="0">
                ret = ""</span>
        }
        <span class="cov0" title="0">return</span>
}

func convertGrantToXml(grant Grant) string <span class="cov0" title="0">{
        xml := make([]string, 0, 4)
        xml = append(xml, fmt.Sprintf("&lt;Grant&gt;&lt;Grantee xsi:type=\"%s\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"&gt;", grant.Grantee.Type))
        if grant.Grantee.Type == GranteeUser </span><span class="cov0" title="0">{
                xml = append(xml, fmt.Sprintf("&lt;ID&gt;%s&lt;/ID&gt;", grant.Grantee.ID))
                if grant.Grantee.DisplayName != "" </span><span class="cov0" title="0">{
                        xml = append(xml, fmt.Sprintf("&lt;DisplayName&gt;%s&lt;/DisplayName&gt;", grant.Grantee.DisplayName))
                }</span>
        } else<span class="cov0" title="0"> {
                xml = append(xml, fmt.Sprintf("&lt;URI&gt;%s&lt;/URI&gt;", grant.Grantee.URI))
        }</span>
        <span class="cov0" title="0">xml = append(xml, fmt.Sprintf("&lt;/Grantee&gt;&lt;Permission&gt;%s&lt;/Permission&gt;&lt;/Grant&gt;", grant.Permission))
        return strings.Join(xml, "")</span>
}

func ConvertLoggingStatusToXml(input BucketLoggingStatus, returnMd5 bool) (data string, md5 string) <span class="cov0" title="0">{
        grantsLength := len(input.TargetGrants)
        xml := make([]string, 0, 8+grantsLength)

        xml = append(xml, "&lt;BucketLoggingStatus&gt;")
        if input.TargetBucket != "" || input.TargetPrefix != "" </span><span class="cov0" title="0">{
                xml = append(xml, "&lt;LoggingEnabled&gt;")
                xml = append(xml, fmt.Sprintf("&lt;TargetBucket&gt;%s&lt;/TargetBucket&gt;", input.TargetBucket))
                xml = append(xml, fmt.Sprintf("&lt;TargetPrefix&gt;%s&lt;/TargetPrefix&gt;", input.TargetPrefix))

                if grantsLength &gt; 0 </span><span class="cov0" title="0">{
                        xml = append(xml, "&lt;TargetGrants&gt;")
                        for _, grant := range input.TargetGrants </span><span class="cov0" title="0">{
                                xml = append(xml, convertGrantToXml(grant))
                        }</span>
                        <span class="cov0" title="0">xml = append(xml, "&lt;/TargetGrants&gt;")</span>
                }

                <span class="cov0" title="0">xml = append(xml, "&lt;/LoggingEnabled&gt;")</span>
        }
        <span class="cov0" title="0">xml = append(xml, "&lt;/BucketLoggingStatus&gt;")
        data = strings.Join(xml, "")
        if returnMd5 </span><span class="cov0" title="0">{
                md5 = Base64Md5([]byte(data))
        }</span>
        <span class="cov0" title="0">return</span>
}

func ConvertAclToXml(input AccessControlPolicy, returnMd5 bool) (data string, md5 string) <span class="cov0" title="0">{
        xml := make([]string, 0, 4+len(input.Grants))
        xml = append(xml, fmt.Sprintf("&lt;AccessControlPolicy&gt;&lt;Owner&gt;&lt;ID&gt;%s&lt;/ID&gt;", input.Owner.ID))
        if input.Owner.DisplayName != "" </span><span class="cov0" title="0">{
                xml = append(xml, fmt.Sprintf("&lt;DisplayName&gt;%s&lt;/DisplayName&gt;", input.Owner.DisplayName))
        }</span>
        <span class="cov0" title="0">xml = append(xml, "&lt;/Owner&gt;&lt;AccessControlList&gt;")
        for _, grant := range input.Grants </span><span class="cov0" title="0">{
                xml = append(xml, convertGrantToXml(grant))
        }</span>
        <span class="cov0" title="0">xml = append(xml, "&lt;/AccessControlList&gt;&lt;/AccessControlPolicy&gt;")
        data = strings.Join(xml, "")
        if returnMd5 </span><span class="cov0" title="0">{
                md5 = Base64Md5([]byte(data))
        }</span>
        <span class="cov0" title="0">return</span>
}

func convertConditionToXml(condition Condition) string <span class="cov0" title="0">{
        xml := make([]string, 0, 2)
        if condition.KeyPrefixEquals != "" </span><span class="cov0" title="0">{
                xml = append(xml, fmt.Sprintf("&lt;KeyPrefixEquals&gt;%s&lt;/KeyPrefixEquals&gt;", condition.KeyPrefixEquals))
        }</span>
        <span class="cov0" title="0">if condition.HttpErrorCodeReturnedEquals != "" </span><span class="cov0" title="0">{
                xml = append(xml, fmt.Sprintf("&lt;HttpErrorCodeReturnedEquals&gt;%s&lt;/HttpErrorCodeReturnedEquals&gt;", condition.HttpErrorCodeReturnedEquals))
        }</span>
        <span class="cov0" title="0">if len(xml) &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Sprintf("&lt;Condition&gt;%s&lt;/Condition&gt;", strings.Join(xml, ""))
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func ConvertWebsiteConfigurationToXml(input BucketWebsiteConfiguration, returnMd5 bool) (data string, md5 string) <span class="cov0" title="0">{
        routingRuleLength := len(input.RoutingRules)
        xml := make([]string, 0, 6+routingRuleLength*10)
        xml = append(xml, "&lt;WebsiteConfiguration&gt;")

        if input.RedirectAllRequestsTo.HostName != "" </span><span class="cov0" title="0">{
                xml = append(xml, fmt.Sprintf("&lt;RedirectAllRequestsTo&gt;&lt;HostName&gt;%s&lt;/HostName&gt;", input.RedirectAllRequestsTo.HostName))
                if input.RedirectAllRequestsTo.Protocol != "" </span><span class="cov0" title="0">{
                        xml = append(xml, fmt.Sprintf("&lt;Protocol&gt;%s&lt;/Protocol&gt;", input.RedirectAllRequestsTo.Protocol))
                }</span>
                <span class="cov0" title="0">xml = append(xml, "&lt;/RedirectAllRequestsTo&gt;")</span>
        } else<span class="cov0" title="0"> {
                xml = append(xml, fmt.Sprintf("&lt;IndexDocument&gt;&lt;Suffix&gt;%s&lt;/Suffix&gt;&lt;/IndexDocument&gt;", input.IndexDocument.Suffix))
                if input.ErrorDocument.Key != "" </span><span class="cov0" title="0">{
                        xml = append(xml, fmt.Sprintf("&lt;ErrorDocument&gt;&lt;Key&gt;%s&lt;/Key&gt;&lt;/ErrorDocument&gt;", input.ErrorDocument.Key))
                }</span>
                <span class="cov0" title="0">if routingRuleLength &gt; 0 </span><span class="cov0" title="0">{
                        xml = append(xml, "&lt;RoutingRules&gt;")
                        for _, routingRule := range input.RoutingRules </span><span class="cov0" title="0">{
                                xml = append(xml, "&lt;RoutingRule&gt;")
                                xml = append(xml, "&lt;Redirect&gt;")
                                if routingRule.Redirect.Protocol != "" </span><span class="cov0" title="0">{
                                        xml = append(xml, fmt.Sprintf("&lt;Protocol&gt;%s&lt;/Protocol&gt;", routingRule.Redirect.Protocol))
                                }</span>
                                <span class="cov0" title="0">if routingRule.Redirect.HostName != "" </span><span class="cov0" title="0">{
                                        xml = append(xml, fmt.Sprintf("&lt;HostName&gt;%s&lt;/HostName&gt;", routingRule.Redirect.HostName))
                                }</span>
                                <span class="cov0" title="0">if routingRule.Redirect.ReplaceKeyPrefixWith != "" </span><span class="cov0" title="0">{
                                        xml = append(xml, fmt.Sprintf("&lt;ReplaceKeyPrefixWith&gt;%s&lt;/ReplaceKeyPrefixWith&gt;", routingRule.Redirect.ReplaceKeyPrefixWith))
                                }</span>

                                <span class="cov0" title="0">if routingRule.Redirect.ReplaceKeyWith != "" </span><span class="cov0" title="0">{
                                        xml = append(xml, fmt.Sprintf("&lt;ReplaceKeyWith&gt;%s&lt;/ReplaceKeyWith&gt;", routingRule.Redirect.ReplaceKeyWith))
                                }</span>
                                <span class="cov0" title="0">if routingRule.Redirect.HttpRedirectCode != "" </span><span class="cov0" title="0">{
                                        xml = append(xml, fmt.Sprintf("&lt;HttpRedirectCode&gt;%s&lt;/HttpRedirectCode&gt;", routingRule.Redirect.HttpRedirectCode))
                                }</span>
                                <span class="cov0" title="0">xml = append(xml, "&lt;/Redirect&gt;")

                                if ret := convertConditionToXml(routingRule.Condition); ret != "" </span><span class="cov0" title="0">{
                                        xml = append(xml, ret)
                                }</span>
                                <span class="cov0" title="0">xml = append(xml, "&lt;/RoutingRule&gt;")</span>
                        }
                        <span class="cov0" title="0">xml = append(xml, "&lt;/RoutingRules&gt;")</span>
                }
        }

        <span class="cov0" title="0">xml = append(xml, "&lt;/WebsiteConfiguration&gt;")
        data = strings.Join(xml, "")
        if returnMd5 </span><span class="cov0" title="0">{
                md5 = Base64Md5([]byte(data))
        }</span>
        <span class="cov0" title="0">return</span>
}

func convertTransitionsToXml(transitions []Transition) string <span class="cov0" title="0">{
        if length := len(transitions); length &gt; 0 </span><span class="cov0" title="0">{
                xml := make([]string, 0, length)
                for _, transition := range transitions </span><span class="cov0" title="0">{
                        var temp string
                        if transition.Days &gt; 0 </span><span class="cov0" title="0">{
                                temp = fmt.Sprintf("&lt;Days&gt;%d&lt;/Days&gt;", transition.Days)
                        }</span> else<span class="cov0" title="0"> if !transition.Date.IsZero() </span><span class="cov0" title="0">{
                                temp = fmt.Sprintf("&lt;Date&gt;%s&lt;/Date&gt;", transition.Date.UTC().Format(ISO8601_MIDNIGHT_DATE_FORMAT))
                        }</span>
                        <span class="cov0" title="0">if temp != "" </span><span class="cov0" title="0">{
                                xml = append(xml, fmt.Sprintf("&lt;Transition&gt;%s&lt;StorageClass&gt;%s&lt;/StorageClass&gt;&lt;/Transition&gt;", temp, transition.StorageClass))
                        }</span>
                }
                <span class="cov0" title="0">return strings.Join(xml, "")</span>
        }
        <span class="cov0" title="0">return ""</span>
}

func convertExpirationToXml(expiration Expiration) string <span class="cov0" title="0">{
        if expiration.Days &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Sprintf("&lt;Expiration&gt;&lt;Days&gt;%d&lt;/Days&gt;&lt;/Expiration&gt;", expiration.Days)
        }</span> else<span class="cov0" title="0"> if !expiration.Date.IsZero() </span><span class="cov0" title="0">{
                return fmt.Sprintf("&lt;Expiration&gt;&lt;Date&gt;%s&lt;/Date&gt;&lt;/Expiration&gt;", expiration.Date.UTC().Format(ISO8601_MIDNIGHT_DATE_FORMAT))
        }</span>
        <span class="cov0" title="0">return ""</span>
}
func convertNoncurrentVersionTransitionsToXml(noncurrentVersionTransitions []NoncurrentVersionTransition) string <span class="cov0" title="0">{
        if length := len(noncurrentVersionTransitions); length &gt; 0 </span><span class="cov0" title="0">{
                xml := make([]string, 0, length)
                for _, noncurrentVersionTransition := range noncurrentVersionTransitions </span><span class="cov0" title="0">{
                        if noncurrentVersionTransition.NoncurrentDays &gt; 0 </span><span class="cov0" title="0">{
                                xml = append(xml, fmt.Sprintf("&lt;NoncurrentVersionTransition&gt;&lt;NoncurrentDays&gt;%d&lt;/NoncurrentDays&gt;"+
                                        "&lt;StorageClass&gt;%s&lt;/StorageClass&gt;&lt;/NoncurrentVersionTransition&gt;",
                                        noncurrentVersionTransition.NoncurrentDays, noncurrentVersionTransition.StorageClass))
                        }</span>
                }
                <span class="cov0" title="0">return strings.Join(xml, "")</span>
        }
        <span class="cov0" title="0">return ""</span>
}
func convertNoncurrentVersionExpirationToXml(noncurrentVersionExpiration NoncurrentVersionExpiration) string <span class="cov0" title="0">{
        if noncurrentVersionExpiration.NoncurrentDays &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Sprintf("&lt;NoncurrentVersionExpiration&gt;&lt;NoncurrentDays&gt;%d&lt;/NoncurrentDays&gt;&lt;/NoncurrentVersionExpiration&gt;", noncurrentVersionExpiration.NoncurrentDays)
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func ConvertLifecyleConfigurationToXml(input BucketLifecyleConfiguration, returnMd5 bool) (data string, md5 string) <span class="cov0" title="0">{
        xml := make([]string, 0, 2+len(input.LifecycleRules)*9)
        xml = append(xml, "&lt;LifecycleConfiguration&gt;")
        for _, lifecyleRule := range input.LifecycleRules </span><span class="cov0" title="0">{
                xml = append(xml, "&lt;Rule&gt;")
                if lifecyleRule.ID != "" </span><span class="cov0" title="0">{
                        xml = append(xml, fmt.Sprintf("&lt;ID&gt;%s&lt;/ID&gt;", lifecyleRule.ID))
                }</span>
                <span class="cov0" title="0">xml = append(xml, fmt.Sprintf("&lt;Prefix&gt;%s&lt;/Prefix&gt;", lifecyleRule.Prefix))
                xml = append(xml, fmt.Sprintf("&lt;Status&gt;%s&lt;/Status&gt;", lifecyleRule.Status))
                if ret := convertTransitionsToXml(lifecyleRule.Transitions); ret != "" </span><span class="cov0" title="0">{
                        xml = append(xml, ret)
                }</span>
                <span class="cov0" title="0">if ret := convertExpirationToXml(lifecyleRule.Expiration); ret != "" </span><span class="cov0" title="0">{
                        xml = append(xml, ret)
                }</span>
                <span class="cov0" title="0">if ret := convertNoncurrentVersionTransitionsToXml(lifecyleRule.NoncurrentVersionTransitions); ret != "" </span><span class="cov0" title="0">{
                        xml = append(xml, ret)
                }</span>
                <span class="cov0" title="0">if ret := convertNoncurrentVersionExpirationToXml(lifecyleRule.NoncurrentVersionExpiration); ret != "" </span><span class="cov0" title="0">{
                        xml = append(xml, ret)
                }</span>
                <span class="cov0" title="0">xml = append(xml, "&lt;/Rule&gt;")</span>
        }
        <span class="cov0" title="0">xml = append(xml, "&lt;/LifecycleConfiguration&gt;")
        data = strings.Join(xml, "")
        if returnMd5 </span><span class="cov0" title="0">{
                md5 = Base64Md5([]byte(data))
        }</span>
        <span class="cov0" title="0">return</span>
}

func converntFilterRulesToXml(filterRules []FilterRule) string <span class="cov0" title="0">{
        if length := len(filterRules); length &gt; 0 </span><span class="cov0" title="0">{
                xml := make([]string, 0, length*4)
                for _, filterRule := range filterRules </span><span class="cov0" title="0">{
                        xml = append(xml, "&lt;FilterRule&gt;")
                        if filterRule.Name != "" </span><span class="cov0" title="0">{
                                xml = append(xml, fmt.Sprintf("&lt;Name&gt;%s&lt;/Name&gt;", filterRule.Name))
                        }</span>
                        <span class="cov0" title="0">if filterRule.Value != "" </span><span class="cov0" title="0">{
                                xml = append(xml, fmt.Sprintf("&lt;Value&gt;%s&lt;/Value&gt;", filterRule.Value))
                        }</span>
                        <span class="cov0" title="0">xml = append(xml, "&lt;/FilterRule&gt;")</span>
                }
                <span class="cov0" title="0">return fmt.Sprintf("&lt;Filter&gt;&lt;S3Key&gt;%s&lt;/S3Key&gt;&lt;/Filter&gt;", strings.Join(xml, ""))</span>
        }
        <span class="cov0" title="0">return ""</span>
}

func converntEventsToXml(events []string) string <span class="cov0" title="0">{
        if length := len(events); length &gt; 0 </span><span class="cov0" title="0">{
                xml := make([]string, 0, length)
                for _, event := range events </span><span class="cov0" title="0">{
                        xml = append(xml, fmt.Sprintf("&lt;Event&gt;%s&lt;/Event&gt;", event))
                }</span>
                <span class="cov0" title="0">return strings.Join(xml, "")</span>
        }
        <span class="cov0" title="0">return ""</span>
}

func ConvertNotificationToXml(input BucketNotification, returnMd5 bool) (data string, md5 string) <span class="cov0" title="0">{
        xml := make([]string, 0, 2+len(input.TopicConfigurations)*6)
        xml = append(xml, "&lt;NotificationConfiguration&gt;")
        for _, topicConfiguration := range input.TopicConfigurations </span><span class="cov0" title="0">{
                xml = append(xml, "&lt;TopicConfiguration&gt;")
                if topicConfiguration.ID != "" </span><span class="cov0" title="0">{
                        xml = append(xml, fmt.Sprintf("&lt;Id&gt;%s&lt;/Id&gt;", topicConfiguration.ID))
                }</span>
                <span class="cov0" title="0">xml = append(xml, fmt.Sprintf("&lt;Topic&gt;%s&lt;/Topic&gt;", topicConfiguration.Topic))

                if ret := converntEventsToXml(topicConfiguration.Events); ret != "" </span><span class="cov0" title="0">{
                        xml = append(xml, ret)
                }</span>
                <span class="cov0" title="0">if ret := converntFilterRulesToXml(topicConfiguration.FilterRules); ret != "" </span><span class="cov0" title="0">{
                        xml = append(xml, ret)
                }</span>
                <span class="cov0" title="0">xml = append(xml, "&lt;/TopicConfiguration&gt;")</span>
        }
        <span class="cov0" title="0">xml = append(xml, "&lt;/NotificationConfiguration&gt;")
        data = strings.Join(xml, "")
        if returnMd5 </span><span class="cov0" title="0">{
                md5 = Base64Md5([]byte(data))
        }</span>
        <span class="cov0" title="0">return</span>
}

func ConvertCompleteMultipartUploadInputToXml(input CompleteMultipartUploadInput, returnMd5 bool) (data string, md5 string) <span class="cov0" title="0">{
        xml := make([]string, 0, 2+len(input.Parts)*4)
        xml = append(xml, "&lt;CompleteMultipartUpload&gt;")
        for _, part := range input.Parts </span><span class="cov0" title="0">{
                xml = append(xml, "&lt;Part&gt;")
                xml = append(xml, fmt.Sprintf("&lt;PartNumber&gt;%d&lt;/PartNumber&gt;", part.PartNumber))
                xml = append(xml, fmt.Sprintf("&lt;ETag&gt;%s&lt;/ETag&gt;", part.ETag))
                xml = append(xml, "&lt;/Part&gt;")
        }</span>
        <span class="cov0" title="0">xml = append(xml, "&lt;/CompleteMultipartUpload&gt;")
        data = strings.Join(xml, "")
        if returnMd5 </span><span class="cov0" title="0">{
                md5 = Base64Md5([]byte(data))
        }</span>
        <span class="cov0" title="0">return</span>
}

func parseSseHeader(responseHeaders map[string][]string) (sseHeader ISseHeader) <span class="cov0" title="0">{
        if ret, ok := responseHeaders[HEADER_SSEC_ENCRYPTION]; ok </span><span class="cov0" title="0">{
                sseCHeader := SseCHeader{Encryption: ret[0]}
                if ret, ok = responseHeaders[HEADER_SSEC_KEY_MD5]; ok </span><span class="cov0" title="0">{
                        sseCHeader.KeyMD5 = ret[0]
                }</span>
                <span class="cov0" title="0">sseHeader = sseCHeader</span>
        } else<span class="cov0" title="0"> if ret, ok := responseHeaders[HEADER_SSEKMS_ENCRYPTION]; ok </span><span class="cov0" title="0">{
                sseKmsHeader := SseKmsHeader{Encryption: ret[0]}
                if ret, ok = responseHeaders[HEADER_SSEKMS_KEY]; ok </span><span class="cov0" title="0">{
                        sseKmsHeader.Key = ret[0]
                }</span>
                <span class="cov0" title="0">sseHeader = sseKmsHeader</span>
        }
        <span class="cov0" title="0">return</span>
}

func ParseGetObjectMetadataOutput(output *GetObjectMetadataOutput) <span class="cov0" title="0">{
        if ret, ok := output.ResponseHeaders[HEADER_VERSION_ID]; ok </span><span class="cov0" title="0">{
                output.VersionId = ret[0]
        }</span>
        <span class="cov0" title="0">if ret, ok := output.ResponseHeaders[HEADER_WEBSITE_REDIRECT_LOCATION]; ok </span><span class="cov0" title="0">{
                output.WebsiteRedirectLocation = ret[0]
        }</span>
        <span class="cov0" title="0">if ret, ok := output.ResponseHeaders[HEADER_EXPIRATION]; ok </span><span class="cov0" title="0">{
                output.Expiration = ret[0]
        }</span>
        <span class="cov0" title="0">if ret, ok := output.ResponseHeaders[HEADER_RESTORE]; ok </span><span class="cov0" title="0">{
                output.Restore = ret[0]
        }</span>

        <span class="cov0" title="0">if ret, ok := output.ResponseHeaders[HEADER_STORAGE_CLASS2]; ok </span><span class="cov0" title="0">{
                output.StorageClass = ParseStringToStorageClassType(ret[0])
        }</span>
        <span class="cov0" title="0">if ret, ok := output.ResponseHeaders[HEADER_ETAG]; ok </span><span class="cov0" title="0">{
                output.ETag = ret[0]
        }</span>
        <span class="cov0" title="0">if ret, ok := output.ResponseHeaders[HEADER_CONTENT_TYPE]; ok </span><span class="cov0" title="0">{
                output.ContentType = ret[0]
        }</span>
        <span class="cov0" title="0">if ret, ok := output.ResponseHeaders[HEADER_ACCESS_CONRTOL_ALLOW_ORIGIN]; ok </span><span class="cov0" title="0">{
                output.AllowOrigin = ret[0]
        }</span>
        <span class="cov0" title="0">if ret, ok := output.ResponseHeaders[HEADER_ACCESS_CONRTOL_ALLOW_HEADERS]; ok </span><span class="cov0" title="0">{
                output.AllowHeader = ret[0]
        }</span>
        <span class="cov0" title="0">if ret, ok := output.ResponseHeaders[HEADER_ACCESS_CONRTOL_MAX_AGE]; ok </span><span class="cov0" title="0">{
                output.MaxAgeSeconds = StringToInt(ret[0], 0)
        }</span>
        <span class="cov0" title="0">if ret, ok := output.ResponseHeaders[HEADER_ACCESS_CONRTOL_ALLOW_METHODS]; ok </span><span class="cov0" title="0">{
                output.AllowMethod = ret[0]
        }</span>
        <span class="cov0" title="0">if ret, ok := output.ResponseHeaders[HEADER_ACCESS_CONRTOL_EXPOSE_HEADERS]; ok </span><span class="cov0" title="0">{
                output.ExposeHeader = ret[0]
        }</span>

        <span class="cov0" title="0">output.SseHeader = parseSseHeader(output.ResponseHeaders)
        if ret, ok := output.ResponseHeaders[HEADER_LASTMODIFIED]; ok </span><span class="cov0" title="0">{
                ret, err := time.Parse(time.RFC1123, ret[0])
                if err == nil </span><span class="cov0" title="0">{
                        output.LastModified = ret
                }</span>
        }
        <span class="cov0" title="0">if ret, ok := output.ResponseHeaders[HEADER_CONTENT_LENGTH]; ok </span><span class="cov0" title="0">{
                output.ContentLength = StringToInt64(ret[0], 0)
        }</span>

        <span class="cov0" title="0">output.Metadata = make(map[string]string)

        for key, value := range output.ResponseHeaders </span><span class="cov0" title="0">{
                if strings.HasPrefix(key, PREFIX_META) </span><span class="cov0" title="0">{
                        _key := key[len(PREFIX_META):]
                        output.ResponseHeaders[_key] = value
                        output.Metadata[_key] = value[0]
                        delete(output.ResponseHeaders, key)
                }</span>
        }

}

func ParseCopyObjectOutput(output *CopyObjectOutput) <span class="cov0" title="0">{
        if ret, ok := output.ResponseHeaders[HEADER_VERSION_ID]; ok </span><span class="cov0" title="0">{
                output.VersionId = ret[0]
        }</span>
        <span class="cov0" title="0">output.SseHeader = parseSseHeader(output.ResponseHeaders)
        if ret, ok := output.ResponseHeaders[HEADER_COPY_SOURCE_VERSION_ID]; ok </span><span class="cov0" title="0">{
                output.CopySourceVersionId = ret[0]
        }</span>
}

func ParsePutObjectOutput(output *PutObjectOutput) <span class="cov0" title="0">{
        if ret, ok := output.ResponseHeaders[HEADER_VERSION_ID]; ok </span><span class="cov0" title="0">{
                output.VersionId = ret[0]
        }</span>
        <span class="cov0" title="0">output.SseHeader = parseSseHeader(output.ResponseHeaders)
        if ret, ok := output.ResponseHeaders[HEADER_STORAGE_CLASS2]; ok </span><span class="cov0" title="0">{
                output.StorageClass = ParseStringToStorageClassType(ret[0])
        }</span>

        <span class="cov0" title="0">if ret, ok := output.ResponseHeaders[HEADER_ETAG]; ok </span><span class="cov0" title="0">{
                output.ETag = ret[0]
        }</span>
}

func ParseInitiateMultipartUploadOutput(output *InitiateMultipartUploadOutput) <span class="cov0" title="0">{
        output.SseHeader = parseSseHeader(output.ResponseHeaders)
}</span>

func ParseUploadPartOutput(output *UploadPartOutput) <span class="cov0" title="0">{
        output.SseHeader = parseSseHeader(output.ResponseHeaders)
        if ret, ok := output.ResponseHeaders[HEADER_ETAG]; ok </span><span class="cov0" title="0">{
                output.ETag = ret[0]
        }</span>
}

func ParseCompleteMultipartUploadOutput(output *CompleteMultipartUploadOutput) <span class="cov0" title="0">{
        output.SseHeader = parseSseHeader(output.ResponseHeaders)
        if ret, ok := output.ResponseHeaders[HEADER_VERSION_ID]; ok </span><span class="cov0" title="0">{
                output.VersionId = ret[0]
        }</span>
}

func ParseCopyPartOutput(output *CopyPartOutput) <span class="cov0" title="0">{
        output.SseHeader = parseSseHeader(output.ResponseHeaders)
}</span>

func ParseGetBucketMetadataOutput(output *GetBucketMetadataOutput) <span class="cov0" title="0">{
        if ret, ok := output.ResponseHeaders[HEADER_STORAGE_CLASS]; ok </span><span class="cov0" title="0">{
                output.StorageClass = ParseStringToStorageClassType(ret[0])
        }</span>
        <span class="cov0" title="0">if ret, ok := output.ResponseHeaders[HEADER_BUCKET_REGION]; ok </span><span class="cov0" title="0">{
                output.Location = ret[0]
        }</span>
        <span class="cov0" title="0">if ret, ok := output.ResponseHeaders[HEADER_ACCESS_CONRTOL_ALLOW_ORIGIN]; ok </span><span class="cov0" title="0">{
                output.AllowOrigin = ret[0]
        }</span>
        <span class="cov0" title="0">if ret, ok := output.ResponseHeaders[HEADER_ACCESS_CONRTOL_ALLOW_HEADERS]; ok </span><span class="cov0" title="0">{
                output.AllowHeader = ret[0]
        }</span>
        <span class="cov0" title="0">if ret, ok := output.ResponseHeaders[HEADER_ACCESS_CONRTOL_MAX_AGE]; ok </span><span class="cov0" title="0">{
                output.MaxAgeSeconds = StringToInt(ret[0], 0)
        }</span>
        <span class="cov0" title="0">if ret, ok := output.ResponseHeaders[HEADER_ACCESS_CONRTOL_ALLOW_METHODS]; ok </span><span class="cov0" title="0">{
                output.AllowMethod = ret[0]
        }</span>
        <span class="cov0" title="0">if ret, ok := output.ResponseHeaders[HEADER_ACCESS_CONRTOL_EXPOSE_HEADERS]; ok </span><span class="cov0" title="0">{
                output.ExposeHeader = ret[0]
        }</span>
}

func ParseDeleteObjectOutput(output *DeleteObjectOutput) <span class="cov0" title="0">{
        if versionId, ok := output.ResponseHeaders[HEADER_VERSION_ID]; ok </span><span class="cov0" title="0">{
                output.VersionId = versionId[0]
        }</span>

        <span class="cov0" title="0">if deleteMarker, ok := output.ResponseHeaders[HEADER_DELETE_MARKER]; ok </span><span class="cov0" title="0">{
                output.DeleteMarker = deleteMarker[0] == "true"
        }</span>
}

func ParseGetObjectOutput(output *GetObjectOutput) <span class="cov0" title="0">{
        ParseGetObjectMetadataOutput(&amp;output.GetObjectMetadataOutput)
        if ret, ok := output.ResponseHeaders[HEADER_DELETE_MARKER]; ok </span><span class="cov0" title="0">{
                output.DeleteMarker = ret[0] == "true"
        }</span>
        <span class="cov0" title="0">if ret, ok := output.ResponseHeaders[HEADER_CACHE_CONTROL]; ok </span><span class="cov0" title="0">{
                output.CacheControl = ret[0]
        }</span>
        <span class="cov0" title="0">if ret, ok := output.ResponseHeaders[HEADER_CONTENT_DISPOSITION]; ok </span><span class="cov0" title="0">{
                output.ContentDisposition = ret[0]
        }</span>
        <span class="cov0" title="0">if ret, ok := output.ResponseHeaders[HEADER_CONTENT_ENCODING]; ok </span><span class="cov0" title="0">{
                output.ContentEncoding = ret[0]
        }</span>
        <span class="cov0" title="0">if ret, ok := output.ResponseHeaders[HEADER_CONTENT_LANGUAGE]; ok </span><span class="cov0" title="0">{
                output.ContentLanguage = ret[0]
        }</span>
        <span class="cov0" title="0">if ret, ok := output.ResponseHeaders[HEADER_EXPIRES]; ok </span><span class="cov0" title="0">{
                output.Expires = ret[0]
        }</span>
}

func ConvertRequestToIoReaderV2(req interface{}) (io.Reader, string, error) <span class="cov0" title="0">{
        data, err := TransToXml(req)
        if err == nil </span><span class="cov0" title="0">{
                log.Debug("Do http request with data: %s", string(data))
                return bytes.NewReader(data), Base64Md5(data), nil
        }</span>
        <span class="cov0" title="0">return nil, "", err</span>
}

func ConvertRequestToIoReader(req interface{}) (io.Reader, error) <span class="cov0" title="0">{
        body, err := TransToXml(req)
        if err == nil </span><span class="cov0" title="0">{
                log.Debug("Do http request with data: %s", string(body))
                return bytes.NewReader(body), nil
        }</span>
        <span class="cov0" title="0">return nil, err</span>
}

func ParseResponseToBaseModel(resp *http.Response, baseModel IBaseModel, xmlResult bool) (err error) <span class="cov0" title="0">{
        readCloser, ok := baseModel.(IReadCloser)
        if !ok </span><span class="cov0" title="0">{
                defer resp.Body.Close()
                body, err := ioutil.ReadAll(resp.Body)
                if err == nil &amp;&amp; len(body) &gt; 0 </span><span class="cov0" title="0">{
                        if xmlResult </span><span class="cov0" title="0">{
                                err = ParseXml(body, baseModel)
                                if err != nil </span><span class="cov0" title="0">{
                                        log.Error("Unmarshal error: %v", err)
                                }</span>
                        } else<span class="cov0" title="0"> {
                                s := reflect.TypeOf(baseModel).Elem()
                                for i := 0; i &lt; s.NumField(); i++ </span><span class="cov0" title="0">{
                                        if s.Field(i).Tag == "body" </span><span class="cov0" title="0">{
                                                reflect.ValueOf(baseModel).Elem().FieldByName(s.Field(i).Name).SetString(string(body))
                                                break</span>
                                        }
                                }
                        }
                }
        } else<span class="cov0" title="0"> {
                readCloser.setReadCloser(resp.Body)
        }</span>

        <span class="cov0" title="0">baseModel.setStatusCode(resp.StatusCode)
        responseHeaders := cleanHeaderPrefix(resp.Header)
        baseModel.setResponseHeaders(responseHeaders)
        if values, ok := responseHeaders[HEADER_REQUEST_ID]; ok </span><span class="cov0" title="0">{
                baseModel.setRequestId(values[0])
        }</span>
        <span class="cov0" title="0">return</span>
}

func ParseResponseToObsError(resp *http.Response) error <span class="cov0" title="0">{
        obsError := ObsError{}
        ParseResponseToBaseModel(resp, &amp;obsError, true)
        obsError.Status = resp.Status
        return obsError
}</span>
</pre>

		<pre class="file" id="file6" style="display: none">package obs

import (
        "encoding/xml"
        "fmt"
)

type ObsError struct {
        BaseModel
        Status   string
        XMLName  xml.Name `xml:"Error"`
        Code     string   `xml:"Code"`
        Message  string   `xml:"Message"`
        Resource string   `xml:"Resource"`
        HostId   string   `xml:"HostId"`
}

func (err ObsError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("obs: service returned error: Status=%s, Code=%s, Message=%s, RequestId=%s",
                err.Status, err.Code, err.Message, err.RequestId)
}</span>
</pre>

		<pre class="file" id="file7" style="display: none">package obs

import (
        "bytes"
        "errors"
        "io"
        "math/rand"
        "net"
        "net/http"
        "net/url"
        "os"
        "strings"
        "time"

        log "github.com/sirupsen/logrus"
)

func prepareHeaders(headers map[string][]string, meta bool) map[string][]string <span class="cov0" title="0">{
        _headers := make(map[string][]string, len(headers))
        if headers != nil </span><span class="cov0" title="0">{
                for key, value := range headers </span><span class="cov0" title="0">{
                        key = strings.TrimSpace(key)
                        if key == "" </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">_key := strings.ToLower(key)
                        if _, ok := allowed_request_http_header_metadata_names[_key]; !ok &amp;&amp; !strings.HasPrefix(key, HEADER_PREFIX) </span><span class="cov0" title="0">{
                                if !meta </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov0" title="0">_key = HEADER_PREFIX_META + _key</span>
                        } else<span class="cov0" title="0"> {
                                _key = key
                        }</span>
                        <span class="cov0" title="0">_headers[_key] = value</span>
                }
        }
        <span class="cov0" title="0">return _headers</span>
}

func (obsClient ObsClient) doActionWithoutBucket(action, method string, input ISerializable, output IBaseModel) error <span class="cov0" title="0">{
        return obsClient.doAction(action, method, "", "", input, output, true, true)
}</span>

func (obsClient ObsClient) doActionWithBucketV2(action, method, bucketName string, input ISerializable, output IBaseModel) error <span class="cov0" title="0">{
        if strings.TrimSpace(bucketName) == "" </span><span class="cov0" title="0">{
                return errors.New("Bucket is empty")
        }</span>
        <span class="cov0" title="0">return obsClient.doAction(action, method, bucketName, "", input, output, false, true)</span>
}

func (obsClient ObsClient) doActionWithBucket(action, method, bucketName string, input ISerializable, output IBaseModel) error <span class="cov0" title="0">{
        if strings.TrimSpace(bucketName) == "" </span><span class="cov0" title="0">{
                return errors.New("Bucket is empty")
        }</span>
        <span class="cov0" title="0">return obsClient.doAction(action, method, bucketName, "", input, output, true, true)</span>
}

func (obsClient ObsClient) doActionWithBucketAndKey(action, method, bucketName, objectKey string, input ISerializable, output IBaseModel) error <span class="cov0" title="0">{
        return obsClient._doActionWithBucketAndKey(action, method, bucketName, objectKey, input, output, true)
}</span>

func (obsClient ObsClient) doActionWithBucketAndKeyUnRepeatable(action, method, bucketName, objectKey string, input ISerializable, output IBaseModel) error <span class="cov0" title="0">{
        return obsClient._doActionWithBucketAndKey(action, method, bucketName, objectKey, input, output, false)
}</span>

func (obsClient ObsClient) _doActionWithBucketAndKey(action, method, bucketName, objectKey string, input ISerializable, output IBaseModel, repeatable bool) error <span class="cov0" title="0">{
        if strings.TrimSpace(bucketName) == "" </span><span class="cov0" title="0">{
                return errors.New("Key is empty")
        }</span>
        <span class="cov0" title="0">if strings.TrimSpace(objectKey) == "" </span><span class="cov0" title="0">{
                return errors.New("Key is empty")
        }</span>
        <span class="cov0" title="0">return obsClient.doAction(action, method, bucketName, objectKey, input, output, true, repeatable)</span>
}

func (obsClient ObsClient) doAction(action, method, bucketName, objectKey string, input ISerializable, output IBaseModel, xmlResult bool, repeatable bool) error <span class="cov0" title="0">{

        var resp *http.Response
        var respError error
        log.Info("Enter method %s...", action)
        start := GetCurrentTimestamp()

        params, headers, data := input.trans()

        if params == nil </span><span class="cov0" title="0">{
                params = make(map[string]string)
        }</span>

        <span class="cov0" title="0">if headers == nil </span><span class="cov0" title="0">{
                headers = make(map[string][]string)
        }</span>

        <span class="cov0" title="0">switch method </span>{
        case HTTP_GET:<span class="cov0" title="0">
                resp, respError = obsClient.doHttpGet(bucketName, objectKey, params, headers, data, repeatable)</span>
        case HTTP_POST:<span class="cov0" title="0">
                resp, respError = obsClient.doHttpPost(bucketName, objectKey, params, headers, data, repeatable)</span>
        case HTTP_PUT:<span class="cov0" title="0">
                resp, respError = obsClient.doHttpPut(bucketName, objectKey, params, headers, data, repeatable)</span>
        case HTTP_DELETE:<span class="cov0" title="0">
                resp, respError = obsClient.doHttpDelete(bucketName, objectKey, params, headers, data, repeatable)</span>
        case HTTP_HEAD:<span class="cov0" title="0">
                resp, respError = obsClient.doHttpHead(bucketName, objectKey, params, headers, data, repeatable)</span>
        case HTTP_OPTIONS:<span class="cov0" title="0">
                resp, respError = obsClient.doHttpOptions(bucketName, objectKey, params, headers, data, repeatable)</span>
        default:<span class="cov0" title="0">
                respError = errors.New("Unexpect http method error")</span>
        }
        <span class="cov0" title="0">if respError == nil &amp;&amp; output != nil </span><span class="cov0" title="0">{
                respError = ParseResponseToBaseModel(resp, output, xmlResult)
                if respError != nil </span><span class="cov0" title="0">{
                        log.Warn("Parse response to BaseModel with error: %v", respError)
                }</span>
        } else<span class="cov0" title="0"> {
                log.Warn("Do http request with error: %v", respError)
        }</span>

        <span class="cov0" title="0">log.Debug("End method %s, obsclient cost %d ms", action, (GetCurrentTimestamp() - start))

        return respError</span>
}

func (obsClient ObsClient) doHttpGet(bucketName, objectKey string, params map[string]string,
        headers map[string][]string, data interface{}, repeatable bool) (*http.Response, error) <span class="cov0" title="0">{
        return obsClient.doHttp(HTTP_GET, bucketName, objectKey, params, prepareHeaders(headers, false), data, repeatable)
}</span>

func (obsClient ObsClient) doHttpHead(bucketName, objectKey string, params map[string]string,
        headers map[string][]string, data interface{}, repeatable bool) (*http.Response, error) <span class="cov0" title="0">{
        return obsClient.doHttp(HTTP_HEAD, bucketName, objectKey, params, prepareHeaders(headers, false), data, repeatable)
}</span>

func (obsClient ObsClient) doHttpOptions(bucketName, objectKey string, params map[string]string,
        headers map[string][]string, data interface{}, repeatable bool) (*http.Response, error) <span class="cov0" title="0">{
        return obsClient.doHttp(HTTP_OPTIONS, bucketName, objectKey, params, prepareHeaders(headers, false), data, repeatable)
}</span>

func (obsClient ObsClient) doHttpDelete(bucketName, objectKey string, params map[string]string,
        headers map[string][]string, data interface{}, repeatable bool) (*http.Response, error) <span class="cov0" title="0">{
        return obsClient.doHttp(HTTP_DELETE, bucketName, objectKey, params, prepareHeaders(headers, false), data, repeatable)
}</span>

func (obsClient ObsClient) doHttpPut(bucketName, objectKey string, params map[string]string,
        headers map[string][]string, data interface{}, repeatable bool) (*http.Response, error) <span class="cov0" title="0">{
        return obsClient.doHttp(HTTP_PUT, bucketName, objectKey, params, prepareHeaders(headers, true), data, repeatable)
}</span>

func (obsClient ObsClient) doHttpPost(bucketName, objectKey string, params map[string]string,
        headers map[string][]string, data interface{}, repeatable bool) (*http.Response, error) <span class="cov0" title="0">{
        return obsClient.doHttp(HTTP_POST, bucketName, objectKey, params, prepareHeaders(headers, true), data, repeatable)
}</span>

func (obsClient ObsClient) doHttpWithSignedUrl(action, method string, signedUrl string, actualSignedRequestHeaders http.Header, data io.Reader, output IBaseModel, xmlResult bool) (respError error) <span class="cov0" title="0">{
        req, err := http.NewRequest(method, signedUrl, data)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var resp *http.Response

        log.Info("Do %s with signedUrl %s...", action, signedUrl)

        req.Header = actualSignedRequestHeaders
        if value, ok := req.Header[HEADER_HOST_CAMEL]; ok </span><span class="cov0" title="0">{
                req.Host = value[0]
                delete(req.Header, HEADER_HOST_CAMEL)
        }</span> else<span class="cov0" title="0"> if value, ok := req.Header[HEADER_HOST]; ok </span><span class="cov0" title="0">{
                req.Host = value[0]
                delete(req.Header, HEADER_HOST)
        }</span>

        <span class="cov0" title="0">if value, ok := req.Header[HEADER_CONTENT_LENGTH_CAMEL]; ok </span><span class="cov0" title="0">{
                req.ContentLength = StringToInt64(value[0], -1)
                delete(req.Header, HEADER_CONTENT_LENGTH_CAMEL)
        }</span> else<span class="cov0" title="0"> if value, ok := req.Header[HEADER_CONTENT_LENGTH]; ok </span><span class="cov0" title="0">{
                req.ContentLength = StringToInt64(value[0], -1)
                delete(req.Header, HEADER_CONTENT_LENGTH)
        }</span>

        <span class="cov0" title="0">req.Header[HEADER_USER_AGENT_CAMEL] = []string{USER_AGENT}
        start := GetCurrentTimestamp()
        resp, err = obsClient.httpClient.Do(req)
        log.Info("Do http request cost %d ms", (GetCurrentTimestamp() - start))


        var msg interface{}
        if err != nil </span><span class="cov0" title="0">{
                respError = err
                resp = nil
        }</span> else<span class="cov0" title="0"> {
                log.Debug("Response headers: %v", resp.Header)
                if resp.StatusCode &gt;= 300 </span><span class="cov0" title="0">{
                        respError = ParseResponseToObsError(resp)
                        msg = resp.Status
                        resp = nil
                }</span> else<span class="cov0" title="0"> {
                        if output != nil </span><span class="cov0" title="0">{
                                respError = ParseResponseToBaseModel(resp, output, xmlResult)
                        }</span>
                        <span class="cov0" title="0">if respError != nil </span><span class="cov0" title="0">{
                                log.Warn("Parse response to BaseModel with error: %v", respError)
                        }</span>
                }
        }

        <span class="cov0" title="0">if msg != nil </span><span class="cov0" title="0">{
                log.Error("Failed to send request with reason:%v", msg)
        }</span>

        <span class="cov0" title="0">log.Debug("End method %s, obsclient cost %d ms", action, (GetCurrentTimestamp() - start))

        return</span>
}

func (obsClient ObsClient) doHttp(method, bucketName, objectKey string, params map[string]string,
        headers map[string][]string, data interface{}, repeatable bool) (resp *http.Response, respError error) <span class="cov0" title="0">{

        bucketName = strings.TrimSpace(bucketName)

        objectKey = strings.TrimSpace(objectKey)

        method = strings.ToUpper(method)

        var redirectUrl string
        var requestUrl string
        maxRetryCount := obsClient.conf.maxRetryCount

        var _data io.Reader
        if data != nil </span><span class="cov0" title="0">{
                if dataStr, ok := data.(string); ok </span><span class="cov0" title="0">{
                        log.Debug("Do http request with string: %s", dataStr)
                        headers["Content-Length"] = []string{IntToString(len(dataStr))}
                        _data = strings.NewReader(dataStr)
                }</span> else<span class="cov0" title="0"> if dataByte, ok := data.([]byte); ok </span><span class="cov0" title="0">{
                        log.Debug("Do http request with byte array")
                        headers["Content-Length"] = []string{IntToString(len(dataByte))}
                        _data = bytes.NewReader(dataByte)
                }</span> else<span class="cov0" title="0"> if dataReader, ok := data.(io.Reader); ok </span><span class="cov0" title="0">{
                        _data = dataReader
                }</span> else<span class="cov0" title="0"> {
                        log.Warn("Data is not a valid io.Reader")
                        return nil, errors.New("Data is not a valid io.Reader")
                }</span>
        }

        <span class="cov0" title="0">for i := 0; i &lt;= maxRetryCount; i++ </span><span class="cov0" title="0">{
                if redirectUrl != "" </span><span class="cov0" title="0">{
                        parsedRedirectUrl, err := url.Parse(redirectUrl)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">requestUrl, _ = obsClient.doAuth(method, bucketName, objectKey, params, headers, parsedRedirectUrl.Host)
                        if parsedRequestUrl, _ := url.Parse(requestUrl); parsedRequestUrl.RawQuery != "" &amp;&amp; parsedRedirectUrl.RawQuery == "" </span><span class="cov0" title="0">{
                                redirectUrl += "?" + parsedRequestUrl.RawQuery
                        }</span>
                        <span class="cov0" title="0">requestUrl = redirectUrl</span>
                } else<span class="cov0" title="0"> {
                        var err error
                        requestUrl, err = obsClient.doAuth(method, bucketName, objectKey, params, headers, "")
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                }

                <span class="cov0" title="0">req, err := http.NewRequest(method, requestUrl, _data)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">log.Debug("Do request with url [%s] and method [%s]", requestUrl, method)

                auth := headers[HEADER_AUTH_CAMEL]
                delete(headers, HEADER_AUTH_CAMEL)
                log.Debug("Request headers: %v", headers)
                headers[HEADER_AUTH_CAMEL] = auth

                for key, value := range headers </span><span class="cov0" title="0">{
                        if key == HEADER_HOST_CAMEL </span><span class="cov0" title="0">{
                                req.Host = value[0]
                                delete(headers, key)
                        }</span> else<span class="cov0" title="0"> if key == HEADER_CONTENT_LENGTH_CAMEL </span><span class="cov0" title="0">{
                                req.ContentLength = StringToInt64(value[0], -1)
                                delete(headers, key)
                        }</span> else<span class="cov0" title="0"> {
                                req.Header[key] = value
                        }</span>
                }

                <span class="cov0" title="0">req.Header[HEADER_USER_AGENT_CAMEL] = []string{USER_AGENT}

                start := GetCurrentTimestamp()
                resp, err = obsClient.httpClient.Do(req)
                log.Info("Do http request cost %d ms", (GetCurrentTimestamp() - start))

                var msg interface{}
                if err != nil </span><span class="cov0" title="0">{
                        msg = err
                        respError = err
                        resp = nil
                }</span> else<span class="cov0" title="0"> {
                        log.Debug("Response headers: %v", resp.Header)
                        if resp.StatusCode &lt; 300 </span><span class="cov0" title="0">{
                                break</span>
                        } else<span class="cov0" title="0"> if !repeatable || (resp.StatusCode &gt;= 400 &amp;&amp; resp.StatusCode &lt; 500) || resp.StatusCode == 304 </span><span class="cov0" title="0">{
                                respError = ParseResponseToObsError(resp)
                                resp = nil
                                break</span>
                        } else<span class="cov0" title="0"> if resp.StatusCode &gt;= 300 &amp;&amp; resp.StatusCode &lt; 400 </span><span class="cov0" title="0">{
                                if location := resp.Header.Get(HEADER_LOCATION_CAMEL); location != "" </span><span class="cov0" title="0">{
                                        redirectUrl = location
                                        log.Warn("Redirect request to %s", redirectUrl)
                                        msg = resp.Status
                                        maxRetryCount++
                                }</span> else<span class="cov0" title="0"> {
                                        respError = ParseResponseToObsError(resp)
                                        resp = nil
                                        break</span>
                                }
                        } else<span class="cov0" title="0"> {
                                msg = resp.Status
                        }</span>
                }
                <span class="cov0" title="0">if i != maxRetryCount </span><span class="cov0" title="0">{
                        if resp != nil </span><span class="cov0" title="0">{
                                resp.Body.Close()
                                resp = nil
                        }</span>
                        <span class="cov0" title="0">if _, ok := headers[HEADER_AUTH_CAMEL]; ok </span><span class="cov0" title="0">{
                                delete(headers, HEADER_AUTH_CAMEL)
                        }</span>
                        <span class="cov0" title="0">log.Warn("Failed to send request with reason:%v, will try again", msg)
                        if r, ok := _data.(*strings.Reader); ok </span><span class="cov0" title="0">{
                                r.Seek(0, 0)
                        }</span> else<span class="cov0" title="0"> if r, ok := _data.(*bytes.Reader); ok </span><span class="cov0" title="0">{
                                r.Seek(0, 0)
                        }</span> else<span class="cov0" title="0"> if r, ok := _data.(*fileReaderWrapper); ok </span><span class="cov0" title="0">{
                                fd, err := os.Open(r.filePath)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                                <span class="cov0" title="0">defer fd.Close()
                                fileReaderWrapper := &amp;fileReaderWrapper{filePath: r.filePath}
                                fileReaderWrapper.mark = r.mark
                                fileReaderWrapper.reader = fd
                                fileReaderWrapper.totalCount = r.totalCount
                                _data = fileReaderWrapper
                                fd.Seek(r.mark, 0)</span>
                        } else<span class="cov0" title="0"> if r, ok := _data.(*readerWrapper); ok </span><span class="cov0" title="0">{
                                r.seek(0, 0)
                        }</span>
                        <span class="cov0" title="0">time.Sleep(time.Duration(float64(i+2) * rand.Float64() * float64(time.Second)))</span>
                } else<span class="cov0" title="0"> {
                        log.Error("Failed to send request with reason:%v", msg)
                        if resp != nil </span><span class="cov0" title="0">{
                                respError = ParseResponseToObsError(resp)
                                resp = nil
                        }</span>
                }
        }
        <span class="cov0" title="0">return</span>
}

type connDelegate struct {
        conn          net.Conn
        socketTimeout time.Duration
        finalTimeout  time.Duration
}

func getConnDelegate(conn net.Conn, socketTimeout int, finalTimeout int) *connDelegate <span class="cov0" title="0">{
        return &amp;connDelegate{
                conn:          conn,
                socketTimeout: time.Second * time.Duration(socketTimeout),
                finalTimeout:  time.Second * time.Duration(finalTimeout),
        }
}</span>

func (delegate *connDelegate) Read(b []byte) (n int, err error) <span class="cov0" title="0">{
        delegate.SetReadDeadline(time.Now().Add(delegate.socketTimeout))
        n, err = delegate.conn.Read(b)
        delegate.SetReadDeadline(time.Now().Add(delegate.finalTimeout))
        return n, err
}</span>

func (delegate *connDelegate) Write(b []byte) (n int, err error) <span class="cov0" title="0">{
        delegate.SetWriteDeadline(time.Now().Add(delegate.socketTimeout))
        n, err = delegate.conn.Write(b)
        finalTimeout := time.Now().Add(delegate.finalTimeout)
        delegate.SetWriteDeadline(finalTimeout)
        delegate.SetReadDeadline(finalTimeout)
        return n, err
}</span>

func (delegate *connDelegate) Close() error <span class="cov0" title="0">{
        return delegate.conn.Close()
}</span>

func (delegate *connDelegate) LocalAddr() net.Addr <span class="cov0" title="0">{
        return delegate.conn.LocalAddr()
}</span>

func (delegate *connDelegate) RemoteAddr() net.Addr <span class="cov0" title="0">{
        return delegate.conn.RemoteAddr()
}</span>

func (delegate *connDelegate) SetDeadline(t time.Time) error <span class="cov0" title="0">{
        return delegate.conn.SetDeadline(t)
}</span>

func (delegate *connDelegate) SetReadDeadline(t time.Time) error <span class="cov0" title="0">{
        return delegate.conn.SetReadDeadline(t)
}</span>

func (delegate *connDelegate) SetWriteDeadline(t time.Time) error <span class="cov0" title="0">{
        return delegate.conn.SetWriteDeadline(t)
}</span>
</pre>

		<pre class="file" id="file8" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package obs

import (
        "fmt"
        "io"
        "log"
        "os"
        "os/user"
        "path/filepath"
        "strconv"
        "strings"
        "time"

        "github.com/go-ini/ini"
        "github.com/sirupsen/logrus"
        "gopkg.in/natefinch/lumberjack.v2"
)

type LogFormatter struct {
        TimestampFormat string
        LogFormat       string
}

const (
        debugLevel             = "debug"
        infoLevel              = "info"
        warnLevel              = "warn"
        errorLevel             = "error"
        path                   = "path"
        level                  = "level"
        format                 = "format"
        defaultLogPath         = "/var/log/multi-cloud"
        defaultLogLevel        = "info"
        unknownHost            = "unknownhost"
        unknownUser            = "unknownuser"
        configFileName         = "/etc/multi-cloud/multi-cloud.conf"
        defaultLogFormat       = "[%time%] [%level%] [%filename%] [%funcName%():%lineNo%] [PID:%process%] %message%"
        defaultTimestampFormat = time.RFC3339
        logSection             = "log"
        tenMb                  = 10
        threeMonth             = 100
)

func InitLogs() <span class="cov8" title="1">{
        path, level, format := readConfigurationFile()
        configureLogModule(path, level, format)
}</span>

func configureLogModule(path, level, format string) <span class="cov8" title="1">{
        configureWriter(path, format)
        configureLevel(level)
}</span>

func configureWriter(path, format string) <span class="cov8" title="1">{
        logrus.SetFormatter(&amp;LogFormatter{
                TimestampFormat: defaultTimestampFormat,
                LogFormat:       format + "\n",
        })
        fileWriter := &amp;lumberjack.Logger{
                Filename: filepath.Join(path, logName()),
                MaxSize:  tenMb,
                MaxAge:   threeMonth,
                Compress: true,
        }
        multiWriter := io.MultiWriter(os.Stdout, fileWriter)
        logrus.SetOutput(multiWriter)
}</span>

func configureLevel(level string) <span class="cov8" title="1">{
        switch level </span>{
        case debugLevel:<span class="cov8" title="1">
                logrus.SetLevel(logrus.DebugLevel)</span>
        case infoLevel:<span class="cov0" title="0">
                logrus.SetLevel(logrus.InfoLevel)</span>
        case warnLevel:<span class="cov0" title="0">
                logrus.SetLevel(logrus.WarnLevel)</span>
        case errorLevel:<span class="cov0" title="0">
                logrus.SetLevel(logrus.ErrorLevel)</span>
        }
        <span class="cov8" title="1">logrus.SetReportCaller(true)</span>
}

func logName() (name string) <span class="cov8" title="1">{
        name = fmt.Sprintf("%s.%s.%s.log",
                filepath.Base(os.Args[0]),
                hostName(),
                userName())
        return name
}</span>

func shortHostname(hostname string) string <span class="cov8" title="1">{
        if i := strings.Index(hostname, "."); i &gt;= 0 </span><span class="cov0" title="0">{
                return hostname[:i]
        }</span>
        <span class="cov8" title="1">return hostname</span>
}

func hostName() string <span class="cov8" title="1">{
        host := unknownHost
        h, err := os.Hostname()
        if err == nil </span><span class="cov8" title="1">{
                host = shortHostname(h)
        }</span>
        <span class="cov8" title="1">return host</span>
}

func userName() string <span class="cov8" title="1">{
        userName := unknownUser
        current, err := user.Current()
        if err == nil </span><span class="cov8" title="1">{
                userName = current.Username
        }</span>
        // Sanitize userName since it may contain filepath separators on Windows.
        <span class="cov8" title="1">userName = strings.Replace(userName, `\`, "_", -1)
        return userName</span>
}

func readConfigurationFile() (cfgPath, cfgLevel, cfgFormat string) <span class="cov8" title="1">{
        cfgPath = defaultLogPath
        cfgLevel = defaultLogLevel
        cfgFormat = defaultLogFormat
        cfg, err := ini.Load(configFileName)
        if err != nil </span><span class="cov0" title="0">{
                log.Println("Failed to open config file")
                return cfgPath, cfgLevel, cfgFormat
        }</span>
        <span class="cov8" title="1">if cfg.Section(logSection).HasKey(path) </span><span class="cov8" title="1">{
                cfgPath = cfg.Section(logSection).Key(path).String()
        }</span>
        <span class="cov8" title="1">if cfg.Section(logSection).HasKey(level) </span><span class="cov8" title="1">{
                cfgLevel = strings.ToLower(cfg.Section(logSection).Key(level).String())
        }</span>
        <span class="cov8" title="1">if cfg.Section(logSection).HasKey(format) </span><span class="cov8" title="1">{
                cfgFormat = cfg.Section(logSection).Key(format).String()
        }</span>

        <span class="cov8" title="1">return cfgPath, cfgLevel, cfgFormat</span>
}

func (f *LogFormatter) Format(entry *logrus.Entry) ([]byte, error) <span class="cov8" title="1">{
        output := f.LogFormat
        if output == "" </span><span class="cov0" title="0">{
                output = defaultLogFormat
        }</span>

        <span class="cov8" title="1">timestampFormat := f.TimestampFormat
        if timestampFormat == "" </span><span class="cov0" title="0">{
                timestampFormat = defaultTimestampFormat
        }</span>

        <span class="cov8" title="1">output = strings.Replace(output, "%time%", entry.Time.Format(timestampFormat), 1)

        output = strings.Replace(output, "%message%", entry.Message, 1)

        level := strings.ToUpper(entry.Level.String())
        output = strings.Replace(output, "%level%", level, 1)

        output = strings.Replace(output, "%process%", strconv.Itoa(os.Getpid()), 1)

        output = strings.Replace(output, "%filename%", entry.Caller.File, 1)
        output = strings.Replace(output, "%lineNo%", strconv.Itoa(entry.Caller.Line), 1)
        funcName := entry.Caller.Function
        if strings.Contains(funcName, "/") </span><span class="cov8" title="1">{
                funcName = string([]byte(funcName)[strings.LastIndex(funcName, "/")+1:])
        }</span>
        <span class="cov8" title="1">output = strings.Replace(output, "%funcName%", funcName, 1)

        return []byte(output), nil</span>
}
</pre>

		<pre class="file" id="file9" style="display: none">package obs

import (
        "errors"
        "fmt"
        "io"
        "net/http"
        "os"
        "strings"
        "time"
)

func (obsClient ObsClient) CreateSignedUrl(input *CreateSignedUrlInput) (output *CreateSignedUrlOutput, err error) <span class="cov0" title="0">{
        if input == nil </span><span class="cov0" title="0">{
                return nil, errors.New("CreateSignedUrlInput is nil")
        }</span>

        <span class="cov0" title="0">params := make(map[string]string, len(input.QueryParams))
        for key, value := range input.QueryParams </span><span class="cov0" title="0">{
                params[key] = value
        }</span>

        <span class="cov0" title="0">if input.SubResource != "" </span><span class="cov0" title="0">{
                params[string(input.SubResource)] = ""
        }</span>

        <span class="cov0" title="0">headers := make(map[string][]string, len(input.Headers))
        for key, value := range input.Headers </span><span class="cov0" title="0">{
                headers[key] = []string{value}
        }</span>

        <span class="cov0" title="0">if input.Expires &lt;= 0 </span><span class="cov0" title="0">{
                input.Expires = 300
        }</span>

        <span class="cov0" title="0">requestUrl, err := obsClient.doAuthTemporary(string(input.Method), input.Bucket, input.Key, params, headers, int64(input.Expires))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">output = &amp;CreateSignedUrlOutput{
                SignedUrl:                  requestUrl,
                ActualSignedRequestHeaders: headers,
        }
        return</span>
}

func (obsClient ObsClient) CreateBrowserBasedSignature(input *CreateBrowserBasedSignatureInput) (output *CreateBrowserBasedSignatureOutput, err error) <span class="cov0" title="0">{
        if input == nil </span><span class="cov0" title="0">{
                return nil, errors.New("CreateBrowserBasedSignatureInput is nil")
        }</span>

        <span class="cov0" title="0">params := make(map[string]string, len(input.FormParams))
        for key, value := range input.FormParams </span><span class="cov0" title="0">{
                params[key] = value
        }</span>

        <span class="cov0" title="0">date := time.Now().UTC()
        shortDate := date.Format(SHORT_DATE_FORMAT)
        longDate := date.Format(LONG_DATE_FORMAT)

        credential, _ := getCredential(obsClient.conf.securityProvider.ak, obsClient.conf.region, shortDate)

        if input.Expires &lt;= 0 </span><span class="cov0" title="0">{
                input.Expires = 300
        }</span>

        <span class="cov0" title="0">expiration := date.Add(time.Second * time.Duration(input.Expires)).Format(ISO8601_DATE_FORMAT)
        params[PARAM_ALGORITHM_AMZ_CAMEL] = V4_HASH_PREFIX
        params[PARAM_CREDENTIAL_AMZ_CAMEL] = credential
        params[PARAM_DATE_AMZ_CAMEL] = longDate

        if obsClient.conf.securityProvider.securityToken != "" </span><span class="cov0" title="0">{
                params[HEADER_STS_TOKEN_AMZ] = obsClient.conf.securityProvider.securityToken
        }</span>

        <span class="cov0" title="0">matchAnyBucket := true
        matchAnyKey := true
        count := 5
        if bucket := strings.TrimSpace(input.Bucket); bucket != "" </span><span class="cov0" title="0">{
                params["bucket"] = bucket
                matchAnyBucket = false
                count--
        }</span>

        <span class="cov0" title="0">if key := strings.TrimSpace(input.Key); key != "" </span><span class="cov0" title="0">{
                params["key"] = key
                matchAnyKey = false
                count--
        }</span>

        <span class="cov0" title="0">originPolicySlice := make([]string, 0, len(params)+count)
        originPolicySlice = append(originPolicySlice, fmt.Sprintf("{\"expiration\":\"%s\",", expiration))
        originPolicySlice = append(originPolicySlice, "\"conditions\":[")
        for key, value := range params </span><span class="cov0" title="0">{
                if _key := strings.TrimSpace(strings.ToLower(key)); _key != "" </span><span class="cov0" title="0">{
                        originPolicySlice = append(originPolicySlice, fmt.Sprintf("{\"%s\":\"%s\"},", _key, value))
                }</span>
        }

        <span class="cov0" title="0">if matchAnyBucket </span><span class="cov0" title="0">{
                originPolicySlice = append(originPolicySlice, "[\"starts-with\", \"$bucket\", \"\"],")
        }</span>

        <span class="cov0" title="0">if matchAnyKey </span><span class="cov0" title="0">{
                originPolicySlice = append(originPolicySlice, "[\"starts-with\", \"$key\", \"\"],")
        }</span>

        <span class="cov0" title="0">originPolicySlice = append(originPolicySlice, "]}")

        originPolicy := strings.Join(originPolicySlice, "")
        policy := Base64Encode([]byte(originPolicy))
        signature := getSignature(policy, obsClient.conf.securityProvider.sk, obsClient.conf.region, shortDate)

        output = &amp;CreateBrowserBasedSignatureOutput{
                OriginPolicy: originPolicy,
                Policy:       policy,
                Algorithm:    params[PARAM_ALGORITHM_AMZ_CAMEL],
                Credential:   params[PARAM_CREDENTIAL_AMZ_CAMEL],
                Date:         params[PARAM_DATE_AMZ_CAMEL],
                Signature:    signature,
        }
        return</span>
}

func (obsClient ObsClient) ListBucketsWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header) (output *ListBucketsOutput, err error) <span class="cov0" title="0">{
        output = &amp;ListBucketsOutput{}
        err = obsClient.doHttpWithSignedUrl("ListBuckets", HTTP_GET, signedUrl, actualSignedRequestHeaders, nil, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) CreateBucketWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header, data io.Reader) (output *BaseModel, err error) <span class="cov0" title="0">{
        output = &amp;BaseModel{}
        err = obsClient.doHttpWithSignedUrl("CreateBucket", HTTP_PUT, signedUrl, actualSignedRequestHeaders, data, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) DeleteBucketWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header) (output *BaseModel, err error) <span class="cov0" title="0">{
        output = &amp;BaseModel{}
        err = obsClient.doHttpWithSignedUrl("DeleteBucket", HTTP_DELETE, signedUrl, actualSignedRequestHeaders, nil, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) SetBucketStoragePolicyWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header, data io.Reader) (output *BaseModel, err error) <span class="cov0" title="0">{
        output = &amp;BaseModel{}
        err = obsClient.doHttpWithSignedUrl("SetBucketStoragePolicy", HTTP_PUT, signedUrl, actualSignedRequestHeaders, data, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) GetBucketStoragePolicyWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header) (output *GetBucketStoragePolicyOutput, err error) <span class="cov0" title="0">{
        output = &amp;GetBucketStoragePolicyOutput{}
        err = obsClient.doHttpWithSignedUrl("GetBucketStoragePolicy", HTTP_GET, signedUrl, actualSignedRequestHeaders, nil, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) ListObjectsWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header) (output *ListObjectsOutput, err error) <span class="cov0" title="0">{
        output = &amp;ListObjectsOutput{}
        err = obsClient.doHttpWithSignedUrl("ListObjects", HTTP_GET, signedUrl, actualSignedRequestHeaders, nil, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span> else<span class="cov0" title="0"> {
                if location, ok := output.ResponseHeaders[HEADER_BUCKET_REGION]; ok </span><span class="cov0" title="0">{
                        output.Location = location[0]
                }</span>
        }
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) ListVersionsWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header) (output *ListVersionsOutput, err error) <span class="cov0" title="0">{
        output = &amp;ListVersionsOutput{}
        err = obsClient.doHttpWithSignedUrl("ListVersions", HTTP_GET, signedUrl, actualSignedRequestHeaders, nil, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span> else<span class="cov0" title="0"> {
                if location, ok := output.ResponseHeaders[HEADER_BUCKET_REGION]; ok </span><span class="cov0" title="0">{
                        output.Location = location[0]
                }</span>
        }
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) ListMultipartUploadsWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header) (output *ListMultipartUploadsOutput, err error) <span class="cov0" title="0">{
        output = &amp;ListMultipartUploadsOutput{}
        err = obsClient.doHttpWithSignedUrl("ListMultipartUploads", HTTP_GET, signedUrl, actualSignedRequestHeaders, nil, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) SetBucketQuotaWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header, data io.Reader) (output *BaseModel, err error) <span class="cov0" title="0">{
        output = &amp;BaseModel{}
        err = obsClient.doHttpWithSignedUrl("SetBucketQuota", HTTP_PUT, signedUrl, actualSignedRequestHeaders, data, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) GetBucketQuotaWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header) (output *GetBucketQuotaOutput, err error) <span class="cov0" title="0">{
        output = &amp;GetBucketQuotaOutput{}
        err = obsClient.doHttpWithSignedUrl("GetBucketQuota", HTTP_GET, signedUrl, actualSignedRequestHeaders, nil, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) HeadBucketWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header) (output *BaseModel, err error) <span class="cov0" title="0">{
        output = &amp;BaseModel{}
        err = obsClient.doHttpWithSignedUrl("HeadBucket", HTTP_HEAD, signedUrl, actualSignedRequestHeaders, nil, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) GetBucketMetadataWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header) (output *GetBucketMetadataOutput, err error) <span class="cov0" title="0">{
        output = &amp;GetBucketMetadataOutput{}
        err = obsClient.doHttpWithSignedUrl("GetBucketMetadata", HTTP_HEAD, signedUrl, actualSignedRequestHeaders, nil, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span> else<span class="cov0" title="0"> {
                ParseGetBucketMetadataOutput(output)
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) GetBucketStorageInfoWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header) (output *GetBucketStorageInfoOutput, err error) <span class="cov0" title="0">{
        output = &amp;GetBucketStorageInfoOutput{}
        err = obsClient.doHttpWithSignedUrl("GetBucketStorageInfo", HTTP_GET, signedUrl, actualSignedRequestHeaders, nil, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) GetBucketLocationWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header) (output *GetBucketLocationOutput, err error) <span class="cov0" title="0">{
        output = &amp;GetBucketLocationOutput{}
        err = obsClient.doHttpWithSignedUrl("GetBucketLocation", HTTP_GET, signedUrl, actualSignedRequestHeaders, nil, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) SetBucketAclWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header, data io.Reader) (output *BaseModel, err error) <span class="cov0" title="0">{
        output = &amp;BaseModel{}
        err = obsClient.doHttpWithSignedUrl("SetBucketAcl", HTTP_PUT, signedUrl, actualSignedRequestHeaders, data, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) GetBucketAclWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header) (output *GetBucketAclOutput, err error) <span class="cov0" title="0">{
        output = &amp;GetBucketAclOutput{}
        err = obsClient.doHttpWithSignedUrl("GetBucketAcl", HTTP_GET, signedUrl, actualSignedRequestHeaders, nil, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) SetBucketPolicyWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header, data io.Reader) (output *BaseModel, err error) <span class="cov0" title="0">{
        output = &amp;BaseModel{}
        err = obsClient.doHttpWithSignedUrl("SetBucketPolicy", HTTP_PUT, signedUrl, actualSignedRequestHeaders, data, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) GetBucketPolicyWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header) (output *GetBucketPolicyOutput, err error) <span class="cov0" title="0">{
        output = &amp;GetBucketPolicyOutput{}
        err = obsClient.doHttpWithSignedUrl("GetBucketPolicy", HTTP_GET, signedUrl, actualSignedRequestHeaders, nil, output, false)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) DeleteBucketPolicyWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header) (output *BaseModel, err error) <span class="cov0" title="0">{
        output = &amp;BaseModel{}
        err = obsClient.doHttpWithSignedUrl("DeleteBucketPolicy", HTTP_DELETE, signedUrl, actualSignedRequestHeaders, nil, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) SetBucketCorsWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header, data io.Reader) (output *BaseModel, err error) <span class="cov0" title="0">{
        output = &amp;BaseModel{}
        err = obsClient.doHttpWithSignedUrl("SetBucketCors", HTTP_PUT, signedUrl, actualSignedRequestHeaders, data, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) GetBucketCorsWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header) (output *GetBucketCorsOutput, err error) <span class="cov0" title="0">{
        output = &amp;GetBucketCorsOutput{}
        err = obsClient.doHttpWithSignedUrl("GetBucketCors", HTTP_GET, signedUrl, actualSignedRequestHeaders, nil, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) DeleteBucketCorsWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header) (output *BaseModel, err error) <span class="cov0" title="0">{
        output = &amp;BaseModel{}
        err = obsClient.doHttpWithSignedUrl("DeleteBucketCors", HTTP_DELETE, signedUrl, actualSignedRequestHeaders, nil, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) SetBucketVersioningWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header, data io.Reader) (output *BaseModel, err error) <span class="cov0" title="0">{
        output = &amp;BaseModel{}
        err = obsClient.doHttpWithSignedUrl("SetBucketVersioning", HTTP_PUT, signedUrl, actualSignedRequestHeaders, data, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) GetBucketVersioningWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header) (output *GetBucketVersioningOutput, err error) <span class="cov0" title="0">{
        output = &amp;GetBucketVersioningOutput{}
        err = obsClient.doHttpWithSignedUrl("GetBucketVersioning", HTTP_GET, signedUrl, actualSignedRequestHeaders, nil, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) SetBucketWebsiteConfigurationWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header, data io.Reader) (output *BaseModel, err error) <span class="cov0" title="0">{
        output = &amp;BaseModel{}
        err = obsClient.doHttpWithSignedUrl("SetBucketWebsiteConfiguration", HTTP_PUT, signedUrl, actualSignedRequestHeaders, data, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) GetBucketWebsiteConfigurationWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header) (output *GetBucketWebsiteConfigurationOutput, err error) <span class="cov0" title="0">{
        output = &amp;GetBucketWebsiteConfigurationOutput{}
        err = obsClient.doHttpWithSignedUrl("GetBucketWebsiteConfiguration", HTTP_GET, signedUrl, actualSignedRequestHeaders, nil, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) DeleteBucketWebsiteConfigurationWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header) (output *BaseModel, err error) <span class="cov0" title="0">{
        output = &amp;BaseModel{}
        err = obsClient.doHttpWithSignedUrl("DeleteBucketWebsiteConfiguration", HTTP_DELETE, signedUrl, actualSignedRequestHeaders, nil, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) SetBucketLoggingConfigurationWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header, data io.Reader) (output *BaseModel, err error) <span class="cov0" title="0">{
        output = &amp;BaseModel{}
        err = obsClient.doHttpWithSignedUrl("SetBucketLoggingConfiguration", HTTP_PUT, signedUrl, actualSignedRequestHeaders, data, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) GetBucketLoggingConfigurationWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header) (output *GetBucketLoggingConfigurationOutput, err error) <span class="cov0" title="0">{
        output = &amp;GetBucketLoggingConfigurationOutput{}
        err = obsClient.doHttpWithSignedUrl("GetBucketLoggingConfiguration", HTTP_GET, signedUrl, actualSignedRequestHeaders, nil, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) SetBucketLifecycleConfigurationWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header, data io.Reader) (output *BaseModel, err error) <span class="cov0" title="0">{
        output = &amp;BaseModel{}
        err = obsClient.doHttpWithSignedUrl("SetBucketLifecycleConfiguration", HTTP_PUT, signedUrl, actualSignedRequestHeaders, data, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) GetBucketLifecycleConfigurationWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header) (output *GetBucketLifecycleConfigurationOutput, err error) <span class="cov0" title="0">{
        output = &amp;GetBucketLifecycleConfigurationOutput{}
        err = obsClient.doHttpWithSignedUrl("GetBucketLifecycleConfiguration", HTTP_GET, signedUrl, actualSignedRequestHeaders, nil, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) DeleteBucketLifecycleConfigurationWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header) (output *BaseModel, err error) <span class="cov0" title="0">{
        output = &amp;BaseModel{}
        err = obsClient.doHttpWithSignedUrl("DeleteBucketLifecycleConfiguration", HTTP_DELETE, signedUrl, actualSignedRequestHeaders, nil, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) SetBucketTaggingWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header, data io.Reader) (output *BaseModel, err error) <span class="cov0" title="0">{
        output = &amp;BaseModel{}
        err = obsClient.doHttpWithSignedUrl("SetBucketTagging", HTTP_PUT, signedUrl, actualSignedRequestHeaders, data, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) GetBucketTaggingWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header) (output *GetBucketTaggingOutput, err error) <span class="cov0" title="0">{
        output = &amp;GetBucketTaggingOutput{}
        err = obsClient.doHttpWithSignedUrl("GetBucketTagging", HTTP_GET, signedUrl, actualSignedRequestHeaders, nil, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) DeleteBucketTaggingWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header) (output *BaseModel, err error) <span class="cov0" title="0">{
        output = &amp;BaseModel{}
        err = obsClient.doHttpWithSignedUrl("DeleteBucketTagging", HTTP_DELETE, signedUrl, actualSignedRequestHeaders, nil, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) SetBucketNotificationWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header, data io.Reader) (output *BaseModel, err error) <span class="cov0" title="0">{
        output = &amp;BaseModel{}
        err = obsClient.doHttpWithSignedUrl("SetBucketNotification", HTTP_PUT, signedUrl, actualSignedRequestHeaders, data, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) GetBucketNotificationWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header) (output *GetBucketNotificationOutput, err error) <span class="cov0" title="0">{
        output = &amp;GetBucketNotificationOutput{}
        err = obsClient.doHttpWithSignedUrl("GetBucketNotification", HTTP_GET, signedUrl, actualSignedRequestHeaders, nil, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) DeleteObjectWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header) (output *DeleteObjectOutput, err error) <span class="cov0" title="0">{
        output = &amp;DeleteObjectOutput{}
        err = obsClient.doHttpWithSignedUrl("DeleteObject", HTTP_DELETE, signedUrl, actualSignedRequestHeaders, nil, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span> else<span class="cov0" title="0"> {
                ParseDeleteObjectOutput(output)
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) DeleteObjectsWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header, data io.Reader) (output *DeleteObjectsOutput, err error) <span class="cov0" title="0">{
        output = &amp;DeleteObjectsOutput{}
        err = obsClient.doHttpWithSignedUrl("DeleteObjects", HTTP_POST, signedUrl, actualSignedRequestHeaders, data, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) SetObjectAclWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header, data io.Reader) (output *BaseModel, err error) <span class="cov0" title="0">{
        output = &amp;BaseModel{}
        err = obsClient.doHttpWithSignedUrl("SetObjectAcl", HTTP_PUT, signedUrl, actualSignedRequestHeaders, data, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) GetObjectAclWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header) (output *GetObjectAclOutput, err error) <span class="cov0" title="0">{
        output = &amp;GetObjectAclOutput{}
        err = obsClient.doHttpWithSignedUrl("GetObjectAcl", HTTP_GET, signedUrl, actualSignedRequestHeaders, nil, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span> else<span class="cov0" title="0"> {
                if versionId, ok := output.ResponseHeaders[HEADER_VERSION_ID]; ok </span><span class="cov0" title="0">{
                        output.VersionId = versionId[0]
                }</span>
        }
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) RestoreObjectWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header, data io.Reader) (output *BaseModel, err error) <span class="cov0" title="0">{
        output = &amp;BaseModel{}
        err = obsClient.doHttpWithSignedUrl("RestoreObject", HTTP_POST, signedUrl, actualSignedRequestHeaders, data, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) GetObjectMetadataWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header) (output *GetObjectMetadataOutput, err error) <span class="cov0" title="0">{
        output = &amp;GetObjectMetadataOutput{}
        err = obsClient.doHttpWithSignedUrl("GetObjectMetadata", HTTP_HEAD, signedUrl, actualSignedRequestHeaders, nil, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span> else<span class="cov0" title="0"> {
                ParseGetObjectMetadataOutput(output)
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) GetObjectWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header) (output *GetObjectOutput, err error) <span class="cov0" title="0">{
        output = &amp;GetObjectOutput{}
        err = obsClient.doHttpWithSignedUrl("GetObject", HTTP_GET, signedUrl, actualSignedRequestHeaders, nil, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span> else<span class="cov0" title="0"> {
                ParseGetObjectOutput(output)
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) PutObjectWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header, data io.Reader) (output *PutObjectOutput, err error) <span class="cov0" title="0">{
        output = &amp;PutObjectOutput{}
        err = obsClient.doHttpWithSignedUrl("PutObject", HTTP_PUT, signedUrl, actualSignedRequestHeaders, data, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span> else<span class="cov0" title="0"> {
                ParsePutObjectOutput(output)
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) PutFileWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header, sourceFile string) (output *PutObjectOutput, err error) <span class="cov0" title="0">{
        var data io.Reader
        sourceFile = strings.TrimSpace(sourceFile)
        if sourceFile != "" </span><span class="cov0" title="0">{
                fd, err := os.Open(sourceFile)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">defer fd.Close()

                stat, err := fd.Stat()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">fileReaderWrapper := &amp;fileReaderWrapper{filePath: sourceFile}
                fileReaderWrapper.reader = fd

                var contentLength int64
                if value, ok := actualSignedRequestHeaders[HEADER_CONTENT_LENGTH_CAMEL]; ok </span><span class="cov0" title="0">{
                        contentLength = StringToInt64(value[0], -1)
                }</span> else<span class="cov0" title="0"> if value, ok := actualSignedRequestHeaders[HEADER_CONTENT_LENGTH]; ok </span><span class="cov0" title="0">{
                        contentLength = StringToInt64(value[0], -1)
                }</span> else<span class="cov0" title="0"> {
                        contentLength = stat.Size()
                }</span>
                <span class="cov0" title="0">if contentLength &gt; stat.Size() </span><span class="cov0" title="0">{
                        return nil, errors.New("ContentLength is larger than fileSize")
                }</span>
                <span class="cov0" title="0">fileReaderWrapper.totalCount = contentLength
                data = fileReaderWrapper</span>
        }

        <span class="cov0" title="0">output = &amp;PutObjectOutput{}
        err = obsClient.doHttpWithSignedUrl("PutObject", HTTP_PUT, signedUrl, actualSignedRequestHeaders, data, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span> else<span class="cov0" title="0"> {
                ParsePutObjectOutput(output)
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) CopyObjectWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header) (output *CopyObjectOutput, err error) <span class="cov0" title="0">{
        output = &amp;CopyObjectOutput{}
        err = obsClient.doHttpWithSignedUrl("CopyObject", HTTP_PUT, signedUrl, actualSignedRequestHeaders, nil, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span> else<span class="cov0" title="0"> {
                ParseCopyObjectOutput(output)
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) AbortMultipartUploadWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header) (output *BaseModel, err error) <span class="cov0" title="0">{
        output = &amp;BaseModel{}
        err = obsClient.doHttpWithSignedUrl("AbortMultipartUpload", HTTP_DELETE, signedUrl, actualSignedRequestHeaders, nil, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) InitiateMultipartUploadWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header) (output *InitiateMultipartUploadOutput, err error) <span class="cov0" title="0">{
        output = &amp;InitiateMultipartUploadOutput{}
        err = obsClient.doHttpWithSignedUrl("InitiateMultipartUpload", HTTP_POST, signedUrl, actualSignedRequestHeaders, nil, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span> else<span class="cov0" title="0"> {
                ParseInitiateMultipartUploadOutput(output)
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) UploadPartWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header, data io.Reader) (output *UploadPartOutput, err error) <span class="cov0" title="0">{
        output = &amp;UploadPartOutput{}
        err = obsClient.doHttpWithSignedUrl("UploadPart", HTTP_PUT, signedUrl, actualSignedRequestHeaders, data, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span> else<span class="cov0" title="0"> {
                ParseUploadPartOutput(output)
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) CompleteMultipartUploadWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header, data io.Reader) (output *CompleteMultipartUploadOutput, err error) <span class="cov0" title="0">{
        output = &amp;CompleteMultipartUploadOutput{}
        err = obsClient.doHttpWithSignedUrl("CompleteMultipartUpload", HTTP_POST, signedUrl, actualSignedRequestHeaders, data, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span> else<span class="cov0" title="0"> {
                ParseCompleteMultipartUploadOutput(output)
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) ListPartsWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header) (output *ListPartsOutput, err error) <span class="cov0" title="0">{
        output = &amp;ListPartsOutput{}
        err = obsClient.doHttpWithSignedUrl("ListParts", HTTP_GET, signedUrl, actualSignedRequestHeaders, nil, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) CopyPartWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header) (output *CopyPartOutput, err error) <span class="cov0" title="0">{
        output = &amp;CopyPartOutput{}
        err = obsClient.doHttpWithSignedUrl("CopyPart", HTTP_PUT, signedUrl, actualSignedRequestHeaders, nil, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span> else<span class="cov0" title="0"> {
                ParseCopyPartOutput(output)
        }</span>
        <span class="cov0" title="0">return</span>
}
</pre>

		<pre class="file" id="file10" style="display: none">package obs

import (
        "bytes"
        "fmt"
        "io"
        "os"
        "strings"
)

type IReadCloser interface {
        setReadCloser(body io.ReadCloser)
}

func (output *GetObjectOutput) setReadCloser(body io.ReadCloser) <span class="cov0" title="0">{
        output.Body = body
}</span>

type IBaseModel interface {
        setStatusCode(statusCode int)

        setRequestId(requestId string)

        setResponseHeaders(responseHeaders map[string][]string)
}

type ISerializable interface {
        trans() (map[string]string, map[string][]string, interface{})
}

type DefaultSerializable struct {
        params  map[string]string
        headers map[string][]string
        data    interface{}
}

func (input DefaultSerializable) trans() (map[string]string, map[string][]string, interface{}) <span class="cov0" title="0">{
        return input.params, input.headers, input.data
}</span>

var defaultSerializable = &amp;DefaultSerializable{}

func newSubResourceSerial(subResource SubResourceType) *DefaultSerializable <span class="cov0" title="0">{
        return &amp;DefaultSerializable{map[string]string{string(subResource): ""}, nil, nil}
}</span>

func trans(subResource SubResourceType, input interface{}) (params map[string]string, headers map[string][]string, data interface{}) <span class="cov0" title="0">{
        params = map[string]string{string(subResource): ""}
        data, _ = ConvertRequestToIoReader(input)
        return
}</span>

func (baseModel *BaseModel) setStatusCode(statusCode int) <span class="cov0" title="0">{
        baseModel.StatusCode = statusCode
}</span>

func (baseModel *BaseModel) setRequestId(requestId string) <span class="cov0" title="0">{
        baseModel.RequestId = requestId
}</span>

func (baseModel *BaseModel) setResponseHeaders(responseHeaders map[string][]string) <span class="cov0" title="0">{
        baseModel.ResponseHeaders = responseHeaders
}</span>

func (input ListBucketsInput) trans() (params map[string]string, headers map[string][]string, data interface{}) <span class="cov0" title="0">{
        headers = make(map[string][]string)
        if input.QueryLocation </span><span class="cov0" title="0">{
                headers[HEADER_LOCATION_AMZ] = []string{"true"}
        }</span>
        <span class="cov0" title="0">return</span>
}

func (input CreateBucketInput) trans() (params map[string]string, headers map[string][]string, data interface{}) <span class="cov0" title="0">{
        headers = make(map[string][]string)
        if acl := string(input.ACL); acl != "" </span><span class="cov0" title="0">{
                headers[HEADER_ACL_AMZ] = []string{acl}
        }</span>

        <span class="cov0" title="0">if storageClass := string(input.StorageClass); storageClass != "" </span><span class="cov0" title="0">{
                headers[HEADER_STORAGE_CLASS] = []string{storageClass}
        }</span>

        <span class="cov0" title="0">if location := strings.TrimSpace(input.Location); location != "" </span><span class="cov0" title="0">{
                input.Location = location
                data, _ = ConvertRequestToIoReader(input)
        }</span>
        <span class="cov0" title="0">return</span>
}

func (input SetBucketStoragePolicyInput) trans() (params map[string]string, headers map[string][]string, data interface{}) <span class="cov0" title="0">{
        return trans(SubResourceStoragePolicy, input)
}</span>

func (input ListObjsInput) trans() (params map[string]string, headers map[string][]string, data interface{}) <span class="cov0" title="0">{
        params = make(map[string]string)
        if input.Prefix != "" </span><span class="cov0" title="0">{
                params["prefix"] = input.Prefix
        }</span>
        <span class="cov0" title="0">if input.Delimiter != "" </span><span class="cov0" title="0">{
                params["delimiter"] = input.Delimiter
        }</span>
        <span class="cov0" title="0">if input.MaxKeys &gt; 0 </span><span class="cov0" title="0">{
                params["max-keys"] = IntToString(input.MaxKeys)
        }</span>
        <span class="cov0" title="0">headers = make(map[string][]string)
        if origin := strings.TrimSpace(input.Origin); origin != "" </span><span class="cov0" title="0">{
                headers[HEADER_ORIGIN_CAMEL] = []string{origin}
        }</span>
        <span class="cov0" title="0">if requestHeader := strings.TrimSpace(input.RequestHeader); requestHeader != "" </span><span class="cov0" title="0">{
                headers[HEADER_ACCESS_CONTROL_REQUEST_HEADER_CAMEL] = []string{requestHeader}
        }</span>
        <span class="cov0" title="0">return</span>
}

func (input ListObjectsInput) trans() (params map[string]string, headers map[string][]string, data interface{}) <span class="cov0" title="0">{
        params, headers, data = input.ListObjsInput.trans()
        if input.Marker != "" </span><span class="cov0" title="0">{
                params["marker"] = input.Marker
        }</span>
        <span class="cov0" title="0">return</span>
}

func (input ListVersionsInput) trans() (params map[string]string, headers map[string][]string, data interface{}) <span class="cov0" title="0">{
        params, headers, data = input.ListObjsInput.trans()
        params[string(SubResourceVersions)] = ""
        if input.KeyMarker != "" </span><span class="cov0" title="0">{
                params["key-marker"] = input.KeyMarker
        }</span>
        <span class="cov0" title="0">if input.VersionIdMarker != "" </span><span class="cov0" title="0">{
                params["version-id-marker"] = input.VersionIdMarker
        }</span>
        <span class="cov0" title="0">return</span>
}

func (input ListMultipartUploadsInput) trans() (params map[string]string, headers map[string][]string, data interface{}) <span class="cov0" title="0">{
        params = map[string]string{string(SubResourceUploads): ""}
        if input.Prefix != "" </span><span class="cov0" title="0">{
                params["prefix"] = input.Prefix
        }</span>
        <span class="cov0" title="0">if input.Delimiter != "" </span><span class="cov0" title="0">{
                params["delimiter"] = input.Delimiter
        }</span>
        <span class="cov0" title="0">if input.MaxUploads &gt; 0 </span><span class="cov0" title="0">{
                params["max-uploads"] = IntToString(input.MaxUploads)
        }</span>
        <span class="cov0" title="0">if input.KeyMarker != "" </span><span class="cov0" title="0">{
                params["key-marker"] = input.KeyMarker
        }</span>
        <span class="cov0" title="0">if input.UploadIdMarker != "" </span><span class="cov0" title="0">{
                params["upload-id-marker"] = input.UploadIdMarker
        }</span>
        <span class="cov0" title="0">return</span>
}

func (input SetBucketQuotaInput) trans() (params map[string]string, headers map[string][]string, data interface{}) <span class="cov0" title="0">{
        return trans(SubResourceQuota, input)
}</span>

func (input SetBucketAclInput) trans() (params map[string]string, headers map[string][]string, data interface{}) <span class="cov0" title="0">{
        params = map[string]string{string(SubResourceAcl): ""}
        headers = make(map[string][]string)

        if acl := string(input.ACL); acl != "" </span><span class="cov0" title="0">{
                headers[HEADER_ACL_AMZ] = []string{acl}
        }</span> else<span class="cov0" title="0"> {
                data, _ = ConvertAclToXml(input.AccessControlPolicy, false)
        }</span>
        <span class="cov0" title="0">return</span>
}

func (input SetBucketPolicyInput) trans() (params map[string]string, headers map[string][]string, data interface{}) <span class="cov0" title="0">{
        params = map[string]string{string(SubResourcePolicy): ""}
        data = strings.NewReader(input.Policy)
        return
}</span>

func (input SetBucketCorsInput) trans() (params map[string]string, headers map[string][]string, data interface{}) <span class="cov0" title="0">{
        params = map[string]string{string(SubResourceCors): ""}
        data, md5, _ := ConvertRequestToIoReaderV2(input)
        headers = map[string][]string{HEADER_MD5_CAMEL: []string{md5}}
        return
}</span>

func (input SetBucketVersioningInput) trans() (params map[string]string, headers map[string][]string, data interface{}) <span class="cov0" title="0">{
        return trans(SubResourceVersioning, input)
}</span>

func (input SetBucketWebsiteConfigurationInput) trans() (params map[string]string, headers map[string][]string, data interface{}) <span class="cov0" title="0">{
        params = map[string]string{string(SubResourceWebsite): ""}
        data, _ = ConvertWebsiteConfigurationToXml(input.BucketWebsiteConfiguration, false)
        return
}</span>

func (input GetBucketMetadataInput) trans() (params map[string]string, headers map[string][]string, data interface{}) <span class="cov0" title="0">{
        headers = make(map[string][]string)
        if origin := strings.TrimSpace(input.Origin); origin != "" </span><span class="cov0" title="0">{
                headers[HEADER_ORIGIN_CAMEL] = []string{origin}
        }</span>
        <span class="cov0" title="0">if requestHeader := strings.TrimSpace(input.RequestHeader); requestHeader != "" </span><span class="cov0" title="0">{
                headers[HEADER_ACCESS_CONTROL_REQUEST_HEADER_CAMEL] = []string{requestHeader}
        }</span>
        <span class="cov0" title="0">return</span>
}

func (input SetBucketLoggingConfigurationInput) trans() (params map[string]string, headers map[string][]string, data interface{}) <span class="cov0" title="0">{
        params = map[string]string{string(SubResourceLogging): ""}
        data, _ = ConvertLoggingStatusToXml(input.BucketLoggingStatus, false)
        return
}</span>

func (input SetBucketLifecycleConfigurationInput) trans() (params map[string]string, headers map[string][]string, data interface{}) <span class="cov0" title="0">{
        params = map[string]string{string(SubResourceLifecycle): ""}
        data, md5 := ConvertLifecyleConfigurationToXml(input.BucketLifecyleConfiguration, true)
        headers = map[string][]string{HEADER_MD5_CAMEL: []string{md5}}
        return
}</span>

func (input SetBucketTaggingInput) trans() (params map[string]string, headers map[string][]string, data interface{}) <span class="cov0" title="0">{
        params = map[string]string{string(SubResourceTagging): ""}
        data, md5, _ := ConvertRequestToIoReaderV2(input)
        headers = map[string][]string{HEADER_MD5_CAMEL: []string{md5}}
        return
}</span>

func (input SetBucketNotificationInput) trans() (params map[string]string, headers map[string][]string, data interface{}) <span class="cov0" title="0">{
        params = map[string]string{string(SubResourceNotification): ""}
        data, _ = ConvertNotificationToXml(input.BucketNotification, false)
        return
}</span>

func (input DeleteObjectInput) trans() (params map[string]string, headers map[string][]string, data interface{}) <span class="cov0" title="0">{
        params = make(map[string]string)
        if input.VersionId != "" </span><span class="cov0" title="0">{
                params[PARAM_VERSION_ID] = input.VersionId
        }</span>
        <span class="cov0" title="0">return</span>
}

func (input DeleteObjectsInput) trans() (params map[string]string, headers map[string][]string, data interface{}) <span class="cov0" title="0">{
        params = map[string]string{string(SubResourceDelete): ""}
        data, md5, _ := ConvertRequestToIoReaderV2(input)
        headers = map[string][]string{HEADER_MD5_CAMEL: []string{md5}}
        return
}</span>

func (input SetObjectAclInput) trans() (params map[string]string, headers map[string][]string, data interface{}) <span class="cov0" title="0">{
        params = map[string]string{string(SubResourceAcl): ""}
        if input.VersionId != "" </span><span class="cov0" title="0">{
                params[PARAM_VERSION_ID] = input.VersionId
        }</span>
        <span class="cov0" title="0">headers = make(map[string][]string)
        if acl := string(input.ACL); acl != "" </span><span class="cov0" title="0">{
                headers[HEADER_ACL_AMZ] = []string{acl}
        }</span> else<span class="cov0" title="0"> {
                data, _ = ConvertAclToXml(input.AccessControlPolicy, false)
        }</span>
        <span class="cov0" title="0">return</span>
}

func (input GetObjectAclInput) trans() (params map[string]string, headers map[string][]string, data interface{}) <span class="cov0" title="0">{
        params = map[string]string{string(SubResourceAcl): ""}
        if input.VersionId != "" </span><span class="cov0" title="0">{
                params[PARAM_VERSION_ID] = input.VersionId
        }</span>
        <span class="cov0" title="0">return</span>
}

func (input RestoreObjectInput) trans() (params map[string]string, headers map[string][]string, data interface{}) <span class="cov0" title="0">{
        params = map[string]string{string(SubResourceRestore): ""}
        if input.VersionId != "" </span><span class="cov0" title="0">{
                params[PARAM_VERSION_ID] = input.VersionId
        }</span>
        <span class="cov0" title="0">data, _ = ConvertRequestToIoReader(input)
        return</span>
}

func (header SseKmsHeader) GetEncryption() string <span class="cov0" title="0">{
        if header.Encryption != "" </span><span class="cov0" title="0">{
                return header.Encryption
        }</span>
        <span class="cov0" title="0">return DEFAULT_SSE_KMS_ENCRYPTION</span>
}

func (header SseKmsHeader) GetKey() string <span class="cov0" title="0">{
        return header.Key
}</span>

func (header SseCHeader) GetEncryption() string <span class="cov0" title="0">{
        if header.Encryption != "" </span><span class="cov0" title="0">{
                return header.Encryption
        }</span>
        <span class="cov0" title="0">return DEFAULT_SSE_C_ENCRYPTION</span>
}

func (header SseCHeader) GetKey() string <span class="cov0" title="0">{
        return header.Key
}</span>

func (header SseCHeader) GetKeyMD5() string <span class="cov0" title="0">{
        if header.KeyMD5 != "" </span><span class="cov0" title="0">{
                return header.KeyMD5
        }</span>

        <span class="cov0" title="0">if ret, err := Base64Decode(header.GetKey()); err == nil </span><span class="cov0" title="0">{
                return Base64Md5(ret)
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func setSseHeader(headers map[string][]string, sseHeader ISseHeader, sseCOnly bool) <span class="cov0" title="0">{
        if sseHeader != nil </span><span class="cov0" title="0">{
                if sseCHeader, ok := sseHeader.(SseCHeader); ok </span><span class="cov0" title="0">{
                        headers[HEADER_SSEC_ENCRYPTION_AMZ] = []string{sseCHeader.GetEncryption()}
                        headers[HEADER_SSEC_KEY_AMZ] = []string{sseCHeader.GetKey()}
                        headers[HEADER_SSEC_KEY_MD5_AMZ] = []string{sseCHeader.GetKeyMD5()}
                }</span> else<span class="cov0" title="0"> if sseKmsHeader, ok := sseHeader.(SseKmsHeader); !sseCOnly &amp;&amp; ok </span><span class="cov0" title="0">{
                        headers[HEADER_SSEKMS_ENCRYPTION_AMZ] = []string{sseKmsHeader.GetEncryption()}
                        headers[HEADER_SSEKMS_KEY_AMZ] = []string{sseKmsHeader.GetKey()}
                }</span>
        }
}

func (input GetObjectMetadataInput) trans() (params map[string]string, headers map[string][]string, data interface{}) <span class="cov0" title="0">{
        params = make(map[string]string)
        if input.VersionId != "" </span><span class="cov0" title="0">{
                params[PARAM_VERSION_ID] = input.VersionId
        }</span>
        <span class="cov0" title="0">headers = make(map[string][]string)

        if input.Origin != "" </span><span class="cov0" title="0">{
                headers[HEADER_ORIGIN_CAMEL] = []string{input.Origin}
        }</span>

        <span class="cov0" title="0">if input.RequestHeader != "" </span><span class="cov0" title="0">{
                headers[HEADER_ACCESS_CONTROL_REQUEST_HEADER_CAMEL] = []string{input.RequestHeader}
        }</span>
        <span class="cov0" title="0">setSseHeader(headers, input.SseHeader, true)
        return</span>
}

func (input GetObjectInput) trans() (params map[string]string, headers map[string][]string, data interface{}) <span class="cov0" title="0">{
        params, headers, data = input.GetObjectMetadataInput.trans()
        if input.ResponseCacheControl != "" </span><span class="cov0" title="0">{
                params[PARAM_RESPONSE_CACHE_CONTROL] = input.ResponseCacheControl
        }</span>
        <span class="cov0" title="0">if input.ResponseContentDisposition != "" </span><span class="cov0" title="0">{
                params[PARAM_RESPONSE_CONTENT_DISPOSITION] = input.ResponseContentDisposition
        }</span>
        <span class="cov0" title="0">if input.ResponseContentEncoding != "" </span><span class="cov0" title="0">{
                params[PARAM_RESPONSE_CONTENT_ENCODING] = input.ResponseContentEncoding
        }</span>
        <span class="cov0" title="0">if input.ResponseContentLanguage != "" </span><span class="cov0" title="0">{
                params[PARAM_RESPONSE_CONTENT_LANGUAGE] = input.ResponseContentLanguage
        }</span>
        <span class="cov0" title="0">if input.ResponseContentType != "" </span><span class="cov0" title="0">{
                params[PARAM_RESPONSE_CONTENT_TYPE] = input.ResponseContentType
        }</span>
        <span class="cov0" title="0">if input.ResponseExpires != "" </span><span class="cov0" title="0">{
                params[PARAM_RESPONSE_EXPIRES] = input.ResponseExpires
        }</span>
        <span class="cov0" title="0">if input.ImageProcess != "" </span><span class="cov0" title="0">{
                params[PARAM_IMAGE_PROCESS] = input.ImageProcess
        }</span>
        <span class="cov0" title="0">if input.RangeStart &gt;= 0 &amp;&amp; input.RangeEnd &gt; input.RangeStart </span><span class="cov0" title="0">{
                headers[HEADER_RANGE] = []string{fmt.Sprintf("bytes=%d-%d", input.RangeStart, input.RangeEnd)}
        }</span>

        <span class="cov0" title="0">if input.IfMatch != "" </span><span class="cov0" title="0">{
                headers[HEADER_IF_MATCH] = []string{input.IfMatch}
        }</span>
        <span class="cov0" title="0">if input.IfNoneMatch != "" </span><span class="cov0" title="0">{
                headers[HEADER_IF_NONE_MATCH] = []string{input.IfNoneMatch}
        }</span>
        <span class="cov0" title="0">if !input.IfModifiedSince.IsZero() </span><span class="cov0" title="0">{
                headers[HEADER_IF_MODIFIED_SINCE] = []string{FormatUtcToRfc1123(input.IfModifiedSince)}
        }</span>
        <span class="cov0" title="0">if !input.IfUnmodifiedSince.IsZero() </span><span class="cov0" title="0">{
                headers[HEADER_IF_UNMODIFIED_SINCE] = []string{FormatUtcToRfc1123(input.IfUnmodifiedSince)}
        }</span>
        <span class="cov0" title="0">return</span>
}

func (input ObjectOperationInput) trans() (params map[string]string, headers map[string][]string, data interface{}) <span class="cov0" title="0">{
        headers = make(map[string][]string)
        params = make(map[string]string)
        if acl := string(input.ACL); acl != "" </span><span class="cov0" title="0">{
                headers[HEADER_ACL_AMZ] = []string{acl}
        }</span>
        <span class="cov0" title="0">if storageClass := string(input.StorageClass); storageClass != "" </span><span class="cov0" title="0">{
                headers[HEADER_STORAGE_CLASS2_AMZ] = []string{storageClass}
        }</span>
        <span class="cov0" title="0">if input.WebsiteRedirectLocation != "" </span><span class="cov0" title="0">{
                headers[HEADER_WEBSITE_REDIRECT_LOCATION_AMZ] = []string{input.WebsiteRedirectLocation}
        }</span>
        <span class="cov0" title="0">setSseHeader(headers, input.SseHeader, false)
        if input.Metadata != nil </span><span class="cov0" title="0">{
                for key, value := range input.Metadata </span><span class="cov0" title="0">{
                        key = strings.TrimSpace(key)
                        if !strings.HasPrefix(key, HEADER_PREFIX_META) </span><span class="cov0" title="0">{
                                key = HEADER_PREFIX_META + key
                        }</span>
                        <span class="cov0" title="0">headers[key] = []string{value}</span>
                }
        }
        <span class="cov0" title="0">return</span>
}

func (input PutObjectBasicInput) trans() (params map[string]string, headers map[string][]string, data interface{}) <span class="cov0" title="0">{
        params, headers, data = input.ObjectOperationInput.trans()

        if input.ContentMD5 != "" </span><span class="cov0" title="0">{
                headers[HEADER_MD5_CAMEL] = []string{input.ContentMD5}
        }</span>

        <span class="cov0" title="0">if input.ContentLength &gt; 0 </span><span class="cov0" title="0">{
                headers[HEADER_CONTENT_LENGTH_CAMEL] = []string{Int64ToString(input.ContentLength)}
        }</span>
        <span class="cov0" title="0">if input.ContentType != "" </span><span class="cov0" title="0">{
                headers[HEADER_CONTENT_TYPE_CAML] = []string{input.ContentType}
        }</span>

        <span class="cov0" title="0">return</span>
}

func (input PutObjectInput) trans() (params map[string]string, headers map[string][]string, data interface{}) <span class="cov0" title="0">{
        params, headers, data = input.PutObjectBasicInput.trans()
        if input.Body != nil </span><span class="cov0" title="0">{
                data = input.Body
        }</span>
        <span class="cov0" title="0">return</span>
}

func (input CopyObjectInput) trans() (params map[string]string, headers map[string][]string, data interface{}) <span class="cov0" title="0">{
        params, headers, data = input.ObjectOperationInput.trans()

        var copySource string
        if input.CopySourceVersionId != "" </span><span class="cov0" title="0">{
                copySource = fmt.Sprintf("%s/%s?versionId=%s", input.CopySourceBucket, UrlEncode(input.CopySourceKey, false), input.CopySourceVersionId)
        }</span> else<span class="cov0" title="0"> {
                copySource = fmt.Sprintf("%s/%s", input.CopySourceBucket, UrlEncode(input.CopySourceKey, false))
        }</span>
        <span class="cov0" title="0">headers[HEADER_COPY_SOURCE_AMZ] = []string{copySource}

        if directive := string(input.MetadataDirective); directive != "" </span><span class="cov0" title="0">{
                headers[HEADER_METADATA_DIRECTIVE_AMZ] = []string{directive}
        }</span>

        <span class="cov0" title="0">if input.MetadataDirective == ReplaceMetadata </span><span class="cov0" title="0">{
                if input.CacheControl != "" </span><span class="cov0" title="0">{
                        headers[HEADER_CACHE_CONTROL] = []string{input.CacheControl}
                }</span>
                <span class="cov0" title="0">if input.ContentDisposition != "" </span><span class="cov0" title="0">{
                        headers[HEADER_CONTENT_DISPOSITION] = []string{input.ContentDisposition}
                }</span>
                <span class="cov0" title="0">if input.ContentEncoding != "" </span><span class="cov0" title="0">{
                        headers[HEADER_CONTENT_ENCODING] = []string{input.ContentEncoding}
                }</span>
                <span class="cov0" title="0">if input.ContentLanguage != "" </span><span class="cov0" title="0">{
                        headers[HEADER_CONTENT_LANGUAGE] = []string{input.ContentLanguage}
                }</span>
                <span class="cov0" title="0">if input.ContentType != "" </span><span class="cov0" title="0">{
                        headers[HEADER_CONTENT_TYPE] = []string{input.ContentType}
                }</span>
                <span class="cov0" title="0">if input.Expires != "" </span><span class="cov0" title="0">{
                        headers[HEADER_EXPIRES] = []string{input.Expires}
                }</span>
        }

        <span class="cov0" title="0">if input.CopySourceIfMatch != "" </span><span class="cov0" title="0">{
                headers[HEADER_COPY_SOURCE_IF_MATCH_AMZ] = []string{input.CopySourceIfMatch}
        }</span>
        <span class="cov0" title="0">if input.CopySourceIfNoneMatch != "" </span><span class="cov0" title="0">{
                headers[HEADER_COPY_SOURCE_IF_NONE_MATCH_AMZ] = []string{input.CopySourceIfNoneMatch}
        }</span>
        <span class="cov0" title="0">if !input.CopySourceIfModifiedSince.IsZero() </span><span class="cov0" title="0">{
                headers[HEADER_COPY_SOURCE_IF_MODIFIED_SINCE_AMZ] = []string{FormatUtcToRfc1123(input.CopySourceIfModifiedSince)}
        }</span>
        <span class="cov0" title="0">if !input.CopySourceIfUnmodifiedSince.IsZero() </span><span class="cov0" title="0">{
                headers[HEADER_COPY_SOURCE_IF_UNMODIFIED_SINCE_AMZ] = []string{FormatUtcToRfc1123(input.CopySourceIfUnmodifiedSince)}
        }</span>
        <span class="cov0" title="0">if input.SourceSseHeader != nil </span><span class="cov0" title="0">{
                if sseCHeader, ok := input.SourceSseHeader.(SseCHeader); ok </span><span class="cov0" title="0">{
                        headers[HEADER_SSEC_COPY_SOURCE_ENCRYPTION_AMZ] = []string{sseCHeader.GetEncryption()}
                        headers[HEADER_SSEC_COPY_SOURCE_KEY_AMZ] = []string{sseCHeader.GetKey()}
                        headers[HEADER_SSEC_COPY_SOURCE_KEY_MD5_AMZ] = []string{sseCHeader.GetKeyMD5()}
                }</span>
        }
        <span class="cov0" title="0">return</span>
}

func (input AbortMultipartUploadInput) trans() (params map[string]string, headers map[string][]string, data interface{}) <span class="cov0" title="0">{
        params = map[string]string{"uploadId": input.UploadId}
        return
}</span>

func (input InitiateMultipartUploadInput) trans() (params map[string]string, headers map[string][]string, data interface{}) <span class="cov0" title="0">{
        params, headers, data = input.ObjectOperationInput.trans()
        params[string(SubResourceUploads)] = ""
        return
}</span>

func (input UploadPartInput) trans() (params map[string]string, headers map[string][]string, data interface{}) <span class="cov0" title="0">{
        params = map[string]string{"uploadId": input.UploadId, "partNumber": IntToString(input.PartNumber)}
        headers = make(map[string][]string)
        setSseHeader(headers, input.SseHeader, true)
        if input.Body != nil </span><span class="cov0" title="0">{
                data = input.Body
        }</span>
        <span class="cov0" title="0">return</span>
}

func (input CompleteMultipartUploadInput) trans() (params map[string]string, headers map[string][]string, data interface{}) <span class="cov0" title="0">{
        params = map[string]string{"uploadId": input.UploadId}
        data, _ = ConvertCompleteMultipartUploadInputToXml(input, false)
        return
}</span>

func (input ListPartsInput) trans() (params map[string]string, headers map[string][]string, data interface{}) <span class="cov0" title="0">{
        params = map[string]string{"uploadId": input.UploadId}
        if input.MaxParts &gt; 0 </span><span class="cov0" title="0">{
                params["max-parts"] = IntToString(input.MaxParts)
        }</span>
        <span class="cov0" title="0">if input.PartNumberMarker &gt; 0 </span><span class="cov0" title="0">{
                params["part-number-marker"] = IntToString(input.PartNumberMarker)
        }</span>
        <span class="cov0" title="0">return</span>
}

func (input CopyPartInput) trans() (params map[string]string, headers map[string][]string, data interface{}) <span class="cov0" title="0">{
        params = map[string]string{"uploadId": input.UploadId, "partNumber": IntToString(input.PartNumber)}
        headers = make(map[string][]string, 1)
        var copySource string
        if input.CopySourceVersionId != "" </span><span class="cov0" title="0">{
                copySource = fmt.Sprintf("%s/%s?versionId=%s", input.CopySourceBucket, UrlEncode(input.CopySourceKey, false), input.CopySourceVersionId)
        }</span> else<span class="cov0" title="0"> {
                copySource = fmt.Sprintf("%s/%s", input.CopySourceBucket, UrlEncode(input.CopySourceKey, false))
        }</span>
        <span class="cov0" title="0">headers[HEADER_COPY_SOURCE_AMZ] = []string{copySource}

        if input.CopySourceRangeStart &gt;= 0 &amp;&amp; input.CopySourceRangeEnd &gt; input.CopySourceRangeStart </span><span class="cov0" title="0">{
                headers[HEADER_COPY_SOURCE_RANGE_AMZ] = []string{fmt.Sprintf("bytes=%d-%d", input.CopySourceRangeStart, input.CopySourceRangeEnd)}
        }</span>

        <span class="cov0" title="0">setSseHeader(headers, input.SseHeader, true)
        if input.SourceSseHeader != nil </span><span class="cov0" title="0">{
                if sseCHeader, ok := input.SourceSseHeader.(SseCHeader); ok </span><span class="cov0" title="0">{
                        headers[HEADER_SSEC_COPY_SOURCE_ENCRYPTION_AMZ] = []string{sseCHeader.GetEncryption()}
                        headers[HEADER_SSEC_COPY_SOURCE_KEY_AMZ] = []string{sseCHeader.GetKey()}
                        headers[HEADER_SSEC_COPY_SOURCE_KEY_MD5_AMZ] = []string{sseCHeader.GetKeyMD5()}
                }</span>
        }
        <span class="cov0" title="0">return</span>
}

type partSlice []Part

func (parts partSlice) Len() int <span class="cov0" title="0">{
        return len(parts)
}</span>

func (parts partSlice) Less(i, j int) bool <span class="cov0" title="0">{
        return parts[i].PartNumber &lt; parts[j].PartNumber
}</span>

func (parts partSlice) Swap(i, j int) <span class="cov0" title="0">{
        parts[i], parts[j] = parts[j], parts[i]
}</span>

type readerWrapper struct {
        reader      io.Reader
        mark        int64
        totalCount  int64
        readedCount int64
}

func (rw *readerWrapper) seek(offset int64, whence int) (int64, error) <span class="cov0" title="0">{
        if r, ok := rw.reader.(*strings.Reader); ok </span><span class="cov0" title="0">{
                return r.Seek(offset, whence)
        }</span> else<span class="cov0" title="0"> if r, ok := rw.reader.(*bytes.Reader); ok </span><span class="cov0" title="0">{
                return r.Seek(offset, whence)
        }</span> else<span class="cov0" title="0"> if r, ok := rw.reader.(*os.File); ok </span><span class="cov0" title="0">{
                return r.Seek(offset, whence)
        }</span>
        <span class="cov0" title="0">return offset, nil</span>
}

func (rw *readerWrapper) Read(p []byte) (n int, err error) <span class="cov0" title="0">{
        if rw.totalCount == 0 </span><span class="cov0" title="0">{
                return 0, io.EOF
        }</span>
        <span class="cov0" title="0">if rw.totalCount &gt; 0 </span><span class="cov0" title="0">{
                n, err = rw.reader.Read(p)
                readedOnce := int64(n)
                if remainCount := rw.totalCount - rw.readedCount; remainCount &gt; readedOnce </span><span class="cov0" title="0">{
                        rw.readedCount += readedOnce
                        return n, err
                }</span> else<span class="cov0" title="0"> {
                        rw.readedCount += remainCount
                        return int(remainCount), io.EOF
                }</span>
        }
        <span class="cov0" title="0">return rw.reader.Read(p)</span>
}

type fileReaderWrapper struct {
        readerWrapper
        filePath string
}
</pre>

		<pre class="file" id="file11" style="display: none">package obs

import (
        "crypto/hmac"
        "crypto/md5"
        "crypto/sha1"
        "crypto/sha256"
        "encoding/base64"
        "encoding/hex"
        "encoding/xml"
        "fmt"
        "net/url"
        "regexp"
        "strconv"
        "strings"
        "time"
)

var regex = regexp.MustCompile("^[\u4e00-\u9fa5]$")
var ipRegex = regexp.MustCompile("^((2[0-4]\\d|25[0-5]|[01]?\\d\\d?)\\.){3}(2[0-4]\\d|25[0-5]|[01]?\\d\\d?)$")
var v4AuthRegex = regexp.MustCompile("Credential=(.+?),SignedHeaders=(.+?),Signature=.+")
var regionRegex = regexp.MustCompile(".+/\\d+/(.+?)/.+")

func StringToInt(value string, def int) int <span class="cov0" title="0">{
        ret, err := strconv.Atoi(value)
        if err != nil </span><span class="cov0" title="0">{
                ret = def
        }</span>
        <span class="cov0" title="0">return ret</span>
}

func StringToInt64(value string, def int64) int64 <span class="cov0" title="0">{
        ret, err := strconv.ParseInt(value, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                ret = def
        }</span>
        <span class="cov0" title="0">return ret</span>
}

func IntToString(value int) string <span class="cov0" title="0">{
        return strconv.Itoa(value)
}</span>

func Int64ToString(value int64) string <span class="cov0" title="0">{
        return strconv.FormatInt(value, 10)
}</span>

func GetCurrentTimestamp() int64 <span class="cov0" title="0">{
        return time.Now().UnixNano() / 1000000
}</span>

func FormatUtcNow(format string) string <span class="cov0" title="0">{
        return time.Now().UTC().Format(format)
}</span>

func FormatUtcToRfc1123(t time.Time) string <span class="cov0" title="0">{
        ret := t.UTC().Format(time.RFC1123)
        return ret[:strings.LastIndex(ret, "UTC")] + "GMT"
}</span>

func Md5(value []byte) []byte <span class="cov0" title="0">{
        m := md5.New()
        m.Write(value)
        return m.Sum(nil)
}</span>

func HmacSha1(key, value []byte) []byte <span class="cov0" title="0">{
        mac := hmac.New(sha1.New, key)
        mac.Write(value)
        return mac.Sum(nil)
}</span>

func HmacSha256(key, value []byte) []byte <span class="cov0" title="0">{
        mac := hmac.New(sha256.New, key)
        mac.Write(value)
        return mac.Sum(nil)
}</span>

func Base64Encode(value []byte) string <span class="cov0" title="0">{
        return base64.StdEncoding.EncodeToString(value)
}</span>

func Base64Decode(value string) ([]byte, error) <span class="cov0" title="0">{
        return base64.StdEncoding.DecodeString(value)
}</span>

func HexMd5(value []byte) string <span class="cov0" title="0">{
        return Hex(Md5(value))
}</span>

func Base64Md5(value []byte) string <span class="cov0" title="0">{
        return Base64Encode(Md5(value))
}</span>

func Sha256Hash(value []byte) []byte <span class="cov0" title="0">{
        hash := sha256.New()
        hash.Write(value)
        return hash.Sum(nil)
}</span>

func ParseXml(value []byte, result interface{}) error <span class="cov0" title="0">{
        if len(value) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return xml.Unmarshal(value, result)</span>
}

func TransToXml(value interface{}) ([]byte, error) <span class="cov0" title="0">{
        if value == nil </span><span class="cov0" title="0">{
                return []byte{}, nil
        }</span>
        <span class="cov0" title="0">return xml.Marshal(value)</span>
}

func Hex(value []byte) string <span class="cov0" title="0">{
        return hex.EncodeToString(value)
}</span>

func HexSha256(value []byte) string <span class="cov0" title="0">{
        return Hex(Sha256Hash(value))
}</span>

func UrlDecode(value string) (string, error) <span class="cov0" title="0">{
        ret, err := url.QueryUnescape(value)
        if err == nil </span><span class="cov0" title="0">{
                return ret, nil
        }</span>
        <span class="cov0" title="0">return "", err</span>
}

func IsIP(value string) bool <span class="cov0" title="0">{
        return ipRegex.MatchString(value)
}</span>

func UrlEncode(value string, chineseOnly bool) string <span class="cov0" title="0">{
        if chineseOnly </span><span class="cov0" title="0">{
                values := make([]string, 0, len(value))
                for _, val := range value </span><span class="cov0" title="0">{
                        _value := string(val)
                        if regex.MatchString(_value) </span><span class="cov0" title="0">{
                                _value = url.QueryEscape(_value)
                        }</span>
                        <span class="cov0" title="0">values = append(values, _value)</span>
                }
                <span class="cov0" title="0">return strings.Join(values, "")</span>
        }
        <span class="cov0" title="0">return url.QueryEscape(value)</span>
}

func copyHeaders(m map[string][]string) (ret map[string][]string) <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                ret = make(map[string][]string, len(m))
                for key, values := range m </span><span class="cov0" title="0">{
                        _values := make([]string, 0, len(values))
                        for _, value := range values </span><span class="cov0" title="0">{
                                _values = append(_values, value)
                        }</span>
                        <span class="cov0" title="0">ret[strings.ToLower(key)] = _values</span>
                }
        } else<span class="cov0" title="0"> {
                ret = make(map[string][]string)
        }</span>

        <span class="cov0" title="0">return</span>
}

func parseHeaders(headers map[string][]string) (signature string, region string, signedHeaders string) <span class="cov0" title="0">{
        signature = "v2"
        if receviedAuthorization, ok := headers[strings.ToLower(HEADER_AUTH_CAMEL)]; ok &amp;&amp; len(receviedAuthorization) &gt; 0 </span><span class="cov0" title="0">{
                if strings.HasPrefix(receviedAuthorization[0], V4_HASH_PREFIX) </span><span class="cov0" title="0">{
                        signature = "v4"
                        matches := v4AuthRegex.FindStringSubmatch(receviedAuthorization[0])
                        if len(matches) &gt;= 3 </span><span class="cov0" title="0">{
                                region = matches[1]
                                regions := regionRegex.FindStringSubmatch(region)
                                if len(regions) &gt;= 2 </span><span class="cov0" title="0">{
                                        region = regions[1]
                                }</span>
                                <span class="cov0" title="0">signedHeaders = matches[2]</span>
                        }

                } else<span class="cov0" title="0"> if strings.HasPrefix(receviedAuthorization[0], V2_HASH_PREFIX) </span><span class="cov0" title="0">{
                        signature = "v2"
                }</span>
        }
        <span class="cov0" title="0">return</span>
}

func getTemporaryKeys() []string <span class="cov0" title="0">{
        return []string{
                "Signature",
                "signature",
                "X-Amz-Signature",
                "x-amz-signature",
        }
}</span>

func GetAuthorization(ak, sk, method, bucketName, objectKey, queryUrl string, headers map[string][]string) (ret map[string]string) <span class="cov0" title="0">{

        if strings.HasPrefix(queryUrl, "?") </span><span class="cov0" title="0">{
                queryUrl = queryUrl[1:]
        }</span>

        <span class="cov0" title="0">method = strings.ToUpper(method)

        querys := strings.Split(queryUrl, "&amp;")

        params := make(map[string]string)

        for _, value := range querys </span><span class="cov0" title="0">{
                kv := strings.Split(value, "=")
                length := len(kv)
                if length == 1 </span><span class="cov0" title="0">{
                        key, _ := UrlDecode(kv[0])
                        params[key] = ""
                }</span> else<span class="cov0" title="0"> if length &gt;= 2 </span><span class="cov0" title="0">{
                        key, _ := UrlDecode(kv[0])
                        vals := make([]string, 0, length-1)
                        for i := 1; i &lt; length; i++ </span><span class="cov0" title="0">{
                                val, _ := UrlDecode(kv[i])
                                vals = append(vals, val)
                        }</span>
                        <span class="cov0" title="0">params[key] = strings.Join(vals, "=")</span>
                }
        }

        <span class="cov0" title="0">isTemporary := false
        signature := "v2"
        temporaryKeys := getTemporaryKeys()
        for _, key := range temporaryKeys </span><span class="cov0" title="0">{
                if _, ok := params[key]; ok </span><span class="cov0" title="0">{
                        isTemporary = true
                        if strings.ToLower(key) == "signature" </span><span class="cov0" title="0">{
                                signature = "v2"
                        }</span> else<span class="cov0" title="0"> if strings.ToLower(key) == "x-amz-signature" </span><span class="cov0" title="0">{
                                signature = "v4"
                        }</span>
                        <span class="cov0" title="0">break</span>
                }
        }
        <span class="cov0" title="0">headers = copyHeaders(headers)
        pathStyle := false
        if receviedHost, ok := headers[HEADER_HOST]; ok &amp;&amp; len(receviedHost) &gt; 0 &amp;&amp; !strings.HasPrefix(receviedHost[0], bucketName+".") </span><span class="cov0" title="0">{
                pathStyle = true
        }</span>
        <span class="cov0" title="0">conf := &amp;config{securityProvider: &amp;securityProvider{ak: ak, sk: sk},
                urlHolder: &amp;urlHolder{scheme: "https", host: "dummy", port: 443},
                pathStyle: pathStyle}

        if isTemporary </span><span class="cov0" title="0">{
                return getTemporaryAuthorization(ak, sk, method, bucketName, objectKey, signature, conf, params, headers)
        }</span> else<span class="cov0" title="0"> {
                signature, region, signedHeaders := parseHeaders(headers)
                if signature == "v4" </span><span class="cov0" title="0">{
                        conf.signature = SignatureV4
                        requestUrl, canonicalizedUrl := conf.formatUrls(bucketName, objectKey, params, false)
                        parsedRequestUrl, _ := url.Parse(requestUrl)
                        headerKeys := strings.Split(signedHeaders, ";")
                        _headers := make(map[string][]string, len(headerKeys))
                        for _, headerKey := range headerKeys </span><span class="cov0" title="0">{
                                _headers[headerKey] = headers[headerKey]
                        }</span>
                        <span class="cov0" title="0">ret = v4Auth(ak, sk, region, method, canonicalizedUrl, parsedRequestUrl.RawQuery, _headers)
                        ret[HEADER_AUTH_CAMEL] = fmt.Sprintf("%s Credential=%s,SignedHeaders=%s,Signature=%s", V4_HASH_PREFIX, ret["Credential"], ret["SignedHeaders"], ret["Signature"])</span>
                } else<span class="cov0" title="0"> if signature == "v2" </span><span class="cov0" title="0">{
                        conf.signature = SignatureV2
                        _, canonicalizedUrl := conf.formatUrls(bucketName, objectKey, params, false)
                        ret = v2Auth(ak, sk, method, canonicalizedUrl, headers)
                        ret[HEADER_AUTH_CAMEL] = fmt.Sprintf("%s %s:%s", V2_HASH_PREFIX, ak, ret["Signature"])
                }</span>
                <span class="cov0" title="0">return</span>
        }

}

func getTemporaryAuthorization(ak, sk, method, bucketName, objectKey, signature string, conf *config, params map[string]string,
        headers map[string][]string) (ret map[string]string) <span class="cov0" title="0">{

        if signature == "v4" </span><span class="cov0" title="0">{
                conf.signature = SignatureV4

                longDate, ok := params[PARAM_DATE_AMZ_CAMEL]
                if !ok </span><span class="cov0" title="0">{
                        longDate = params[HEADER_DATE_AMZ]
                }</span>
                <span class="cov0" title="0">shortDate := longDate[:8]

                credential, ok := params[PARAM_CREDENTIAL_AMZ_CAMEL]
                if !ok </span><span class="cov0" title="0">{
                        credential = params[strings.ToLower(PARAM_CREDENTIAL_AMZ_CAMEL)]
                }</span>

                <span class="cov0" title="0">_credential, _ := UrlDecode(credential)

                regions := regionRegex.FindStringSubmatch(_credential)
                var region string
                if len(regions) &gt;= 2 </span><span class="cov0" title="0">{
                        region = regions[1]
                }</span>

                <span class="cov0" title="0">_, scope := getCredential(ak, region, shortDate)

                expires, ok := params[PARAM_EXPIRES_AMZ_CAMEL]
                if !ok </span><span class="cov0" title="0">{
                        expires = params[strings.ToLower(PARAM_EXPIRES_AMZ_CAMEL)]
                }</span>

                <span class="cov0" title="0">signedHeaders, ok := params[PARAM_SIGNEDHEADERS_AMZ_CAMEL]
                if !ok </span><span class="cov0" title="0">{
                        signedHeaders = params[strings.ToLower(PARAM_SIGNEDHEADERS_AMZ_CAMEL)]
                }</span>

                <span class="cov0" title="0">algorithm, ok := params[PARAM_ALGORITHM_AMZ_CAMEL]
                if !ok </span><span class="cov0" title="0">{
                        algorithm = params[strings.ToLower(PARAM_ALGORITHM_AMZ_CAMEL)]
                }</span>

                <span class="cov0" title="0">if _, ok := params[PARAM_SIGNATURE_AMZ_CAMEL]; ok </span><span class="cov0" title="0">{
                        delete(params, PARAM_SIGNATURE_AMZ_CAMEL)
                }</span> else<span class="cov0" title="0"> if _, ok := params[strings.ToLower(PARAM_SIGNATURE_AMZ_CAMEL)]; ok </span><span class="cov0" title="0">{
                        delete(params, strings.ToLower(PARAM_SIGNATURE_AMZ_CAMEL))
                }</span>

                <span class="cov0" title="0">ret = make(map[string]string, 6)
                ret[PARAM_ALGORITHM_AMZ_CAMEL] = algorithm
                ret[PARAM_CREDENTIAL_AMZ_CAMEL] = credential
                ret[PARAM_DATE_AMZ_CAMEL] = longDate
                ret[PARAM_EXPIRES_AMZ_CAMEL] = expires
                ret[PARAM_SIGNEDHEADERS_AMZ_CAMEL] = signedHeaders

                requestUrl, canonicalizedUrl := conf.formatUrls(bucketName, objectKey, params, false)
                parsedRequestUrl, _ := url.Parse(requestUrl)
                stringToSign := getV4StringToSign(method, canonicalizedUrl, parsedRequestUrl.RawQuery, scope, longDate, UNSIGNED_PAYLOAD, strings.Split(signedHeaders, ";"), headers)
                ret[PARAM_SIGNATURE_AMZ_CAMEL] = UrlEncode(getSignature(stringToSign, sk, region, shortDate), false)</span>
        } else<span class="cov0" title="0"> if signature == "v2" </span><span class="cov0" title="0">{
                conf.signature = SignatureV2
                _, canonicalizedUrl := conf.formatUrls(bucketName, objectKey, params, false)
                expires, ok := params["Expires"]
                if !ok </span><span class="cov0" title="0">{
                        expires = params["expires"]
                }</span>
                <span class="cov0" title="0">headers[HEADER_DATE_CAMEL] = []string{expires}
                stringToSign := getV2StringToSign(method, canonicalizedUrl, headers)
                ret = make(map[string]string, 3)
                ret["Signature"] = UrlEncode(Base64Encode(HmacSha1([]byte(sk), []byte(stringToSign))), false)
                ret["AWSAccessKeyId"] = UrlEncode(ak, false)
                ret["Expires"] = UrlEncode(expires, false)</span>
        }

        <span class="cov0" title="0">return</span>
}
</pre>

		<pre class="file" id="file12" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package main

import (
        "fmt"
        "os"

        micro "github.com/micro/go-micro"
        "github.com/soda/multi-cloud/backend/pkg/db"
        handler "github.com/soda/multi-cloud/backend/pkg/service"
        "github.com/soda/multi-cloud/backend/pkg/utils/config"
        pb "github.com/soda/multi-cloud/backend/proto"
        "github.com/soda/multi-cloud/api/pkg/utils/obs"
)

func main() <span class="cov8" title="1">{
        dbHost := os.Getenv("DB_HOST")
        db.Init(&amp;config.Database{
                Driver:   "mongodb",
                Endpoint: dbHost})
        defer db.Exit()

        obs.InitLogs()
        service := micro.NewService(
                micro.Name("backend"),
        )

        service.Init()

        pb.RegisterBackendHandler(service.Server(), handler.NewBackendService())
        if err := service.Run(); err != nil </span><span class="cov0" title="0">{
                fmt.Println(err)
        }</span>
}
</pre>

		<pre class="file" id="file13" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package db

import (
        "fmt"
        "context"
        "github.com/soda/multi-cloud/backend/pkg/db/drivers/mongo"
        "github.com/soda/multi-cloud/backend/pkg/model"
        "github.com/soda/multi-cloud/backend/pkg/utils/config"
)

type Repository interface {
        // Backend
        CreateBackend(ctx context.Context, backend *model.Backend) (*model.Backend, error)
        DeleteBackend(ctx context.Context, id string) error
        UpdateBackend(ctx context.Context, backend *model.Backend) (*model.Backend, error)
        GetBackend(ctx context.Context, id string) (*model.Backend, error)
        ListBackend(ctx context.Context, limit, offset int, query interface{}) ([]*model.Backend, error)
        Close()
}

var Repo Repository

func Init(db *config.Database) <span class="cov8" title="1">{
        switch db.Driver </span>{
        case "etcd":<span class="cov0" title="0">
                // C = etcd.Init(db.Driver, db.Crendential)
                fmt.Printf("etcd is not implemented right now!")
                return</span>
        case "mongodb":<span class="cov8" title="1">
                Repo = mongo.Init(db.Endpoint)
                return</span>
        default:<span class="cov0" title="0">
                fmt.Printf("Can't find database driver %s!\n", db.Driver)</span>
        }
}

func Exit() <span class="cov8" title="1">{
        Repo.Close()
}</span>
</pre>

		<pre class="file" id="file14" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mongo

import (
        "context"
        "errors"
        "math"
        "sync"

        "github.com/globalsign/mgo"
        "github.com/globalsign/mgo/bson"
        log "github.com/sirupsen/logrus"
        "github.com/micro/go-micro/metadata"
        "github.com/soda/multi-cloud/api/pkg/common"
        "github.com/soda/multi-cloud/backend/pkg/model"
)

type mongoRepository struct {
        session *mgo.Session
}

var defaultDBName = "multi-cloud"
var defaultCollection = "backends"
var mutex sync.Mutex
var mongoRepo = &amp;mongoRepository{}

func Init(host string) *mongoRepository <span class="cov8" title="1">{
        mutex.Lock()
        defer mutex.Unlock()

        if mongoRepo.session != nil </span><span class="cov0" title="0">{
                return mongoRepo
        }</span>

        <span class="cov8" title="1">session, err := mgo.Dial(host)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov8" title="1">session.SetMode(mgo.Monotonic, true)
        mongoRepo.session = session
        return mongoRepo</span>
}

// The implementation of Repository
func UpdateFilter(m bson.M, filter map[string]string) error <span class="cov8" title="1">{
        for k, v := range filter </span><span class="cov8" title="1">{
                m[k] = interface{}(v)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func UpdateContextFilter(ctx context.Context, m bson.M) error <span class="cov8" title="1">{
        // if context is admin, no need filter by tenantId.
        md, ok := metadata.FromContext(ctx)
        if !ok </span><span class="cov0" title="0">{
                log.Error("get context failed")
                return errors.New("get context failed")
        }</span>

        <span class="cov8" title="1">isAdmin, _ := md[common.CTX_KEY_IS_ADMIN]
        if isAdmin != common.CTX_VAL_TRUE </span><span class="cov8" title="1">{
                tenantId, ok := md[common.CTX_KEY_TENANT_ID]
                if !ok </span><span class="cov0" title="0">{
                        log.Error("get tenantid failed")
                        return errors.New("get tenantid failed")
                }</span>
                <span class="cov8" title="1">m["tenantId"] = tenantId</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (repo *mongoRepository) CreateBackend(ctx context.Context, backend *model.Backend) (*model.Backend, error) <span class="cov0" title="0">{
        session := repo.session.Copy()
        defer session.Close()

        if backend.Id == "" </span><span class="cov0" title="0">{
                backend.Id = bson.NewObjectId()
        }</span>

        <span class="cov0" title="0">err := session.DB(defaultDBName).C(defaultCollection).Insert(backend)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return backend, nil</span>
}

func (repo *mongoRepository) DeleteBackend(ctx context.Context, id string) error <span class="cov0" title="0">{
        session := repo.session.Copy()
        defer session.Close()

        m := bson.M{"_id": bson.ObjectIdHex(id)}
        err := UpdateContextFilter(ctx, m)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return session.DB(defaultDBName).C(defaultCollection).Remove(m)</span>
}

func (repo *mongoRepository) UpdateBackend(ctx context.Context,
        backend *model.Backend) (*model.Backend, error) <span class="cov0" title="0">{
        session := repo.session.Copy()
        defer session.Close()

        m := bson.M{"_id": backend.Id}
        err := UpdateContextFilter(ctx, m)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">err = session.DB(defaultDBName).C(defaultCollection).Update(m, backend)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return backend, nil</span>
}

func (repo *mongoRepository) GetBackend(ctx context.Context, id string) (*model.Backend,
        error) <span class="cov0" title="0">{
        session := repo.session.Copy()
        defer session.Close()

        m := bson.M{"_id": bson.ObjectIdHex(id)}
        err := UpdateContextFilter(ctx, m)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var backend = &amp;model.Backend{}
        collection := session.DB(defaultDBName).C(defaultCollection)
        err = collection.Find(m).One(backend)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return backend, nil</span>
}

func (repo *mongoRepository) ListBackend(ctx context.Context, limit, offset int,
        query interface{}) ([]*model.Backend, error) <span class="cov8" title="1">{

        session := repo.session.Copy()
        defer session.Close()

        if limit == 0 </span><span class="cov0" title="0">{
                limit = math.MinInt32
        }</span>
        <span class="cov8" title="1">var backends []*model.Backend

        m := bson.M{}
        UpdateFilter(m, query.(map[string]string))
        err := UpdateContextFilter(ctx, m)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">log.Infof("ListBackend, limit=%d, offset=%d, m=%+v\n", limit, offset, m)

        err = session.DB(defaultDBName).C(defaultCollection).Find(m).Skip(offset).Limit(limit).All(&amp;backends)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return backends, nil</span>
}

func (repo *mongoRepository) Close() <span class="cov8" title="1">{
        repo.session.Close()
}</span>
</pre>

		<pre class="file" id="file15" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package service

import (
        "context"
        "errors"
        "fmt"

        log "github.com/sirupsen/logrus"
        "github.com/soda/multi-cloud/backend/pkg/db"
        "github.com/soda/multi-cloud/backend/pkg/model"
        "github.com/soda/multi-cloud/backend/pkg/utils/constants"
        pb "github.com/soda/multi-cloud/backend/proto"
)

type backendService struct{}

func NewBackendService() pb.BackendHandler <span class="cov8" title="1">{
        return &amp;backendService{}
}</span>

func (b *backendService) CreateBackend(ctx context.Context, in *pb.CreateBackendRequest, out *pb.CreateBackendResponse) error <span class="cov0" title="0">{
        log.Info("Received CreateBackend request.")
        backend := &amp;model.Backend{
                Name:       in.Backend.Name,
                TenantId:   in.Backend.TenantId,
                UserId:     in.Backend.UserId,
                Type:       in.Backend.Type,
                Region:     in.Backend.Region,
                Endpoint:   in.Backend.Endpoint,
                BucketName: in.Backend.BucketName,
                Access:     in.Backend.Access,
                Security:   in.Backend.Security,
        }
        res, err := db.Repo.CreateBackend(ctx, backend)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("Failed to create backend: %v", err)
                return err
        }</span>
        <span class="cov0" title="0">out.Backend = &amp;pb.BackendDetail{
                Id:         res.Id.Hex(),
                Name:       res.Name,
                TenantId:   res.TenantId,
                UserId:     res.UserId,
                Type:       res.Type,
                Region:     res.Region,
                Endpoint:   res.Endpoint,
                BucketName: res.BucketName,
                Access:     res.Access,
                Security:   res.Security,
        }
        log.Info("Create backend successfully.")
        return nil</span>

}

func (b *backendService) GetBackend(ctx context.Context, in *pb.GetBackendRequest, out *pb.GetBackendResponse) error <span class="cov0" title="0">{
        log.Info("Received GetBackend request.")
        res, err := db.Repo.GetBackend(ctx, in.Id)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to get backend: %v\n", err)
                return err
        }</span>
        <span class="cov0" title="0">out.Backend = &amp;pb.BackendDetail{
                Id:         res.Id.Hex(),
                Name:       res.Name,
                TenantId:   res.TenantId,
                UserId:     res.UserId,
                Type:       res.Type,
                Region:     res.Region,
                Endpoint:   res.Endpoint,
                BucketName: res.BucketName,
                Access:     res.Access,
                Security:   res.Security,
        }
        log.Info("Get backend successfully.")
        return nil</span>
}

func (b *backendService) ListBackend(ctx context.Context, in *pb.ListBackendRequest, out *pb.ListBackendResponse) error <span class="cov8" title="1">{
        log.Info("Received ListBackend request.")
        // (query *model.QueryField, sort *model.SortField, sortBy *model.SortBy, page *model.Pagination

        if in.Limit &lt; 0 || in.Offset &lt; 0 </span><span class="cov0" title="0">{
                msg := fmt.Sprintf("invalid pagination parameter, limit = %d and offset = %d.", in.Limit, in.Offset)
                log.Info(msg)
                return errors.New(msg)
        }</span>

        <span class="cov8" title="1">res, err := db.Repo.ListBackend(ctx, int(in.Limit), int(in.Offset), in.Filter)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to list backend: %v\n", err)
                return err
        }</span>

        <span class="cov8" title="1">var backends []*pb.BackendDetail
        for _, item := range res </span><span class="cov8" title="1">{
                backends = append(backends, &amp;pb.BackendDetail{
                        Id:         item.Id.Hex(),
                        Name:       item.Name,
                        TenantId:   item.TenantId,
                        UserId:     item.UserId,
                        Type:       item.Type,
                        Region:     item.Region,
                        Endpoint:   item.Endpoint,
                        BucketName: item.BucketName,
                        Access:     item.Access,
                        Security:   item.Security,
                })
        }</span>
        <span class="cov8" title="1">out.Backends = backends
        out.Next = in.Offset + int32(len(res))

        log.Infof("Get backend successfully, #num=%d, backends:%+v\n", len(backends), backends)
        return nil</span>
}

func (b *backendService) UpdateBackend(ctx context.Context, in *pb.UpdateBackendRequest, out *pb.UpdateBackendResponse) error <span class="cov0" title="0">{
        log.Info("Received UpdateBackend request.")
        backend, err := db.Repo.GetBackend(ctx, in.Id)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to get backend: %v\n", err)
                return err
        }</span>

        // TODO: check if access and security is valid.
        <span class="cov0" title="0">backend.Access = in.Access
        backend.Security = in.Security
        res, err := db.Repo.UpdateBackend(ctx, backend)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to update backend: %v\n", err)
                return err
        }</span>

        <span class="cov0" title="0">out.Backend = &amp;pb.BackendDetail{
                Id:         res.Id.Hex(),
                Name:       res.Name,
                TenantId:   res.TenantId,
                UserId:     res.UserId,
                Type:       res.Type,
                Region:     res.Region,
                Endpoint:   res.Endpoint,
                BucketName: res.BucketName,
                Access:     res.Access,
                Security:   res.Security,
        }
        log.Info("Update backend successfully.")
        return nil</span>
}

func (b *backendService) DeleteBackend(ctx context.Context, in *pb.DeleteBackendRequest, out *pb.DeleteBackendResponse) error <span class="cov0" title="0">{
        log.Info("Received DeleteBackend request.")
        err := db.Repo.DeleteBackend(ctx, in.Id)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to delete backend: %v\n", err)
                return err
        }</span>
        <span class="cov0" title="0">log.Info("Delete backend successfully.")
        return nil</span>
}

func (b *backendService) ListType(ctx context.Context, in *pb.ListTypeRequest, out *pb.ListTypeResponse) error <span class="cov8" title="1">{
        log.Info("Received ListType request.")
        allTypes := []*pb.TypeDetail{
                {
                        Name:        constants.BackendTypeAws,
                        Description: "AWS Simple Cloud Storage Service(S3)",
                },
                {
                        Name:        constants.BackendTypeObs,
                        Description: "Huawei Object Storage Service(OBS)",
                },
                {
                        Name:        constants.BackendTypeAzure,
                        Description: "Azure Blob Storage",
                },
                {
                        Name:        constants.BackendTypeCeph,
                        Description: "Ceph Object Storage",
                },
                {
                        Name:        constants.BackendTypeGcs,
                        Description: "GCP Storage",
                },
                {
                        Name:        constants.BackendFusionStorage,
                        Description: "Huawei Fusionstorage Object Storage",
                },
                {
                        Name:        constants.BackendTypeIBMCos,
                        Description: "IBM Cloud Object Storage",
                },
                {
                        Name:        constants.BackendTypeYIGS3,
                        Description: "YIG Storage",
                },
                {
                        Name:        constants.BackendTypeAlibaba,
                        Description: "Alibaba OSS Object Storage",
                },
                 {
                        Name:        constants.BackendTypeSonyODA,
                        Description: "Sony-ODA Object Storage",
                },
        }

        // Filter by name
        var types []*pb.TypeDetail
        if name, ok := in.Filter["name"]; ok </span><span class="cov0" title="0">{
                for _, t := range allTypes </span><span class="cov0" title="0">{
                        if t.Name == name </span><span class="cov0" title="0">{
                                types = append(types, t)
                        }</span>
                }
        } else<span class="cov8" title="1"> {
                types = allTypes
        }</span>

        // Pagination handle
        <span class="cov8" title="1">if int(in.Offset) &gt; len(types) </span><span class="cov0" title="0">{
                return fmt.Errorf("offset exceeds the max type length")
        }</span>
        <span class="cov8" title="1">start := int(in.Offset)
        end := start + int(in.Limit)
        if end &gt; len(types) </span><span class="cov8" title="1">{
                end = len(types)
        }</span>

        <span class="cov8" title="1">out.Types = types[start:end]
        out.Next = in.Offset + int32(len(out.Types))
        log.Infof("Types:%+v\n", out.Types)
        return nil</span>
}
</pre>

		<pre class="file" id="file16" style="display: none">// Code generated by protoc-gen-micro. DO NOT EDIT.
// source: backend.proto

/*
Package backend is a generated protocol buffer package.

It is generated from these files:
        backend.proto

It has these top-level messages:
        CreateBackendRequest
        CreateBackendResponse
        GetBackendRequest
        GetBackendResponse
        ListBackendRequest
        ListBackendResponse
        UpdateBackendRequest
        UpdateBackendResponse
        DeleteBackendRequest
        DeleteBackendResponse
        BackendDetail
        ListTypeRequest
        ListTypeResponse
        TypeDetail
*/
package backend

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
        context "context"

        client "github.com/micro/go-micro/client"
        server "github.com/micro/go-micro/server"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ client.Option
var _ server.Option

// Client API for Backend service

type BackendService interface {
        CreateBackend(ctx context.Context, in *CreateBackendRequest, opts ...client.CallOption) (*CreateBackendResponse, error)
        GetBackend(ctx context.Context, in *GetBackendRequest, opts ...client.CallOption) (*GetBackendResponse, error)
        ListBackend(ctx context.Context, in *ListBackendRequest, opts ...client.CallOption) (*ListBackendResponse, error)
        UpdateBackend(ctx context.Context, in *UpdateBackendRequest, opts ...client.CallOption) (*UpdateBackendResponse, error)
        DeleteBackend(ctx context.Context, in *DeleteBackendRequest, opts ...client.CallOption) (*DeleteBackendResponse, error)
        ListType(ctx context.Context, in *ListTypeRequest, opts ...client.CallOption) (*ListTypeResponse, error)
}

type backendService struct {
        c    client.Client
        name string
}

func NewBackendService(name string, c client.Client) BackendService <span class="cov0" title="0">{
        if c == nil </span><span class="cov0" title="0">{
                c = client.NewClient()
        }</span>
        <span class="cov0" title="0">if len(name) == 0 </span><span class="cov0" title="0">{
                name = "backend"
        }</span>
        <span class="cov0" title="0">return &amp;backendService{
                c:    c,
                name: name,
        }</span>
}

func (c *backendService) CreateBackend(ctx context.Context, in *CreateBackendRequest, opts ...client.CallOption) (*CreateBackendResponse, error) <span class="cov0" title="0">{
        req := c.c.NewRequest(c.name, "Backend.CreateBackend", in)
        out := new(CreateBackendResponse)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *backendService) GetBackend(ctx context.Context, in *GetBackendRequest, opts ...client.CallOption) (*GetBackendResponse, error) <span class="cov0" title="0">{
        req := c.c.NewRequest(c.name, "Backend.GetBackend", in)
        out := new(GetBackendResponse)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *backendService) ListBackend(ctx context.Context, in *ListBackendRequest, opts ...client.CallOption) (*ListBackendResponse, error) <span class="cov0" title="0">{
        req := c.c.NewRequest(c.name, "Backend.ListBackend", in)
        out := new(ListBackendResponse)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *backendService) UpdateBackend(ctx context.Context, in *UpdateBackendRequest, opts ...client.CallOption) (*UpdateBackendResponse, error) <span class="cov0" title="0">{
        req := c.c.NewRequest(c.name, "Backend.UpdateBackend", in)
        out := new(UpdateBackendResponse)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *backendService) DeleteBackend(ctx context.Context, in *DeleteBackendRequest, opts ...client.CallOption) (*DeleteBackendResponse, error) <span class="cov0" title="0">{
        req := c.c.NewRequest(c.name, "Backend.DeleteBackend", in)
        out := new(DeleteBackendResponse)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *backendService) ListType(ctx context.Context, in *ListTypeRequest, opts ...client.CallOption) (*ListTypeResponse, error) <span class="cov0" title="0">{
        req := c.c.NewRequest(c.name, "Backend.ListType", in)
        out := new(ListTypeResponse)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// Server API for Backend service

type BackendHandler interface {
        CreateBackend(context.Context, *CreateBackendRequest, *CreateBackendResponse) error
        GetBackend(context.Context, *GetBackendRequest, *GetBackendResponse) error
        ListBackend(context.Context, *ListBackendRequest, *ListBackendResponse) error
        UpdateBackend(context.Context, *UpdateBackendRequest, *UpdateBackendResponse) error
        DeleteBackend(context.Context, *DeleteBackendRequest, *DeleteBackendResponse) error
        ListType(context.Context, *ListTypeRequest, *ListTypeResponse) error
}

func RegisterBackendHandler(s server.Server, hdlr BackendHandler, opts ...server.HandlerOption) error <span class="cov8" title="1">{
        type backend interface {
                CreateBackend(ctx context.Context, in *CreateBackendRequest, out *CreateBackendResponse) error
                GetBackend(ctx context.Context, in *GetBackendRequest, out *GetBackendResponse) error
                ListBackend(ctx context.Context, in *ListBackendRequest, out *ListBackendResponse) error
                UpdateBackend(ctx context.Context, in *UpdateBackendRequest, out *UpdateBackendResponse) error
                DeleteBackend(ctx context.Context, in *DeleteBackendRequest, out *DeleteBackendResponse) error
                ListType(ctx context.Context, in *ListTypeRequest, out *ListTypeResponse) error
        }
        type Backend struct {
                backend
        }
        h := &amp;backendHandler{hdlr}
        return s.Handle(s.NewHandler(&amp;Backend{h}, opts...))
}</span>

type backendHandler struct {
        BackendHandler
}

func (h *backendHandler) CreateBackend(ctx context.Context, in *CreateBackendRequest, out *CreateBackendResponse) error <span class="cov0" title="0">{
        return h.BackendHandler.CreateBackend(ctx, in, out)
}</span>

func (h *backendHandler) GetBackend(ctx context.Context, in *GetBackendRequest, out *GetBackendResponse) error <span class="cov0" title="0">{
        return h.BackendHandler.GetBackend(ctx, in, out)
}</span>

func (h *backendHandler) ListBackend(ctx context.Context, in *ListBackendRequest, out *ListBackendResponse) error <span class="cov8" title="1">{
        return h.BackendHandler.ListBackend(ctx, in, out)
}</span>

func (h *backendHandler) UpdateBackend(ctx context.Context, in *UpdateBackendRequest, out *UpdateBackendResponse) error <span class="cov0" title="0">{
        return h.BackendHandler.UpdateBackend(ctx, in, out)
}</span>

func (h *backendHandler) DeleteBackend(ctx context.Context, in *DeleteBackendRequest, out *DeleteBackendResponse) error <span class="cov0" title="0">{
        return h.BackendHandler.DeleteBackend(ctx, in, out)
}</span>

func (h *backendHandler) ListType(ctx context.Context, in *ListTypeRequest, out *ListTypeResponse) error <span class="cov8" title="1">{
        return h.BackendHandler.ListType(ctx, in, out)
}</span>
</pre>

		<pre class="file" id="file17" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// source: backend.proto

/*
Package backend is a generated protocol buffer package.

It is generated from these files:
        backend.proto

It has these top-level messages:
        CreateBackendRequest
        CreateBackendResponse
        GetBackendRequest
        GetBackendResponse
        ListBackendRequest
        ListBackendResponse
        UpdateBackendRequest
        UpdateBackendResponse
        DeleteBackendRequest
        DeleteBackendResponse
        BackendDetail
        ListTypeRequest
        ListTypeResponse
        TypeDetail
*/
package backend

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type CreateBackendRequest struct {
        Backend *BackendDetail `protobuf:"bytes,1,opt,name=backend" json:"backend,omitempty"`
}

func (m *CreateBackendRequest) Reset()                    <span class="cov0" title="0">{ *m = CreateBackendRequest{} }</span>
func (m *CreateBackendRequest) String() string            <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*CreateBackendRequest) ProtoMessage()               {<span class="cov0" title="0">}</span>
func (*CreateBackendRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{ return fileDescriptor0, []int{0} }</span>

func (m *CreateBackendRequest) GetBackend() *BackendDetail <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Backend
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type CreateBackendResponse struct {
        Backend *BackendDetail `protobuf:"bytes,1,opt,name=backend" json:"backend,omitempty"`
}

func (m *CreateBackendResponse) Reset()                    <span class="cov0" title="0">{ *m = CreateBackendResponse{} }</span>
func (m *CreateBackendResponse) String() string            <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*CreateBackendResponse) ProtoMessage()               {<span class="cov0" title="0">}</span>
func (*CreateBackendResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{ return fileDescriptor0, []int{1} }</span>

func (m *CreateBackendResponse) GetBackend() *BackendDetail <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Backend
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type GetBackendRequest struct {
        Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
}

func (m *GetBackendRequest) Reset()                    <span class="cov0" title="0">{ *m = GetBackendRequest{} }</span>
func (m *GetBackendRequest) String() string            <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*GetBackendRequest) ProtoMessage()               {<span class="cov0" title="0">}</span>
func (*GetBackendRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{ return fileDescriptor0, []int{2} }</span>

func (m *GetBackendRequest) GetId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type GetBackendResponse struct {
        Backend *BackendDetail `protobuf:"bytes,1,opt,name=backend" json:"backend,omitempty"`
}

func (m *GetBackendResponse) Reset()                    <span class="cov0" title="0">{ *m = GetBackendResponse{} }</span>
func (m *GetBackendResponse) String() string            <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*GetBackendResponse) ProtoMessage()               {<span class="cov0" title="0">}</span>
func (*GetBackendResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{ return fileDescriptor0, []int{3} }</span>

func (m *GetBackendResponse) GetBackend() *BackendDetail <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Backend
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type ListBackendRequest struct {
        Limit    int32             `protobuf:"varint,1,opt,name=limit" json:"limit,omitempty"`
        Offset   int32             `protobuf:"varint,2,opt,name=offset" json:"offset,omitempty"`
        SortKeys []string          `protobuf:"bytes,3,rep,name=sortKeys" json:"sortKeys,omitempty"`
        SortDirs []string          `protobuf:"bytes,4,rep,name=sortDirs" json:"sortDirs,omitempty"`
        Filter   map[string]string `protobuf:"bytes,5,rep,name=Filter" json:"Filter,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *ListBackendRequest) Reset()                    <span class="cov8" title="1">{ *m = ListBackendRequest{} }</span>
func (m *ListBackendRequest) String() string            <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*ListBackendRequest) ProtoMessage()               {<span class="cov0" title="0">}</span>
func (*ListBackendRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{ return fileDescriptor0, []int{4} }</span>

func (m *ListBackendRequest) GetLimit() int32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Limit
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *ListBackendRequest) GetOffset() int32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Offset
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *ListBackendRequest) GetSortKeys() []string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.SortKeys
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *ListBackendRequest) GetSortDirs() []string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.SortDirs
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *ListBackendRequest) GetFilter() map[string]string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Filter
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type ListBackendResponse struct {
        Backends []*BackendDetail `protobuf:"bytes,1,rep,name=backends" json:"backends,omitempty"`
        Next     int32            `protobuf:"varint,2,opt,name=next" json:"next,omitempty"`
}

func (m *ListBackendResponse) Reset()                    <span class="cov0" title="0">{ *m = ListBackendResponse{} }</span>
func (m *ListBackendResponse) String() string            <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*ListBackendResponse) ProtoMessage()               {<span class="cov0" title="0">}</span>
func (*ListBackendResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{ return fileDescriptor0, []int{5} }</span>

func (m *ListBackendResponse) GetBackends() []*BackendDetail <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Backends
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *ListBackendResponse) GetNext() int32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Next
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type UpdateBackendRequest struct {
        Id       string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
        Access   string `protobuf:"bytes,2,opt,name=access" json:"access,omitempty"`
        Security string `protobuf:"bytes,3,opt,name=security" json:"security,omitempty"`
}

func (m *UpdateBackendRequest) Reset()                    <span class="cov0" title="0">{ *m = UpdateBackendRequest{} }</span>
func (m *UpdateBackendRequest) String() string            <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*UpdateBackendRequest) ProtoMessage()               {<span class="cov0" title="0">}</span>
func (*UpdateBackendRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{ return fileDescriptor0, []int{6} }</span>

func (m *UpdateBackendRequest) GetId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *UpdateBackendRequest) GetAccess() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Access
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *UpdateBackendRequest) GetSecurity() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Security
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type UpdateBackendResponse struct {
        Backend *BackendDetail `protobuf:"bytes,1,opt,name=backend" json:"backend,omitempty"`
}

func (m *UpdateBackendResponse) Reset()                    <span class="cov0" title="0">{ *m = UpdateBackendResponse{} }</span>
func (m *UpdateBackendResponse) String() string            <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*UpdateBackendResponse) ProtoMessage()               {<span class="cov0" title="0">}</span>
func (*UpdateBackendResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{ return fileDescriptor0, []int{7} }</span>

func (m *UpdateBackendResponse) GetBackend() *BackendDetail <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Backend
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type DeleteBackendRequest struct {
        Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
}

func (m *DeleteBackendRequest) Reset()                    <span class="cov0" title="0">{ *m = DeleteBackendRequest{} }</span>
func (m *DeleteBackendRequest) String() string            <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*DeleteBackendRequest) ProtoMessage()               {<span class="cov0" title="0">}</span>
func (*DeleteBackendRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{ return fileDescriptor0, []int{8} }</span>

func (m *DeleteBackendRequest) GetId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type DeleteBackendResponse struct {
}

func (m *DeleteBackendResponse) Reset()                    <span class="cov0" title="0">{ *m = DeleteBackendResponse{} }</span>
func (m *DeleteBackendResponse) String() string            <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*DeleteBackendResponse) ProtoMessage()               {<span class="cov0" title="0">}</span>
func (*DeleteBackendResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{ return fileDescriptor0, []int{9} }</span>

type BackendDetail struct {
        Id         string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
        TenantId   string `protobuf:"bytes,2,opt,name=tenantId" json:"tenantId,omitempty"`
        UserId     string `protobuf:"bytes,3,opt,name=userId" json:"userId,omitempty"`
        Name       string `protobuf:"bytes,4,opt,name=name" json:"name,omitempty"`
        Type       string `protobuf:"bytes,5,opt,name=type" json:"type,omitempty"`
        Region     string `protobuf:"bytes,6,opt,name=region" json:"region,omitempty"`
        Endpoint   string `protobuf:"bytes,7,opt,name=endpoint" json:"endpoint,omitempty"`
        BucketName string `protobuf:"bytes,8,opt,name=bucketName" json:"bucketName,omitempty"`
        Access     string `protobuf:"bytes,9,opt,name=access" json:"access,omitempty"`
        Security   string `protobuf:"bytes,10,opt,name=security" json:"security,omitempty"`
}

func (m *BackendDetail) Reset()                    <span class="cov0" title="0">{ *m = BackendDetail{} }</span>
func (m *BackendDetail) String() string            <span class="cov8" title="1">{ return proto.CompactTextString(m) }</span>
func (*BackendDetail) ProtoMessage()               {<span class="cov0" title="0">}</span>
func (*BackendDetail) Descriptor() ([]byte, []int) <span class="cov0" title="0">{ return fileDescriptor0, []int{10} }</span>

func (m *BackendDetail) GetId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *BackendDetail) GetTenantId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.TenantId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *BackendDetail) GetUserId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.UserId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *BackendDetail) GetName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *BackendDetail) GetType() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Type
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *BackendDetail) GetRegion() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Region
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *BackendDetail) GetEndpoint() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Endpoint
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *BackendDetail) GetBucketName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.BucketName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *BackendDetail) GetAccess() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Access
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *BackendDetail) GetSecurity() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Security
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type ListTypeRequest struct {
        Limit    int32             `protobuf:"varint,1,opt,name=limit" json:"limit,omitempty"`
        Offset   int32             `protobuf:"varint,2,opt,name=offset" json:"offset,omitempty"`
        SortKeys []string          `protobuf:"bytes,3,rep,name=sortKeys" json:"sortKeys,omitempty"`
        SortDirs []string          `protobuf:"bytes,4,rep,name=sortDirs" json:"sortDirs,omitempty"`
        Filter   map[string]string `protobuf:"bytes,5,rep,name=Filter" json:"Filter,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *ListTypeRequest) Reset()                    <span class="cov8" title="1">{ *m = ListTypeRequest{} }</span>
func (m *ListTypeRequest) String() string            <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*ListTypeRequest) ProtoMessage()               {<span class="cov0" title="0">}</span>
func (*ListTypeRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{ return fileDescriptor0, []int{11} }</span>

func (m *ListTypeRequest) GetLimit() int32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Limit
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *ListTypeRequest) GetOffset() int32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Offset
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *ListTypeRequest) GetSortKeys() []string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.SortKeys
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *ListTypeRequest) GetSortDirs() []string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.SortDirs
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *ListTypeRequest) GetFilter() map[string]string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Filter
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type ListTypeResponse struct {
        Types []*TypeDetail `protobuf:"bytes,1,rep,name=types" json:"types,omitempty"`
        Next  int32         `protobuf:"varint,2,opt,name=next" json:"next,omitempty"`
}

func (m *ListTypeResponse) Reset()                    <span class="cov0" title="0">{ *m = ListTypeResponse{} }</span>
func (m *ListTypeResponse) String() string            <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*ListTypeResponse) ProtoMessage()               {<span class="cov0" title="0">}</span>
func (*ListTypeResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{ return fileDescriptor0, []int{12} }</span>

func (m *ListTypeResponse) GetTypes() []*TypeDetail <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Types
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *ListTypeResponse) GetNext() int32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Next
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type TypeDetail struct {
        Name        string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
        Description string `protobuf:"bytes,2,opt,name=description" json:"description,omitempty"`
}

func (m *TypeDetail) Reset()                    <span class="cov0" title="0">{ *m = TypeDetail{} }</span>
func (m *TypeDetail) String() string            <span class="cov8" title="1">{ return proto.CompactTextString(m) }</span>
func (*TypeDetail) ProtoMessage()               {<span class="cov0" title="0">}</span>
func (*TypeDetail) Descriptor() ([]byte, []int) <span class="cov0" title="0">{ return fileDescriptor0, []int{13} }</span>

func (m *TypeDetail) GetName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *TypeDetail) GetDescription() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Description
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func init() <span class="cov8" title="1">{
        proto.RegisterType((*CreateBackendRequest)(nil), "CreateBackendRequest")
        proto.RegisterType((*CreateBackendResponse)(nil), "CreateBackendResponse")
        proto.RegisterType((*GetBackendRequest)(nil), "GetBackendRequest")
        proto.RegisterType((*GetBackendResponse)(nil), "GetBackendResponse")
        proto.RegisterType((*ListBackendRequest)(nil), "ListBackendRequest")
        proto.RegisterType((*ListBackendResponse)(nil), "ListBackendResponse")
        proto.RegisterType((*UpdateBackendRequest)(nil), "UpdateBackendRequest")
        proto.RegisterType((*UpdateBackendResponse)(nil), "UpdateBackendResponse")
        proto.RegisterType((*DeleteBackendRequest)(nil), "DeleteBackendRequest")
        proto.RegisterType((*DeleteBackendResponse)(nil), "DeleteBackendResponse")
        proto.RegisterType((*BackendDetail)(nil), "BackendDetail")
        proto.RegisterType((*ListTypeRequest)(nil), "ListTypeRequest")
        proto.RegisterType((*ListTypeResponse)(nil), "ListTypeResponse")
        proto.RegisterType((*TypeDetail)(nil), "TypeDetail")
}</span>

func init() <span class="cov8" title="1">{ proto.RegisterFile("backend.proto", fileDescriptor0) }</span>

var fileDescriptor0 = []byte{
        // 630 bytes of a gzipped FileDescriptorProto
        0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x55, 0x4d, 0x6f, 0xd3, 0x40,
        0x10, 0x8d, 0x93, 0x26, 0x4d, 0xc6, 0x6a, 0x69, 0xb7, 0x49, 0xb0, 0x2c, 0x04, 0xc1, 0x48, 0x28,
        0xe2, 0xb0, 0x12, 0x05, 0xa9, 0xd0, 0x03, 0x2a, 0xa5, 0x80, 0x2a, 0x10, 0x07, 0x8b, 0x5e, 0xb8,
        0xb9, 0xf6, 0x14, 0xad, 0x9a, 0xda, 0xc6, 0xbb, 0x41, 0xf8, 0xcc, 0x9f, 0xe5, 0xc4, 0x95, 0x2b,
        0xda, 0x0f, 0x27, 0xce, 0xc6, 0x08, 0x45, 0x42, 0xdc, 0xfc, 0x66, 0x66, 0x77, 0x66, 0xe7, 0xcd,
        0x3c, 0xc3, 0xce, 0x65, 0x14, 0x5f, 0x63, 0x9a, 0xd0, 0xbc, 0xc8, 0x44, 0x16, 0x9c, 0xc0, 0xf0,
        0x55, 0x81, 0x91, 0xc0, 0x53, 0x6d, 0x0e, 0xf1, 0xcb, 0x1c, 0xb9, 0x20, 0x53, 0xd8, 0x36, 0x81,
        0x9e, 0x33, 0x71, 0xa6, 0xee, 0xe1, 0x2e, 0x35, 0x11, 0x67, 0x28, 0x22, 0x36, 0x0b, 0x2b, 0x77,
        0xf0, 0x12, 0x46, 0xd6, 0x0d, 0x3c, 0xcf, 0x52, 0x8e, 0x1b, 0x5c, 0xf1, 0x00, 0xf6, 0xdf, 0xa2,
        0xb0, 0x2a, 0xd8, 0x85, 0x36, 0xd3, 0x27, 0x07, 0x61, 0x9b, 0x25, 0xc1, 0x0b, 0x20, 0xf5, 0xa0,
        0x8d, 0x93, 0xfc, 0x74, 0x80, 0xbc, 0x67, 0xdc, 0x4e, 0x33, 0x84, 0xee, 0x8c, 0xdd, 0x30, 0xa1,
        0x8e, 0x77, 0x43, 0x0d, 0xc8, 0x18, 0x7a, 0xd9, 0xd5, 0x15, 0x47, 0xe1, 0xb5, 0x95, 0xd9, 0x20,
        0xe2, 0x43, 0x9f, 0x67, 0x85, 0x78, 0x87, 0x25, 0xf7, 0x3a, 0x93, 0xce, 0x74, 0x10, 0x2e, 0x70,
        0xe5, 0x3b, 0x63, 0x05, 0xf7, 0xb6, 0x96, 0x3e, 0x89, 0xc9, 0x11, 0xf4, 0xde, 0xb0, 0x99, 0xc0,
        0xc2, 0xeb, 0x4e, 0x3a, 0x53, 0xf7, 0xf0, 0x1e, 0x5d, 0x2f, 0x85, 0xea, 0x88, 0xd7, 0xa9, 0x28,
        0xca, 0xd0, 0x84, 0xfb, 0xcf, 0xc1, 0xad, 0x99, 0xc9, 0x1e, 0x74, 0xae, 0xb1, 0x34, 0x5d, 0x91,
        0x9f, 0xb2, 0xfe, 0xaf, 0xd1, 0x6c, 0x8e, 0xaa, 0xd0, 0x41, 0xa8, 0xc1, 0x71, 0xfb, 0x99, 0x13,
        0x5c, 0xc0, 0xc1, 0x4a, 0x12, 0xd3, 0xb1, 0x47, 0xd0, 0x37, 0x2d, 0xe1, 0x9e, 0xa3, 0x8a, 0xb1,
        0x5b, 0xb6, 0xf0, 0x13, 0x02, 0x5b, 0x29, 0x7e, 0xab, 0x9a, 0xa0, 0xbe, 0x83, 0x4f, 0x30, 0xbc,
        0xc8, 0x93, 0xf5, 0x89, 0xb1, 0xf8, 0x92, 0x2d, 0x8c, 0xe2, 0x18, 0x39, 0x37, 0x95, 0x19, 0xa4,
        0xda, 0x84, 0xf1, 0xbc, 0x60, 0xa2, 0xf4, 0x3a, 0xca, 0xb3, 0xc0, 0x72, 0x96, 0xac, 0xbb, 0x37,
        0xa6, 0xf9, 0x21, 0x0c, 0xcf, 0x70, 0x86, 0x7f, 0x2b, 0x2f, 0xb8, 0x0d, 0x23, 0x2b, 0x4e, 0xa7,
        0x0a, 0xbe, 0xb7, 0x61, 0x67, 0xe5, 0xee, 0xb5, 0x97, 0xf9, 0xd0, 0x17, 0x98, 0x46, 0xa9, 0x38,
        0x4f, 0xcc, 0xdb, 0x16, 0x58, 0xbe, 0x7a, 0xce, 0xb1, 0x38, 0x4f, 0xcc, 0xdb, 0x0c, 0x52, 0x9d,
        0x8c, 0x6e, 0xd0, 0xdb, 0x52, 0x56, 0xf5, 0x2d, 0x6d, 0xa2, 0xcc, 0xd1, 0xeb, 0x6a, 0x9b, 0xfc,
        0x96, 0xe7, 0x0b, 0xfc, 0xcc, 0xb2, 0xd4, 0xeb, 0xe9, 0xf3, 0x1a, 0xc9, 0x9c, 0x98, 0x26, 0x79,
        0xc6, 0x52, 0xe1, 0x6d, 0xeb, 0x9c, 0x15, 0x26, 0x77, 0x01, 0x2e, 0xe7, 0xf1, 0x35, 0x8a, 0x0f,
        0x32, 0x43, 0x5f, 0x79, 0x6b, 0x96, 0x1a, 0x13, 0x83, 0x3f, 0x32, 0x01, 0x16, 0x13, 0x3f, 0x1c,
        0xb8, 0x25, 0xa7, 0xe7, 0x63, 0x99, 0xe3, 0xff, 0x5d, 0x95, 0xa7, 0xd6, 0xaa, 0xdc, 0xa1, 0x56,
        0x1d, 0xff, 0x7a, 0x4f, 0xce, 0x61, 0x6f, 0x99, 0xc1, 0xcc, 0xdb, 0x7d, 0xe8, 0x4a, 0x3a, 0xaa,
        0x0d, 0x71, 0xa9, 0xf4, 0x9a, 0x51, 0xd3, 0x9e, 0xc6, 0xdd, 0x38, 0x05, 0x58, 0x06, 0x2e, 0x38,
        0x77, 0x6a, 0x9c, 0x4f, 0xc0, 0x4d, 0x90, 0xc7, 0x05, 0xcb, 0x85, 0x24, 0x59, 0x17, 0x53, 0x37,
        0x1d, 0xfe, 0x6a, 0xc3, 0xb6, 0x99, 0x3f, 0x72, 0x02, 0x3b, 0x2b, 0xda, 0x4a, 0x46, 0xb4, 0x49,
        0xad, 0xfd, 0x31, 0x6d, 0x94, 0xe0, 0xa0, 0x45, 0x8e, 0x00, 0x96, 0xaa, 0x49, 0x08, 0x5d, 0xd3,
        0x59, 0xff, 0x80, 0xae, 0xcb, 0x6a, 0xd0, 0x22, 0xc7, 0xe0, 0xd6, 0xd4, 0x83, 0x1c, 0x34, 0x08,
        0x96, 0x3f, 0xa4, 0x0d, 0x02, 0x13, 0xb4, 0x64, 0xd9, 0x2b, 0x6b, 0x4c, 0x46, 0xb4, 0x49, 0x32,
        0xfc, 0x31, 0x6d, 0xdc, 0x76, 0x7d, 0xc3, 0xca, 0x76, 0x92, 0x11, 0x6d, 0xda, 0x6a, 0x7f, 0x4c,
        0x9b, 0x97, 0xb8, 0x45, 0x1e, 0x43, 0xbf, 0x62, 0x95, 0xec, 0xd9, 0x23, 0xe4, 0xef, 0x53, 0x9b,
        0xf2, 0xa0, 0x75, 0xd9, 0x53, 0xbf, 0xc4, 0x27, 0xbf, 0x03, 0x00, 0x00, 0xff, 0xff, 0x50, 0xb6,
        0xe0, 0x3d, 0x23, 0x07, 0x00, 0x00,
}
</pre>

		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>