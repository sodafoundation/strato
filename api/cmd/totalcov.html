
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/soda/multi-cloud/api/cmd/main.go (96.4%)</option>
				
				<option value="file1">github.com/soda/multi-cloud/api/pkg/backend/router.go (100.0%)</option>
				
				<option value="file2">github.com/soda/multi-cloud/api/pkg/backend/service.go (26.1%)</option>
				
				<option value="file3">github.com/soda/multi-cloud/api/pkg/common/common.go (56.8%)</option>
				
				<option value="file4">github.com/soda/multi-cloud/api/pkg/context/context.go (56.2%)</option>
				
				<option value="file5">github.com/soda/multi-cloud/api/pkg/dataflow/router.go (100.0%)</option>
				
				<option value="file6">github.com/soda/multi-cloud/api/pkg/dataflow/service.go (8.5%)</option>
				
				<option value="file7">github.com/soda/multi-cloud/api/pkg/filters/auth/auth.go (29.4%)</option>
				
				<option value="file8">github.com/soda/multi-cloud/api/pkg/filters/auth/keystone.go (74.6%)</option>
				
				<option value="file9">github.com/soda/multi-cloud/api/pkg/filters/context/context.go (100.0%)</option>
				
				<option value="file10">github.com/soda/multi-cloud/api/pkg/filters/logging/logging.go (100.0%)</option>
				
				<option value="file11">github.com/soda/multi-cloud/api/pkg/filters/signature/credentials/credential.go (77.8%)</option>
				
				<option value="file12">github.com/soda/multi-cloud/api/pkg/filters/signature/credentials/keystonecredentials/provider.go (81.8%)</option>
				
				<option value="file13">github.com/soda/multi-cloud/api/pkg/filters/signature/signer/signature.go (78.1%)</option>
				
				<option value="file14">github.com/soda/multi-cloud/api/pkg/model/error.go (0.0%)</option>
				
				<option value="file15">github.com/soda/multi-cloud/api/pkg/policy/checks.go (23.4%)</option>
				
				<option value="file16">github.com/soda/multi-cloud/api/pkg/policy/parser.go (74.4%)</option>
				
				<option value="file17">github.com/soda/multi-cloud/api/pkg/policy/policy.go (69.4%)</option>
				
				<option value="file18">github.com/soda/multi-cloud/api/pkg/s3/abortmultipartupload.go (0.0%)</option>
				
				<option value="file19">github.com/soda/multi-cloud/api/pkg/s3/acl.go (38.5%)</option>
				
				<option value="file20">github.com/soda/multi-cloud/api/pkg/s3/api-headers.go (22.7%)</option>
				
				<option value="file21">github.com/soda/multi-cloud/api/pkg/s3/api-response.go (29.5%)</option>
				
				<option value="file22">github.com/soda/multi-cloud/api/pkg/s3/bucketacl.go (24.6%)</option>
				
				<option value="file23">github.com/soda/multi-cloud/api/pkg/s3/bucketdelete.go (0.0%)</option>
				
				<option value="file24">github.com/soda/multi-cloud/api/pkg/s3/bucketget.go (47.6%)</option>
				
				<option value="file25">github.com/soda/multi-cloud/api/pkg/s3/bucketlifecycledelete.go (0.0%)</option>
				
				<option value="file26">github.com/soda/multi-cloud/api/pkg/s3/bucketlifecycleget.go (11.7%)</option>
				
				<option value="file27">github.com/soda/multi-cloud/api/pkg/s3/bucketlifecycleput.go (0.0%)</option>
				
				<option value="file28">github.com/soda/multi-cloud/api/pkg/s3/bucketput.go (68.6%)</option>
				
				<option value="file29">github.com/soda/multi-cloud/api/pkg/s3/bucketsseput.go (0.0%)</option>
				
				<option value="file30">github.com/soda/multi-cloud/api/pkg/s3/bucketversioningput.go (0.0%)</option>
				
				<option value="file31">github.com/soda/multi-cloud/api/pkg/s3/completemultipartupload.go (0.0%)</option>
				
				<option value="file32">github.com/soda/multi-cloud/api/pkg/s3/datatype/acl.go (21.0%)</option>
				
				<option value="file33">github.com/soda/multi-cloud/api/pkg/s3/datatype/datetime.go (0.0%)</option>
				
				<option value="file34">github.com/soda/multi-cloud/api/pkg/s3/datatype/httprange.go (0.0%)</option>
				
				<option value="file35">github.com/soda/multi-cloud/api/pkg/s3/handler-utils.go (15.6%)</option>
				
				<option value="file36">github.com/soda/multi-cloud/api/pkg/s3/listbuckets.go (81.6%)</option>
				
				<option value="file37">github.com/soda/multi-cloud/api/pkg/s3/listbucketuploadrecrds.go (0.0%)</option>
				
				<option value="file38">github.com/soda/multi-cloud/api/pkg/s3/listobjectparts.go (0.0%)</option>
				
				<option value="file39">github.com/soda/multi-cloud/api/pkg/s3/liststorageclasses.go (0.0%)</option>
				
				<option value="file40">github.com/soda/multi-cloud/api/pkg/s3/multipartuploadinit.go (0.0%)</option>
				
				<option value="file41">github.com/soda/multi-cloud/api/pkg/s3/object-handlers-common.go (0.0%)</option>
				
				<option value="file42">github.com/soda/multi-cloud/api/pkg/s3/object-utils.go (41.4%)</option>
				
				<option value="file43">github.com/soda/multi-cloud/api/pkg/s3/objectacl.go (0.0%)</option>
				
				<option value="file44">github.com/soda/multi-cloud/api/pkg/s3/objectcopy.go (0.0%)</option>
				
				<option value="file45">github.com/soda/multi-cloud/api/pkg/s3/objectdelete.go (0.0%)</option>
				
				<option value="file46">github.com/soda/multi-cloud/api/pkg/s3/objectget.go (0.0%)</option>
				
				<option value="file47">github.com/soda/multi-cloud/api/pkg/s3/objectpartcopy.go (0.0%)</option>
				
				<option value="file48">github.com/soda/multi-cloud/api/pkg/s3/objectpost.go (0.0%)</option>
				
				<option value="file49">github.com/soda/multi-cloud/api/pkg/s3/objectput.go (53.1%)</option>
				
				<option value="file50">github.com/soda/multi-cloud/api/pkg/s3/routbucketdelete.go (0.0%)</option>
				
				<option value="file51">github.com/soda/multi-cloud/api/pkg/s3/routbucketget.go (84.6%)</option>
				
				<option value="file52">github.com/soda/multi-cloud/api/pkg/s3/routbuckethead.go (0.0%)</option>
				
				<option value="file53">github.com/soda/multi-cloud/api/pkg/s3/routbucketput.go (60.0%)</option>
				
				<option value="file54">github.com/soda/multi-cloud/api/pkg/s3/routeobjectdelete.go (0.0%)</option>
				
				<option value="file55">github.com/soda/multi-cloud/api/pkg/s3/routeobjectget.go (0.0%)</option>
				
				<option value="file56">github.com/soda/multi-cloud/api/pkg/s3/routeobjecthead.go (0.0%)</option>
				
				<option value="file57">github.com/soda/multi-cloud/api/pkg/s3/routeobjectpost.go (0.0%)</option>
				
				<option value="file58">github.com/soda/multi-cloud/api/pkg/s3/routeobjectput.go (56.2%)</option>
				
				<option value="file59">github.com/soda/multi-cloud/api/pkg/s3/router.go (100.0%)</option>
				
				<option value="file60">github.com/soda/multi-cloud/api/pkg/s3/service.go (66.0%)</option>
				
				<option value="file61">github.com/soda/multi-cloud/api/pkg/s3/uploadpart.go (0.0%)</option>
				
				<option value="file62">github.com/soda/multi-cloud/api/pkg/s3/utils.go (20.0%)</option>
				
				<option value="file63">github.com/soda/multi-cloud/api/pkg/utils/obs/auth.go (0.0%)</option>
				
				<option value="file64">github.com/soda/multi-cloud/api/pkg/utils/obs/client.go (0.0%)</option>
				
				<option value="file65">github.com/soda/multi-cloud/api/pkg/utils/obs/conf.go (0.0%)</option>
				
				<option value="file66">github.com/soda/multi-cloud/api/pkg/utils/obs/convert.go (0.0%)</option>
				
				<option value="file67">github.com/soda/multi-cloud/api/pkg/utils/obs/error.go (0.0%)</option>
				
				<option value="file68">github.com/soda/multi-cloud/api/pkg/utils/obs/http.go (0.0%)</option>
				
				<option value="file69">github.com/soda/multi-cloud/api/pkg/utils/obs/log.go (87.1%)</option>
				
				<option value="file70">github.com/soda/multi-cloud/api/pkg/utils/obs/temporary.go (0.0%)</option>
				
				<option value="file71">github.com/soda/multi-cloud/api/pkg/utils/obs/trait.go (0.0%)</option>
				
				<option value="file72">github.com/soda/multi-cloud/api/pkg/utils/obs/util.go (0.0%)</option>
				
				<option value="file73">github.com/soda/multi-cloud/api/pkg/utils/utils.go (11.9%)</option>
				
				<option value="file74">github.com/soda/multi-cloud/backend/proto/backend.micro.go (25.5%)</option>
				
				<option value="file75">github.com/soda/multi-cloud/backend/proto/backend.pb.go (11.1%)</option>
				
				<option value="file76">github.com/soda/multi-cloud/dataflow/proto/dataflow.micro.go (8.0%)</option>
				
				<option value="file77">github.com/soda/multi-cloud/dataflow/proto/dataflow.pb.go (6.2%)</option>
				
				<option value="file78">github.com/soda/multi-cloud/s3/error/s3errors.go (69.2%)</option>
				
				<option value="file79">github.com/soda/multi-cloud/s3/pkg/exception/exception.go (0.0%)</option>
				
				<option value="file80">github.com/soda/multi-cloud/s3/pkg/helper/config.go (0.0%)</option>
				
				<option value="file81">github.com/soda/multi-cloud/s3/pkg/helper/escape.go (0.0%)</option>
				
				<option value="file82">github.com/soda/multi-cloud/s3/pkg/helper/file.go (0.0%)</option>
				
				<option value="file83">github.com/soda/multi-cloud/s3/pkg/helper/functional.go (0.0%)</option>
				
				<option value="file84">github.com/soda/multi-cloud/s3/pkg/helper/helper.go (0.0%)</option>
				
				<option value="file85">github.com/soda/multi-cloud/s3/pkg/helper/http.go (0.0%)</option>
				
				<option value="file86">github.com/soda/multi-cloud/s3/pkg/helper/msgpack.go (0.0%)</option>
				
				<option value="file87">github.com/soda/multi-cloud/s3/pkg/helper/string.go (10.0%)</option>
				
				<option value="file88">github.com/soda/multi-cloud/s3/pkg/meta/types/bucket.go (0.0%)</option>
				
				<option value="file89">github.com/soda/multi-cloud/s3/pkg/meta/types/cluster.go (0.0%)</option>
				
				<option value="file90">github.com/soda/multi-cloud/s3/pkg/meta/types/gc.go (0.0%)</option>
				
				<option value="file91">github.com/soda/multi-cloud/s3/pkg/meta/types/multipart.go (0.0%)</option>
				
				<option value="file92">github.com/soda/multi-cloud/s3/pkg/meta/types/object-errors.go (0.0%)</option>
				
				<option value="file93">github.com/soda/multi-cloud/s3/pkg/meta/types/object.go (0.0%)</option>
				
				<option value="file94">github.com/soda/multi-cloud/s3/pkg/meta/types/objectmap.go (0.0%)</option>
				
				<option value="file95">github.com/soda/multi-cloud/s3/pkg/meta/types/simpleindex.go (0.0%)</option>
				
				<option value="file96">github.com/soda/multi-cloud/s3/pkg/meta/types/storage-class.go (0.0%)</option>
				
				<option value="file97">github.com/soda/multi-cloud/s3/pkg/meta/util/util.go (0.0%)</option>
				
				<option value="file98">github.com/soda/multi-cloud/s3/pkg/model/xmlstruct.go (0.0%)</option>
				
				<option value="file99">github.com/soda/multi-cloud/s3/pkg/utils/encryptionutils.go (0.0%)</option>
				
				<option value="file100">github.com/soda/multi-cloud/s3/pkg/utils/utils.go (0.0%)</option>
				
				<option value="file101">github.com/soda/multi-cloud/s3/proto/s3.micro.go (9.4%)</option>
				
				<option value="file102">github.com/soda/multi-cloud/s3/proto/s3.pb.go (7.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package main

import (
        "github.com/emicklei/go-restful"
        log "github.com/sirupsen/logrus"
        "github.com/micro/go-web"
        "github.com/soda/multi-cloud/api/pkg/backend"
        "github.com/soda/multi-cloud/api/pkg/dataflow"
        "github.com/soda/multi-cloud/api/pkg/filters/context"
        "github.com/soda/multi-cloud/api/pkg/filters/signature/signer"
        "github.com/soda/multi-cloud/api/pkg/filters/auth"
        "github.com/soda/multi-cloud/api/pkg/filters/logging"
        "github.com/soda/multi-cloud/api/pkg/s3"
        "github.com/soda/multi-cloud/api/pkg/utils/obs"
)

const (
        serviceName = "gelato"
)

func main() <span class="cov8" title="1">{
        webService := web.NewService(
                web.Name(serviceName),
                web.Version("v0.1.0"),
        )
        webService.Init()

        obs.InitLogs()
        wc := restful.NewContainer()
        ws := new(restful.WebService)
        ws.Path("/v1")
        ws.Doc("soda Multi-Cloud API")
        ws.Consumes(restful.MIME_JSON)
        ws.Produces(restful.MIME_JSON)

        backend.RegisterRouter(ws)
        dataflow.RegisterRouter(ws)
        // add filter for authentication context
        ws.Filter(logging.FilterFactory())
        ws.Filter(context.FilterFactory())
        ws.Filter(auth.FilterFactory())

        s3ws := new(restful.WebService)
        s3ws.Path("/v1/s3")
        s3ws.Doc("soda Multi-Cloud API")
        s3ws.Consumes(restful.MIME_XML)
        s3ws.Produces(restful.MIME_XML)

        s3ws.Filter(logging.FilterFactory())
        s3ws.Filter(context.FilterFactory())
        s3ws.Filter(signer.FilterFactory())
        s3.RegisterRouter(s3ws)

        wc.Add(ws)
        wc.Add(s3ws)
        webService.Handle("/", wc)
        if err := webService.Run(); err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package backend

import (
        "github.com/emicklei/go-restful"
        "github.com/micro/go-micro/client"
)

func RegisterRouter(ws *restful.WebService) <span class="cov8" title="1">{
        handler := NewAPIService(client.DefaultClient)
        ws.Route(ws.GET("/{tenantId}/backends/{id}").To(handler.GetBackend)).
                Doc("Show backend details")
        ws.Route(ws.GET("/{tenantId}/backends").To(handler.ListBackend)).
                Doc("Get backend list")
        ws.Route(ws.POST("/{tenantId}/backends").To(handler.CreateBackend)).
                Doc("Create backend")
        ws.Route(ws.PUT("/{tenantId}/backends/{id}").To(handler.UpdateBackend)).
                Doc("Update backend")
        ws.Route(ws.DELETE("/{tenantId}/backends/{id}").To(handler.DeleteBackend)).
                Doc("Delete backend")
        ws.Route(ws.GET("/{tenantId}/types").To(handler.ListType)).
                Doc("Get backend types")
}</span>

</pre>
		
		<pre class="file" id="file2" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package backend

import (
        "errors"
        "net/http"
        "strconv"

        "github.com/emicklei/go-restful"
        log "github.com/sirupsen/logrus"
        "github.com/micro/go-micro/client"
        "github.com/soda/multi-cloud/api/pkg/common"
        c "github.com/soda/multi-cloud/api/pkg/context"
        "github.com/soda/multi-cloud/api/pkg/policy"
        "github.com/soda/multi-cloud/backend/proto"
        "github.com/soda/multi-cloud/dataflow/proto"
        . "github.com/soda/multi-cloud/s3/pkg/exception"
        "github.com/soda/multi-cloud/s3/proto"
        "golang.org/x/net/context"
)

const (
        backendService  = "backend"
        s3Service       = "s3"
        dataflowService = "dataflow"
)

type APIService struct {
        backendClient  backend.BackendService
        s3Client       s3.S3Service
        dataflowClient dataflow.DataFlowService
}

func NewAPIService(c client.Client) *APIService <span class="cov8" title="1">{
        return &amp;APIService{
                backendClient:  backend.NewBackendService(backendService, c),
                s3Client:       s3.NewS3Service(s3Service, c),
                dataflowClient: dataflow.NewDataFlowService(dataflowService, c),
        }
}</span>

func (s *APIService) GetBackend(request *restful.Request, response *restful.Response) <span class="cov0" title="0">{
        if !policy.Authorize(request, response, "backend:get") </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">log.Infof("Received request for backend details: %s\n", request.PathParameter("id"))
        id := request.PathParameter("id")

        ctx := common.InitCtxWithAuthInfo(request)
        res, err := s.backendClient.GetBackend(ctx, &amp;backend.GetBackendRequest{Id: id})
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to get backend details: %v\n", err)
                response.WriteError(http.StatusInternalServerError, err)
                return
        }</span>

        // do not return sensitive information
        <span class="cov0" title="0">res.Backend.Access = ""
        res.Backend.Security = ""

        log.Info("Get backend details successfully.")
        response.WriteEntity(res.Backend)</span>
}

func (s *APIService) listBackendDefault(ctx context.Context, request *restful.Request, response *restful.Response) <span class="cov8" title="1">{
        listBackendRequest := &amp;backend.ListBackendRequest{}

        limit, offset, err := common.GetPaginationParam(request)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("get pagination parameters failed: %v\n", err)
                response.WriteError(http.StatusInternalServerError, err)
                return
        }</span>
        <span class="cov8" title="1">listBackendRequest.Limit = limit
        listBackendRequest.Offset = offset

        sortKeys, sortDirs, err := common.GetSortParam(request)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("get sort parameters failed: %v\n", err)
                response.WriteError(http.StatusInternalServerError, err)
                return
        }</span>
        <span class="cov8" title="1">listBackendRequest.SortKeys = sortKeys
        listBackendRequest.SortDirs = sortDirs

        filterOpts := []string{"name", "type", "region"}
        filter, err := common.GetFilter(request, filterOpts)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("get filter failed: %v\n", err)
                response.WriteError(http.StatusInternalServerError, err)
                return
        }</span>
        <span class="cov8" title="1">listBackendRequest.Filter = filter

        res, err := s.backendClient.ListBackend(ctx, listBackendRequest)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to list backends: %v\n", err)
                response.WriteError(http.StatusInternalServerError, err)
                return
        }</span>

        // do not return sensitive information
        <span class="cov8" title="1">for _, v := range res.Backends </span><span class="cov8" title="1">{
                v.Access = ""
                v.Security = ""
        }</span>

        <span class="cov8" title="1">log.Info("List backends successfully.")
        response.WriteEntity(res)</span>
}

func (s *APIService) FilterBackendByTier(ctx context.Context, request *restful.Request, response *restful.Response,
        tier int32) <span class="cov0" title="0">{
        // Get those backend type which supporte the specific tier.
        req := s3.GetBackendTypeByTierRequest{Tier: tier}
        res, _ := s.s3Client.GetBackendTypeByTier(context.Background(), &amp;req)
        req1 := &amp;backend.ListBackendRequest{}
        resp := &amp;backend.ListBackendResponse{}
        for _, v := range res.Types </span><span class="cov0" title="0">{
                // Get backends with specific backend type.
                filter := make(map[string]string)
                filter["type"] = v
                req1.Filter = filter
                res1, err := s.backendClient.ListBackend(ctx, req1)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("failed to list backends of type[%s]: %v\n", v, err)
                        response.WriteError(http.StatusInternalServerError, err)
                }</span>
                <span class="cov0" title="0">if len(res1.Backends) != 0 </span><span class="cov0" title="0">{
                        resp.Backends = append(resp.Backends, res1.Backends...)
                }</span>
        }
        //TODO: Need to consider pagination

        // do not return sensitive information
        <span class="cov0" title="0">for _, v := range resp.Backends </span><span class="cov0" title="0">{
                v.Access = ""
                v.Security = ""
        }</span>

        <span class="cov0" title="0">log.Info("fiterBackendByTier backends successfully.")
        response.WriteEntity(resp)</span>
}

func (s *APIService) ListBackend(request *restful.Request, response *restful.Response) <span class="cov8" title="1">{
        if !policy.Authorize(request, response, "backend:list") </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">log.Info("Received request for backend list.")

        ctx := common.InitCtxWithAuthInfo(request)
        para := request.QueryParameter("tier")
        if para != "" </span><span class="cov0" title="0">{ //List those backends which support the specific tier.
                tier, err := strconv.Atoi(para)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("list backends with tier as filter, but tier[%s] is invalid\n", tier)
                        response.WriteError(http.StatusBadRequest, errors.New("invalid tier"))
                        return
                }</span>
                <span class="cov0" title="0">s.FilterBackendByTier(ctx, request, response, int32(tier))</span>
        } else<span class="cov8" title="1"> {
                s.listBackendDefault(ctx, request, response)
        }</span>
}

func (s *APIService) CreateBackend(request *restful.Request, response *restful.Response) <span class="cov0" title="0">{
        if !policy.Authorize(request, response, "backend:create") </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">log.Info("Received request for creating backend.")
        backendDetail := &amp;backend.BackendDetail{}
        err := request.ReadEntity(&amp;backendDetail)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to read request body: %v\n", err)
                response.WriteError(http.StatusInternalServerError, err)
                return
        }</span>

        <span class="cov0" title="0">ctx := common.InitCtxWithAuthInfo(request)
        actx := request.Attribute(c.KContext).(*c.Context)
        backendDetail.TenantId = actx.TenantId
        backendDetail.UserId = actx.UserId
        res, err := s.backendClient.CreateBackend(ctx, &amp;backend.CreateBackendRequest{Backend: backendDetail})
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to create backend: %v\n", err)
                response.WriteError(http.StatusInternalServerError, err)
                return
        }</span>

        <span class="cov0" title="0">log.Info("Create backend successfully.")
        response.WriteEntity(res.Backend)</span>
}

func (s *APIService) UpdateBackend(request *restful.Request, response *restful.Response) <span class="cov0" title="0">{
        if !policy.Authorize(request, response, "backend:update") </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">log.Infof("Received request for updating backend: %v\n", request.PathParameter("id"))
        updateBackendRequest := backend.UpdateBackendRequest{Id: request.PathParameter("id")}
        err := request.ReadEntity(&amp;updateBackendRequest)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to read request body: %v\n", err)
                response.WriteError(http.StatusInternalServerError, err)
                return
        }</span>

        <span class="cov0" title="0">ctx := common.InitCtxWithAuthInfo(request)
        res, err := s.backendClient.UpdateBackend(ctx, &amp;updateBackendRequest)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to update backend: %v\n", err)
                response.WriteError(http.StatusInternalServerError, err)
                return
        }</span>

        <span class="cov0" title="0">log.Info("Update backend successfully.")
        response.WriteEntity(res.Backend)</span>
}

func (s *APIService) DeleteBackend(request *restful.Request, response *restful.Response) <span class="cov0" title="0">{
        if !policy.Authorize(request, response, "backend:delete") </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">id := request.PathParameter("id")
        log.Infof("Received request for deleting backend: %s\n", id)

        ctx := common.InitCtxWithAuthInfo(request)
        // TODO: refactor this part
        res, err := s.s3Client.ListBuckets(ctx, &amp;s3.BaseRequest{})
        count := 0
        for _, v := range res.Buckets </span><span class="cov0" title="0">{
                res, err := s.backendClient.GetBackend(ctx, &amp;backend.GetBackendRequest{Id: id})
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("failed to get backend details: %v\n", err)
                        response.WriteError(http.StatusInternalServerError, err)
                        return
                }</span>
                <span class="cov0" title="0">backendname := res.Backend.Name
                if backendname == v.DefaultLocation </span><span class="cov0" title="0">{
                        count++
                }</span>
        }
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                response.WriteError(http.StatusInternalServerError, err)
                return
        }</span>
        <span class="cov0" title="0">if count == 0 </span><span class="cov0" title="0">{
                _, err := s.backendClient.DeleteBackend(ctx, &amp;backend.DeleteBackendRequest{Id: id})
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("failed to delete backend: %v\n", err)
                        response.WriteError(http.StatusInternalServerError, err)
                        return
                }</span>
                <span class="cov0" title="0">log.Info("Delete backend successfully.")
                response.WriteHeader(http.StatusOK)
                return</span>
        } else<span class="cov0" title="0"> {
                log.Info("the backend can not be deleted, need to delete bucket first.")
                response.WriteError(http.StatusInternalServerError, BackendDeleteError.Error())
                return
        }</span>
}

func (s *APIService) ListType(request *restful.Request, response *restful.Response) <span class="cov8" title="1">{
        if !policy.Authorize(request, response, "type:list") </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">log.Info("Received request for backend type list.")
        listTypeRequest := &amp;backend.ListTypeRequest{}

        limit, offset, err := common.GetPaginationParam(request)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("get pagination parameters failed: %v\n", err)
                response.WriteError(http.StatusInternalServerError, err)
                return
        }</span>
        <span class="cov8" title="1">listTypeRequest.Limit = limit
        listTypeRequest.Offset = offset

        sortKeys, sortDirs, err := common.GetSortParam(request)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("get sort parameters failed: %v\n", err)
                response.WriteError(http.StatusInternalServerError, err)
                return
        }</span>
        <span class="cov8" title="1">listTypeRequest.SortKeys = sortKeys
        listTypeRequest.SortDirs = sortDirs

        filterOpts := []string{"name"}
        filter, err := common.GetFilter(request, filterOpts)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("get filter failed: %v\n", err)
                response.WriteError(http.StatusInternalServerError, err)
                return
        }</span>
        <span class="cov8" title="1">listTypeRequest.Filter = filter

        ctx := context.Background()
        res, err := s.backendClient.ListType(ctx, listTypeRequest)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to list types: %v\n", err)
                response.WriteError(http.StatusInternalServerError, err)
                return
        }</span>

        <span class="cov8" title="1">log.Info("List types successfully.")
        response.WriteEntity(res)</span>
}



</pre>
		
		<pre class="file" id="file3" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package common

import (
        "context"
        "fmt"
        "strconv"
        "strings"

        "github.com/emicklei/go-restful"
        "github.com/micro/go-micro/metadata"
        c "github.com/soda/multi-cloud/api/pkg/context"
        log "github.com/sirupsen/logrus"
)

const (
        MaxPaginationLimit      = 1000
        DefaultPaginationLimit  = MaxPaginationLimit
        DefaultPaginationOffset = 0
        MaxObjectSize           = 5 * 1024 * 1024 * 1024 // 5GB
        SortDirectionAsc        = "asc"
        SortDirectionDesc       = "desc"
)

const (
        KLimit        = "limit"
        KOffset       = "offset"
        KSort         = "sort"
        KLastModified = "lastmodified"
        KObjKey       = "objkey"
        KStorageTier  = "tier"
        KPrefix       = "prefix"
        KMarker       = "marker"
        KDelimiter    = "delimiter"
        KVerMarker    = "verMarker"
)

const (
        CTX_KEY_TENANT_ID   = "Tenantid"
        CTX_KEY_USER_ID     = "Userid"
        CTX_KEY_IS_ADMIN    = "Isadmin"
        CTX_VAL_TRUE        = "true"
        CTX_KEY_OBJECT_KEY  = "ObjectKey"
        CTX_KEY_BUCKET_NAME = "BucketName"
        CTX_KEY_SIZE        = "ObjectSize"
        CTX_KEY_LOCATION    = "Location"
)

const (
        REQUEST_PATH_BUCKET_NAME         = "bucketName"
        REQUEST_PATH_OBJECT_KEY          = "objectKey"
        REQUEST_HEADER_CONTENT_LENGTH    = "Content-Length"
        REQUEST_HEADER_STORAGE_CLASS     = "x-amz-storage-class"
        REQUEST_HEADER_COPY_SOURCE       = "X-Amz-Copy-Source"
        REQUEST_HEADER_COPY_SOURCE_RANGE = "X-Amz-Copy-Source-Range"
        REQUEST_HEADER_ACL               = "X-Amz-Acl"
        REQUEST_HEADER_CONTENT_MD5       = "Content-Md5"
        REQUEST_HEADER_CONTENT_TYPE      = "Content-Type"
)

const (
        REQUEST_FORM_KEY    = "Key"
        REQUEST_FORM_BUCKET = "Bucket"
)

func GetPaginationParam(request *restful.Request) (int32, int32, error) <span class="cov8" title="1">{
        limit := int32(DefaultPaginationLimit)
        offset := int32(DefaultPaginationOffset)

        if request.QueryParameter(KLimit) != "" </span><span class="cov0" title="0">{
                limitVal, err := strconv.Atoi(request.QueryParameter("limit"))
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("limit is invalid: %v", err)
                        return limit, offset, err
                }</span>
                <span class="cov0" title="0">if limit &gt; int32(limitVal) </span><span class="cov0" title="0">{
                        limit = int32(limitVal)
                }</span>
        }

        <span class="cov8" title="1">if request.QueryParameter(KOffset) != "" </span><span class="cov0" title="0">{
                offsetVal, err := strconv.Atoi(request.QueryParameter("offset"))
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("offset is invalid: %v", err)
                        return limit, offset, err
                }</span>
                <span class="cov0" title="0">offset = int32(offsetVal)</span>
        }
        <span class="cov8" title="1">return limit, offset, nil</span>
}

// An example of sort key parameter will be like this: sort=key1:asc,key2:desc
func GetSortParam(request *restful.Request) (sortKeys []string, sortDirs []string, err error) <span class="cov8" title="1">{
        sortStr := request.QueryParameter(KSort)
        if sortStr != "" </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">sortStr = strings.TrimSpace(sortStr)
        for _, sort := range strings.Split(sortStr, ",") </span><span class="cov8" title="1">{
                parts := strings.Split(sort, ":")
                switch </span>{
                case len(parts) &gt; 2:<span class="cov0" title="0">
                        err = fmt.Errorf("invalid sort value %s", sort)
                        return</span>
                case len(parts) == 1:<span class="cov8" title="1">
                        parts = append(parts, SortDirectionAsc)</span>
                }
                <span class="cov8" title="1">sortKeys = append(sortKeys, parts[0])
                sortDirs = append(sortDirs, parts[1])</span>
        }
        <span class="cov8" title="1">return</span>
}

func GetFilter(request *restful.Request, filterOpts []string) (map[string]string, error) <span class="cov8" title="1">{

        filter := make(map[string]string)
        for _, opt := range filterOpts </span><span class="cov8" title="1">{
                v := request.QueryParameter(opt)
                if v == "" </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">filter[opt] = v</span>
        }
        <span class="cov8" title="1">return filter, nil</span>
}

func InitCtxWithAuthInfo(request *restful.Request) context.Context <span class="cov8" title="1">{
        actx := request.Attribute(c.KContext).(*c.Context)
        ctx := metadata.NewContext(context.Background(), map[string]string{
                CTX_KEY_USER_ID:   actx.UserId,
                CTX_KEY_TENANT_ID: actx.TenantId,
                CTX_KEY_IS_ADMIN:  strconv.FormatBool(actx.IsAdmin),
        })

        return ctx
}</span>

func InitCtxWithVal(request *restful.Request, md map[string]string) context.Context <span class="cov0" title="0">{
        actx := request.Attribute(c.KContext).(*c.Context)
        md[CTX_KEY_USER_ID] = actx.UserId
        md[CTX_KEY_TENANT_ID] = actx.TenantId
        md[CTX_KEY_IS_ADMIN] = strconv.FormatBool(actx.IsAdmin)

        return metadata.NewContext(context.Background(), md)
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may
// not use this file except in compliance with the License. You may obtain
// a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations
// under the License.

// This is self defined context which is stored in context.Input.data.
// It is used to transport data in the pipe line.

package context

import (
        "encoding/json"
        "reflect"

        "github.com/emicklei/go-restful"
        log "github.com/sirupsen/logrus"
)

const (
        KContext = "context"
)

const (
        DefaultTenantId     = "tenantId"
        DefaultUserId       = "userId"
        NoAuthAdminTenantId = "adminTenantId"
)

func NewAdminContext() *Context <span class="cov0" title="0">{
        return &amp;Context{
                TenantId: NoAuthAdminTenantId,
                IsAdmin:  true,
                UserId:   "unknown",
        }
}</span>

func NewContext() *Context <span class="cov8" title="1">{
        return &amp;Context{
                TenantId: DefaultTenantId,
                IsAdmin:  false,
                UserId:   DefaultUserId,
        }
}</span>

func NewContextFromJson(s string) *Context <span class="cov0" title="0">{
        ctx := &amp;Context{}
        err := json.Unmarshal([]byte(s), ctx)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("Unmarshal json to context failed, reason: %v", err)
        }</span>
        <span class="cov0" title="0">return ctx</span>
}

func NewInternalTenantContext(tenantId, userId string, isAdmin bool) *Context <span class="cov0" title="0">{
        return &amp;Context{
                TenantId: tenantId,
                UserId:   userId,
                IsAdmin:  isAdmin,
        }
}</span>

func GetContext(req *restful.Request) *Context <span class="cov8" title="1">{
        ctx, _ := req.Attribute("context").(*Context)
        if ctx == nil </span><span class="cov0" title="0">{
                ctx = &amp;Context{}
        }</span>
        <span class="cov8" title="1">return ctx</span>
}

type Context struct {
        IsAdmin           bool     `policy:"true" json:"is_admin"`
        AuthToken         string   `policy:"true" json:"auth_token"`
        UserId            string   `policy:"true" json:"user_id"`
        TenantId          string   `policy:"true" json:"tenant_id"`
        DomainId          string   `policy:"true" json:"domain_id"`
        UserDomainId      string   `policy:"true" json:"user_domain_id"`
        ProjectDomainId   string   `policy:"true" json:"project_domain_id"`
        Roles             []string `policy:"true" json:"roles"`
        UserName          string   `policy:"true" json:"user_name"`
        ProjectName       string   `policy:"true" json:"project_name"`
        DomainName        string   `policy:"true" json:"domain_name"`
        UserDomainName    string   `policy:"true" json:"user_domain_name"`
        ProjectDomainName string   `policy:"true" json:"project_domain_name"`
        IsAdminTenant     bool     `policy:"true" json:"is_admin_tenant"`
}

func (ctx *Context) ToPolicyValue() map[string]interface{} <span class="cov8" title="1">{
        ctxMap := map[string]interface{}{}
        t := reflect.TypeOf(ctx).Elem()
        v := reflect.ValueOf(ctx).Elem()

        for i := 0; i &lt; t.NumField(); i++ </span><span class="cov8" title="1">{
                field := v.Field(i)
                name := t.Field(i).Tag.Get("json")
                if t.Field(i).Tag.Get("policy") == "false" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">if field.Kind() == reflect.String &amp;&amp; field.String() == "" </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if field.Kind() == reflect.Slice &amp;&amp; field.Len() == 0 </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if field.Kind() == reflect.Map &amp;&amp; field.Len() == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">ctxMap[name] = field.Interface()</span>
        }
        <span class="cov8" title="1">return ctxMap</span>
}

func (ctx *Context) ToJson() string <span class="cov0" title="0">{
        b, err := json.Marshal(ctx)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("Context convert to json failed, reason: %v", err)
        }</span>
        <span class="cov0" title="0">return string(b)</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package dataflow

import (
        "github.com/emicklei/go-restful"
        "github.com/micro/go-micro/client"
)

func RegisterRouter(ws *restful.WebService) <span class="cov8" title="1">{
        handler := NewAPIService(client.DefaultClient)
        ws.Route(ws.POST("/{tenantId}/policies").To(handler.CreatePolicy)).
                Doc("Create policy")
        ws.Route(ws.GET("/{tenantId}/policies").To(handler.ListPolicy)).
                Doc("List policy")
        ws.Route(ws.GET("/{tenantId}/policies/{id}").To(handler.GetPolicy)).
                Doc("Get policy details")
        ws.Route(ws.PUT("/{tenantId}/policies/{id}").To(handler.UpdatePolicy)).
                Doc("Update policy")
        ws.Route(ws.DELETE("/{tenantId}/policies/{id}").To(handler.DeletePolicy)).
                Doc("Delete policy")

        ws.Route(ws.POST("/{tenantId}/plans").To(handler.CreatePlan)).
                Doc("Create plan")
        ws.Route(ws.GET("/{tenantId}/plans").To(handler.ListPlan)).
                Doc("List plan")
        ws.Route(ws.GET("/{tenantId}/plans/{id}").To(handler.GetPlan)).
                Doc("Get plan details")
        ws.Route(ws.PUT("/{tenantId}/plans/{id}").To(handler.UpdatePlan)).
                Doc("Update plan")
        ws.Route(ws.DELETE("/{tenantId}/plans/{id}").To(handler.DeletePlan)).
                Doc("Delete plan")
        ws.Route(ws.POST("/{tenantId}/plans/{id}/run").To(handler.RunPlan)).
                Doc("Create connector")

        ws.Route(ws.GET("/{tenantId}/jobs").To(handler.ListJob)).
                Doc("List jobs details")
        ws.Route(ws.GET("/{tenantId}/jobs/{id}").To(handler.GetJob)).
                Doc("Get job details")
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package dataflow

import (
        "encoding/json"
        "io/ioutil"
        "net/http"

        "github.com/emicklei/go-restful"
        log "github.com/sirupsen/logrus"
        "github.com/micro/go-micro/client"
        "github.com/soda/multi-cloud/api/pkg/common"
        c "github.com/soda/multi-cloud/api/pkg/context"
        "github.com/soda/multi-cloud/api/pkg/policy"
        "github.com/soda/multi-cloud/backend/proto"
        "github.com/soda/multi-cloud/dataflow/proto"
        "github.com/soda/multi-cloud/s3/proto"
)

const (
        backendService  = "backend"
        s3Service       = "s3"
        dataflowService = "dataflow"
)

type APIService struct {
        backendClient  backend.BackendService
        s3Client       s3.S3Service
        dataflowClient dataflow.DataFlowService
}

func NewAPIService(c client.Client) *APIService <span class="cov8" title="1">{
        return &amp;APIService{
                backendClient:  backend.NewBackendService(backendService, c),
                s3Client:       s3.NewS3Service(s3Service, c),
                dataflowClient: dataflow.NewDataFlowService(dataflowService, c),
        }
}</span>

func (s *APIService) ListPolicy(request *restful.Request, response *restful.Response) <span class="cov0" title="0">{
        if !policy.Authorize(request, response, "policy:list") </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">ctx := common.InitCtxWithAuthInfo(request)
        res, err := s.dataflowClient.ListPolicy(ctx, &amp;dataflow.ListPolicyRequest{})
        if err != nil </span><span class="cov0" title="0">{
                response.WriteError(http.StatusInternalServerError, err)
                return
        }</span>

        //For debug -- begin
        <span class="cov0" title="0">log.Infof("Get policy reponse:%v", res)
        jsons, errs := json.Marshal(res)
        if errs != nil </span><span class="cov0" title="0">{
                log.Errorf(errs.Error())
        }</span> else<span class="cov0" title="0"> {
                log.Infof("res: %s.\n", jsons)
        }</span>
        //For debug -- end

        <span class="cov0" title="0">log.Info("List policy details successfully.")
        response.WriteEntity(res)</span>
}

func (s *APIService) GetPolicy(request *restful.Request, response *restful.Response) <span class="cov0" title="0">{
        if !policy.Authorize(request, response, "policy:get") </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">id := request.PathParameter("id")
        log.Infof("Received request for policy[id=%s] details.", id)

        ctx := common.InitCtxWithAuthInfo(request)
        res, err := s.dataflowClient.GetPolicy(ctx, &amp;dataflow.GetPolicyRequest{Id: id})
        if err != nil </span><span class="cov0" title="0">{
                response.WriteError(http.StatusInternalServerError, err)
                return
        }</span>

        //For debug -- begin
        <span class="cov0" title="0">log.Infof("Get policy reponse:%v", res)
        jsons, errs := json.Marshal(res)
        if errs != nil </span><span class="cov0" title="0">{
                log.Errorf(errs.Error())
        }</span> else<span class="cov0" title="0"> {
                log.Infof("res: %s.\n", jsons)
        }</span>
        //For debug -- end

        <span class="cov0" title="0">log.Info("Get policy details successfully.")
        response.WriteEntity(res)</span>
}

func (s *APIService) CreatePolicy(request *restful.Request, response *restful.Response) <span class="cov0" title="0">{
        if !policy.Authorize(request, response, "policy:create") </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">log.Infof("Received request for create policy.\n")

        pol := dataflow.Policy{}
        err := request.ReadEntity(&amp;pol)
        if err != nil </span><span class="cov0" title="0">{
                response.WriteError(http.StatusInternalServerError, err)
                log.Errorf("read request body failed, err:%v.\n", err)
                return
        }</span>

        //For debug --begin
        <span class="cov0" title="0">jsons, errs := json.Marshal(pol)
        if errs != nil </span><span class="cov0" title="0">{
                log.Errorf(errs.Error())
        }</span> else<span class="cov0" title="0"> {
                log.Infof("Req body: %s.\n", jsons)
        }</span>
        //For debug --end

        <span class="cov0" title="0">ctx := common.InitCtxWithAuthInfo(request)
        actx := request.Attribute(c.KContext).(*c.Context)
        pol.TenantId = actx.TenantId
        pol.UserId = actx.UserId
        log.Infof("create policy:%+v\n", pol)
        res, err := s.dataflowClient.CreatePolicy(ctx, &amp;dataflow.CreatePolicyRequest{Policy: &amp;pol})
        if err != nil </span><span class="cov0" title="0">{
                response.WriteError(http.StatusInternalServerError, err)
                return
        }</span>

        <span class="cov0" title="0">log.Info("Get policy details successfully.")
        response.WriteEntity(res)</span>
}

func (s *APIService) UpdatePolicy(request *restful.Request, response *restful.Response) <span class="cov0" title="0">{
        if !policy.Authorize(request, response, "policy:update") </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">policyId := request.PathParameter("id")
        body, err := ioutil.ReadAll(request.Request.Body)
        if err != nil </span><span class="cov0" title="0">{
                response.WriteError(http.StatusInternalServerError, err)
                log.Errorf("read request body failed, err:%v.\n", err)
                return
        }</span>
        <span class="cov0" title="0">log.Infof("Received request for update policy.body:%s\n", body)

        ctx := common.InitCtxWithAuthInfo(request)
        req := &amp;dataflow.UpdatePolicyRequest{PolicyId: policyId, Body: string(body)}
        res, err := s.dataflowClient.UpdatePolicy(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                response.WriteError(http.StatusInternalServerError, err)
                return
        }</span>

        <span class="cov0" title="0">response.WriteEntity(res)

        //For debug --begin
        jsons1, errs1 := json.Marshal(res)
        if errs1 != nil </span><span class="cov0" title="0">{
                log.Errorf(errs1.Error())
        }</span> else<span class="cov0" title="0"> {
                log.Infof("Rsp body: %s.\n", jsons1)
        }</span>
        //For debug --end
        <span class="cov0" title="0">log.Info("Update policy successfully.")</span>
}

func (s *APIService) DeletePolicy(request *restful.Request, response *restful.Response) <span class="cov0" title="0">{
        if !policy.Authorize(request, response, "policy:delete") </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">id := request.PathParameter("id")
        log.Infof("Received request for delete policy[id=%s] details.", id)

        ctx := common.InitCtxWithAuthInfo(request)
        res, err := s.dataflowClient.DeletePolicy(ctx, &amp;dataflow.DeletePolicyRequest{Id: id})
        if err != nil </span><span class="cov0" title="0">{
                response.WriteError(http.StatusInternalServerError, err)
                return
        }</span>

        <span class="cov0" title="0">log.Info("Delete policy end, err = %d.", err)
        response.WriteEntity(res)</span>
}

func (s *APIService) ListPlan(request *restful.Request, response *restful.Response) <span class="cov8" title="1">{
        if !policy.Authorize(request, response, "plan:list") </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">log.Info("Received request for list plan.")

        listPlanReq := &amp;dataflow.ListPlanRequest{}
        limit, offset, err := common.GetPaginationParam(request)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("get pagination parameters failed: %v\n", err)
                response.WriteError(http.StatusInternalServerError, err)
                return
        }</span>
        <span class="cov8" title="1">listPlanReq.Limit = limit
        listPlanReq.Offset = offset

        sortKeys, sortDirs, err := common.GetSortParam(request)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("get sort parameters failed: %v\n", err)
                response.WriteError(http.StatusInternalServerError, err)
                return
        }</span>
        <span class="cov8" title="1">listPlanReq.SortKeys = sortKeys
        listPlanReq.SortDirs = sortDirs

        filterOpts := []string{"name", "type", "bucketname"}
        filter, err := common.GetFilter(request, filterOpts)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("get filter failed: %v\n", err)
                response.WriteError(http.StatusInternalServerError, err)
                return
        }</span> else<span class="cov8" title="1"> {
                log.Infof("Get filter for list plan: %v\n", filter)
        }</span>
        <span class="cov8" title="1">listPlanReq.Filter = filter

        ctx := common.InitCtxWithAuthInfo(request)
        res, err := s.dataflowClient.ListPlan(ctx, listPlanReq)
        if err != nil </span><span class="cov8" title="1">{
                response.WriteError(http.StatusInternalServerError, err)
                return
        }</span>

        //For debug -- begin
        <span class="cov0" title="0">log.Infof("List plans reponse:%v\n", res)
        jsons, errs := json.Marshal(res)
        if errs != nil </span><span class="cov0" title="0">{
                log.Errorf(errs.Error())
        }</span> else<span class="cov0" title="0"> {
                log.Infof("res: %s.\n", jsons)
        }</span>
        //For debug -- end

        <span class="cov0" title="0">log.Info("List plans successfully.")
        response.WriteEntity(res)</span>
}

func (s *APIService) GetPlan(request *restful.Request, response *restful.Response) <span class="cov0" title="0">{
        if !policy.Authorize(request, response, "plan:get") </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">id := request.PathParameter("id")
        log.Infof("Received request for plan[id=%s] details.\n", id)

        ctx := common.InitCtxWithAuthInfo(request)
        res, err := s.dataflowClient.GetPlan(ctx, &amp;dataflow.GetPlanRequest{Id: id})
        if err != nil </span><span class="cov0" title="0">{
                response.WriteError(http.StatusInternalServerError, err)
                return
        }</span>

        //For debug -- begin
        <span class="cov0" title="0">log.Infof("Get plan reponse:%v\n", res)
        jsons, errs := json.Marshal(res)
        if errs != nil </span><span class="cov0" title="0">{
                log.Errorf(errs.Error())
        }</span> else<span class="cov0" title="0"> {
                log.Infof("res: %s.\n", jsons)
        }</span>
        //For debug -- end

        <span class="cov0" title="0">log.Info("Get plan details successfully.")
        response.WriteEntity(res)</span>
}

func (s *APIService) CreatePlan(request *restful.Request, response *restful.Response) <span class="cov0" title="0">{
        if !policy.Authorize(request, response, "plan:create") </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">log.Infof("Received request for create plan.\n")

        plan := dataflow.Plan{}
        err := request.ReadEntity(&amp;plan)
        if err != nil </span><span class="cov0" title="0">{
                response.WriteError(http.StatusInternalServerError, err)
                log.Infof("read request body failed, err:%v.\n", err)
                return
        }</span>

        //For debug --begin
        <span class="cov0" title="0">jsons, errs := json.Marshal(plan)
        if errs != nil </span><span class="cov0" title="0">{
                log.Errorf(errs.Error())
        }</span> else<span class="cov0" title="0"> {
                log.Infof("Req body: %s.\n", jsons)
        }</span>
        //For debug --end

        <span class="cov0" title="0">ctx := common.InitCtxWithAuthInfo(request)
        actx := request.Attribute(c.KContext).(*c.Context)
        plan.TenantId = actx.TenantId
        plan.UserId = actx.UserId
        resp, err := s.dataflowClient.CreatePlan(ctx, &amp;dataflow.CreatePlanRequest{Plan: &amp;plan})
        if err != nil </span><span class="cov0" title="0">{
                response.WriteError(http.StatusInternalServerError, err)
                return
        }</span>

        <span class="cov0" title="0">log.Info("Create plan successfully.")
        response.WriteEntity(resp)</span>
}

func (s *APIService) UpdatePlan(request *restful.Request, response *restful.Response) <span class="cov0" title="0">{
        if !policy.Authorize(request, response, "plan:update") </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">planId := request.PathParameter("id")
        log.Infof("Received request for update plan(%s).\n", planId)
        body, err := ioutil.ReadAll(request.Request.Body)
        if err != nil </span><span class="cov0" title="0">{
                response.WriteError(http.StatusInternalServerError, err)
                log.Infof("read request body failed, err:%v.\n", err)
                return
        }</span>
        <span class="cov0" title="0">log.Infof("Req body: %s.\n", string(body))

        ctx := common.InitCtxWithAuthInfo(request)
        req := &amp;dataflow.UpdatePlanRequest{PlanId: planId, Body: string(body)}
        resp, err := s.dataflowClient.UpdatePlan(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                response.WriteError(http.StatusInternalServerError, err)
                return
        }</span>

        <span class="cov0" title="0">log.Info("Update plan successfully.")
        response.WriteEntity(resp)

        //For debug --begin
        jsons1, errs1 := json.Marshal(resp)
        if errs1 != nil </span><span class="cov0" title="0">{
                log.Errorf(errs1.Error())
        }</span> else<span class="cov0" title="0"> {
                log.Infof("Rsp body: %s.\n", jsons1)
        }</span>
        //For debug --end
}

func (s *APIService) DeletePlan(request *restful.Request, response *restful.Response) <span class="cov0" title="0">{
        if !policy.Authorize(request, response, "plan:delete") </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">id := request.PathParameter("id")
        log.Infof("Received request for delete plan[id=%s] details.\n", id)

        ctx := common.InitCtxWithAuthInfo(request)
        res, err := s.dataflowClient.DeletePlan(ctx, &amp;dataflow.DeletePlanRequest{Id: id})
        if err != nil </span><span class="cov0" title="0">{
                response.WriteError(http.StatusInternalServerError, err)
                return
        }</span>

        <span class="cov0" title="0">response.WriteEntity(res)</span>
}

func (s *APIService) RunPlan(request *restful.Request, response *restful.Response) <span class="cov0" title="0">{
        if !policy.Authorize(request, response, "plan:run") </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">id := request.PathParameter("id")
        log.Infof("Received request for run plan[id=%s] details.\n", id)

        ctx := common.InitCtxWithAuthInfo(request)
        res, err := s.dataflowClient.RunPlan(ctx, &amp;dataflow.RunPlanRequest{Id: id})
        if err != nil </span><span class="cov0" title="0">{
                response.WriteError(http.StatusInternalServerError, err)
                return
        }</span>

        <span class="cov0" title="0">response.WriteEntity(res)</span>
}

func (s *APIService) GetJob(request *restful.Request, response *restful.Response) <span class="cov0" title="0">{
        if !policy.Authorize(request, response, "job:get") </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">id := request.PathParameter("id")
        log.Infof("Received request jobs [id=%s] details.\n", id)

        ctx := common.InitCtxWithAuthInfo(request)
        res, err := s.dataflowClient.GetJob(ctx, &amp;dataflow.GetJobRequest{Id: id})
        if err != nil </span><span class="cov0" title="0">{
                response.WriteError(http.StatusInternalServerError, err)
                return
        }</span>

        //For debug -- begin
        <span class="cov0" title="0">log.Infof("Get jobs reponse:%v\n", res)
        jsons, errs := json.Marshal(res)
        if errs != nil </span><span class="cov0" title="0">{
                log.Errorf(errs.Error())
        }</span> else<span class="cov0" title="0"> {
                log.Infof("res: %s.\n", jsons)
        }</span>
        //For debug -- end

        <span class="cov0" title="0">log.Info("Get job details successfully.")
        response.WriteEntity(res)</span>
}

func (s *APIService) ListJob(request *restful.Request, response *restful.Response) <span class="cov0" title="0">{
        if !policy.Authorize(request, response, "job:list") </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">log.Infof("Received request for list jobs:%v.\n", request)

        listJobReq := &amp;dataflow.ListJobRequest{}
        limit, offset, err := common.GetPaginationParam(request)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("get pagination parameters failed: %v\n", err)
                response.WriteError(http.StatusInternalServerError, err)
                return
        }</span>
        <span class="cov0" title="0">listJobReq.Limit = limit
        listJobReq.Offset = offset

        sortKeys, sortDirs, err := common.GetSortParam(request)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("get sort parameters failed: %v\n", err)
                response.WriteError(http.StatusInternalServerError, err)
                return
        }</span>
        <span class="cov0" title="0">listJobReq.SortKeys = sortKeys
        listJobReq.SortDirs = sortDirs

        filterOpts := []string{"planName", "type"}
        filter, err := common.GetFilter(request, filterOpts)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("get filter failed: %v\n", err)
                response.WriteError(http.StatusInternalServerError, err)
                return
        }</span> else<span class="cov0" title="0"> {
                log.Infof("Get filter for list job: %v\n", filter)
        }</span>
        <span class="cov0" title="0">listJobReq.Filter = filter

        ctx := common.InitCtxWithAuthInfo(request)
        res, err := s.dataflowClient.ListJob(ctx, listJobReq)
        if err != nil </span><span class="cov0" title="0">{
                response.WriteError(http.StatusInternalServerError, err)
                return
        }</span>

        //For debug -- begin
        <span class="cov0" title="0">log.Infof("List jobs reponse:%v\n", res)
        jsons, errs := json.Marshal(res)
        if errs != nil </span><span class="cov0" title="0">{
                log.Errorf(errs.Error())
        }</span> else<span class="cov0" title="0"> {
                log.Infof("res: %s.\n", jsons)
        }</span>
        //For debug -- end

        <span class="cov0" title="0">log.Info("List jobs successfully.")
        response.WriteEntity(res)</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package auth

import (
        "os"

        "github.com/emicklei/go-restful"
        log "github.com/sirupsen/logrus"
        c "github.com/soda/multi-cloud/api/pkg/context"
)

type AuthBase interface {
        Filter(req *restful.Request, resp *restful.Response, chain *restful.FilterChain)
}

type NoAuth struct {
}

func NewNoAuth() AuthBase <span class="cov0" title="0">{
        return &amp;NoAuth{}
}</span>

func (auth *NoAuth) Filter(req *restful.Request, resp *restful.Response, chain *restful.FilterChain) <span class="cov0" title="0">{
        log.Info("Noauth filter begin")
        ctx := req.Attribute(c.KContext).(*c.Context)
        log.Info(ctx.TenantId)
        params := req.PathParameters()
        if tenantId, ok := params["tenantId"]; ok </span><span class="cov0" title="0">{
                ctx.TenantId = tenantId
        }</span>

        <span class="cov0" title="0">ctx.IsAdmin = ctx.TenantId == c.NoAuthAdminTenantId
        chain.ProcessFilter(req, resp)</span>
}

func FilterFactory() restful.FilterFunction <span class="cov8" title="1">{
        var auth AuthBase
        log.Info(os.Getenv("OS_AUTH_AUTHSTRATEGY"))
        switch os.Getenv("OS_AUTH_AUTHSTRATEGY") </span>{
        case "keystone":<span class="cov8" title="1">
                auth = NewKeystone()</span>
        case "noauth":<span class="cov0" title="0">
                log.Info("filter is noauth")
                auth = NewNoAuth()</span>
        default:<span class="cov0" title="0">
                auth = NewNoAuth()</span>
        }
        <span class="cov8" title="1">return auth.Filter</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may
// not use this file except in compliance with the License. You may obtain
// a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations
// under the License.

// Keystone authentication middleware, only support keystone v3.
package auth

import (
        "net/http"
        "os"
        "strings"
        "time"

        "github.com/emicklei/go-restful"
        log "github.com/sirupsen/logrus"
        "github.com/gophercloud/gophercloud"
        "github.com/gophercloud/gophercloud/openstack"
        "github.com/gophercloud/gophercloud/openstack/identity/v3/tokens"
        c "github.com/soda/multi-cloud/api/pkg/context"
        "github.com/soda/multi-cloud/api/pkg/model"
        "github.com/soda/multi-cloud/api/pkg/utils"
        "github.com/soda/multi-cloud/api/pkg/utils/constants"
)

type Keystone struct {
        identity *gophercloud.ServiceClient
}

func GetIdentity(k *Keystone) *gophercloud.ServiceClient <span class="cov8" title="1">{
        return k.identity
}</span>

func NewKeystone() AuthBase <span class="cov8" title="1">{
        k := &amp;Keystone{}
        if err := k.SetUp(); err != nil </span><span class="cov0" title="0">{
                // If auth set up failed, raise panic.
                panic(err)</span>
        }
        <span class="cov8" title="1">return k</span>
}

func (k *Keystone) SetUp() error <span class="cov8" title="1">{
        opts := gophercloud.AuthOptions{
                IdentityEndpoint: os.Getenv("OS_AUTH_URL"),
                DomainName:       os.Getenv("OS_USER_DOMIN_ID"),
                Username:         os.Getenv("OS_USERNAME"),
                Password:         os.Getenv("OS_PASSWORD"),
                TenantName:       os.Getenv("OS_PROJECT_NAME"),
        }
        log.Infof("opts:%v", opts)
        provider, err := openstack.AuthenticatedClient(opts)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("When get auth client:", err)
                return err
        }</span>
        // Only support keystone v3
        <span class="cov8" title="1">k.identity, err = openstack.NewIdentityV3(provider, gophercloud.EndpointOpts{})
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("When get identity session:", err)
                return err
        }</span>
        <span class="cov8" title="1">log.Infof("Service Token Info: %s", provider.TokenID)
        return nil</span>
}

func (k *Keystone) Filter(req *restful.Request, resp *restful.Response, chain *restful.FilterChain) <span class="cov8" title="1">{
        // Strip the spaces around the token  ctx.Input.Header(constants.AuthTokenHeader)
        token := strings.TrimSpace(req.HeaderParameter(constants.AuthTokenHeader))
        if err := k.validateToken(req, resp, token); err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">chain.ProcessFilter(req, resp)</span>
}

func (k *Keystone) validateToken(req *restful.Request, res *restful.Response, token string) error <span class="cov8" title="1">{
        if token == "" </span><span class="cov0" title="0">{
                return model.HttpError(res, http.StatusUnauthorized, "token not found in header")
        }</span>
        <span class="cov8" title="1">var r tokens.GetResult
        // The service token may be expired or revoked, so retry to get new token.
        err := utils.Retry(2, "verify token", false, func(retryIdx int, lastErr error) error </span><span class="cov8" title="1">{
                if retryIdx &gt; 0 </span><span class="cov0" title="0">{
                        // Fixme: Is there any better method ?
                        if lastErr.Error() == "Authentication failed" </span><span class="cov0" title="0">{
                                k.SetUp()
                        }</span> else<span class="cov0" title="0"> {
                                return lastErr
                        }</span>
                }
                <span class="cov8" title="1">log.Infof("k.identity:", k.identity)
                r = tokens.Get(k.identity, token)
                log.Infof("r:", r)
                log.Infof("r.err:", r.Err)
                return r.Err</span>
        })
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return model.HttpError(res, http.StatusUnauthorized, "get token failed,%v", r.Err)
        }</span>

        <span class="cov8" title="1">t, err := r.ExtractToken()
        if err != nil </span><span class="cov0" title="0">{
                return model.HttpError(res, http.StatusUnauthorized, "extract token failed,%v", err)

        }</span>
        <span class="cov8" title="1">log.Infof("token: %v", t)

        if time.Now().After(t.ExpiresAt) </span><span class="cov0" title="0">{
                return model.HttpError(res, http.StatusUnauthorized,
                        "token has expired, expire time %v", t.ExpiresAt)
        }</span>
        <span class="cov8" title="1">return k.setPolicyContext(req, res, r)</span>
}

func (k *Keystone) setPolicyContext(req *restful.Request, res *restful.Response, r tokens.GetResult) error <span class="cov8" title="1">{
        roles, err := r.ExtractRoles()
        if err != nil </span><span class="cov0" title="0">{
                return model.HttpError(res, http.StatusUnauthorized, "extract roles failed,%v", err)
        }</span>

        <span class="cov8" title="1">var roleNames []string
        for _, role := range roles </span><span class="cov8" title="1">{
                roleNames = append(roleNames, role.Name)
        }</span>

        <span class="cov8" title="1">project, err := r.ExtractProject()
        if err != nil </span><span class="cov0" title="0">{
                return model.HttpError(res, http.StatusUnauthorized, "extract project failed,%v", err)
        }</span>

        <span class="cov8" title="1">user, err := r.ExtractUser()
        if err != nil </span><span class="cov0" title="0">{
                return model.HttpError(res, http.StatusUnauthorized, "extract user failed,%v", err)
        }</span>

        <span class="cov8" title="1">t, _ := r.ExtractToken()
        ctx := req.Attribute(c.KContext).(*c.Context)
        ctx.AuthToken = t.ID
        ctx.TenantId = project.ID
        ctx.UserId = user.ID
        ctx.Roles = roleNames
        ctx.IsAdminTenant = strings.ToLower(project.Name) == "admin"

        return nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package context

import (
        "github.com/emicklei/go-restful"
        c "github.com/soda/multi-cloud/api/pkg/context"
)

func FilterFactory() restful.FilterFunction <span class="cov8" title="1">{
        return func(req *restful.Request, resp *restful.Response, chain *restful.FilterChain) </span><span class="cov8" title="1">{
                req.SetAttribute(c.KContext, c.NewContext())
                chain.ProcessFilter(req, resp)
        }</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package logging

import (
        "github.com/emicklei/go-restful"
        log "github.com/sirupsen/logrus"
)

func FilterFactory() restful.FilterFunction <span class="cov8" title="1">{
        return func(req *restful.Request, resp *restful.Response, chain *restful.FilterChain) </span><span class="cov8" title="1">{
                log.Infof("\033[32m[D] %s -- %s %s\033[0m\n", req.Request.RemoteAddr, req.Request.Method,
                        req.Request.URL)
                chain.ProcessFilter(req, resp)
        }</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package credentials

import (
        "sync"
)

// A Value is the soda multi-cloud credentials value.
type Value struct {
        // soda multi-cloud Access key ID
        AccessKeyID string

        // soda multi-cloud Secret Access Key
        SecretAccessKey string

        // TenantID
        TenantID string

        // UserID
        UserID string

        // Provider used to get credentials
        ProviderName string
}

// A Provider is the interface to provide credentials Value.
type Provider interface {
        // Retrieve returns credential value if it successfully retrieved the value,
        // otherwise returns Error.
        Retrieve() (Value, error)
}

// An ErrorProvider is a credentials provider that always returns an error
type ErrorProvider struct {
        // The error to be returned from Retrieve
        Err error

        // The provider name to set on the Retrieved returned Value
        ProviderName string
}

// Retrieve will always return the error that the ErrorProvider was created with.
func (p ErrorProvider) Retrieve() (Value, error) <span class="cov0" title="0">{
        return Value{ProviderName: p.ProviderName}, p.Err
}</span>

// A Credentials provides concurrency safe retrieval of soda multi-cloud credentials Value.
type Credentials struct {
        credentials Value

        m sync.RWMutex

        provider Provider
}

// NewCredentials returns a pointer to a new Credentials with the provider set.
func NewCredentials(provider Provider) *Credentials <span class="cov8" title="1">{
        return &amp;Credentials{
                provider: provider,
        }
}</span>

// Get returns the credentials value, or error on failed retrieval
func (c *Credentials) Get() (Value, error) <span class="cov8" title="1">{

        c.m.RLock()
        credentials, err := c.provider.Retrieve()
        if err != nil </span><span class="cov0" title="0">{
                return Value{}, err
        }</span>
        <span class="cov8" title="1">c.credentials = credentials
        c.m.RUnlock()

        return c.credentials, nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package keystonecredentials provides support for retrieving credentials from keystone

package keystonecredentials

import (
        "encoding/json"
        "strings"

        log "github.com/sirupsen/logrus"
        "github.com/gophercloud/gophercloud"
        creds "github.com/gophercloud/gophercloud/openstack/identity/v3/credentials"
        "github.com/soda/multi-cloud/api/pkg/filters/auth"
        "github.com/soda/multi-cloud/api/pkg/filters/signature/credentials"
        "github.com/soda/multi-cloud/api/pkg/model"
)

// ProviderName is the name of the credentials provider.
const ProviderName = `KeystoneProvider`

// KeystoneProvider is a client to retrieve credentials from Keystone.
type KeystoneProvider struct {
        // Requires a gopher cloud Client to make HTTP requests to the Keystone with.
        Identity *gophercloud.ServiceClient

        // Requires an AccessKeyID to filter the credentials request.
        AccessKeyID string
}

type Blob struct {
        Access string `json:"access"`
        Secret string `json:"secret"`
}

// NewProviderClient returns a credentials Provider for retrieving credentials
func NewProviderClient(accessKeyID string, options ...func(*KeystoneProvider)) credentials.Provider <span class="cov8" title="1">{

        k := &amp;auth.Keystone{}
        if err := k.SetUp(); err != nil </span><span class="cov0" title="0">{
                // If auth set up failed, raise panic.
                panic(err)</span>
        }

        <span class="cov8" title="1">kp := &amp;KeystoneProvider{
                AccessKeyID: accessKeyID,
        }
        kp.Identity = auth.GetIdentity(k)

        log.Infof("Service Token Info: %s", kp.Identity.TokenID)

        return kp</span>
}

// NewCredentialsClient returns a Credentials wrapper for retrieving credentials
func NewCredentialsClient(accessKeyID string, options ...func(*KeystoneProvider)) *credentials.Credentials <span class="cov8" title="1">{
        return credentials.NewCredentials(NewProviderClient(accessKeyID, options...))
}</span>

// Retrieve will attempt to request the credentials from the Keystone
// And error will be returned if the retrieval fails.
func (p *KeystoneProvider) Retrieve() (credentials.Value, error) <span class="cov8" title="1">{
        resp, err := p.getCredentials(p.AccessKeyID)
        if err != nil </span><span class="cov0" title="0">{
                return credentials.Value{ProviderName: ProviderName}, err
        }</span>

        <span class="cov8" title="1">return credentials.Value{
                AccessKeyID:     resp.AccessKeyID,
                SecretAccessKey: resp.SecretAccessKey,
                TenantID:        resp.TenantID,
                UserID:          resp.UserID,
                ProviderName:    ProviderName,
        }, nil</span>
}

type GetCredentialOutput struct {
        AccessKeyID     string
        SecretAccessKey string
        TenantID        string
        UserID          string
}

// Returns AccessKey and SecretKey Values, Retrieves Credentials
// from Keystone And error will be returned if the retrieval fails.
func (p *KeystoneProvider) getCredentials(accessKeyID string) (*GetCredentialOutput, error) <span class="cov8" title="1">{

        allPages, err := creds.List(p.Identity, nil).AllPages()

        credentials, err := creds.ExtractCredentials(allPages)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("getCredentials failed, err: %+v", err)
                return nil, err
        }</span>
        <span class="cov8" title="1">log.Infof("provider-Credentials: %+v", credentials)

        cred, err := getCredential(credentials, accessKeyID)
        log.Infof("cred: %+v", cred)

        return cred, err</span>
}

// Returns a credential Blob for getting access and secret
// And error will be returned if it fails.
func getCredential(credentials []creds.Credential, accessKeyID string) (*GetCredentialOutput, error) <span class="cov8" title="1">{
        blob := &amp;Blob{}
        for _, credential := range credentials </span><span class="cov8" title="1">{
                var blobStr = credential.Blob
                b := strings.Replace(blobStr, "\\", "", -1)
                err := json.Unmarshal([]byte(b), blob)

                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">if blob.Access == accessKeyID </span><span class="cov8" title="1">{
                        out := &amp;GetCredentialOutput{
                                AccessKeyID:     blob.Access,
                                SecretAccessKey: blob.Secret,
                                TenantID:        credential.ProjectID,
                                UserID:          credential.UserID,
                        }

                        log.Infof("Get credential for %s successfully.", blob.Access)
                        return out, nil
                }</span>
        }
        <span class="cov0" title="0">return nil, model.NewNotFoundError("credential is missing")</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may
// not use this file except in compliance with the License. You may obtain
// a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations
// under the License.

// Package signer implements signing and signature validation for soda multi-cloud signer.
//
// Provides request signing for request that need to be signed with the Signature.
// Provides signature validation for request.
//
package signer

import (
        "crypto/hmac"
        "crypto/sha256"
        "encoding/hex"
        "net/http"
        "net/url"
        "sort"
        "strings"

        "github.com/emicklei/go-restful"
        log "github.com/sirupsen/logrus"
        c "github.com/soda/multi-cloud/api/pkg/context"
        "github.com/soda/multi-cloud/api/pkg/filters/signature/credentials"
        "github.com/soda/multi-cloud/api/pkg/filters/signature/credentials/keystonecredentials"
        "github.com/soda/multi-cloud/api/pkg/model"
        "github.com/soda/multi-cloud/api/pkg/utils/constants"
)

const (
        authHeaderPrefix  = "soda-HMAC-SHA256"
        emptyStringSHA256 = `e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855`
)

type SignatureBase interface {
        Filter(req *restful.Request, resp *restful.Response, chain *restful.FilterChain)
}

type Signature struct {
        Service string
        Region  string
        Request *http.Request
        Body    string
        Query   url.Values

        SignedHeaderValues http.Header

        credValues       credentials.Value
        requestDateTime  string
        requestDate      string
        requestPayload   string
        signedHeaders    string
        canonicalHeaders string
        canonicalString  string
        credentialString string
        stringToSign     string
        signature        string
        authorization    string
}

func NewSignature() SignatureBase <span class="cov8" title="1">{
        return &amp;Signature{}
}</span>

func FilterFactory() restful.FilterFunction <span class="cov8" title="1">{
        sign := NewSignature()
        return sign.Filter
}</span>

// Signature Authorization Filter to validate the Request Signature
// Authorization: algorithm Credential=accesskeyID/credential scope, SignedHeaders=SignedHeaders, Signature=signature
// credential scope &lt;requestDate&gt;/&lt;region&gt;/&lt;service&gt;/sign_request
func (sign *Signature) Filter(req *restful.Request, resp *restful.Response, chain *restful.FilterChain) <span class="cov8" title="1">{

        //Get the Authorization Header from the request
        authorization, err := getHeaderParams(req, resp, constants.AuthorizationHeader)

        if err != nil </span><span class="cov0" title="0">{
                log.Error("When get Authorization value:", err)
                return
        }</span>

        //Get the X-Auth-Date Header from the request
        <span class="cov8" title="1">requestDateTime, err := getHeaderParams(req, resp, constants.SignDateHeader)

        if err != nil </span><span class="cov0" title="0">{
                log.Error("When get Request DateTimeStamp value:", err)
                return
        }</span>

        //Get the Authorization parameters from the Authorization String
        <span class="cov8" title="1">authorizationParts := strings.Split(authorization, ",")
        credential, signature := strings.TrimSpace(authorizationParts[0]), strings.TrimSpace(authorizationParts[2])

        signatureParts := strings.Split(signature, "=")
        expectedSignature := signatureParts[1]

        credentialParts := strings.Split(credential, " ")
        creds := credentialParts[1]

        credsParts := strings.Split(creds, "=")
        credentialStr := credsParts[1]

        credentialStrParts := strings.Split(credentialStr, "/")
        accessKeyID, requestDate, region, service := credentialStrParts[0], credentialStrParts[1], credentialStrParts[2], credentialStrParts[3]

        //TODO Get Request Body
        body := ""

        //Create a keystone credentials Provider client for retrieving credentials
        credentials := keystonecredentials.NewCredentialsClient(accessKeyID)

        //Create a Signer and the calculate the signature based on the Header parameters passed in request
        signer := NewSigner(credentials)
        calculatedSignature, err := signer.Sign(req, body, service, region, requestDateTime, requestDate, credentialStr)

        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        //Validate the signature
        <span class="cov8" title="1">if err := sign.validateSignature(req, resp, expectedSignature, calculatedSignature); err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">chain.ProcessFilter(req, resp)</span>
}

//Returns nil if the signatures are matched, else http error
func (sign *Signature) validateSignature(req *restful.Request, res *restful.Response, expectedSign string, calculatedSign string) error <span class="cov8" title="1">{
        if expectedSign == "" </span><span class="cov0" title="0">{
                return model.HttpError(res, http.StatusUnauthorized, "signature not found in header")
        }</span>
        <span class="cov8" title="1">if calculatedSign == "" </span><span class="cov0" title="0">{
                return model.HttpError(res, http.StatusUnauthorized, "signature calculation failed")
        }</span>
        <span class="cov8" title="1">if calculatedSign != expectedSign </span><span class="cov0" title="0">{
                return model.HttpError(res, http.StatusUnauthorized, "signature validation failed")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

//Returns the Header value, else http error
func getHeaderParams(req *restful.Request, resp *restful.Response, header string) (string, error) <span class="cov8" title="1">{
        // Strip the spaces around the Header
        value := strings.TrimSpace(req.HeaderParameter(header))

        if value == "" </span><span class="cov0" title="0">{
                return "", model.HttpError(resp, http.StatusUnauthorized, header+" not found in header")
        }</span>
        <span class="cov8" title="1">return value, nil</span>
}

// Signer provides sign requests that need to be signed with the Signature.
type Signer struct {
        // The authentication credentials the request will be signed against.
        Credentials *credentials.Credentials
}

// NewSigner returns a Signer pointer configured with the credentials and optional
// option values provided.
func NewSigner(credentials *credentials.Credentials, options ...func(*Signer)) *Signer <span class="cov8" title="1">{
        signer := &amp;Signer{
                Credentials: credentials,
        }

        for _, option := range options </span><span class="cov0" title="0">{
                option(signer)
        }</span>

        <span class="cov8" title="1">return signer</span>
}

// Sign signs soda multi-cloud requests with the service, name, region,
// date time the request is signed at.
//
// Returns the signature or an error if signing the request failed.
func (signer Signer) Sign(req *restful.Request, body string, service, region string, requestDateTime string, requestDate string, credentialStr string) (string, error) <span class="cov8" title="1">{

        sign := &amp;Signature{
                Request:         req.Request,
                requestDateTime: requestDateTime,
                requestDate:     requestDate,
                Body:            body,
                Query:           req.Request.URL.Query(),
                Service:         service,
                Region:          region,
        }

        for key := range sign.Query </span><span class="cov8" title="1">{
                sort.Strings(sign.Query[key])
        }</span>

        <span class="cov8" title="1">var err error
        sign.credValues, err = signer.Credentials.Get()
        sign.credentialString = credentialStr

        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">if err := sign.build(); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">ctx := req.Attribute(c.KContext).(*c.Context)
        ctx.TenantId = sign.credValues.TenantID
        ctx.UserId = sign.credValues.UserID

        return sign.signature, nil</span>
}

// ************* CREATE A SIGNATURE *************
func (sign *Signature) build() error <span class="cov8" title="1">{

        if err := sign.buildPayloadDigest(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">unsignedHeaders := sign.Request.Header
        sign.buildCanonicalHeaders(unsignedHeaders)

        sign.buildCanonicalString() // depends on canonical headers / signed headers
        sign.buildStringToSign()    // depends on credential string
        sign.buildSignature()       // depends on string to sign

        return nil</span>
}

// Build the canonical header list. Convert all header names to lowercase and
// remove leading spaces and trailing spaces. Convert sequential spaces in
// the header value to a single space.
func (sign *Signature) buildCanonicalHeaders(header http.Header) <span class="cov8" title="1">{
        var headers []string
        //TODO Add other Header parameters like content-type etc.
        for k, v := range header </span><span class="cov8" title="1">{

                canonicalKey := http.CanonicalHeaderKey(k)
                if canonicalKey != "X-Auth-Date" </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">if sign.SignedHeaderValues == nil </span><span class="cov8" title="1">{
                        sign.SignedHeaderValues = make(http.Header)
                }</span>

                <span class="cov8" title="1">lowerCaseKey := strings.ToLower(k)
                if _, ok := sign.SignedHeaderValues[lowerCaseKey]; ok </span><span class="cov0" title="0">{
                        sign.SignedHeaderValues[lowerCaseKey] = append(sign.SignedHeaderValues[lowerCaseKey], v...)
                        continue</span>
                }

                <span class="cov8" title="1">headers = append(headers, lowerCaseKey)
                sign.SignedHeaderValues[lowerCaseKey] = v</span>
        }
        <span class="cov8" title="1">sort.Strings(headers)

        sign.signedHeaders = strings.Join(headers, ";")

        headerValues := make([]string, len(headers))
        for i, k := range headers </span><span class="cov8" title="1">{
                headerValues[i] = k + ":" +
                        strings.Join(sign.SignedHeaderValues[k], ",")
        }</span>
        <span class="cov8" title="1">stripExcessSpaces(headerValues)
        sign.canonicalHeaders = strings.Join(headerValues, "\n")</span>
}

// ************* TASK 1: CREATE A CANONICAL REQUEST *************
func (sign *Signature) buildCanonicalString() <span class="cov8" title="1">{

        sign.Request.URL.RawQuery = strings.Replace(sign.Query.Encode(), "+", "%20", -1)

        canonicalURI := getURIPath(sign.Request.URL)

        sign.canonicalString = strings.Join([]string{
                // Step 1 is to define the verb (GET, POST, etc.) Already defined in the Request.
                sign.Request.Method,
                // Step 2: Create canonical URI--the part of the URI from domain to query
                canonicalURI,
                // Step 3: Create the canonical query string.Query string values must be URL-encoded
                // (space=%20). The parameters must be sorted by name.
                sign.Request.URL.RawQuery,
                // Step 4: Create the canonical headers and signed headers. Header names must be
                // trimmed and lowercase, and in alpha order \n.
                sign.canonicalHeaders + "\n",
                // Step 5: Create the list of signed headers. This lists the headers in the
                // canonical_headers list, delimited with ";" and in alpha order.
                sign.signedHeaders,
                // Step 6: Create payload hash (hash of the request body content). For GET requests,
                // the payload is an empty string ("").
                sign.requestPayload,
        }, "\n") //Step 7: Combine elements to create canonical request
}</span>

// ************* TASK 2: CREATE THE STRING TO SIGN *************
// Match the algorithm to the hashing algorithm, SHA-256
func (sign *Signature) buildStringToSign() <span class="cov8" title="1">{
        sign.stringToSign = strings.Join([]string{
                // Step 1: is to define the hashing Algorithm.
                authHeaderPrefix,
                // Step 2: Append the request date value which is specified with ISO8601 basic format
                // in the x-auth-date header in the format YYYYMMDD'T'HHMMSS'Z'.
                sign.requestDateTime,
                //Step 3: Append the credential scope value that includes the date, the region,service,
                // and a termination string ("sign_request") in lowercase characters.
                sign.credentialString,
                //Step 4: Append the hash of the canonical request created in Task 1
                hex.EncodeToString(makeSha256([]byte(sign.canonicalString))),
        }, "\n") //Step 5: Combine elements to create canonical request
}</span>

// ************* TASK 3: CALCULATE THE SIGNATURE *************
func (sign *Signature) buildSignature() <span class="cov8" title="1">{
        // Step 1:  Create the signing key, use the secret access key to create a series of
        // hash-based message authentication codes (HMACs).
        kSecret := sign.credValues.SecretAccessKey
        kDate := makeHmac([]byte("soda"+kSecret), []byte(sign.requestDate))
        kRegion := makeHmac(kDate, []byte(sign.Region))
        kService := makeHmac(kRegion, []byte(sign.Service))
        signingKey := makeHmac(kService, []byte("sign_request"))

        // Step 2: Calculate the signature using the signing key and the string to sign as inputs
        // to the keyed hash function. Convert the binary value to a hexadecimal representation.
        signature := makeHmac(signingKey, []byte(sign.stringToSign))
        sign.signature = hex.EncodeToString(signature)
}</span>

// Use a SHA256 hash to create a hashed value from the payload in the body of the HTTP request
// If the payload is empty, use an empty string as the input to the hash function.
func (sign *Signature) buildPayloadDigest() error <span class="cov8" title="1">{
        hash := ""

        if sign.Body == "" </span><span class="cov8" title="1">{
                hash = emptyStringSHA256
        }</span> else<span class="cov0" title="0"> {
                hash = hex.EncodeToString(makeSha256([]byte(sign.Body)))
        }</span>

        <span class="cov8" title="1">sign.requestPayload = hash

        return nil</span>
}

func makeHmac(key []byte, value []byte) []byte <span class="cov8" title="1">{
        hash := hmac.New(sha256.New, key)
        hash.Write(value)
        return hash.Sum(nil)
}</span>

func makeSha256(data []byte) []byte <span class="cov8" title="1">{
        hash := sha256.New()
        hash.Write(data)
        return hash.Sum(nil)
}</span>

// stripExcessSpaces will trim multiple side-by-side spaces.
func stripExcessSpaces(vals []string) <span class="cov8" title="1">{
        var j, k, l, m, spaces int
        for i, str := range vals </span><span class="cov8" title="1">{
                // Trim trailing spaces
                for j = len(str) - 1; j &gt;= 0 &amp;&amp; str[j] == ' '; j-- </span>{<span class="cov0" title="0">
                }</span>

                // Trim leading spaces
                <span class="cov8" title="1">for k = 0; k &lt; j &amp;&amp; str[k] == ' '; k++ </span>{<span class="cov0" title="0">
                }</span>
                <span class="cov8" title="1">str = str[k : j+1]

                // Strip multiple spaces.
                j = strings.Index(str, "  ")
                if j &lt; 0 </span><span class="cov8" title="1">{
                        vals[i] = str
                        continue</span>
                }

                <span class="cov0" title="0">buf := []byte(str)
                for k, m, l = j, j, len(buf); k &lt; l; k++ </span><span class="cov0" title="0">{
                        if buf[k] == ' ' </span><span class="cov0" title="0">{
                                if spaces == 0 </span><span class="cov0" title="0">{
                                        buf[m] = buf[k]
                                        m++
                                }</span>
                                <span class="cov0" title="0">spaces++</span>
                        } else<span class="cov0" title="0"> {
                                spaces = 0
                                buf[m] = buf[k]
                                m++
                        }</span>
                }

                <span class="cov0" title="0">vals[i] = string(buf[:m])</span>
        }
}

func getURIPath(url *url.URL) string <span class="cov8" title="1">{
        var canonicalURI string

        if len(url.Opaque) &gt; 0 </span><span class="cov0" title="0">{
                canonicalURI = "/" + strings.Join(strings.Split(url.Opaque, "/")[3:], "/")
        }</span> else<span class="cov8" title="1"> {
                canonicalURI = url.EscapedPath()
        }</span>

        <span class="cov8" title="1">if len(canonicalURI) == 0 </span><span class="cov0" title="0">{
                canonicalURI = "/"
        }</span>

        <span class="cov8" title="1">return canonicalURI</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*
This module implements the common data structure.

*/

package model

import (
        "encoding/json"
        "errors"
        "fmt"

        "github.com/emicklei/go-restful"
        log "github.com/sirupsen/logrus"
)

const (
        // ErrorBadRequest
        ErrorBadRequest = 400
        // ErrorUnauthorized
        ErrorUnauthorized = 401
        // ErrorForbidden
        ErrorForbidden = 403
        // ErrorNotFound
        ErrorNotFound = 404
        // ErrorInternalServer
        ErrorInternalServer = 500
        // ErrorNotImplemented
        ErrorNotImplemented = 501
)

// ErrorSpec describes Detailed HTTP error response, which consists of a HTTP
// status code, and a custom error message unique for each failure case.
type ErrorSpec struct {
        Code    int    `json:"code,omitempty"`
        Message string `json:"message,omitempty"`
}

// ErrorBadRequestStatus
func ErrorBadRequestStatus(message string) []byte <span class="cov0" title="0">{
        return errorStatus(ErrorBadRequest, message)
}</span>

// ErrorForbiddenStatus
func ErrorForbiddenStatus(message string) []byte <span class="cov0" title="0">{
        return errorStatus(ErrorForbidden, message)
}</span>

// ErrorUnauthorizedStatus
func ErrorUnauthorizedStatus(message string) []byte <span class="cov0" title="0">{
        return errorStatus(ErrorUnauthorized, message)
}</span>

// ErrorNotFoundStatus
func ErrorNotFoundStatus(message string) []byte <span class="cov0" title="0">{
        return errorStatus(ErrorNotFound, message)
}</span>

// ErrorInternalServerStatus
func ErrorInternalServerStatus(message string) []byte <span class="cov0" title="0">{
        return errorStatus(ErrorInternalServer, message)
}</span>

// ErrorNotImplementedStatus
func ErrorNotImplementedStatus(message string) []byte <span class="cov0" title="0">{
        return errorStatus(ErrorNotImplemented, message)
}</span>

func errorStatus(code int, message string) []byte <span class="cov0" title="0">{
        errStatus := &amp;ErrorSpec{
                Code:    code,
                Message: message,
        }

        // Mashal the error status.
        body, err := json.Marshal(errStatus)
        if err != nil </span><span class="cov0" title="0">{
                return []byte("Failed to mashal error response: " + err.Error())
        }</span>
        <span class="cov0" title="0">return body</span>
}

/*
func HttpError(ctx *context.Context, code int, format string, a ...interface{}) error {
        ctx.Output.SetStatus(code)
        msg := fmt.Sprintf(format, a...)
        ctx.Output.Body(errorStatus(code, msg))
        errInfo := fmt.Sprintf("Code:%d, Reason:%s", code, msg)
        log.Error(errInfo)
        return fmt.Errorf(errInfo)
}
*/

func HttpError(res *restful.Response, code int, format string, a ...interface{}) error <span class="cov0" title="0">{
        msg := fmt.Sprintf(format, a...)
        res.WriteError(code, errors.New(msg))
        errInfo := fmt.Sprintf("Code:%d, Reason:%s", code, msg)
        log.Error(errInfo)
        return fmt.Errorf(errInfo)
}</span>

// Volume group error
type NotImplementError struct {
        S string
}

func (e *NotImplementError) Error() string <span class="cov0" title="0">{
        return e.S
}</span>

type NotFoundError struct {
        S string
}

func NewNotFoundError(msg string) error <span class="cov0" title="0">{
        return &amp;NotFoundError{S: msg}
}</span>

func (e *NotFoundError) Error() string <span class="cov0" title="0">{
        return e.S
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may
// not use this file except in compliance with the License. You may obtain
// a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations
// under the License.

package policy

import (
        "fmt"
        "reflect"
        "regexp"
        "strings"

        log "github.com/sirupsen/logrus"
        "github.com/soda/multi-cloud/api/pkg/utils"
)

func init() <span class="cov8" title="1">{
        registerAll()
}</span>

type NewCheckFunc func(kind string, match string) BaseCheck

var registeredChecks map[string]NewCheckFunc

func register(name string, f NewCheckFunc) <span class="cov8" title="1">{
        registeredChecks[name] = f
}</span>

func registerAll() <span class="cov8" title="1">{
        if registeredChecks == nil </span><span class="cov8" title="1">{
                registeredChecks = make(map[string]NewCheckFunc)
        }</span>
        <span class="cov8" title="1">register("rule", NewRuleCheck)
        register("role", NewRoleCheck)
        register("generic", NewGenericCheck)</span>
}

type BaseCheck interface {
        String() string
        Exec(target map[string]string, cred map[string]interface{}, enforcer Enforcer, currentRule string) bool
}

func check(rule BaseCheck,
        target map[string]string,
        cred map[string]interface{},
        enforcer Enforcer,
        currentRule string) bool <span class="cov8" title="1">{
        ret := rule.Exec(target, cred, enforcer, currentRule)
        log.Infof("check rules:%s -- %v", rule, ret)
        return ret
}</span>

func NewFalseCheck() BaseCheck <span class="cov0" title="0">{
        return &amp;FalseCheck{}
}</span>

type FalseCheck struct{}

func (this *FalseCheck) String() string <span class="cov0" title="0">{
        return "!"
}</span>

func (this *FalseCheck) Exec(target map[string]string,
        cred map[string]interface{},
        enforcer Enforcer,
        currentRule string) bool <span class="cov0" title="0">{
        return false
}</span>

func NewTrueCheck() BaseCheck <span class="cov0" title="0">{
        return &amp;TrueCheck{}
}</span>

type TrueCheck struct {
        rule string
}

func (this *TrueCheck) String() string <span class="cov8" title="1">{
        return "@"
}</span>

func (this *TrueCheck) Exec(target map[string]string,
        cred map[string]interface{},
        enforcer Enforcer,
        currentRule string) bool <span class="cov8" title="1">{
        return true
}</span>

func NewNotCheck(check BaseCheck) *NotCheck <span class="cov0" title="0">{
        return &amp;NotCheck{check}
}</span>

type NotCheck struct {
        rule BaseCheck
}

func (this *NotCheck) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("not %s", this.rule)
}</span>

func (this *NotCheck) Exec(target map[string]string,
        cred map[string]interface{},
        enforcer Enforcer,
        currentRule string) bool <span class="cov0" title="0">{
        return !check(this.rule, target, cred, enforcer, currentRule)
}</span>

func NewAndCheck(check1 BaseCheck, check2 BaseCheck) *AndCheck <span class="cov8" title="1">{
        ac := &amp;AndCheck{}
        ac.AddCheck(check1)
        ac.AddCheck(check2)
        return ac
}</span>

type AndCheck struct {
        rules []BaseCheck
}

func (this *AndCheck) String() string <span class="cov0" title="0">{
        var r []string
        for _, rule := range this.rules </span><span class="cov0" title="0">{
                r = append(r, rule.String())
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("(%s)", strings.Join(r, " and "))</span>
}

func (this *AndCheck) Exec(target map[string]string,
        cred map[string]interface{},
        enforcer Enforcer,
        currentRule string) bool <span class="cov0" title="0">{
        for _, rule := range this.rules </span><span class="cov0" title="0">{
                if !check(rule, target, cred, enforcer, currentRule) </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov0" title="0">return true</span>
}

func (this *AndCheck) AddCheck(rule BaseCheck) *AndCheck <span class="cov8" title="1">{
        this.rules = append(this.rules, rule)
        return this
}</span>

func NewOrCheck(check1 BaseCheck, check2 BaseCheck) *OrCheck <span class="cov8" title="1">{
        oc := &amp;OrCheck{}
        oc.AddCheck(check1)
        oc.AddCheck(check2)
        return oc
}</span>

type OrCheck struct {
        rules []BaseCheck
}

func (this *OrCheck) String() string <span class="cov0" title="0">{
        var r []string
        for _, rule := range this.rules </span><span class="cov0" title="0">{
                r = append(r, rule.String())
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("(%s)", strings.Join(r, " or "))</span>
}

func (this *OrCheck) Exec(target map[string]string,
        cred map[string]interface{},
        enforcer Enforcer,
        currentRule string) bool <span class="cov0" title="0">{
        for _, rule := range this.rules </span><span class="cov0" title="0">{
                if check(rule, target, cred, enforcer, currentRule) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func (this *OrCheck) AddCheck(rule BaseCheck) *OrCheck <span class="cov8" title="1">{
        this.rules = append(this.rules, rule)
        return this
}</span>

func (this *OrCheck) PopCheck() (*OrCheck, BaseCheck) <span class="cov0" title="0">{
        x := this.rules[len(this.rules)-1]
        this.rules = this.rules[:len(this.rules)-1]
        return this, x
}</span>

func NewRuleCheck(kind string, match string) BaseCheck <span class="cov0" title="0">{
        return &amp;RuleCheck{kind, match}
}</span>

type RuleCheck struct {
        kind  string
        match string
}

func (this *RuleCheck) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("%s:%s", this.kind, this.match)
}</span>

func (this *RuleCheck) Exec(target map[string]string,
        cred map[string]interface{},
        enforcer Enforcer,
        currentRule string) bool <span class="cov0" title="0">{
        if len(enforcer.Rules) == 0 </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return check(enforcer.Rules[this.match], target, cred, enforcer, currentRule)</span>
}

func keyWorkFormatter(target map[string]string, match string) (string, error) <span class="cov0" title="0">{
        reg := regexp.MustCompile(`%([[:graph:]]+)s`)
        if ms := reg.FindAllString(match, -1); len(ms) == 1 </span><span class="cov0" title="0">{
                s := ms[0][2 : len(ms[0])-2]
                for key, val := range target </span><span class="cov0" title="0">{
                        if s == key </span><span class="cov0" title="0">{
                                return val, nil
                                break</span>
                        }
                }
                <span class="cov0" title="0">return "", fmt.Errorf("target key doesn`t match")</span>
        }
        <span class="cov0" title="0">return match, nil</span>
}

func NewRoleCheck(kind string, match string) BaseCheck <span class="cov8" title="1">{
        return &amp;RoleCheck{kind, match}
}</span>

type RoleCheck struct {
        kind  string
        match string
}

func (this *RoleCheck) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("%s:%s", this.kind, this.match)
}</span>

func (this *RoleCheck) Exec(target map[string]string,
        cred map[string]interface{},
        enforcer Enforcer,
        currentRule string) bool <span class="cov0" title="0">{
        match, err := keyWorkFormatter(target, this.match)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">if roles, ok := cred["roles"]; ok </span><span class="cov0" title="0">{
                for _, role := range roles.([]string) </span><span class="cov0" title="0">{
                        if strings.ToLower(match) == strings.ToLower(role) </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
        }
        <span class="cov0" title="0">return false</span>
}

func NewGenericCheck(kind string, match string) BaseCheck <span class="cov8" title="1">{
        return &amp;GenericCheck{kind, match}
}</span>

type GenericCheck struct {
        kind  string
        match string
}

func (this *GenericCheck) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("%s:%s", this.kind, this.match)
}</span>

func (this *GenericCheck) simpleLiteral(expr string) (string, error) <span class="cov0" title="0">{
        s := fmt.Sprintf("%c%c", expr[0], expr[len(expr)-1])
        if len(expr) &gt;= 2 &amp;&amp; (s == "\"\"" || s == "''") </span><span class="cov0" title="0">{
                return expr[1 : len(expr)-1], nil
        }</span>
        <span class="cov0" title="0">if utils.Contained(strings.ToLower(expr), []string{"true", "false"}) </span><span class="cov0" title="0">{
                return strings.ToLower(expr), nil
        }</span>
        <span class="cov0" title="0">return "", fmt.Errorf("Not support right now")</span>
}

func (this *GenericCheck) findInMap(testVal interface{}, pathSegs []string, match string) bool <span class="cov0" title="0">{
        if len(pathSegs) == 0 </span><span class="cov0" title="0">{
                switch testVal.(type) </span>{
                case string:<span class="cov0" title="0">
                        return strings.ToLower(match) == strings.ToLower(testVal.(string))</span>
                case bool:<span class="cov0" title="0">
                        return strings.ToLower(match) == fmt.Sprint(testVal.(bool))</span>
                default:<span class="cov0" title="0">
                        return false</span>
                }
        }
        <span class="cov0" title="0">key, pathSegs := pathSegs[0], pathSegs[1:]
        if val, ok := testVal.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                testVal = val[key]
        }</span> else<span class="cov0" title="0"> {
                return false
        }</span>
        <span class="cov0" title="0">if testVal == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">if reflect.TypeOf(testVal).Kind() == reflect.Slice </span><span class="cov0" title="0">{
                if vList, ok := testVal.([]interface{}); ok </span><span class="cov0" title="0">{
                        for _, val := range vList </span><span class="cov0" title="0">{
                                if this.findInMap(val, pathSegs, match) </span><span class="cov0" title="0">{
                                        return true
                                }</span>
                        }
                } else<span class="cov0" title="0"> {
                        for _, val := range testVal.([]string) </span><span class="cov0" title="0">{
                                if this.findInMap(val, pathSegs, match) </span><span class="cov0" title="0">{
                                        return true
                                }</span>
                        }
                }
                <span class="cov0" title="0">return false</span>
        } else<span class="cov0" title="0"> {
                return this.findInMap(testVal, pathSegs, match)
        }</span>
}

func (this *GenericCheck) Exec(target map[string]string,
        cred map[string]interface{},
        enforcer Enforcer,
        currentRule string) bool <span class="cov0" title="0">{
        match, err := keyWorkFormatter(target, strings.ToLower(this.match))
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">if test_value, err := this.simpleLiteral(this.kind); err == nil </span><span class="cov0" title="0">{
                return strings.ToLower(match) == test_value
        }</span>
        <span class="cov0" title="0">if len(cred) == 0 </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return this.findInMap(cred, strings.Split(this.kind, "."), match)</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may
// not use this file except in compliance with the License. You may obtain
// a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations
// under the License.

package policy

import (
        "fmt"
        "strings"

        "github.com/soda/multi-cloud/api/pkg/utils"
)

type TokenPair struct {
        token string
        value interface{}
}

func parseCheck(rule string) BaseCheck <span class="cov8" title="1">{
        if rule == "!" </span><span class="cov0" title="0">{
                return &amp;FalseCheck{}
        }</span> else<span class="cov8" title="1"> if rule == "@" </span><span class="cov0" title="0">{
                return &amp;TrueCheck{}
        }</span>
        <span class="cov8" title="1">items := strings.SplitN(rule, ":", 2)
        if len(items) != 2 </span><span class="cov0" title="0">{
                return &amp;FalseCheck{}
        }</span>
        <span class="cov8" title="1">kind, match := items[0], items[1]
        if check, ok := registeredChecks[kind]; ok </span><span class="cov8" title="1">{
                return check(kind, match)
        }</span> else<span class="cov8" title="1"> if check, ok := registeredChecks["generic"]; ok </span><span class="cov8" title="1">{
                return check(kind, match)
        }</span> else<span class="cov0" title="0"> {
                return &amp;FalseCheck{}
        }</span>
}

func parseTokenize(rule string) []TokenPair <span class="cov8" title="1">{
        var tokPairs []TokenPair
        for _, tok := range strings.Fields(rule) </span><span class="cov8" title="1">{
                if tok == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">clean := strings.TrimLeft(tok, "(")
                for i := 0; i &lt; len(tok)-len(clean); i++ </span><span class="cov8" title="1">{
                        tokPairs = append(tokPairs, TokenPair{"(", "("})
                }</span>

                // If it was only parentheses, continue
                <span class="cov8" title="1">if clean == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">tok = clean
                // Handle trailing parens on the token
                clean = strings.TrimRight(tok, ")")
                trail := len(tok) - len(clean)
                lowered := strings.ToLower(clean)

                if utils.Contained(lowered, []string{"and", "or", "not"}) </span><span class="cov8" title="1">{
                        tokPairs = append(tokPairs, TokenPair{lowered, clean})
                }</span> else<span class="cov8" title="1"> if clean != "" </span><span class="cov8" title="1">{
                        s := fmt.Sprintf("%c%c", tok[0], tok[len(tok)-1])
                        if len(tok) &gt;= 2 &amp;&amp; (s == "\"\"" || s == "''") </span><span class="cov0" title="0">{
                                tokPairs = append(tokPairs, TokenPair{"string", tok[1 : len(tok)-1]})
                        }</span> else<span class="cov8" title="1"> {
                                tokPairs = append(tokPairs, TokenPair{"check", parseCheck(clean)})
                        }</span>
                }

                <span class="cov8" title="1">for i := 0; i &lt; trail; i++ </span><span class="cov8" title="1">{
                        tokPairs = append(tokPairs, TokenPair{")", ")"})
                }</span>
        }

        <span class="cov8" title="1">return tokPairs</span>
}

func parseRule(rule string) BaseCheck <span class="cov8" title="1">{
        if rule == "" </span><span class="cov8" title="1">{
                return &amp;TrueCheck{}
        }</span>
        <span class="cov8" title="1">state := NewParseState()
        tokPairs := parseTokenize(rule)
        for _, tp := range tokPairs </span><span class="cov8" title="1">{
                state.Shift(tp.token, tp.value)
        }</span>
        <span class="cov8" title="1">if result, err := state.Result(); err == nil </span><span class="cov8" title="1">{
                return result.(BaseCheck)
        }</span>
        <span class="cov0" title="0">return &amp;FalseCheck{}</span>
}

var ReduceFuncMap = map[string]ReduceFunc{
        "(,check,)":          wrapCheck,
        "(,and_expr,)":       wrapCheck,
        "(,or_expr,)":        wrapCheck,
        "check,and,check":    makeAndExpr,
        "or_expr,and,check":  mixOrAndExpr,
        "and_expr,and,check": extendAndExpr,
        "check,or,check":     makeOrExpr,
        "and_expr,or,check":  makeOrExpr,
        "or_expr,or,check":   extendOrExpr,
        "not,check":          makeNotExpr,
}

func NewParseState() *ParseState <span class="cov8" title="1">{
        return &amp;ParseState{}
}</span>

type ParseState struct {
        tokens []string
        values []interface{}
}

type ReduceFunc func(args ...interface{}) []TokenPair

func (p *ParseState) reduce() <span class="cov8" title="1">{
        tokenStr := strings.Join(p.tokens, ",")
        for key, fun := range ReduceFuncMap </span><span class="cov8" title="1">{
                if strings.HasSuffix(tokenStr, key) </span><span class="cov8" title="1">{
                        argNum := strings.Count(key, ",") + 1
                        argIdx := len(p.values) - argNum
                        args := p.values[argIdx:]
                        results := fun(args...)
                        p.tokens = append(p.tokens[:argIdx], results[0].token)
                        p.values = append(p.values[:argIdx], results[0].value)
                        p.reduce()
                }</span>
        }
}

func (p *ParseState) Shift(tok string, val interface{}) <span class="cov8" title="1">{
        p.tokens = append(p.tokens, tok)
        p.values = append(p.values, val)
        p.reduce()
}</span>

func (p *ParseState) Result() (interface{}, error) <span class="cov8" title="1">{
        if len(p.values) != 1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Could not parse rule")
        }</span>
        <span class="cov8" title="1">return p.values[0], nil</span>
}

func wrapCheck(args ...interface{}) []TokenPair <span class="cov8" title="1">{
        check := args[1].(BaseCheck)
        return []TokenPair{{"check", check}}
}</span>

func makeAndExpr(args ...interface{}) []TokenPair <span class="cov8" title="1">{
        check1 := args[0].(BaseCheck)
        check2 := args[2].(BaseCheck)
        return []TokenPair{{"and_expr", NewAndCheck(check1, check2)}}
}</span>

func mixOrAndExpr(args ...interface{}) []TokenPair <span class="cov0" title="0">{
        orExpr := args[0].(*OrCheck)
        check := args[2].(BaseCheck)
        var andExpr *AndCheck
        orExpr, check1 := orExpr.PopCheck()
        if v, ok := check1.(*AndCheck); ok </span><span class="cov0" title="0">{
                andExpr = v
                andExpr.AddCheck(check)
        }</span> else<span class="cov0" title="0"> {
                andExpr = NewAndCheck(check1, check)
        }</span>
        <span class="cov0" title="0">return []TokenPair{{"or_expr", orExpr.AddCheck(andExpr)}}</span>
}

func extendAndExpr(args ...interface{}) []TokenPair <span class="cov0" title="0">{
        andExpr := args[0].(*AndCheck)
        check2 := args[2].(BaseCheck)
        return []TokenPair{{"and_expr", andExpr.AddCheck(check2)}}
}</span>

func makeOrExpr(args ...interface{}) []TokenPair <span class="cov8" title="1">{
        check1 := args[0].(BaseCheck)
        check2 := args[2].(BaseCheck)
        return []TokenPair{{"or_expr", NewOrCheck(check1, check2)}}
}</span>

func extendOrExpr(args ...interface{}) []TokenPair <span class="cov8" title="1">{
        orExpr := args[0].(*OrCheck)
        check := args[2].(BaseCheck)
        return []TokenPair{{"or_expr", orExpr.AddCheck(check)}}
}</span>

func makeNotExpr(args ...interface{}) []TokenPair <span class="cov0" title="0">{
        return []TokenPair{{"check", NewNotCheck(args[1].(BaseCheck))}}
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may
// not use this file except in compliance with the License. You may obtain
// a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations
// under the License.

package policy

import (
        "encoding/json"
        "fmt"
        "io/ioutil"
        "net/http"
        "os"
        "strings"

        "github.com/emicklei/go-restful"
        log "github.com/sirupsen/logrus"
        "github.com/soda/multi-cloud/api/pkg/context"
        "github.com/soda/multi-cloud/api/pkg/model"
        "github.com/soda/multi-cloud/api/pkg/utils"
        "github.com/soda/multi-cloud/api/pkg/utils/constants"
)

var enforcer *Enforcer

func init() <span class="cov8" title="1">{
        enforcer = NewEnforcer(false)
        RegisterRules(enforcer)
        enforcer.LoadRules(false)
}</span>

type DefaultRule struct {
        Name     string
        CheckStr string
}

func listRules() []DefaultRule <span class="cov8" title="1">{
        return []DefaultRule{
                {Name: "context_is_admin", CheckStr: "role:admin"},
        }
}</span>

func RegisterRules(e *Enforcer) <span class="cov8" title="1">{
        e.RegisterDefaults(listRules())
}</span>

func NewEnforcer(overWrite bool) *Enforcer <span class="cov8" title="1">{
        return &amp;Enforcer{OverWrite: overWrite}
}</span>

type Enforcer struct {
        Rules        map[string]BaseCheck
        DefaultRules []DefaultRule
        OverWrite    bool
}

func (e *Enforcer) RegisterDefaults(rules []DefaultRule) <span class="cov8" title="1">{
        e.DefaultRules = rules
}</span>

func (e *Enforcer) Enforce(rule string, target map[string]string, cred map[string]interface{}) (bool, error) <span class="cov8" title="1">{
        if err := e.LoadRules(false); err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov8" title="1">toRule, ok := e.Rules[rule]
        if !ok </span><span class="cov0" title="0">{
                err := fmt.Errorf("rule [%s] does not exist", rule)
                return false, err
        }</span>
        <span class="cov8" title="1">return check(toRule, target, cred, *e, ""), nil</span>
}

func (e *Enforcer) Authorize(rule string, target map[string]string, cred map[string]interface{}) (bool, error) <span class="cov8" title="1">{
        return e.Enforce(rule, target, cred)
}</span>

func (e *Enforcer) LoadRules(forcedReload bool) error <span class="cov8" title="1">{
        path := os.Getenv("POLICY_PATH")
        if path == "" </span><span class="cov8" title="1">{
                path = constants.DefaultPolicyPath
        }</span>

        <span class="cov8" title="1">fileInfo, err := os.Stat(path)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // Load all policy files that in the specified path
        <span class="cov8" title="1">if fileInfo.IsDir() </span><span class="cov0" title="0">{
                files, err := ioutil.ReadDir(path)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">for _, f := range files </span><span class="cov0" title="0">{
                        if !f.IsDir() &amp;&amp; strings.HasSuffix(f.Name(), ".json") </span><span class="cov0" title="0">{
                                err := e.LoadPolicyFile(path, forcedReload, false)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                }
                <span class="cov0" title="0">return nil</span>
        } else<span class="cov8" title="1"> {
                return e.LoadPolicyFile(path, forcedReload, e.OverWrite)
        }</span>

}

func (e *Enforcer) UpdateRules(rules map[string]BaseCheck) <span class="cov8" title="1">{
        if e.Rules == nil </span><span class="cov8" title="1">{
                e.Rules = make(map[string]BaseCheck)
        }</span>
        <span class="cov8" title="1">for k, c := range rules </span><span class="cov8" title="1">{
                e.Rules[k] = c
        }</span>
}

func (e *Enforcer) LoadPolicyFile(path string, forcedReload bool, overWrite bool) error <span class="cov8" title="1">{
        // if rules is already set or user doesn't want to force reload, return it.
        if e.Rules != nil &amp;&amp; !forcedReload </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">data, err := ioutil.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                msg := fmt.Sprintf("read policy file (%s) failed, reason:(%v)", path, err)
                log.Infof(msg)
                return fmt.Errorf(msg)
        }</span>
        <span class="cov8" title="1">r, err := NewRules(data, e.DefaultRules)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if overWrite </span><span class="cov0" title="0">{
                e.Rules = r.Rules
        }</span> else<span class="cov8" title="1"> {
                e.UpdateRules(r.Rules)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func NewRules(data []byte, defaultRule []DefaultRule) (*Rules, error) <span class="cov8" title="1">{
        r := &amp;Rules{}
        err := r.Load(data, defaultRule)
        return r, err
}</span>

type Rules struct {
        Rules map[string]BaseCheck
}

func (r *Rules) Load(data []byte, defaultRules []DefaultRule) error <span class="cov8" title="1">{
        rulesMap := map[string]string{}
        err := json.Unmarshal(data, &amp;rulesMap)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf(err.Error())
                return err
        }</span>
        // add default value
        <span class="cov8" title="1">for _, r := range defaultRules </span><span class="cov8" title="1">{
                if v, ok := rulesMap[r.Name]; ok </span><span class="cov0" title="0">{
                        log.Errorf("policy rule (%s:%s) has conflict with default rule(%s:%s),abandon default value\n",
                                r.Name, v, r.Name, r.CheckStr)
                }</span> else<span class="cov8" title="1"> {
                        rulesMap[r.Name] = r.CheckStr
                }</span>
        }

        <span class="cov8" title="1">if r.Rules == nil </span><span class="cov8" title="1">{
                r.Rules = make(map[string]BaseCheck)
        }</span>
        <span class="cov8" title="1">for k, v := range rulesMap </span><span class="cov8" title="1">{
                r.Rules[k] = parseRule(v)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (r *Rules) String() string <span class="cov0" title="0">{
        b, _ := json.MarshalIndent(r.Rules, "", "  ")
        return string(b)
}</span>

func Authorize(req *restful.Request, res *restful.Response, action string) bool <span class="cov8" title="1">{
        if os.Getenv("OS_AUTH_AUTHSTRATEGY") != "keystone" </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov8" title="1">ctx := context.GetContext(req)
        credentials := ctx.ToPolicyValue()
        //TenantId := httpCtx.Input.Param(":tenantId")
        TenantId := req.PathParameter("tenantId")
        target := map[string]string{
                "tenant_id": TenantId,
        }
        log.Infof("Action: %v", action)
        log.Infof("Target: %v", target)
        log.Infof("policy-Credentials: %v", credentials)
        ok, err := enforcer.Authorize(action, target, credentials)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("authorize failed, %s", err)
        }</span>
        <span class="cov8" title="1">if !ok </span><span class="cov0" title="0">{
                model.HttpError(res, http.StatusForbidden, "Operation is not permitted")
        }</span> else<span class="cov8" title="1"> {
                ctx.IsAdmin = utils.Contained("admin", ctx.Roles)
        }</span>
        <span class="cov8" title="1">return ok</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package s3

import (
        "github.com/emicklei/go-restful"
        "github.com/soda/multi-cloud/api/pkg/common"
        pb "github.com/soda/multi-cloud/s3/proto"
        log "github.com/sirupsen/logrus"
)

func (s *APIService) AbortMultipartUpload(request *restful.Request, response *restful.Response) <span class="cov0" title="0">{
        bucketName := request.PathParameter("bucketName")
        objectKey := request.PathParameter("objectKey")
        uploadId := request.QueryParameter("uploadId")

        multipartUpload := pb.MultipartUpload{}
        multipartUpload.Key = objectKey
        multipartUpload.Bucket = bucketName
        multipartUpload.UploadId = uploadId

        ctx := common.InitCtxWithAuthInfo(request)
        result, err := s.s3Client.AbortMultipartUpload(ctx, &amp;pb.AbortMultipartRequest{BucketName:bucketName,ObjectKey:objectKey,UploadId:uploadId})
        if HandleS3Error(response, request, err, result.GetErrorCode()) != nil </span><span class="cov0" title="0">{
                log.Errorf("unable to abort multipart. err:%v, errCode:%v", err, result.ErrorCode)
                return
        }</span>

        <span class="cov0" title="0">WriteSuccessNoContent(response)
        log.Infof("Abort multipart upload[bucketName=%s, objectKey=%s, uploadId=%s] successfully.\n",
                bucketName, objectKey, uploadId)</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package s3

import (
        "net/http"

        "github.com/emicklei/go-restful"
        "github.com/soda/multi-cloud/api/pkg/common"
        . "github.com/soda/multi-cloud/api/pkg/s3/datatype"
)

func getAclFromHeader(request *restful.Request) (acl Acl, err error) <span class="cov8" title="1">{
        acl.CannedAcl = request.HeaderParameter(common.REQUEST_HEADER_ACL)
        if acl.CannedAcl == "" </span><span class="cov8" title="1">{
                acl.CannedAcl = "private"
        }</span>
        <span class="cov8" title="1">err = IsValidCannedAcl(acl)
        return</span>
}

func getAclFromFormValues(formValues map[string]string) (acl Acl, err error) <span class="cov0" title="0">{
        headerfiedFormValues := make(http.Header)
        for key := range formValues </span><span class="cov0" title="0">{
                headerfiedFormValues.Add(key, formValues[key])
        }</span>
        <span class="cov0" title="0">acl.CannedAcl = headerfiedFormValues.Get("acl")
        if acl.CannedAcl == "" </span><span class="cov0" title="0">{
                acl.CannedAcl = "private"
        }</span>
        <span class="cov0" title="0">err = IsValidCannedAcl(acl)
        return</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">/*
 * Minio Cloud Storage, (C) 2015 Minio, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package s3

import (
        "bytes"
        "encoding/xml"
        "net/http"
        "strconv"
        "time"

        "github.com/emicklei/go-restful"
        . "github.com/soda/multi-cloud/api/pkg/s3/datatype"
        "github.com/soda/multi-cloud/s3/pkg/meta/types"
        pb "github.com/soda/multi-cloud/s3/proto"
)

// Refer: https://docs.aws.amazon.com/AmazonS3/latest/API/RESTCommonResponseHeaders.html
var CommonS3ResponseHeaders = []string{"Content-Length", "Content-Type", "Connection", "Date", "ETag", "Server",
        "x-amz-delete-marker", "x-amz-id-2", "x-amz-request-id", "x-amz-version-id"}

// Encodes the response headers into XML format.
func EncodeResponse(response interface{}) []byte <span class="cov8" title="1">{
        var bytesBuffer bytes.Buffer
        bytesBuffer.WriteString(xml.Header)
        e := xml.NewEncoder(&amp;bytesBuffer)
        e.Encode(response)
        return bytesBuffer.Bytes()
}</span>

// Write object header
func SetObjectHeaders(response *restful.Response, object *pb.Object, contentRange *HttpRange) <span class="cov0" title="0">{
        // set object-related metadata headers
        w := response.ResponseWriter
        lastModified := time.Unix(object.LastModified, 0).UTC().Format(http.TimeFormat)
        response.ResponseWriter.Header().Set("Last-Modified", lastModified)

        w.Header().Set("Content-Type", object.ContentType)
        if object.Etag != "" </span><span class="cov0" title="0">{
                w.Header()["ETag"] = []string{"\"" + object.Etag + "\""}
        }</span>

        <span class="cov0" title="0">for key, val := range object.CustomAttributes </span><span class="cov0" title="0">{
                w.Header().Set(key, val)
        }</span>
        //default cache-control is no-store
        <span class="cov0" title="0">if _, ok := object.CustomAttributes["Cache-Control"]; !ok </span><span class="cov0" title="0">{
                w.Header().Set("Cache-Control", "no-store")
        }</span>

        <span class="cov0" title="0">w.Header().Set("X-Amz-Object-Type", (&amp;types.Object{Object: object}).ObjectTypeToString())
        w.Header().Set("X-Amz-Storage-Class", object.StorageClass)
        w.Header().Set("Content-Length", strconv.FormatInt(object.Size, 10))

        // for providing ranged content
        if contentRange != nil &amp;&amp; contentRange.OffsetBegin &gt; -1 </span><span class="cov0" title="0">{
                // Override content-length
                w.Header().Set("Content-Length", strconv.FormatInt(contentRange.GetLength(), 10))
                w.Header().Set("Content-Range", contentRange.String())
                w.WriteHeader(http.StatusPartialContent)
        }</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">/*
 * Minio Cloud Storage, (C) 2015, 2016 Minio, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package s3

import (
        "encoding/xml"
        "net/http"
        "net/url"
        "path"
        "strconv"
        "time"

        "github.com/emicklei/go-restful"
        . "github.com/soda/multi-cloud/api/pkg/s3/datatype"
        . "github.com/soda/multi-cloud/s3/error"
        "github.com/soda/multi-cloud/s3/pkg/helper"
        log "github.com/sirupsen/logrus"
)

const (
        timeFormatAMZ = "2006-01-02T15:04:05.000Z" // Reply date format
)

func GetFinalError(err error, errorCode int32) error <span class="cov0" title="0">{
        if errorCode != int32(ErrNoErr) </span><span class="cov0" title="0">{
                return S3ErrorCode(errorCode)
        }</span> else<span class="cov0" title="0"> {
                return err
        }</span>
}

// WriteSuccessResponse write success headers and response if any.
func WriteSuccessResponse(response *restful.Response, data []byte) <span class="cov8" title="1">{
        if data == nil </span><span class="cov8" title="1">{
                response.WriteHeader(http.StatusOK)
                return
        }</span>

        <span class="cov8" title="1">response.AddHeader("Content-Length", strconv.Itoa(len(data)))
        response.WriteHeader(http.StatusOK)
        response.Write(data)
        response.Flush()</span>
}

// writeErrorResponse write error headers
// w http.ResponseWriter, r *http.Request
func WriteErrorResponse(response *restful.Response, request *restful.Request, err error) <span class="cov8" title="1">{
        WriteErrorResponseHeaders(response, err)
        WriteErrorResponseNoHeader(response, request, err, request.Request.URL.Path)
}</span>

func WriteErrorResponseWithResource(response *restful.Response, request *restful.Request, err error, resource string) <span class="cov0" title="0">{
        WriteErrorResponseHeaders(response, err)
        WriteErrorResponseNoHeader(response, request, err, resource)
}</span>

func WriteErrorResponseHeaders(response *restful.Response, err error) <span class="cov8" title="1">{
        var status int
        apiErrorCode, ok := err.(S3Error)
        if ok </span><span class="cov8" title="1">{
                status = apiErrorCode.HttpStatusCode()
        }</span> else<span class="cov0" title="0"> {
                status = http.StatusInternalServerError
        }</span>

        <span class="cov8" title="1">response.WriteHeader(status)</span>
}

func WriteErrorResponseNoHeader(response *restful.Response, request *restful.Request, err error, resource string) <span class="cov8" title="1">{
        // HEAD should have no body, do not attempt to write to it
        if request.Request.Method == "HEAD" </span><span class="cov0" title="0">{
                return
        }</span>

        // Generate error response.
        <span class="cov8" title="1">errorResponse := ApiErrorResponse{}
        apiErrorCode, ok := err.(S3Error)
        if ok </span><span class="cov8" title="1">{
                errorResponse.AwsErrorCode = apiErrorCode.AwsErrorCode()
                errorResponse.Message = apiErrorCode.Description()
        }</span> else<span class="cov0" title="0"> {
                errorResponse.AwsErrorCode = "InternalError"
                errorResponse.Message = "We encountered an internal error, please try again."
        }</span>
        <span class="cov8" title="1">errorResponse.Resource = resource
        errorResponse.HostId = helper.CONFIG.InstanceId

        encodedErrorResponse := EncodeResponse(errorResponse)

        response.Write(encodedErrorResponse)
        response.ResponseWriter.(http.Flusher).Flush()</span>
}

// getLocation get URL location.
func GetLocation(r *http.Request) string <span class="cov8" title="1">{
        return path.Clean(r.URL.Path) // Clean any trailing slashes.
}</span>

// writeSuccessNoContent write success headers with http status 204
func WriteSuccessNoContent(response *restful.Response) <span class="cov0" title="0">{
        response.ResponseWriter.WriteHeader(http.StatusNoContent)
}</span>

func WriteApiErrorResponse(response *restful.Response, request *restful.Request, status int, awsErrCode, message string) <span class="cov0" title="0">{
        // write header
        response.WriteHeader(status)

        // HEAD should have no body, do not attempt to write to it
        if request.Request.Method == "HEAD" </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">errorResponse := ApiErrorResponse{}
        errorResponse.AwsErrorCode = awsErrCode
        errorResponse.Message = message
        errorResponse.Resource = request.Request.URL.Path
        errorResponse.HostId = helper.CONFIG.InstanceId

        encodedErrorResponse := EncodeResponse(errorResponse)

        response.Write(encodedErrorResponse)
        response.ResponseWriter.(http.Flusher).Flush()</span>
}

// GenerateCopyObjectResponse
func GenerateCopyObjectResponse(etag string, lastModified time.Time) CopyObjectResponse <span class="cov0" title="0">{
        return CopyObjectResponse{
                ETag:         "\"" + etag + "\"",
                LastModified: lastModified.UTC().Format(timeFormatAMZ),
        }
}</span>

func GenerateCopyObjectPartResponse(etag string, lastModified int64) CopyObjectPartResponse <span class="cov0" title="0">{
        return CopyObjectPartResponse{
                LastModified: time.Unix(lastModified, 0).UTC().Format(timeFormatAMZ),
                ETag:         "\"" + etag + "\"",
        }
}</span>

// GenerateInitiateMultipartUploadResponse
func GenerateInitiateMultipartUploadResponse(bucket, key, uploadID string) InitiateMultipartUploadResponse <span class="cov0" title="0">{
        return InitiateMultipartUploadResponse{
                Bucket:   bucket,
                Key:      key,
                UploadID: uploadID,
        }
}</span>

// GenerateCompleteMultipartUploadResponse
func GenerateCompleteMultipartUploadResponse(bucket, key, location, etag string) CompleteMultipartUploadResponse <span class="cov0" title="0">{
        return CompleteMultipartUploadResponse{
                Location: location,
                Bucket:   bucket,
                Key:      key,
                ETag:     etag,
        }
}</span>

// APIErrorResponse - error response format
type ApiErrorResponse struct {
        XMLName      xml.Name `xml:"Error" json:"-"`
        AwsErrorCode string   `xml:"Code"`
        Message      string
        Key          string
        BucketName   string
        Resource     string
        RequestId    string
        HostId       string
}

// Parse bucket url queries for ?uploads
func parseListUploadsQuery(query url.Values) (request ListUploadsRequest, err error) <span class="cov0" title="0">{
        request.Delimiter = query.Get("delimiter")
        request.EncodingType = query.Get("encoding-type")
        if query.Get("max-uploads") == "" </span><span class="cov0" title="0">{
                request.MaxUploads = MaxUploadsList
        }</span> else<span class="cov0" title="0"> {
                request.MaxUploads, err = strconv.Atoi(query.Get("max-uploads"))
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">if request.MaxUploads &gt; MaxUploadsList || request.MaxUploads &lt; 1 </span><span class="cov0" title="0">{
                        err = ErrInvalidMaxUploads
                        return
                }</span>
        }
        <span class="cov0" title="0">request.KeyMarker = query.Get("key-marker")
        request.Prefix = query.Get("prefix")
        request.UploadIdMarker = query.Get("upload-id-marker")
        return</span>
}

// Parse object url queries
func parseListObjectPartsQuery(query url.Values) (request ListPartsRequest, err error) <span class="cov0" title="0">{
        request.EncodingType = query.Get("encoding-type")
        request.UploadId = query.Get("uploadId")
        if request.UploadId == "" </span><span class="cov0" title="0">{
                err = ErrNoSuchUpload
                return
        }</span>
        <span class="cov0" title="0">if query.Get("max-parts") == "" </span><span class="cov0" title="0">{
                request.MaxParts = MaxPartsList
        }</span> else<span class="cov0" title="0"> {
                request.MaxParts, err = strconv.Atoi(query.Get("max-parts"))
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorln("failed to convert from string to integer. err:", err)
                        return
                }</span>
                <span class="cov0" title="0">if request.MaxParts &gt; MaxPartsList || request.MaxParts &lt; 1 </span><span class="cov0" title="0">{
                        err = ErrInvalidMaxParts
                        return
                }</span>
        }
        <span class="cov0" title="0">if query.Get("part-number-marker") != "" </span><span class="cov0" title="0">{
                request.PartNumberMarker, err = strconv.Atoi(query.Get("part-number-marker"))
                if err != nil </span><span class="cov0" title="0">{
                        err = ErrInvalidPartNumberMarker
                        return
                }</span>
                <span class="cov0" title="0">if request.PartNumberMarker &lt; 0 </span><span class="cov0" title="0">{
                        err = ErrInvalidPartNumberMarker
                        return
                }</span>
        }
        <span class="cov0" title="0">return</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package s3

import (
        "encoding/xml"
        "io"
        "io/ioutil"
        "strings"

        "github.com/emicklei/go-restful"
        "github.com/journeymidnight/yig/helper"
        "github.com/soda/multi-cloud/api/pkg/common"
        "github.com/soda/multi-cloud/api/pkg/s3/datatype"
        s3error "github.com/soda/multi-cloud/s3/error"
        pb "github.com/soda/multi-cloud/s3/proto"
        log "github.com/sirupsen/logrus"
)

func (s *APIService) BucketAclPut(request *restful.Request, response *restful.Response) <span class="cov0" title="0">{
        bucketName := strings.ToLower(request.PathParameter(common.REQUEST_PATH_BUCKET_NAME))
        log.Infof("received request: PUT bucket[name=%s] acl\n", bucketName)

        var err error
        var acl datatype.Acl
        var policy datatype.AccessControlPolicy
        if _, ok := request.Request.Header[common.REQUEST_HEADER_ACL]; ok </span><span class="cov0" title="0">{
                acl, err = getAclFromHeader(request)
                if err != nil </span><span class="cov0" title="0">{
                        WriteErrorResponse(response, request, err)
                        return
                }</span>
        } else<span class="cov0" title="0"> {
                // because we only support canned acl, the body of request must be not too big, and 1024 is enough
                aclBuffer, err := ioutil.ReadAll(io.LimitReader(request.Request.Body, 1024))
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("unable to read acls body, err:", err)
                        WriteErrorResponse(response, request, s3error.ErrInvalidAcl)
                        return
                }</span>
                <span class="cov0" title="0">err = xml.Unmarshal(aclBuffer, &amp;policy)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("unable to parse acls xml body, err:", err)
                        WriteErrorResponse(response, request, s3error.ErrInternalError)
                        return
                }</span>
        }

        <span class="cov0" title="0">if acl.CannedAcl == "" </span><span class="cov0" title="0">{
                newCannedAcl, err := datatype.GetCannedAclFromPolicy(policy)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error("failed to get canned acl from policy. err:", err)
                        WriteErrorResponse(response, request, err)
                        return
                }</span>
                <span class="cov0" title="0">acl = newCannedAcl</span>
        }

        <span class="cov0" title="0">ctx := common.InitCtxWithAuthInfo(request)
        res, err := s.s3Client.PutBucketACL(ctx, &amp;pb.PutBucketACLRequest{ACLConfig: &amp;pb.BucketACL{BucketName: bucketName, CannedAcl: acl.CannedAcl}})
        if err != nil || res.ErrorCode != int32(s3error.ErrNoErr) </span><span class="cov0" title="0">{
                WriteErrorResponse(response, request, GetFinalError(err, res.ErrorCode))
                return
        }</span>

        <span class="cov0" title="0">log.Infoln("PUT bucket acl successfully.")
        WriteSuccessResponse(response, nil)</span>
}

func (s *APIService) BucketAclGet(request *restful.Request, response *restful.Response) <span class="cov8" title="1">{
        bucketName := strings.ToLower(request.PathParameter(common.REQUEST_PATH_BUCKET_NAME))
        log.Infof("received request: GET bucket[name=%s] acl\n", bucketName)

        ctx := common.InitCtxWithAuthInfo(request)
        bucket, err := s.getBucketMeta(ctx, bucketName)
        if err != nil </span><span class="cov0" title="0">{
                log.Error("failed to get bucket[%s] acl policy for bucket", bucketName)
                WriteErrorResponse(response, request, err)
                return
        }</span>

        <span class="cov8" title="1">owner := datatype.Owner{ID: bucket.TenantId, DisplayName: bucket.TenantId}
        bucketOwner := datatype.Owner{}
        policy, err := datatype.CreatePolicyFromCanned(owner, bucketOwner, datatype.Acl{CannedAcl: bucket.Acl.CannedAcl})
        if err != nil </span><span class="cov0" title="0">{
                log.Error("failed to create policy. err:", err)
                WriteErrorResponse(response, request, err)
                return
        }</span>

        <span class="cov8" title="1">aclBuffer, err := xmlFormat(policy)
        if err != nil </span><span class="cov0" title="0">{
                helper.ErrorIf(err, "failed to marshal acl XML for bucket", bucketName)
                WriteErrorResponse(response, request, s3error.ErrInternalError)
                return
        }</span>

        <span class="cov8" title="1">setXmlHeader(response, aclBuffer)
        WriteSuccessResponse(response, aclBuffer)
        log.Infoln("GET bucket acl successfully.")</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package s3

import (
        "github.com/emicklei/go-restful"
        "github.com/soda/multi-cloud/api/pkg/common"
        "github.com/soda/multi-cloud/s3/proto"
        log "github.com/sirupsen/logrus"
)

func (s *APIService) BucketDelete(request *restful.Request, response *restful.Response) <span class="cov0" title="0">{
        bucketName := request.PathParameter("bucketName")
        log.Infof("Received request for deleting bucket[name=%s].\n", bucketName)

        ctx := common.InitCtxWithAuthInfo(request)
        rsp, err := s.s3Client.DeleteBucket(ctx, &amp;s3.Bucket{Name: bucketName})
        if HandleS3Error(response, request, err, rsp.GetErrorCode()) != nil </span><span class="cov0" title="0">{
                log.Errorf("delete bucket[%s] failed, err=%v, errCode=%d\n", bucketName, err, rsp.ErrorCode)
                return
        }</span>

        <span class="cov0" title="0">log.Infof("delete bucket[%s] successfully\n", bucketName)</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package s3

import (
        "net/url"
        "strconv"
        "time"
        "unicode/utf8"

        "github.com/emicklei/go-restful"
        "github.com/soda/multi-cloud/api/pkg/common"
        "github.com/soda/multi-cloud/api/pkg/s3/datatype"
        "github.com/soda/multi-cloud/api/pkg/utils/constants"
        . "github.com/soda/multi-cloud/s3/error"
        "github.com/soda/multi-cloud/s3/pkg/helper"
        "github.com/soda/multi-cloud/s3/pkg/utils"
        "github.com/soda/multi-cloud/s3/proto"
        log "github.com/sirupsen/logrus"
)

func (s *APIService) BucketGet(request *restful.Request, response *restful.Response) <span class="cov8" title="1">{
        bucketName := request.PathParameter("bucketName")
        log.Infof("Received request for bucket details: %s\n", bucketName)

        var err error
        req, err := parseListObjectsQuery(request.Request.URL.Query())
        if err != nil </span><span class="cov0" title="0">{
                WriteErrorResponse(response, request, err)
                return
        }</span>
        <span class="cov8" title="1">req.Bucket = bucketName

        ctx := common.InitCtxWithAuthInfo(request)
        lsRsp, err := s.s3Client.ListObjects(ctx, &amp;req)
        if HandleS3Error(response, request, err, lsRsp.GetErrorCode()) != nil </span><span class="cov0" title="0">{
                log.Errorf("get bucket[%s] failed, err=%v, errCode=%d\n", bucketName, err, lsRsp.ErrorCode)
                return
        }</span>

        <span class="cov8" title="1">rsp := CreateListObjectsResponse(bucketName, &amp;req, lsRsp)
        log.Debugf("rsp:%+v\n", rsp)
        // Write success response.
        response.WriteEntity(rsp)

        return</span>
}

func parseListObjectsQuery(query url.Values) (request s3.ListObjectsRequest, err error) <span class="cov8" title="1">{
        if query.Get("list-type") == constants.ListObjectsType2Str </span><span class="cov0" title="0">{
                request.Version = constants.ListObjectsType2Int
                request.ContinuationToken = query.Get("continuation-token")
                request.StartAfter = query.Get("start-after")
                if !utf8.ValidString(request.StartAfter) </span><span class="cov0" title="0">{
                        err = ErrNonUTF8Encode
                        return
                }</span>
                <span class="cov0" title="0">request.FetchOwner = helper.Ternary(query.Get("fetch-owner") == "true",
                        true, false).(bool)</span>
        } else<span class="cov8" title="1"> {
                request.Version = constants.ListObjectsType1Int
                request.Marker = query.Get("marker")
                if !utf8.ValidString(request.Marker) </span><span class="cov0" title="0">{
                        err = ErrNonUTF8Encode
                        return
                }</span>
        }
        <span class="cov8" title="1">request.Delimiter = query.Get("delimiter")
        if !utf8.ValidString(request.Delimiter) </span><span class="cov0" title="0">{
                err = ErrNonUTF8Encode
                return
        }</span>
        <span class="cov8" title="1">request.EncodingType = query.Get("encoding-type")
        if request.EncodingType != "" &amp;&amp; request.EncodingType != "url" </span><span class="cov0" title="0">{
                err = ErrInvalidEncodingType
                return
        }</span>
        <span class="cov8" title="1">if query.Get("max-keys") == "" </span><span class="cov8" title="1">{
                request.MaxKeys = utils.MaxObjectList
        }</span> else<span class="cov0" title="0"> {
                var maxKey int
                maxKey, err = strconv.Atoi(query.Get("max-keys"))
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("parsing max-keys error:%v\n", err)
                        return request, ErrInvalidMaxKeys
                }</span>
                <span class="cov0" title="0">request.MaxKeys = int32(maxKey)
                if request.MaxKeys &gt; utils.MaxObjectList || request.MaxKeys &lt; 1 </span><span class="cov0" title="0">{
                        err = ErrInvalidMaxKeys
                        return
                }</span>
        }
        <span class="cov8" title="1">request.Prefix = query.Get("prefix")
        if !utf8.ValidString(request.Prefix) </span><span class="cov0" title="0">{
                err = ErrNonUTF8Encode
                return
        }</span>

        <span class="cov8" title="1">request.KeyMarker = query.Get("key-marker")
        if !utf8.ValidString(request.KeyMarker) </span><span class="cov0" title="0">{
                err = ErrNonUTF8Encode
                return
        }</span>
        <span class="cov8" title="1">request.VersionIdMarker = query.Get("version-id-marker")
        if !utf8.ValidString(request.VersionIdMarker) </span><span class="cov0" title="0">{
                err = ErrNonUTF8Encode
                return
        }</span>

        <span class="cov8" title="1">log.Infof("request:%+v\n", request)
        return</span>
}

// this function refers to GenerateListObjectsResponse in api-response.go from Minio Cloud Storage.
func CreateListObjectsResponse(bucketName string, request *s3.ListObjectsRequest,
        listRsp *s3.ListObjectsResponse) (response datatype.ListObjectsResponse) <span class="cov8" title="1">{
        for _, o := range listRsp.Objects </span><span class="cov8" title="1">{
                obj := datatype.Object{
                        Key:          o.ObjectKey,
                        LastModified: time.Unix(o.LastModified, 0).In(time.Local).Format(timeFormatAMZ),
                        ETag:         o.Etag,
                        Size:         o.Size,
                        StorageClass: o.StorageClass,
                        Location:     o.Location,
                        Tier:         o.Tier,
                }
                if request.EncodingType != "" </span><span class="cov0" title="0">{ // only support "url" encoding for now
                        obj.Key = url.QueryEscape(obj.Key)
                }</span>
                <span class="cov8" title="1">if request.FetchOwner </span><span class="cov0" title="0">{
                        obj.Owner.ID = o.TenantId //TODO: DisplayName
                }</span>
                <span class="cov8" title="1">response.Contents = append(response.Contents, obj)</span>
        }

        <span class="cov8" title="1">var prefixes []datatype.CommonPrefix
        for _, prefix := range listRsp.Prefixes </span><span class="cov0" title="0">{
                item := datatype.CommonPrefix{
                        Prefix: prefix,
                }
                prefixes = append(prefixes, item)
        }</span>
        <span class="cov8" title="1">response.CommonPrefixes = prefixes

        response.Delimiter = request.Delimiter
        response.EncodingType = request.EncodingType
        response.IsTruncated = listRsp.IsTruncated
        response.MaxKeys = int(request.MaxKeys)
        response.Prefix = request.Prefix
        response.BucketName = bucketName

        if request.Version == constants.ListObjectsType2Int </span><span class="cov0" title="0">{
                response.KeyCount = len(response.Contents)
                response.ContinuationToken = request.ContinuationToken
                response.NextContinuationToken = listRsp.NextMarker
                response.StartAfter = request.StartAfter
        }</span> else<span class="cov8" title="1"> { // version 1
                response.Marker = request.Marker
                response.NextMarker = listRsp.NextMarker
        }</span>

        <span class="cov8" title="1">if request.EncodingType != "" </span><span class="cov0" title="0">{
                response.Delimiter = url.QueryEscape(response.Delimiter)
                response.Prefix = url.QueryEscape(response.Prefix)
                response.StartAfter = url.QueryEscape(response.StartAfter)
                response.Marker = url.QueryEscape(response.Marker)
        }</span>

        <span class="cov8" title="1">return</span>
}

func (s *APIService) HeadBucket(request *restful.Request, response *restful.Response) <span class="cov0" title="0">{
        bucketName := request.PathParameter("bucketName")
        log.Infof("Received request for head bucket: %s\n", bucketName)

        var err error

        ctx := common.InitCtxWithAuthInfo(request)
        _, err = s.getBucketMeta(ctx, bucketName)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("get bucket[%s] failed, err=%v\n", bucketName, err)
                WriteErrorResponse(response, request, err)
                return
        }</span>

        <span class="cov0" title="0">log.Debugln("head bucket succeed")
        WriteSuccessResponse(response, nil)</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package s3

import (
        "github.com/emicklei/go-restful"
        "github.com/soda/multi-cloud/api/pkg/common"
        "github.com/soda/multi-cloud/s3/proto"
        log "github.com/sirupsen/logrus"
)

func (s *APIService) BucketLifecycleDelete(request *restful.Request, response *restful.Response) <span class="cov0" title="0">{
        bucketName := request.PathParameter("bucketName")
        log.Infof("received request for creating lifecycle of bucket: %s", bucketName)

        ctx := common.InitCtxWithAuthInfo(request)
        rsp, err := s.s3Client.DeleteBucketLifecycle(ctx, &amp;s3.BaseRequest{Id: bucketName})
        log.Infof("rsp:%s, err:%v\n", rsp, err)
        if HandleS3Error(response, request, err, rsp.GetErrorCode()) != nil </span><span class="cov0" title="0">{
                log.Errorf("delete bucket[%s] lifecycle failed, err=%v, errCode=%d\n", bucketName, err, rsp.ErrorCode)
                return
        }</span>

        <span class="cov0" title="0">log.Info("delete bucket lifecycle end.")</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package s3

import (
        "fmt"
        "github.com/emicklei/go-restful"
        "github.com/soda/multi-cloud/api/pkg/common"
        . "github.com/soda/multi-cloud/api/pkg/utils/constants"
        . "github.com/soda/multi-cloud/s3/error"
        "github.com/soda/multi-cloud/s3/pkg/model"
        "github.com/soda/multi-cloud/s3/proto"
        log "github.com/sirupsen/logrus"
)

//Convert function from storage tier to storage class for XML format output
func (s *APIService) tier2class(tier int32) (string, error) <span class="cov0" title="0">{
        </span><span class="cov0" title="0">{
                mutext.Lock()
                defer mutext.Unlock()
                if len(ClassAndTier) == 0 </span><span class="cov0" title="0">{
                        err := s.loadStorageClassDefinition()
                        if err != nil </span><span class="cov0" title="0">{
                                log.Errorf("load storage classes failed: %v.\n", err)
                                return "", err
                        }</span>
                }
        }
        <span class="cov0" title="0">className := ""
        for k, v := range ClassAndTier </span><span class="cov0" title="0">{
                if v == tier </span><span class="cov0" title="0">{
                        className = k
                }</span>
        }
        <span class="cov0" title="0">if className == "" </span><span class="cov0" title="0">{
                log.Infof("invalid tier: %d\n", tier)
                return "", fmt.Errorf(InvalidTier)
        }</span>
        <span class="cov0" title="0">return className, nil</span>
}

//Function for GET Bucket Lifecycle API
func (s *APIService) BucketLifecycleGet(request *restful.Request, response *restful.Response) <span class="cov8" title="1">{
        bucketName := request.PathParameter("bucketName")
        log.Infof("received request for bucket details in GET lifecycle: %s", bucketName)

        ctx := common.InitCtxWithAuthInfo(request)
        rsp, err := s.s3Client.GetBucketLifecycle(ctx, &amp;s3.BaseRequest{Id: bucketName})
        if HandleS3Error(response, request, err, rsp.GetErrorCode()) != nil </span><span class="cov8" title="1">{
                log.Errorf("get bucket[%s] lifecycle failed, err=%v, errCode=%d\n", bucketName, err, rsp.ErrorCode)
                return
        }</span>

        // convert back to xml struct
        <span class="cov0" title="0">lifecycleConfXml := model.LifecycleConfiguration{}

        // convert lifecycle rule to xml Rule
        for _, lcRule := range rsp.Lc </span><span class="cov0" title="0">{
                xmlRule := model.Rule{}

                xmlRule.Status = lcRule.Status
                xmlRule.ID = lcRule.Id
                xmlRule.Filter = converts3FilterToRuleFilter(lcRule.Filter)
                xmlRule.AbortIncompleteMultipartUpload = converts3UploadToRuleUpload(lcRule.AbortIncompleteMultipartUpload)
                xmlRule.Transition = make([]model.Transition, 0)

                //Arranging the transition and expiration actions in XML
                for _, action := range lcRule.Actions </span><span class="cov0" title="0">{
                        log.Infof("action is : %v\n", action)

                        if action.Name == ActionNameTransition </span><span class="cov0" title="0">{
                                xmlTransition := model.Transition{}
                                xmlTransition.Days = action.Days
                                xmlTransition.Backend = action.Backend
                                className, err := s.tier2class(action.Tier)
                                if err == nil </span><span class="cov0" title="0">{
                                        xmlTransition.StorageClass = className
                                }</span>
                                <span class="cov0" title="0">xmlRule.Transition = append(xmlRule.Transition, xmlTransition)</span>
                        }
                        <span class="cov0" title="0">if action.Name == ActionNameExpiration </span><span class="cov0" title="0">{
                                xmlExpiration := model.Expiration{}
                                xmlExpiration.Days = action.Days
                                xmlRule.Expiration = append(xmlRule.Expiration, xmlExpiration)
                        }</span>
                }
                // append each xml rule to xml array
                <span class="cov0" title="0">lifecycleConfXml.Rule = append(lifecycleConfXml.Rule, xmlRule)</span>
        }

        // marshall the array back to xml format
        <span class="cov0" title="0">err = response.WriteAsXml(lifecycleConfXml)
        if err != nil </span><span class="cov0" title="0">{
                log.Infof("write lifecycle of bucket[%s] as xml failed, lifecycle =%s, err=%v.\n", bucketName,
                        lifecycleConfXml, err)
                WriteErrorResponse(response, request, ErrInternalError)
                return
        }</span>

        <span class="cov0" title="0">log.Info("GET lifecycle succeed.")</span>
}

func converts3FilterToRuleFilter(filter *s3.LifecycleFilter) model.Filter <span class="cov0" title="0">{
        retFilter := model.Filter{}
        if filter != nil </span><span class="cov0" title="0">{
                retFilter.Prefix = filter.Prefix
        }</span>
        <span class="cov0" title="0">return retFilter</span>
}

func converts3UploadToRuleUpload(upload *s3.AbortMultipartUpload) model.AbortIncompleteMultipartUpload <span class="cov0" title="0">{
        retUpload := model.AbortIncompleteMultipartUpload{}
        if upload != nil </span><span class="cov0" title="0">{
                retUpload.DaysAfterInitiation = upload.DaysAfterInitiation
        }</span>
        <span class="cov0" title="0">return retUpload</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package s3

import (
        "crypto/md5"
        "encoding/xml"
        "fmt"
        "net/http"
        "sync"

        "github.com/emicklei/go-restful"
        "github.com/soda/multi-cloud/api/pkg/common"
        . "github.com/soda/multi-cloud/api/pkg/utils/constants"
        . "github.com/soda/multi-cloud/s3/error"
        "github.com/soda/multi-cloud/s3/pkg/model"
        "github.com/soda/multi-cloud/s3/pkg/utils"
        "github.com/soda/multi-cloud/s3/proto"
        log "github.com/sirupsen/logrus"
        "golang.org/x/net/context"
)

// Map from storage calss to tier
var ClassAndTier map[string]int32
var mutext sync.Mutex

func (s *APIService) loadStorageClassDefinition() error <span class="cov0" title="0">{
        ctx := context.Background()
        log.Info("Load storage classes.")
        res, err := s.s3Client.GetStorageClasses(ctx, &amp;s3.BaseRequest{})
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("get storage classes from s3 service failed: %v\n", err)
                return err
        }</span>
        <span class="cov0" title="0">ClassAndTier = make(map[string]int32)
        for _, v := range res.Classes </span><span class="cov0" title="0">{
                ClassAndTier[v.Name] = v.Tier
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (s *APIService) class2tier(name string) (int32, error) <span class="cov0" title="0">{
        </span><span class="cov0" title="0">{
                mutext.Lock()
                defer mutext.Unlock()
                if len(ClassAndTier) == 0 </span><span class="cov0" title="0">{
                        err := s.loadStorageClassDefinition()
                        if err != nil </span><span class="cov0" title="0">{
                                log.Errorf("load storage classes failed: %v.\n", err)
                                return 0, err
                        }</span>
                }
        }
        <span class="cov0" title="0">tier, ok := ClassAndTier[name]
        if !ok </span><span class="cov0" title="0">{
                log.Errorf("translate storage class name[%s] to tier failed: %s.\n", name)
                return 0, fmt.Errorf("invalid storage class:%s", name)
        }</span>
        <span class="cov0" title="0">log.Infof("class[%s] to tier[%d]\n", name, tier)
        return tier, nil</span>
}

func checkValidationOfActions(actions []*s3.Action) error <span class="cov0" title="0">{
        var pre *s3.Action = nil
        for _, action := range actions </span><span class="cov0" title="0">{
                log.Infof("action: %+v\n", *action)
                if pre == nil </span><span class="cov0" title="0">{
                        if action.Name == ActionNameExpiration &amp;&amp; action.Days &lt; ExpirationMinDays </span><span class="cov0" title="0">{
                                // If only an expiration action for a rule, the days for that action should be more than ExpirationMinDays
                                return fmt.Errorf(InvalidExpireDays, ExpirationMinDays)
                        }</span>
                        <span class="cov0" title="0">if action.Name == ActionNameTransition &amp;&amp; action.Days &lt; TransitionMinDays </span><span class="cov0" title="0">{
                                // the days for transition to tiers except tier999 should not less than TransitionMinDays
                                minDays := int32(TransitionMinDays)
                                if action.Tier == utils.Tier999 </span><span class="cov0" title="0">{
                                        // the days for transition to tier999 should not less than TransitionToArchiveMinDays
                                        minDays = TransitionToArchiveMinDays
                                }</span>
                                <span class="cov0" title="0">if action.Days &lt; minDays </span><span class="cov0" title="0">{
                                        return fmt.Errorf(InvalidTransistionDays, action.Tier, minDays)
                                }</span>

                        }
                } else<span class="cov0" title="0"> {
                        if pre.Name == ActionNameExpiration </span><span class="cov0" title="0">{
                                // Only one expiration action for each rule is supported
                                return fmt.Errorf(MoreThanOneExpirationAction)
                        }</span>

                        <span class="cov0" title="0">if action.Name == ActionNameExpiration &amp;&amp; pre.Days+ExpirationMinDays &gt; action.Days </span><span class="cov0" title="0">{
                                return fmt.Errorf(DaysInStorageClassBeforeExpiration)
                        }</span>

                        <span class="cov0" title="0">if action.Name == ActionNameTransition &amp;&amp; pre.Days+LifecycleTransitionDaysStep &gt; action.Days </span><span class="cov0" title="0">{
                                return fmt.Errorf(DaysInStorageClassBeforeTransition)
                        }</span>
                }
                <span class="cov0" title="0">pre = action</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (s *APIService) BucketLifecyclePut(request *restful.Request, response *restful.Response) <span class="cov0" title="0">{
        bucketName := request.PathParameter("bucketName")
        log.Infof("received request for creating lifecycle of bucket: %s", bucketName)

        ctx := common.InitCtxWithAuthInfo(request)
        _, err := s.getBucketMeta(ctx, bucketName)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("get bucket[%s] failed, err=%v\n", bucketName, err)
                WriteErrorResponse(response, request, err)
                return
        }</span>

        <span class="cov0" title="0">body := ReadBody(request)
        log.Infof("MD5 sum for body is %x", md5.Sum(body))
        if body == nil </span><span class="cov0" title="0">{
                log.Info("no request body provided for creating lifecycle configuration")
                WriteErrorResponse(response, request, S3ErrorCode(ErrInvalidLc))
                return
        }</span>

        <span class="cov0" title="0">createLifecycleConf := model.LifecycleConfiguration{}
        err = xml.Unmarshal(body, &amp;createLifecycleConf)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("unmarshal error:%v\n", err)
                WriteErrorResponse(response, request, S3ErrorCode(ErrInvalidLc))
                return
        }</span>

        <span class="cov0" title="0">dupIdCheck := make(map[string]interface{})
        s3RulePtrArr := make([]*s3.LifecycleRule, 0)
        ruleCount := 0
        for _, rule := range createLifecycleConf.Rule </span><span class="cov0" title="0">{
                if ruleCount &gt; 1000 </span><span class="cov0" title="0">{
                        log.Error("too many rules\n")
                        WriteApiErrorResponse(response, request, http.StatusBadRequest, AWSErrCodeInvalidArgument,
                                fmt.Sprintf(TooMuchLCRuls, 1000))
                        return
                }</span>

                <span class="cov0" title="0">s3Rule := s3.LifecycleRule{}

                //check if the ruleID has any duplicate values
                if _, ok := dupIdCheck[rule.ID]; ok </span><span class="cov0" title="0">{
                        log.Errorf("duplicate ruleID found for rule : %s\n", rule.ID)
                        WriteApiErrorResponse(response, request, http.StatusBadRequest, AWSErrCodeInvalidArgument,
                                fmt.Sprintf(DuplicateRuleIDError, rule.ID))
                        return
                }</span>
                // Assigning the rule ID
                <span class="cov0" title="0">dupIdCheck[rule.ID] = struct{}{}
                s3Rule.Id = rule.ID

                //Assigning the status value to s3 status
                log.Infof("status in rule file is %v\n", rule.Status)
                s3Rule.Status = rule.Status

                //Assigning the filter, using convert function to convert xml struct to s3 struct
                s3Rule.Filter = convertRuleFilterToS3Filter(rule.Filter)

                // Create the type of transition array
                s3ActionArr := make([]*s3.Action, 0)

                for _, transition := range rule.Transition </span><span class="cov0" title="0">{

                        //Defining the Transition array and assigning the values tp populate fields
                        s3Transition := s3.Action{Name: ActionNameTransition}

                        //Assigning the value of days for transition to happen
                        s3Transition.Days = transition.Days

                        //Assigning the backend value to the s3 struct
                        s3Transition.Backend = transition.Backend

                        //Assigning the storage class of the object to s3 struct
                        tier, err := s.class2tier(transition.StorageClass)
                        if err != nil </span><span class="cov0" title="0">{
                                response.WriteError(http.StatusBadRequest, err)
                                return
                        }</span>
                        <span class="cov0" title="0">s3Transition.Tier = tier

                        //Adding the transition value to the main rule
                        s3ActionArr = append(s3ActionArr, &amp;s3Transition)
                        ruleCount++</span>
                }

                //Loop for getting the values from xml struct
                <span class="cov0" title="0">for _, expiration := range rule.Expiration </span><span class="cov0" title="0">{
                        s3Expiration := s3.Action{Name: ActionNameExpiration}
                        s3Expiration.Days = expiration.Days
                        s3ActionArr = append(s3ActionArr, &amp;s3Expiration)
                        ruleCount++
                }</span>

                //validate actions
                <span class="cov0" title="0">err := checkValidationOfActions(s3ActionArr)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("validation of actions failed: %v\n", err)
                        WriteApiErrorResponse(response, request, http.StatusBadRequest, AWSErrCodeInvalidArgument, err.Error())
                        return
                }</span>

                //Assigning the Expiration action to s3 struct expiration
                <span class="cov0" title="0">s3Rule.Actions = s3ActionArr

                s3Rule.AbortIncompleteMultipartUpload = convertRuleUploadToS3Upload(rule.AbortIncompleteMultipartUpload)

                // add to the s3 array
                s3RulePtrArr = append(s3RulePtrArr, &amp;s3Rule)</span>
        }

        <span class="cov0" title="0">lcRsp, err := s.s3Client.PutBucketLifecycle(ctx, &amp;s3.PutBucketLifecycleRequest{BucketName: bucketName, Lc: s3RulePtrArr})
        if HandleS3Error(response, request, err, lcRsp.GetErrorCode()) != nil </span><span class="cov0" title="0">{
                log.Errorf("put bucket[%s] lifecycle failed, err=%v, errCode=%d\n", bucketName, err, lcRsp.ErrorCode)
                return
        }</span>

        <span class="cov0" title="0">log.Info("create bucket lifecycle successful.")
        WriteSuccessResponse(response, nil)</span>
}

func convertRuleFilterToS3Filter(filter model.Filter) *s3.LifecycleFilter <span class="cov0" title="0">{
        retFilter := s3.LifecycleFilter{}
        /*
                check if prefix is not empty
        */
        if filter.Prefix != "" </span><span class="cov0" title="0">{
                retFilter.Prefix = filter.Prefix
                return &amp;retFilter
        }</span> else<span class="cov0" title="0"> {
                return nil
        }</span>
}

func convertRuleUploadToS3Upload(upload model.AbortIncompleteMultipartUpload) *s3.AbortMultipartUpload <span class="cov0" title="0">{
        retUpload := s3.AbortMultipartUpload{}
        retUpload.DaysAfterInitiation = upload.DaysAfterInitiation
        return &amp;retUpload
}</span>
</pre>
		
		<pre class="file" id="file28" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package s3

import (
        "encoding/xml"
        "strings"
        "time"

        "github.com/emicklei/go-restful"
        "github.com/soda/multi-cloud/api/pkg/common"
        c "github.com/soda/multi-cloud/api/pkg/context"
        "github.com/soda/multi-cloud/s3/error"
        "github.com/soda/multi-cloud/s3/pkg/model"
        "github.com/soda/multi-cloud/s3/pkg/utils"
        "github.com/soda/multi-cloud/s3/proto"
        pb "github.com/soda/multi-cloud/s3/proto"
        log "github.com/sirupsen/logrus"
)

func (s *APIService) BucketPut(request *restful.Request, response *restful.Response) <span class="cov8" title="1">{
        bucketName := strings.ToLower(request.PathParameter(common.REQUEST_PATH_BUCKET_NAME))
        if !isValidBucketName(bucketName) </span><span class="cov0" title="0">{
                WriteErrorResponse(response, request, s3error.ErrInvalidBucketName)
                return
        }</span>
        <span class="cov8" title="1">log.Infof("received request: PUT bucket[name=%s]\n", bucketName)

        if len(request.HeaderParameter(common.REQUEST_HEADER_CONTENT_LENGTH)) == 0 </span><span class="cov0" title="0">{
                log.Errorf("missing content length")
                WriteErrorResponse(response, request, s3error.ErrMissingContentLength)
                return
        }</span>

        <span class="cov8" title="1">acl, err := getAclFromHeader(request)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorln("failed to get canned acl. err:", err)
                WriteErrorResponse(response, request, err)
                return
        }</span>

        <span class="cov8" title="1">ctx := common.InitCtxWithAuthInfo(request)
        actx := request.Attribute(c.KContext).(*c.Context)
        bucket := s3.Bucket{Name: bucketName}
        bucket.TenantId = actx.TenantId
        bucket.UserId = actx.UserId
        bucket.Deleted = false
        bucket.CreateTime = time.Now().Unix()
        bucket.Versioning = &amp;s3.BucketVersioning{}
        bucket.Versioning.Status = utils.VersioningDisabled // it's the default
        bucket.Acl = &amp;pb.Acl{CannedAcl: acl.CannedAcl}
        log.Infof("Bucket PUT: TenantId=%s, UserId=%s\n", bucket.TenantId, bucket.UserId)

        body := ReadBody(request)
        flag := false
        if body != nil &amp;&amp; len(body) != 0 </span><span class="cov8" title="1">{
                log.Infof("request body is not empty")
                createBucketConf := model.CreateBucketConfiguration{}
                err := xml.Unmarshal(body, &amp;createBucketConf)
                if err != nil </span><span class="cov0" title="0">{
                        log.Infof("unmarshal failed, body:%v, err:%v\n", body, err)
                        WriteErrorResponse(response, request, s3error.ErrUnmarshalFailed)
                        return
                }</span>

                <span class="cov8" title="1">backendName := createBucketConf.LocationConstraint
                if backendName != "" </span><span class="cov8" title="1">{
                        log.Infof("backendName is %v\n", backendName)
                        bucket.DefaultLocation = backendName
                        flag = s.isBackendExist(ctx, backendName)
                }</span>
        }
        <span class="cov8" title="1">if flag == false </span><span class="cov0" title="0">{
                log.Errorf("default backend is not provided or it is not exist.")
                WriteErrorResponse(response, request, s3error.ErrGetBackendFailed)
                return
        }</span>

        <span class="cov8" title="1">rsp, err := s.s3Client.CreateBucket(ctx, &amp;bucket)
        if HandleS3Error(response, request, err, rsp.GetErrorCode()) != nil </span><span class="cov0" title="0">{
                log.Errorf("delete bucket[%s] failed, err=%v, errCode=%d\n", bucketName, err, rsp.ErrorCode)
                return
        }</span>

        <span class="cov8" title="1">log.Infof("create bucket[name=%s, defaultLocation=%s] successfully.\n", bucket.Name, bucket.DefaultLocation)
        // Make sure to add Location information here only for bucket
        response.Header().Set("Location", GetLocation(request.Request))
        WriteSuccessResponse(response, nil)</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package s3

import (
        "crypto/md5"
        "encoding/xml"
        "fmt"
        "net/http"
        "sync"

        "github.com/emicklei/go-restful"
        "github.com/soda/multi-cloud/api/pkg/common"
        "github.com/soda/multi-cloud/s3/pkg/model"
        "github.com/soda/multi-cloud/s3/proto"
        log "github.com/sirupsen/logrus"
)

// Map from storage calss to tier
var ClassAndTier1 map[string]int32
var mutext1 sync.Mutex

func (s *APIService) BucketSSEPut(request *restful.Request, response *restful.Response) <span class="cov0" title="0">{
        bucketName := request.PathParameter("bucketName")
        log.Infof("received request for PUT bucket SSE: %s", bucketName)

        ctx := common.InitCtxWithAuthInfo(request)
        bucket, err := s.s3Client.GetBucket(ctx, &amp;s3.Bucket{Name: bucketName})
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("get bucket failed, err=%v\n", err)
                response.WriteError(http.StatusInternalServerError, fmt.Errorf("bucket does not exist"))
        }</span>
        <span class="cov0" title="0">if bucket.ErrorCode != 0 </span><span class="cov0" title="0">{
                log.Errorf("get bucket failed, err=%v\n", bucket.ErrorCode)
                response.WriteError(http.StatusInternalServerError, fmt.Errorf("Get bucket error code %v", bucket.ErrorCode))
        }</span>

        <span class="cov0" title="0">body := ReadBody(request)
        log.Infof("MD5 sum for request body is %x", md5.Sum(body))

        if body != nil </span><span class="cov0" title="0">{
                sseConf := model.SSEConfiguration{}
                errSSE := xml.Unmarshal(body, &amp;sseConf)
                if errSSE != nil </span><span class="cov0" title="0">{
                        response.WriteError(http.StatusInternalServerError, err)
                        return
                }</span>

                <span class="cov0" title="0">s3SSE := &amp;s3.ServerSideEncryption{
                        SseType:              "",
                        EncryptionKey:        nil,
                        InitilizationVector:  nil,
                        XXX_NoUnkeyedLiteral: struct{}{},
                        XXX_unrecognized:     nil,
                        XXX_sizecache:        0,
                }
                if sseConf.SSE.Enabled == "true" </span><span class="cov0" title="0">{
                        s3SSE.SseType = "SSE"
                }</span>

                <span class="cov0" title="0">bucket.BucketMeta.ServerSideEncryption = s3SSE

                baseResponse, errSSE := s.s3Client.UpdateBucket(ctx, bucket.BucketMeta)
                if baseResponse.ErrorCode != 0</span><span class="cov0" title="0">{
                        response.WriteError(http.StatusInternalServerError, fmt.Errorf("Update bucket SSE options failed, error code %v", baseResponse.ErrorCode))
                }</span>
                <span class="cov0" title="0">if errSSE != nil</span><span class="cov0" title="0">{
                        response.WriteError(http.StatusInternalServerError, fmt.Errorf("Update bucket SSE options failed"))
                }</span>

        } else<span class="cov0" title="0"> {
                log.Info("no request body provided for creating SSE configuration")
                response.WriteError(http.StatusBadRequest, fmt.Errorf(NoRequestBodySSE))
                return
        }</span>

        // Create bucket with bucket name will check if the bucket exists or not, if it exists
        // it will internally call UpdateBucket function
        <span class="cov0" title="0">res, err := s.s3Client.UpdateBucket(ctx, bucket.BucketMeta)
        if err != nil </span><span class="cov0" title="0">{
                response.WriteError(http.StatusInternalServerError, err)
                return
        }</span>
        <span class="cov0" title="0">log.Info("create bucket SSE successful.")
        response.WriteEntity(res)</span>

}
</pre>
		
		<pre class="file" id="file30" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package s3

import (
        "crypto/md5"
        "encoding/xml"
        "github.com/emicklei/go-restful"
        "github.com/soda/multi-cloud/api/pkg/common"
        . "github.com/soda/multi-cloud/s3/error"
        "github.com/soda/multi-cloud/s3/pkg/model"
        "github.com/soda/multi-cloud/s3/pkg/utils"
        s3 "github.com/soda/multi-cloud/s3/proto"
        log "github.com/sirupsen/logrus"
)

func (s *APIService) BucketVersioningPut(request *restful.Request, response *restful.Response) <span class="cov0" title="0">{
        bucketName := request.PathParameter("bucketName")
        log.Infof("received request for creating versioning of bucket: %s", bucketName)

        ctx := common.InitCtxWithAuthInfo(request)
        bucket, err := s.getBucketMeta(ctx, bucketName)
        if err != nil </span><span class="cov0" title="0">{
                WriteErrorResponse(response, request, err)
                log.Errorf("get bucket[%s] failed, err=%v\n", bucketName, err)
                return
        }</span>

        <span class="cov0" title="0">body := ReadBody(request)
        if body == nil </span><span class="cov0" title="0">{
                log.Info("no request body provided for creating versioning configuration")
                WriteErrorResponse(response, request, S3ErrorCode(ErrInvalidVersioning))
                return
        }</span>
        <span class="cov0" title="0">log.Infof("MD5 sum for body is %x", md5.Sum(body))

        versionConf := model.VersioningConfiguration{}
        err = xml.Unmarshal(body, &amp;versionConf)
        if err != nil </span><span class="cov0" title="0">{
                WriteErrorResponse(response, request, S3ErrorCode(ErrInvalidVersioning))
                return
        }</span>

        <span class="cov0" title="0">s3version := &amp;s3.BucketVersioning{
                Status:               "",
                XXX_NoUnkeyedLiteral: struct{}{},
                XXX_unrecognized:     nil,
                XXX_sizecache:        0,
        }

        if versionConf.Status == utils.VersioningEnabled </span><span class="cov0" title="0">{
                s3version.Status = utils.VersioningEnabled
        }</span> else<span class="cov0" title="0"> {
                s3version.Status = utils.VersioningDisabled
        }</span>

        <span class="cov0" title="0">bucket.Versioning = s3version

        _, err = s.s3Client.UpdateBucket(ctx, bucket)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("versioning configuration failed, errCode=%d\n", bucketName, err)
                return
        }</span>

        <span class="cov0" title="0">log.Info("create bucket version configuration successful.")
        WriteSuccessResponse(response, nil)</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package s3

import (
        "encoding/xml"
        "errors"
        "io/ioutil"
        "sort"
        "strings"

        "github.com/emicklei/go-restful"
        "github.com/soda/multi-cloud/api/pkg/common"
        "github.com/soda/multi-cloud/s3/pkg/model"
        pb "github.com/soda/multi-cloud/s3/proto"
        log "github.com/sirupsen/logrus"

        . "github.com/soda/multi-cloud/s3/error"
)

func (s *APIService) CompleteMultipartUpload(request *restful.Request, response *restful.Response) <span class="cov0" title="0">{
        bucketName := request.PathParameter("bucketName")
        objectKey := request.PathParameter("objectKey")
        uploadId := request.QueryParameter("uploadId")

        multipartUpload := pb.MultipartUpload{}
        multipartUpload.Bucket = bucketName
        multipartUpload.Key = objectKey
        multipartUpload.UploadId = uploadId

        completeMultipartBytes, err := ioutil.ReadAll(request.Request.Body)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorln("unable to complete multipart upload when read request body. err:", err)
                WriteErrorResponse(response, request, ErrInternalError)
                return
        }</span>
        <span class="cov0" title="0">complMultipartUpload := &amp;model.CompleteMultipartUpload{}
        if err = xml.Unmarshal(completeMultipartBytes, complMultipartUpload); err != nil </span><span class="cov0" title="0">{
                log.Errorf("unable to parse complete multipart upload XML. data: %s, err: %v", string(completeMultipartBytes), err)
                WriteErrorResponse(response, request, ErrMalformedXML)
                return
        }</span>

        <span class="cov0" title="0">if len(complMultipartUpload.Parts) == 0 </span><span class="cov0" title="0">{
                log.Errorf("unable to complete multipart upload. err: %v", errors.New("len(complMultipartUpload.Parts) == 0"))
                WriteErrorResponse(response, request, ErrMalformedXML)
                return
        }</span>
        <span class="cov0" title="0">if !sort.IsSorted(model.CompletedParts(complMultipartUpload.Parts)) </span><span class="cov0" title="0">{
                log.Errorf("unable to complete multipart upload. data: %+v, err: %v", complMultipartUpload.Parts, errors.New("part not sorted."))
                WriteErrorResponse(response, request, ErrInvalidPartOrder)
                return
        }</span>

        // Complete parts.
        <span class="cov0" title="0">var completeParts []*pb.CompletePart
        for _, part := range complMultipartUpload.Parts </span><span class="cov0" title="0">{
                part.ETag = strings.TrimPrefix(part.ETag, "\"")
                part.ETag = strings.TrimSuffix(part.ETag, "\"")
                completeParts = append(completeParts, &amp;pb.CompletePart{PartNumber: part.PartNumber, ETag: part.ETag})
        }</span>

        <span class="cov0" title="0">ctx := common.InitCtxWithAuthInfo(request)
        result, err := s.s3Client.CompleteMultipartUpload(ctx, &amp;pb.CompleteMultipartRequest{
                BucketName:    bucketName,
                ObjectKey:     objectKey,
                UploadId:      uploadId,
                CompleteParts: completeParts,
        })
        if HandleS3Error(response, request, err, result.GetErrorCode()) != nil </span><span class="cov0" title="0">{
                log.Errorf("unable to complete multipart. err:%v, errCode:%v", err, result.ErrorCode)
                return
        }</span>

        // Get object location.
        <span class="cov0" title="0">location := GetLocation(request.Request)
        // Generate complete multipart response.
        data := GenerateCompleteMultipartUploadResponse(bucketName, objectKey, location, result.ETag)
        encodedSuccessResponse, err := xmlFormat(data)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorln("unable to parse CompleteMultipartUpload response, err:", err)
                WriteErrorResponseNoHeader(response, request, ErrInternalError, request.Request.URL.Path)
                return
        }</span>

        <span class="cov0" title="0">setXmlHeader(response, encodedSuccessResponse)
        // write success response.
        WriteSuccessResponse(response, encodedSuccessResponse)
        log.Infof("Complete multipart upload[bucketName=%s, objectKey=%s, uploadId=%s] successfully.\n",
                bucketName, objectKey, uploadId)</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package datatype

import (
        "encoding/xml"
        . "github.com/soda/multi-cloud/s3/error"
        "github.com/soda/multi-cloud/s3/pkg/helper"
        log "github.com/sirupsen/logrus"
)

var ValidCannedAcl = []string{
        "private",
        "public-read",
        "public-read-write",
}

const (
        CANNEDACL_PRIVATE                    = 0
        CANNEDACL_PUBLIC_READ                = 1
        CANNEDACL_PUBLIC_READ_WRITE          = 2
        CANNEDACL_AWS_EXEC_READ              = 3
        CANNEDACL_AUTHENTICATED_READ         = 4
        CANNEDACL_BUCKET_OWNER_READ          = 5
        CANNEDACL_BUCKET_OWNER_FULL_CONTROLL = 6
)

const (
        XMLNSXSI = "http://www.w3.org/2001/XMLSchema-instance"
        XMLNS    = "http://s3.amazonaws.com/doc/2006-03-01/"
)

const (
        ACL_TYPE_CANON_USER = "CanonicalUser"
        ACL_TYPE_GROUP      = "Group"
)

const (
        ACL_GROUP_TYPE_ALL_USERS           = "http://acs.amazonaws.com/groups/global/AllUsers"
        ACL_GROUP_TYPE_AUTHENTICATED_USERS = "http://acs.amazonaws.com/groups/global/AuthenticatedUsers"
)

const (
        ACL_PERM_READ         = "READ"
        ACL_PERM_WRITE        = "WRITE"
        ACL_PERM_READ_ACP     = "READ_ACP"
        ACL_PERM_WRITE_ACP    = "WRITE_ACP"
        ACL_PERM_FULL_CONTROL = "FULL_CONTROL"
)

type Acl struct {
        CannedAcl string
        // TODO fancy ACLs
}

type AccessControlPolicy struct {
        XMLName           xml.Name `xml:"AccessControlPolicy"`
        Xmlns             string   `xml:"xmlns,attr,omitempty"`
        ID                string   `xml:"Owner&gt;ID"`
        DisplayName       string   `xml:"Owner&gt;DisplayName"`
        AccessControlList []Grant  `xml:"AccessControlList&gt;Grant"`
}

type Grant struct {
        XMLName    xml.Name `xml:"Grant"`
        Grantee    Grantee  `xml:"Grantee"`
        Permission string   `xml:"Permission"`
}

type Grantee struct {
        XMLName      xml.Name `xml:"Grantee"`
        XmlnsXsi     string   `xml:"xmlns:xsi,attr"`
        XsiType      string   `xml:"http://www.w3.org/2001/XMLSchema-instance type,attr"`
        URI          string   `xml:"URI,omitempty"`
        ID           string   `xml:"ID,omitempty"`
        DisplayName  string   `xml:"DisplayName,omitempty"`
        EmailAddress string   `xml:"EmailAddress,omitempty"`
}

type AccessControlPolicyResponse struct {
        XMLName           xml.Name `xml:"AccessControlPolicy"`
        Xmlns             string   `xml:"xmlns,attr,omitempty"`
        ID                string   `xml:"Owner&gt;ID"`
        DisplayName       string   `xml:"Owner&gt;DisplayName"`
        AccessControlList []GrantResponse  `xml:"AccessControlList&gt;Grant"`
}

type GrantResponse struct {
        XMLName    xml.Name `xml:"Grant"`
        Grantee    GranteeResponse  `xml:"Grantee"`
        Permission string   `xml:"Permission"`
}

type GranteeResponse struct {
        XMLName      xml.Name `xml:"Grantee"`
        XmlnsXsi     string   `xml:"xmlns:xsi,attr"`
        XsiType      string   `xml:"xsi:type,attr"`
        URI          string   `xml:"URI,omitempty"`
        ID           string   `xml:"ID,omitempty"`
        DisplayName  string   `xml:"DisplayName,omitempty"`
        EmailAddress string   `xml:"EmailAddress,omitempty"`
}

func IsValidCannedAcl(acl Acl) (err error) <span class="cov8" title="1">{
        if !helper.StringInSlice(acl.CannedAcl, ValidCannedAcl) </span><span class="cov0" title="0">{
                err = ErrInvalidCannedAcl
                return
        }</span>
        <span class="cov8" title="1">return</span>
}

// the function will be deleted, because we will use AccessControlPolicy instead canned acl stored in hbase
func GetCannedAclFromPolicy(policy AccessControlPolicy) (acl Acl, err error) <span class="cov0" title="0">{
        aclOwner := Owner{ID: policy.ID, DisplayName: policy.DisplayName}
        var canonUser bool
        var group bool
        for _, grant := range policy.AccessControlList </span><span class="cov0" title="0">{
                log.Infoln("GetCannedAclFromPolicy")
                switch grant.Grantee.XsiType </span>{
                case ACL_TYPE_CANON_USER:<span class="cov0" title="0">
                        if grant.Grantee.ID != aclOwner.ID </span><span class="cov0" title="0">{
                                log.Infoln("grant.Grantee.ID:", grant.Grantee.ID, "not equals aclOwner.ID:", aclOwner.ID)
                                return acl, ErrUnsupportedAcl
                        }</span>
                        <span class="cov0" title="0">if grant.Permission != ACL_PERM_FULL_CONTROL </span><span class="cov0" title="0">{
                                log.Infoln("grant.Permission:", grant.Permission, "not equals", ACL_PERM_FULL_CONTROL)
                                return acl, ErrUnsupportedAcl
                        }</span>
                        <span class="cov0" title="0">canonUser = true</span>
                case ACL_TYPE_GROUP:<span class="cov0" title="0">
                        if grant.Grantee.URI == ACL_GROUP_TYPE_ALL_USERS </span><span class="cov0" title="0">{
                                log.Infoln("grant.Grantee.URI is", ACL_GROUP_TYPE_ALL_USERS)
                                if grant.Permission != ACL_PERM_READ </span><span class="cov0" title="0">{
                                        log.Infoln("grant.Permission:", grant.Permission, "not equals", ACL_PERM_READ)
                                        return acl, ErrUnsupportedAcl
                                }</span>
                                <span class="cov0" title="0">acl = Acl{CannedAcl: ValidCannedAcl[CANNEDACL_PUBLIC_READ]}
                                group = true</span>
                        } else<span class="cov0" title="0"> if grant.Grantee.URI == ACL_GROUP_TYPE_AUTHENTICATED_USERS </span><span class="cov0" title="0">{
                                log.Infoln("grant.Grantee.URI is", ACL_GROUP_TYPE_AUTHENTICATED_USERS)
                                if grant.Permission != ACL_PERM_READ </span><span class="cov0" title="0">{
                                        log.Infoln("grant.Permission:", grant.Permission, "not equals", ACL_PERM_FULL_CONTROL)
                                        return acl, ErrUnsupportedAcl
                                }</span>
                                <span class="cov0" title="0">acl = Acl{CannedAcl: ValidCannedAcl[CANNEDACL_AUTHENTICATED_READ]}
                                group = true</span>
                        } else<span class="cov0" title="0"> {
                                log.Infoln("grant.Grantee.URI is invalid:", grant.Grantee.URI)
                                return acl, ErrUnsupportedAcl
                        }</span>
                default:<span class="cov0" title="0">
                        log.Infoln("grant.Grantee.XsiType is invalid:", grant.Grantee.XsiType)
                        return acl, ErrUnsupportedAcl</span>
                }
        }

        <span class="cov0" title="0">if !canonUser </span><span class="cov0" title="0">{
                log.Infoln("canonUser is invalid:", canonUser)
                return acl, ErrUnsupportedAcl
        }</span>

        <span class="cov0" title="0">if !group </span><span class="cov0" title="0">{
                acl = Acl{CannedAcl: ValidCannedAcl[CANNEDACL_PRIVATE]}
        }</span>

        <span class="cov0" title="0">return acl, nil</span>
}

func createGrant(xsiType string, owner Owner, perm string, groupType string) (grant GrantResponse, err error) <span class="cov8" title="1">{

        if xsiType == ACL_TYPE_CANON_USER </span><span class="cov8" title="1">{
                grant.Grantee.ID = owner.ID
                grant.Grantee.DisplayName = owner.DisplayName
        }</span> else<span class="cov0" title="0"> if xsiType == ACL_TYPE_GROUP </span><span class="cov0" title="0">{
                grant.Grantee.URI = groupType
        }</span> else<span class="cov0" title="0"> {
                return grant, ErrUnsupportedAcl
        }</span>
        <span class="cov8" title="1">grant.Permission = perm
        grant.Grantee.XmlnsXsi = XMLNSXSI
        grant.Grantee.XsiType = xsiType
        return</span>
}

func CreatePolicyFromCanned(owner Owner, bucketOwner Owner, acl Acl) (
        policy AccessControlPolicyResponse, err error) <span class="cov8" title="1">{

        policy.ID = owner.ID
        policy.DisplayName = owner.DisplayName
        policy.Xmlns = XMLNS
        grant, err := createGrant(ACL_TYPE_CANON_USER, owner, ACL_PERM_FULL_CONTROL, "")
        if err != nil </span><span class="cov0" title="0">{
                return policy, err
        }</span>
        <span class="cov8" title="1">policy.AccessControlList = append(policy.AccessControlList, grant)
        if acl.CannedAcl == "private" </span><span class="cov8" title="1">{
                return policy, nil
        }</span>
        <span class="cov0" title="0">switch acl.CannedAcl </span>{
        case "public-read":<span class="cov0" title="0">
                owner := Owner{}
                grant, err := createGrant(ACL_TYPE_GROUP, owner, ACL_PERM_READ, ACL_GROUP_TYPE_ALL_USERS)
                if err != nil </span><span class="cov0" title="0">{
                        return policy, err
                }</span>
                <span class="cov0" title="0">policy.AccessControlList = append(policy.AccessControlList, grant)</span>
        case "public-read-write":<span class="cov0" title="0">
                owner := Owner{}
                rGrant, err := createGrant(ACL_TYPE_GROUP, owner, ACL_PERM_READ, ACL_GROUP_TYPE_ALL_USERS)
                if err != nil </span><span class="cov0" title="0">{
                        return policy, err
                }</span>
                <span class="cov0" title="0">wGrant, err := createGrant(ACL_TYPE_GROUP, owner, ACL_PERM_WRITE, ACL_GROUP_TYPE_ALL_USERS)
                if err != nil </span><span class="cov0" title="0">{
                        return policy, err
                }</span>
                <span class="cov0" title="0">policy.AccessControlList = append(policy.AccessControlList, rGrant, wGrant)</span>
        case "bucket-owner-full-control":<span class="cov0" title="0">
                grant, err := createGrant(ACL_TYPE_CANON_USER, bucketOwner, ACL_PERM_FULL_CONTROL, "")
                if err != nil </span><span class="cov0" title="0">{
                        return policy, err
                }</span>
                <span class="cov0" title="0">if bucketOwner.ID != owner.ID </span><span class="cov0" title="0">{
                        policy.AccessControlList = append(policy.AccessControlList, grant)
                }</span>
        default:<span class="cov0" title="0">
                return policy, ErrUnsupportedAcl</span>
        }
        <span class="cov0" title="0">return</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package datatype

import (
        . "github.com/soda/multi-cloud/s3/error"
        "time"
)

const (
        Iso8601Format           = "20060102T150405Z"
        YYYYMMDD                = "20060102"
        PresignedUrlExpireLimit = 7 * 24 * time.Hour
)

// Supported Amz date formats.
var amzDateFormats = []string{
        time.RFC1123,
        time.RFC1123Z,
        Iso8601Format,
        // Add new AMZ date formats here.
}

// parseAmzDate - parses date string into supported amz date formats.
func ParseAmzDate(amzDateStr string) (amzDate time.Time, apiErr error) <span class="cov0" title="0">{
        for _, dateFormat := range amzDateFormats </span><span class="cov0" title="0">{
                amzDate, e := time.Parse(dateFormat, amzDateStr)
                if e == nil </span><span class="cov0" title="0">{
                        return amzDate, nil
                }</span>
        }
        <span class="cov0" title="0">return time.Time{}, ErrMalformedDate</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">/*
 * Minio Cloud Storage, (C) 2015, 2016 Minio, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package datatype

import (
        "errors"
        "fmt"
        "regexp"
        "strconv"
        "strings"
)

const (
        byteRangePrefix = "bytes="
)

// Valid byte position regexp
var validBytePos = regexp.MustCompile(`^[0-9]+$`)

// ErrorInvalidRange - returned when given range value is not valid.
var ErrorInvalidRange = errors.New("Invalid range")

// HttpRange specifies the byte range to be sent to the client.
type HttpRange struct {
        OffsetBegin  int64
        OffsetEnd    int64
        ResourceSize int64
}

// String populate range stringer interface
func (hrange HttpRange) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("bytes %d-%d/%d", hrange.OffsetBegin, hrange.OffsetEnd, hrange.ResourceSize)
}</span>

// getlength - get length from the range.
func (hrange HttpRange) GetLength() int64 <span class="cov0" title="0">{
        return 1 + hrange.OffsetEnd - hrange.OffsetBegin
}</span>

func getOffset(offsetString string) (offset int64, err error) <span class="cov0" title="0">{
        offset = int64(-1)
        if len(offsetString) &gt; 0 </span><span class="cov0" title="0">{
                if !validBytePos.MatchString(offsetString) </span><span class="cov0" title="0">{
                        return offset, fmt.Errorf("'%s' does not have a valid first byte position value", offsetString)
                }</span>

                <span class="cov0" title="0">if offset, err = strconv.ParseInt(offsetString, 10, 64); err != nil </span><span class="cov0" title="0">{
                        return offset, fmt.Errorf("'%s' does not have a valid first byte position value", offsetString)
                }</span>
        }
        <span class="cov0" title="0">return</span>
}

func ParseRequestRange(rangeString string, resourceSize int64) (hrange *HttpRange, err error) <span class="cov0" title="0">{
        // TODO handle multi-range request
        // see https://tools.ietf.org/html/rfc7233

        // Return error if given range string doesn't start with byte range prefix.
        if !strings.HasPrefix(rangeString, byteRangePrefix) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("'%s' does not start with '%s'", rangeString, byteRangePrefix)
        }</span>

        // Trim byte range prefix.
        <span class="cov0" title="0">byteRangeString := strings.TrimPrefix(rangeString, byteRangePrefix)

        // Check if range string contains delimiter '-', else return error. eg. "bytes=8"
        sepIndex := strings.Index(byteRangeString, "-")
        if sepIndex == -1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("'%s' does not have a valid range value", rangeString)
        }</span>

        <span class="cov0" title="0">offsetBeginString := byteRangeString[:sepIndex]
        offsetBegin, err := getOffset(offsetBeginString)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">offsetEndString := byteRangeString[sepIndex+1:]
        offsetEnd, err := getOffset(offsetEndString)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // rangeString contains first and last byte positions. eg. "bytes=2-5"
        <span class="cov0" title="0">if offsetBegin &gt; -1 &amp;&amp; offsetEnd &gt; -1 </span><span class="cov0" title="0">{
                if offsetBegin &gt; offsetEnd </span><span class="cov0" title="0">{
                        // Last byte position is not greater than first byte position. eg. "bytes=5-2"
                        return nil, fmt.Errorf("'%s' does not have valid range value", rangeString)
                }</span>

                // First and last byte positions should not be &gt;= resourceSize.
                <span class="cov0" title="0">if offsetBegin &gt;= resourceSize </span><span class="cov0" title="0">{
                        return nil, ErrorInvalidRange
                }</span>

                <span class="cov0" title="0">if offsetEnd &gt;= resourceSize </span><span class="cov0" title="0">{
                        offsetEnd = resourceSize - 1
                }</span>
        } else<span class="cov0" title="0"> if offsetBegin &gt; -1 </span><span class="cov0" title="0">{
                // rangeString contains only first byte position. eg. "bytes=8-"
                if offsetBegin &gt;= resourceSize </span><span class="cov0" title="0">{
                        // First byte position should not be &gt;= resourceSize.
                        return nil, ErrorInvalidRange
                }</span>

                <span class="cov0" title="0">offsetEnd = resourceSize - 1</span>
        } else<span class="cov0" title="0"> if offsetEnd &gt; -1 </span><span class="cov0" title="0">{
                // rangeString contains only last byte position. eg. "bytes=-3"
                if offsetEnd == 0 </span><span class="cov0" title="0">{
                        // Last byte position should not be zero eg. "bytes=-0"
                        return nil, ErrorInvalidRange
                }</span>

                <span class="cov0" title="0">if offsetEnd &gt;= resourceSize </span><span class="cov0" title="0">{
                        offsetBegin = 0
                }</span> else<span class="cov0" title="0"> {
                        offsetBegin = resourceSize - offsetEnd
                }</span>

                <span class="cov0" title="0">offsetEnd = resourceSize - 1</span>
        } else<span class="cov0" title="0"> {
                // rangeString contains first and last byte positions missing. eg. "bytes=-"
                return nil, fmt.Errorf("'%s' does not have valid range value", rangeString)
        }</span>

        <span class="cov0" title="0">return &amp;HttpRange{offsetBegin, offsetEnd, resourceSize}, nil</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">/*
 * Minio Cloud Storage, (C) 2015, 2016 Minio, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package s3

import (
        "io"
        "io/ioutil"
        "mime/multipart"
        "net/http"
        "strings"

        "github.com/emicklei/go-restful"
        . "github.com/soda/multi-cloud/api/pkg/s3/datatype"
        . "github.com/soda/multi-cloud/s3/error"
        "github.com/soda/multi-cloud/s3/pkg/helper"
)

// validates location constraint from the request body.
// the location value in the request body should match the Region in serverConfig.
// other values of location are not accepted.
// make bucket fails in such cases.
func isValidLocationConstraint(reqBody io.Reader) (err error) <span class="cov0" title="0">{
        var region = helper.CONFIG.Region
        var locationConstraint CreateBucketLocationConfiguration
        e := xmlDecoder(reqBody, &amp;locationConstraint)
        if e != nil </span><span class="cov0" title="0">{
                if e == io.EOF </span><span class="cov0" title="0">{
                        // Failed due to empty request body. The location will be set to
                        // default value from the serverConfig
                        err = nil
                }</span> else<span class="cov0" title="0"> {
                        // Failed due to malformed configuration.
                        err = ErrMalformedXML
                }</span>
        } else<span class="cov0" title="0"> {
                // Region obtained from the body.
                // It should be equal to Region in serverConfig.
                // Else ErrInvalidRegion returned.
                // For empty value location will be to set to  default value from the serverConfig.
                if locationConstraint.Location != "" &amp;&amp; region != locationConstraint.Location </span><span class="cov0" title="0">{
                        err = ErrInvalidRegion
                }</span>
        }
        <span class="cov0" title="0">return err</span>
}

// Supported headers that needs to be extracted.
var supportedHeaders = []string{
        "cache-control",
        "content-disposition",
        "content-encoding",
        "content-language",
        "content-type",
        "expires",
        "website-redirect-location",
        // Add more supported headers here
}

// extractMetadataFromHeader extracts metadata from HTTP header.
func extractMetadataFromHeader(request *restful.Request) map[string]string <span class="cov8" title="1">{
        metadata := make(map[string]string)
        // Save standard supported headers.
        for _, supportedHeader := range supportedHeaders </span><span class="cov8" title="1">{
                if h := request.HeaderParameter(supportedHeader); h != "" </span><span class="cov8" title="1">{
                        metadata[supportedHeader] = h
                }</span>
        }

        // Go through all other headers for any additional headers that needs to be saved.
        <span class="cov8" title="1">for key := range request.Request.Header </span><span class="cov8" title="1">{
                if strings.HasPrefix(strings.ToLower(key), "x-amz-meta-") </span><span class="cov0" title="0">{
                        metadata[key] = request.HeaderParameter(key)
                }</span>
        }
        // Return.
        <span class="cov8" title="1">return metadata</span>
}

// Suffix matcher string matches suffix in a platform specific way.
// For example on windows since its case insensitive we are supposed
// to do case insensitive checks.
func hasSuffix(s string, suffix string) bool <span class="cov0" title="0">{
        return strings.HasSuffix(s, suffix)
}</span>

func extractHTTPFormValues(reader *multipart.Reader) (filePartReader io.Reader,
        formValues map[string]string, err error) <span class="cov0" title="0">{

        formValues = make(map[string]string)
        for </span><span class="cov0" title="0">{
                var part *multipart.Part
                part, err = reader.NextPart()
                if err == io.EOF </span><span class="cov0" title="0">{
                        err = nil
                        break</span>
                }
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, err
                }</span>

                <span class="cov0" title="0">if part.FormName() != "file" </span><span class="cov0" title="0">{
                        var buffer []byte
                        buffer, err = ioutil.ReadAll(part)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, nil, err
                        }</span>
                        <span class="cov0" title="0">formValues[http.CanonicalHeaderKey(part.FormName())] = string(buffer)</span>
                } else<span class="cov0" title="0"> {
                        // "All variables within the form are expanded prior to validating
                        // the POST policy"
                        fileName := part.FileName()
                        objectKey, ok := formValues["Key"]
                        if !ok </span><span class="cov0" title="0">{
                                return nil, nil, ErrMissingFields
                        }</span>
                        <span class="cov0" title="0">if strings.Contains(objectKey, "${filename}") </span><span class="cov0" title="0">{
                                formValues["Key"] = strings.Replace(objectKey, "${filename}", fileName, -1)
                        }</span>

                        <span class="cov0" title="0">filePartReader = part
                        // "The file or content must be the last field in the form.
                        // Any fields below it are ignored."
                        break</span>
                }
        }

        <span class="cov0" title="0">if filePartReader == nil </span><span class="cov0" title="0">{
                err = ErrEmptyEntity
        }</span>
        <span class="cov0" title="0">return</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package s3

import (
        "encoding/xml"
        "time"

        "github.com/emicklei/go-restful"
        "github.com/soda/multi-cloud/api/pkg/common"
        "github.com/soda/multi-cloud/api/pkg/policy"
        "github.com/soda/multi-cloud/s3/pkg/model"
        "github.com/soda/multi-cloud/s3/pkg/utils"
        s3 "github.com/soda/multi-cloud/s3/proto"
        log "github.com/sirupsen/logrus"
)

func parseListBuckets(list *s3.ListBucketsResponse) []byte <span class="cov8" title="1">{
        if list == nil || list.Buckets == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">temp := model.ListAllMyBucketsResult{}

        log.Infof("Parse ListBuckets: %v", list.Buckets)
        //default xmlns
        temp.Xmlns = model.Xmlns
        buckets := []model.Bucket{}
        for _, value := range list.Buckets </span><span class="cov8" title="1">{
                ctime := time.Unix(value.CreateTime, 0).Format(time.RFC3339)
                versionOpts := model.VersioningConfiguration{}
                versionOpts.Status = utils.VersioningDisabled
                if value.Versioning != nil </span><span class="cov8" title="1">{
                        if value.Versioning.Status == utils.VersioningEnabled </span><span class="cov0" title="0">{
                                versionOpts.Status = utils.VersioningEnabled
                        }</span>
                }
                <span class="cov8" title="1">sseOpts := model.SSEConfiguration{}
                if value.ServerSideEncryption != nil </span><span class="cov8" title="1">{
                        if value.ServerSideEncryption.SseType == "SSE" </span><span class="cov0" title="0">{
                                sseOpts.SSE.Enabled = "true"
                        }</span> else<span class="cov8" title="1"> {
                                sseOpts.SSE.Enabled = "false"
                        }</span>
                }
                <span class="cov8" title="1">bucket := model.Bucket{Name: value.Name, CreateTime: ctime, LocationConstraint: value.DefaultLocation,
                        VersionOpts: versionOpts, SSEOpts: sseOpts}
                buckets = append(buckets, bucket)</span>
        }
        <span class="cov8" title="1">temp.Buckets = buckets

        xmlstring, err := xml.MarshalIndent(temp, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("Parse ListBuckets error: %v", err)
                return nil
        }</span>
        <span class="cov8" title="1">xmlstring = []byte(xml.Header + string(xmlstring))
        return xmlstring</span>
}

func (s *APIService) ListBuckets(request *restful.Request, response *restful.Response) <span class="cov8" title="1">{
        if !policy.Authorize(request, response, "bucket:list") </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">log.Infof("Received request for all buckets")

        ctx := common.InitCtxWithAuthInfo(request)
        rsp, err := s.s3Client.ListBuckets(ctx, &amp;s3.BaseRequest{})
        if HandleS3Error(response, request, err, rsp.GetErrorCode()) != nil </span><span class="cov0" title="0">{
                log.Errorf("list bucket failed, err=%v, errCode=%d\n", err, rsp.GetErrorCode())
                return
        }</span>

        <span class="cov8" title="1">realRes := parseListBuckets(rsp)

        log.Infof("Get List of buckets successfully:%v\n", string(realRes))
        response.Write(realRes)</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package s3

import (
        "net/url"
        "sort"

        "github.com/emicklei/go-restful"
        "github.com/soda/multi-cloud/api/pkg/common"
        "github.com/soda/multi-cloud/api/pkg/s3/datatype"
        s3error "github.com/soda/multi-cloud/s3/error"
        pb "github.com/soda/multi-cloud/s3/proto"
        log "github.com/sirupsen/logrus"
)

func (s *APIService) ListBucketUploadRecords(request *restful.Request, response *restful.Response) <span class="cov0" title="0">{
        bucketName := request.PathParameter("bucketName")

        log.Infof("Received request for listing multipart uploads records: %s\n", bucketName)

        parameters, err := parseListUploadsQuery(request.Request.URL.Query())
        if err != nil </span><span class="cov0" title="0">{
                log.Errorln("failed to parse list upload query parameter. err:", err)
                WriteErrorResponse(response, request, err)
                return
        }</span>

        <span class="cov0" title="0">ctx := common.InitCtxWithAuthInfo(request)
        listMultipartsResponse, err := s.s3Client.ListBucketUploadRecords(ctx, &amp;pb.ListBucketUploadRequest{
                BucketName:     bucketName,
                Delimiter:      parameters.Delimiter,
                EncodingType:   parameters.EncodingType,
                MaxUploads:     int32(parameters.MaxUploads),
                KeyMarker:      parameters.KeyMarker,
                Prefix:         parameters.Prefix,
                UploadIdMarker: parameters.UploadIdMarker,
        })
        if err != nil || listMultipartsResponse.ErrorCode != int32(s3error.ErrNoErr) </span><span class="cov0" title="0">{
                log.Errorf("Unable to list multipart uploads. err:", err)
                WriteErrorResponse(response, request, err)
                return
        }</span>

        <span class="cov0" title="0">resData := datatype.ListMultipartUploadsResponse{}
        resData.IsTruncated = listMultipartsResponse.Result.IsTruncated
        resData.NextKeyMarker = listMultipartsResponse.Result.NextKeyMarker
        resData.NextUploadIdMarker = listMultipartsResponse.Result.NextUploadIdMarker
        sort.Strings(listMultipartsResponse.Result.CommonPrefix)
        for _, prefix := range listMultipartsResponse.Result.CommonPrefix </span><span class="cov0" title="0">{
                resData.CommonPrefixes = append(resData.CommonPrefixes, datatype.CommonPrefix{
                        Prefix: prefix,
                })
        }</span>
        <span class="cov0" title="0">for _, upload := range listMultipartsResponse.Result.Uploads </span><span class="cov0" title="0">{
                resData.Uploads = append(resData.Uploads, datatype.Upload{
                        Key:      upload.Key,
                        UploadId: upload.UploadId,
                        Initiator: datatype.Initiator{
                                ID:          upload.Initiator.Id,
                                DisplayName: upload.Initiator.DisplayName,
                        },
                        Owner: datatype.Owner{
                                ID:          upload.Owner.Id,
                                DisplayName: upload.Owner.DisplayName,
                        },
                        StorageClass: upload.StorageClass,
                        Initiated:    upload.Initiated,
                })
        }</span>

        <span class="cov0" title="0">resData.Bucket = bucketName
        resData.KeyMarker = parameters.KeyMarker
        resData.UploadIdMarker = parameters.UploadIdMarker
        resData.MaxUploads = parameters.MaxUploads
        resData.Prefix = parameters.Prefix
        resData.Delimiter = parameters.Delimiter
        resData.EncodingType = parameters.EncodingType
        if resData.EncodingType != "" </span><span class="cov0" title="0">{ // only support "url" encoding for now
                resData.Delimiter = url.QueryEscape(resData.Delimiter)
                resData.KeyMarker = url.QueryEscape(resData.KeyMarker)
                resData.Prefix = url.QueryEscape(resData.Prefix)
                resData.NextKeyMarker = url.QueryEscape(resData.NextKeyMarker)
                for _, upload := range resData.Uploads </span><span class="cov0" title="0">{
                        upload.Key = url.QueryEscape(upload.Key)
                }</span>
        }

        <span class="cov0" title="0">encodedSuccessResponse := EncodeResponse(resData)
        // write success response.
        WriteSuccessResponse(response, encodedSuccessResponse)
        log.Infoln("List bucket multipart uploads successfully.")</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package s3

import (
        "github.com/emicklei/go-restful"
        "github.com/soda/multi-cloud/api/pkg/common"
        "github.com/soda/multi-cloud/api/pkg/s3/datatype"
        pb "github.com/soda/multi-cloud/s3/proto"
        log "github.com/sirupsen/logrus"
)

func (s *APIService) ListObjectParts(request *restful.Request, response *restful.Response) <span class="cov0" title="0">{
        bucketName := request.PathParameter("bucketName")
        objectKey := request.PathParameter("objectKey")
        log.Infof("received request: list object multipart, bucketet[name=%s] object[name=%s]\n", bucketName, objectKey)

        listPartReq, err := parseListObjectPartsQuery(request.Request.URL.Query())
        if err != nil </span><span class="cov0" title="0">{
                log.Errorln("failed to parse object part query parameter. err:", err)
                WriteErrorResponse(response, request, err)
                return
        }</span>

        <span class="cov0" title="0">ctx := common.InitCtxWithAuthInfo(request)
        listObjectPartsRes, err := s.s3Client.ListObjectParts(ctx, &amp;pb.ListObjectPartsRequest{
                BucketName:       bucketName,
                ObjectKey:        objectKey,
                UploadId:         listPartReq.UploadId,
                EncodingType:     listPartReq.EncodingType,
                MaxParts:         int64(listPartReq.MaxParts),
                PartNumberMarker: int64(listPartReq.PartNumberMarker),
        })
        if err != nil </span><span class="cov0" title="0">{
                log.Errorln("unable to list uploaded parts. err:", err)
                WriteErrorResponse(response, request, err)
                return
        }</span>

        <span class="cov0" title="0">data := datatype.ListPartsResponse{
                Bucket:       bucketName,
                Key:          objectKey,
                UploadId:     listPartReq.UploadId,
                EncodingType: listPartReq.EncodingType,
                Initiator: datatype.Initiator(datatype.Owner{
                        ID:          listObjectPartsRes.Initiator.Id,
                        DisplayName: listObjectPartsRes.Initiator.DisplayName,
                }),
                Owner: datatype.Owner{
                        ID:          listObjectPartsRes.Owner.Id,
                        DisplayName: listObjectPartsRes.Owner.DisplayName,
                },
                PartNumberMarker:     int(listObjectPartsRes.PartNumberMarker),
                NextPartNumberMarker: int(listObjectPartsRes.NextPartNumberMarker),
                MaxParts:             int(listObjectPartsRes.MaxParts),
                IsTruncated:          listObjectPartsRes.IsTruncated,
        }
        data.Parts = make([]datatype.Part, 0)
        for _, part := range listObjectPartsRes.Parts </span><span class="cov0" title="0">{
                data.Parts = append(data.Parts, datatype.Part{
                        PartNumber:   int(part.PartNumber),
                        ETag:         part.ETag,
                        LastModified: part.LastModified,
                        Size:         part.Size,
                })
        }</span>

        <span class="cov0" title="0">encodedSuccessResponse := EncodeResponse(data)
        // Write success response.
        log.Infof("list object parts successfully.")
        WriteSuccessResponse(response, encodedSuccessResponse)</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package s3

import (
        "encoding/xml"
        "net/http"
        "github.com/emicklei/go-restful"
        log "github.com/sirupsen/logrus"
        "github.com/soda/multi-cloud/api/pkg/common"
        "github.com/soda/multi-cloud/api/pkg/policy"
        "github.com/soda/multi-cloud/s3/pkg/model"
        "github.com/soda/multi-cloud/s3/proto"
)

func (s *APIService) GetStorageClasses(request *restful.Request, response *restful.Response) <span class="cov0" title="0">{
        if !policy.Authorize(request, response, "storageclass:get") </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">log.Info("Received request for storage classes.")

        ctx := common.InitCtxWithAuthInfo(request)
        res, err := s.s3Client.GetStorageClasses(ctx, &amp;s3.BaseRequest{})
        if err != nil </span><span class="cov0" title="0">{
                response.WriteError(http.StatusInternalServerError, err)
                return
        }</span>

        <span class="cov0" title="0">tmp := model.ListStorageClasses{}
        classes := []model.StorageClass{}
        for _, v := range res.Classes </span><span class="cov0" title="0">{
                classes = append(classes, model.StorageClass{Name: v.Name, Tier: v.Tier})
        }</span>
        <span class="cov0" title="0">tmp.Classes = classes

        xmlstring, err := xml.MarshalIndent(tmp, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("parse ListStorageClasses error: %v\n", err)
                response.WriteError(http.StatusInternalServerError, err)
        }</span> else<span class="cov0" title="0"> {
                xmlstring = []byte(xml.Header + string(xmlstring))
                response.Write(xmlstring)
                log.Infof("Get List of storage classes successfully:%v\n", string(xmlstring))
        }</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package s3

import (
        "github.com/emicklei/go-restful"
        "github.com/soda/multi-cloud/api/pkg/common"
        pb "github.com/soda/multi-cloud/s3/proto"
        log "github.com/sirupsen/logrus"

        . "github.com/soda/multi-cloud/s3/error"
)

func (s *APIService) MultiPartUploadInit(request *restful.Request, response *restful.Response) <span class="cov0" title="0">{
        bucketName := request.PathParameter("bucketName")
        objectKey := request.PathParameter("objectKey")

        log.Infof("received request: multipart init, objectkey=%s, bucketName=%s\n:",
                objectKey, bucketName)

        if !isValidObjectName(objectKey) </span><span class="cov0" title="0">{
                log.Errorf("object name is not valid.")
                WriteErrorResponse(response, request, ErrInvalidObjectName)
                return
        }</span>

        <span class="cov0" title="0">acl, err := getAclFromHeader(request)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to get acl from http header, err:", err)
                WriteErrorResponse(response, request, err)
                return
        }</span>

        // Save metadata.
        <span class="cov0" title="0">attr := extractMetadataFromHeader(request)

        tier, err := getTierFromHeader(request)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to get storage class from http header. err:", err)
                WriteErrorResponse(response, request, err)
                return
        }</span>

        <span class="cov0" title="0">ctx := common.InitCtxWithAuthInfo(request)
        result, err := s.s3Client.InitMultipartUpload(ctx, &amp;pb.InitMultiPartRequest{
                BucketName: bucketName, ObjectKey: objectKey, Acl: &amp;pb.Acl{CannedAcl: acl.CannedAcl}, Tier: int32(tier), Attrs: attr})
        if HandleS3Error(response, request, err, result.GetErrorCode()) != nil </span><span class="cov0" title="0">{
                log.Errorln("unable to init multipart. err:%v, errcode:%v", err, result.ErrorCode)
                return
        }</span>

        <span class="cov0" title="0">data := GenerateInitiateMultipartUploadResponse(bucketName, objectKey, result.UploadID)
        encodedSuccessResponse := EncodeResponse(data)
        // write success response.
        WriteSuccessResponse(response, encodedSuccessResponse)

        log.Infof("Init multipart upload[bucketName=%s, objectKey=%s] successfully.\n",
                bucketName, objectKey)</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">/*
 * Minio Cloud Storage, (C) 2016 Minio, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package s3

import (
        "net/http"
        "strings"
        "time"

        . "github.com/soda/multi-cloud/s3/error"
        pb "github.com/soda/multi-cloud/s3/proto"
)

// Validates the preconditions for CopyObject, returns nil if validates
// Preconditions supported are:
//  x-amz-copy-source-if-modified-since
//  x-amz-copy-source-if-unmodified-since
//  x-amz-copy-source-if-match
//  x-amz-copy-source-if-none-match
func checkObjectPreconditions(w http.ResponseWriter, r *http.Request, object *pb.Object) error <span class="cov0" title="0">{
        // x-amz-copy-source-if-modified-since: Return the object only if it has been modified
        // since the specified time
        ifModifiedSinceHeader := r.Header.Get("x-amz-copy-source-if-modified-since")
        if ifModifiedSinceHeader != "" </span><span class="cov0" title="0">{
                givenTime, err := time.Parse(http.TimeFormat, ifModifiedSinceHeader)
                if err != nil </span><span class="cov0" title="0">{
                        return ErrInvalidPrecondition
                }</span>
                <span class="cov0" title="0">if time.Unix(object.LastModified, 0).Before(givenTime) </span><span class="cov0" title="0">{
                        // If the object is not modified since the specified time.
                        return ErrPreconditionFailed
                }</span>
        }

        // x-amz-copy-source-if-unmodified-since : Return the object only if it has not been
        // modified since the specified time
        <span class="cov0" title="0">ifUnmodifiedSinceHeader := r.Header.Get("x-amz-copy-source-if-unmodified-since")
        if ifUnmodifiedSinceHeader != "" </span><span class="cov0" title="0">{
                givenTime, err := time.Parse(http.TimeFormat, ifUnmodifiedSinceHeader)
                if err != nil </span><span class="cov0" title="0">{
                        return ErrInvalidPrecondition
                }</span>
                <span class="cov0" title="0">if time.Unix(object.LastModified, 0).After(givenTime) </span><span class="cov0" title="0">{
                        // If the object is modified since the specified time.
                        return ErrPreconditionFailed
                }</span>
        }

        // x-amz-copy-source-if-match : Return the object only if its entity tag (ETag) is the
        // same as the one specified
        <span class="cov0" title="0">ifMatchETagHeader := r.Header.Get("x-amz-copy-source-if-match")
        if ifMatchETagHeader != "" </span><span class="cov0" title="0">{
                if !isETagEqual(object.Etag, ifMatchETagHeader) </span><span class="cov0" title="0">{
                        // If the object ETag does not match with the specified ETag.
                        return ErrPreconditionFailed
                }</span>
        }

        // If-None-Match : Return the object only if its entity tag (ETag) is different from the
        // one specified
        <span class="cov0" title="0">ifNoneMatchETagHeader := r.Header.Get("x-amz-copy-source-if-none-match")
        if ifNoneMatchETagHeader != "" </span><span class="cov0" title="0">{
                if isETagEqual(object.Etag, ifNoneMatchETagHeader) </span><span class="cov0" title="0">{
                        // If the object ETag matches with the specified ETag.
                        return ErrPreconditionFailed
                }</span>
        }

        <span class="cov0" title="0">if ifNoneMatchETagHeader != "" &amp;&amp; ifUnmodifiedSinceHeader != "" </span><span class="cov0" title="0">{
                return ErrInvalidPrecondition
        }</span>
        <span class="cov0" title="0">if ifMatchETagHeader != "" &amp;&amp; ifModifiedSinceHeader != "" </span><span class="cov0" title="0">{
                return ErrInvalidPrecondition
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Validates the preconditions for GetObject/HeadObject. Returns nil if validates
// Preconditions supported are:
//  If-Modified-Since
//  If-Unmodified-Since
//  If-Match
//  If-None-Match
func checkPreconditions(header http.Header, object *pb.Object) error <span class="cov0" title="0">{
        // If-Modified-Since : Return the object only if it has been modified since the specified time,
        // otherwise return a 304 (not modified).
        ifModifiedSinceHeader := header.Get("If-Modified-Since")
        if ifModifiedSinceHeader != "" </span><span class="cov0" title="0">{
                givenTime, err := time.Parse(http.TimeFormat, ifModifiedSinceHeader)
                if err != nil </span><span class="cov0" title="0">{
                        return ErrInvalidPrecondition
                }</span>
                <span class="cov0" title="0">if time.Unix(object.LastModified, 0).Before(givenTime) </span><span class="cov0" title="0">{
                        // If the object is not modified since the specified time.
                        return ContentNotModified
                }</span>
        }

        // If-Unmodified-Since : Return the object only if it has not been modified since the specified
        // time, otherwise return a 412 (precondition failed).
        <span class="cov0" title="0">ifUnmodifiedSinceHeader := header.Get("If-Unmodified-Since")
        if ifUnmodifiedSinceHeader != "" </span><span class="cov0" title="0">{
                givenTime, err := time.Parse(http.TimeFormat, ifUnmodifiedSinceHeader)
                if err != nil </span><span class="cov0" title="0">{
                        return ErrInvalidPrecondition
                }</span>
                <span class="cov0" title="0">if time.Unix(object.LastModified, 0).After(givenTime) </span><span class="cov0" title="0">{
                        return ErrPreconditionFailed
                }</span>
        }

        // If-Match : Return the object only if its entity tag (ETag) is the same as the one specified;
        // otherwise return a 412 (precondition failed).
        <span class="cov0" title="0">ifMatchETagHeader := header.Get("If-Match")
        if ifMatchETagHeader != "" </span><span class="cov0" title="0">{
                if !isETagEqual(object.Etag, ifMatchETagHeader) </span><span class="cov0" title="0">{
                        // If the object ETag does not match with the specified ETag.
                        return ErrPreconditionFailed
                }</span>
        }

        // If-None-Match : Return the object only if its entity tag (ETag) is different from the
        // one specified otherwise, return a 304 (not modified).
        <span class="cov0" title="0">ifNoneMatchETagHeader := header.Get("If-None-Match")
        if ifNoneMatchETagHeader != "" </span><span class="cov0" title="0">{
                if isETagEqual(object.Etag, ifNoneMatchETagHeader) </span><span class="cov0" title="0">{
                        // If the object ETag matches with the specified ETag.
                        return ContentNotModified
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// canonicalizeETag returns ETag with leading and trailing double-quotes removed,
// if any present
func canonicalizeETag(etag string) string <span class="cov0" title="0">{
        canonicalETag := strings.TrimPrefix(etag, "\"")
        return strings.TrimSuffix(canonicalETag, "\"")
}</span>

// isETagEqual return true if the canonical representations of two ETag strings
// are equal, false otherwise
func isETagEqual(left, right string) bool <span class="cov0" title="0">{
        return canonicalizeETag(left) == canonicalizeETag(right)
}</span>
</pre>
		
		<pre class="file" id="file42" style="display: none">/*
 * Minio Cloud Storage, (C) 2015, 2016 Minio, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package s3

import (
        "regexp"
        "strconv"
        "strings"
        "unicode/utf8"
        "fmt"
)

// validBucket regexp.
var validBucket = regexp.MustCompile(`^[a-z0-9][a-z0-9\.\-]{1,61}[a-z0-9]$`)

// IsValidBucketName verifies a bucket name in accordance with Amazon's
// requirements. It must be 3-63 characters long, can contain dashes
// and periods, but must begin and end with a lowercase letter or a number.
// See: http://docs.aws.amazon.com/AmazonS3/latest/dev/BucketRestrictions.html
func isValidBucketName(bucketName string) bool <span class="cov8" title="1">{
        if !validBucket.MatchString(bucketName) </span><span class="cov0" title="0">{
                return false
        }</span>
        // make sure there're no continuous dots
        <span class="cov8" title="1">if strings.Contains(bucketName, "..") </span><span class="cov0" title="0">{
                return false
        }</span>
        // make sure it's not an IP address
        <span class="cov8" title="1">split := strings.Split(bucketName, ".")
        if len(split) == 4 </span><span class="cov0" title="0">{
                for _, p := range split </span><span class="cov0" title="0">{
                        n, err := strconv.Atoi(p)
                        if err == nil &amp;&amp; n &gt;= 0 &amp;&amp; n &lt;= 255 </span><span class="cov0" title="0">{
                                return false
                        }</span>
                }
        }
        <span class="cov8" title="1">return true</span>
}

// IsValidObjectName verifies an object name in accordance with Amazon's
// requirements. It cannot exceed 1024 characters and must be a valid UTF8
// string.
// Some characters require special handling:
// &amp; $ @ = ; : + (space) , ?
// and ASCII ranges 0x00-0x1F(0-31 decimal) and 7F(127 decimal)
// Some characters to avoid:
// \ { ^ } % ` [ ] ' " &lt; &gt; ~ # |
// and non-printable ASCII characters(128-255 decimal)
//
// As in YIG, we PROHIBIT ALL the characters listed above
// See http://docs.aws.amazon.com/AmazonS3/latest/dev/UsingMetadata.html
func isValidObjectName(objectName string) bool <span class="cov8" title="1">{
        if len(objectName) &lt;= 0 || len(objectName) &gt; 1024 </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">if !utf8.ValidString(objectName) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">for _, n := range objectName </span><span class="cov8" title="1">{
                if (n &gt;= 0 &amp;&amp; n &lt;= 31) || (n &gt;= 127 &amp;&amp; n &lt;= 255) </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov8" title="1">c := string(n)
                if strings.ContainsAny(c, "\\") </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

// Argument position in handler AppendObject must be non-negative integer
func checkPosition(position string) (uint64, error) <span class="cov0" title="0">{
        p, err := strconv.ParseUint(position, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">if p &lt; 0 </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("position must ben on-negative integer.")
        }</span>
        <span class="cov0" title="0">return p, nil</span>
}

func isFirstAppend(position uint64) bool <span class="cov0" title="0">{
        return position == 0
}</span>
</pre>
		
		<pre class="file" id="file43" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package s3

import (
        "encoding/xml"
        "io"
        "io/ioutil"
        "strings"

        "github.com/emicklei/go-restful"
        "github.com/journeymidnight/yig/helper"
        "github.com/soda/multi-cloud/api/pkg/common"
        "github.com/soda/multi-cloud/api/pkg/s3/datatype"
        s3error "github.com/soda/multi-cloud/s3/error"
        pb "github.com/soda/multi-cloud/s3/proto"
        log "github.com/sirupsen/logrus"
)

func (s *APIService) ObjectAclPut(request *restful.Request, response *restful.Response) <span class="cov0" title="0">{
        bucketName := strings.ToLower(request.PathParameter(common.REQUEST_PATH_BUCKET_NAME))
        objectKey := request.PathParameter(common.REQUEST_PATH_OBJECT_KEY)
        log.Infof("received request: PUT bucket[name=%s] object[name=%s] acl\n", bucketName, objectKey)

        var err error
        var acl datatype.Acl
        var policy datatype.AccessControlPolicy
        if _, ok := request.Request.Header[common.REQUEST_HEADER_ACL]; ok </span><span class="cov0" title="0">{
                acl, err = getAclFromHeader(request)
                if err != nil </span><span class="cov0" title="0">{
                        WriteErrorResponse(response, request, err)
                        return
                }</span>
        } else<span class="cov0" title="0"> {
                // because we only support canned acl, the body of request must be not too big, and 1024 is enough
                aclBuffer, err := ioutil.ReadAll(io.LimitReader(request.Request.Body, 1024))
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("unable to read acls body, err:", err)
                        WriteErrorResponse(response, request, s3error.ErrInvalidAcl)
                        return
                }</span>
                <span class="cov0" title="0">err = xml.Unmarshal(aclBuffer, &amp;policy)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("unable to parse acls xml body, err:", err)
                        WriteErrorResponse(response, request, s3error.ErrInternalError)
                        return
                }</span>
        }

        <span class="cov0" title="0">if acl.CannedAcl == "" </span><span class="cov0" title="0">{
                newCannedAcl, err := datatype.GetCannedAclFromPolicy(policy)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error("failed to get canned acl from policy. err:", err)
                        WriteErrorResponse(response, request, err)
                        return
                }</span>
                <span class="cov0" title="0">acl = newCannedAcl</span>
        }

        <span class="cov0" title="0">ctx := common.InitCtxWithAuthInfo(request)
        res, err := s.s3Client.PutObjACL(ctx, &amp;pb.PutObjACLRequest{ACLConfig: &amp;pb.ObjACL{BucketName: bucketName,
                ObjectKey: objectKey, CannedAcl: acl.CannedAcl}})
        if err != nil || res.ErrorCode != int32(s3error.ErrNoErr) </span><span class="cov0" title="0">{
                WriteErrorResponse(response, request, GetFinalError(err, res.ErrorCode))
                return
        }</span>

        <span class="cov0" title="0">log.Infoln("PUT object acl successfully.")
        WriteSuccessResponse(response, nil)</span>
}

func (s *APIService) ObjectAclGet(request *restful.Request, response *restful.Response) <span class="cov0" title="0">{
        bucketName := strings.ToLower(request.PathParameter(common.REQUEST_PATH_BUCKET_NAME))
        objectKey := request.PathParameter(common.REQUEST_PATH_OBJECT_KEY)
        log.Infof("received request: GET bucket[name=%s] object[name=%s] acl\n", bucketName, objectKey)

        ctx := common.InitCtxWithAuthInfo(request)
        object, err := s.getObjectMeta(ctx, bucketName, objectKey, "")
        if err != nil </span><span class="cov0" title="0">{
                log.Error("failed to get object[%s] meta", objectKey)
                WriteErrorResponse(response, request, err)
                return
        }</span>

        <span class="cov0" title="0">owner := datatype.Owner{ID: object.TenantId, DisplayName: object.TenantId}
        bucketOwner := datatype.Owner{}
        policy, err := datatype.CreatePolicyFromCanned(owner, bucketOwner, datatype.Acl{CannedAcl: object.Acl.CannedAcl})
        if err != nil </span><span class="cov0" title="0">{
                log.Error("failed to create policy. err:", err)
                WriteErrorResponse(response, request, err)
                return
        }</span>

        <span class="cov0" title="0">aclBuffer, err := xmlFormat(policy)
        if err != nil </span><span class="cov0" title="0">{
                helper.ErrorIf(err, "failed to marshal acl XML for bucket", bucketName)
                WriteErrorResponse(response, request, s3error.ErrInternalError)
                return
        }</span>

        <span class="cov0" title="0">setXmlHeader(response, aclBuffer)
        WriteSuccessResponse(response, aclBuffer)
        log.Infoln("GET object acl successfully.")</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package s3

import (
        "net/url"
        "strings"
        "time"

        "github.com/emicklei/go-restful"
        "github.com/micro/go-micro/client"
        "github.com/soda/multi-cloud/api/pkg/common"
        . "github.com/soda/multi-cloud/s3/error"
        "github.com/soda/multi-cloud/s3/pkg/meta/types"
        "github.com/soda/multi-cloud/s3/pkg/utils"
        pb "github.com/soda/multi-cloud/s3/proto"
        log "github.com/sirupsen/logrus"
)

func getTierFromHeader(request *restful.Request) (types.StorageClass, error) <span class="cov0" title="0">{
        storageClassStr := request.HeaderParameter(common.REQUEST_HEADER_STORAGE_CLASS)
        if storageClassStr != "" </span><span class="cov0" title="0">{
                return types.MatchStorageClassIndex(storageClassStr)
        }</span> else<span class="cov0" title="0"> {
                // If you don't specify this header, STANDARD will be used
                return utils.Tier1, nil
        }</span>
}

// ObjectCopy copy object from http header x-amz-copy-source
func (s *APIService) ObjectCopy(request *restful.Request, response *restful.Response) <span class="cov0" title="0">{
        log.Infof("received request: Copy object")

        targetBucketName := request.PathParameter(common.REQUEST_PATH_BUCKET_NAME)
        targetObjectName := request.PathParameter(common.REQUEST_PATH_OBJECT_KEY)
        //backendName := request.HeaderParameter(common.REQUEST_HEADER_STORAGE_CLASS)
        log.Infof("received request: Copy object, objectkey=%s, bucketName=%s\n:",
                targetObjectName, targetBucketName)

        // copy source is of form: /bucket-name/object-name?versionId=xxxxxx
        copySource := request.HeaderParameter(common.REQUEST_HEADER_COPY_SOURCE)
        if copySource == "" </span><span class="cov0" title="0">{
                WriteErrorResponse(response, request, ErrInvalidCopySource)
                return
        }</span>
        // Skip the first element if it is '/', split the rest.
        <span class="cov0" title="0">if strings.HasPrefix(copySource, "/") </span><span class="cov0" title="0">{
                copySource = copySource[1:]
        }</span>
        <span class="cov0" title="0">splits := strings.SplitN(copySource, "/", 2)

        // Save sourceBucket and sourceObject extracted from url Path.
        var err error
        var sourceBucketName, sourceObjectName, sourceVersion string
        if len(splits) == 2 </span><span class="cov0" title="0">{
                sourceBucketName = splits[0]
                sourceObjectName = splits[1]
        }</span> else<span class="cov0" title="0"> {
                log.Infoln("copy source should be splited at least two parts.")
                WriteErrorResponse(response, request, ErrInvalidCopySource)
                return
        }</span>
        // If source object is empty, reply back error.
        <span class="cov0" title="0">if sourceBucketName == "" || sourceObjectName == "" </span><span class="cov0" title="0">{
                WriteErrorResponse(response, request, ErrInvalidCopySource)
                return
        }</span>

        <span class="cov0" title="0">splits = strings.SplitN(sourceObjectName, "?", 2)
        if len(splits) == 2 </span><span class="cov0" title="0">{
                sourceObjectName = splits[0]
                if !strings.HasPrefix(splits[1], "versionId=") </span><span class="cov0" title="0">{
                        WriteErrorResponse(response, request, ErrInvalidCopySource)
                        return
                }</span>
                <span class="cov0" title="0">sourceVersion = strings.TrimPrefix(splits[1], "versionId=")</span>
        }

        // X-Amz-Copy-Source should be URL-encoded
        <span class="cov0" title="0">sourceBucketName, err = url.QueryUnescape(sourceBucketName)
        if err != nil </span><span class="cov0" title="0">{
                WriteErrorResponse(response, request, ErrInvalidCopySource)
                return
        }</span>
        <span class="cov0" title="0">sourceObjectName, err = url.QueryUnescape(sourceObjectName)
        if err != nil </span><span class="cov0" title="0">{
                WriteErrorResponse(response, request, ErrInvalidCopySource)
                return
        }</span>

        <span class="cov0" title="0">var isOnlyUpdateMetadata = false
        if sourceBucketName == targetBucketName &amp;&amp; sourceObjectName == targetObjectName </span><span class="cov0" title="0">{
                if request.HeaderParameter("X-Amz-Metadata-Directive") == "COPY" </span><span class="cov0" title="0">{
                        WriteErrorResponse(response, request, ErrInvalidCopyDest)
                        return
                }</span> else<span class="cov0" title="0"> if request.HeaderParameter("X-Amz-Metadata-Directive") == "REPLACE" </span><span class="cov0" title="0">{
                        isOnlyUpdateMetadata = true
                }</span> else<span class="cov0" title="0"> {
                        WriteErrorResponse(response, request, ErrInvalidRequestBody)
                        return
                }</span>
        }

        <span class="cov0" title="0">log.Infoln("sourceBucketName:", sourceBucketName, " sourceObjectName:", sourceObjectName, " sourceVersion:", sourceVersion)

        ctx := common.InitCtxWithAuthInfo(request)
        sourceObject, err := s.getObjectMeta(ctx, sourceBucketName, sourceObjectName, "")
        if err != nil </span><span class="cov0" title="0">{
                log.Errorln("unable to fetch object info. err:", err)
                WriteErrorResponse(response, request, err)
                return
        }</span>

        // Verify before x-amz-copy-source preconditions before continuing with CopyObject.
        <span class="cov0" title="0">if err = checkObjectPreconditions(response.ResponseWriter, request.Request, sourceObject); err != nil </span><span class="cov0" title="0">{
                WriteErrorResponse(response, request, err)
                return
        }</span>

        //TODO: In a versioning-enabled bucket, you cannot change the storage class of a specific version of an object. When you copy it, Amazon S3 gives it a new version ID.
        <span class="cov0" title="0">storClass, err := getTierFromHeader(request)
        if err != nil </span><span class="cov0" title="0">{
                WriteErrorResponse(response, request, err)
                return
        }</span>

        // if source == dest and X-Amz-Metadata-Directive == REPLACE, only update the meta;
        <span class="cov0" title="0">if isOnlyUpdateMetadata </span><span class="cov0" title="0">{
                log.Infoln("only update metadata.")
                targetObject := sourceObject

                //update custom attrs from headers
                newMetadata := extractMetadataFromHeader(request)
                if c, ok := newMetadata["Content-Type"]; ok </span><span class="cov0" title="0">{
                        targetObject.ContentType = c
                }</span> else<span class="cov0" title="0"> {
                        targetObject.ContentType = sourceObject.ContentType
                }</span>
                <span class="cov0" title="0">targetObject.CustomAttributes = newMetadata
                targetObject.Tier = int32(storClass)

                result, err := s.s3Client.UpdateObjectMeta(ctx, targetObject)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("unable to update object meta for %v", targetObject.ObjectId)
                        WriteErrorResponse(response, request, err)
                        return
                }</span>
                <span class="cov0" title="0">copyObjRes := GenerateCopyObjectResponse(result.Md5, time.Unix(result.LastModified, 0))
                encodedSuccessResponse := EncodeResponse(copyObjRes)
                // write headers
                if result.Md5 != "" </span><span class="cov0" title="0">{
                        response.ResponseWriter.Header()["ETag"] = []string{"\"" + result.Md5 + "\""}
                }</span>
                <span class="cov0" title="0">if sourceVersion != "" </span><span class="cov0" title="0">{
                        response.AddHeader("x-amz-copy-source-version-id", sourceVersion)
                }</span>
                <span class="cov0" title="0">if result.VersionId != "" </span><span class="cov0" title="0">{
                        response.AddHeader("x-amz-version-id", result.VersionId)
                }</span>

                <span class="cov0" title="0">log.Info("Update object meta successfully.")
                // write success response.
                WriteSuccessResponse(response, encodedSuccessResponse)
                return</span>
        }

        /// maximum Upload size for object in a single CopyObject operation.
        <span class="cov0" title="0">if isMaxObjectSize(sourceObject.Size) </span><span class="cov0" title="0">{
                WriteErrorResponseWithResource(response, request, ErrEntityTooLarge, copySource)
                return
        }</span>

        <span class="cov0" title="0">log.Infoln("srcBucket:", sourceBucketName, " srcObject:", sourceObjectName,
                " targetBucket:", targetBucketName, " targetObject:", targetObjectName)
        tmoutSec := sourceObject.Size / MiniSpeed
        opt := client.WithRequestTimeout(time.Duration(tmoutSec) * time.Second)
        result, err := s.s3Client.CopyObject(ctx, &amp;pb.CopyObjectRequest{
                SrcBucketName:    sourceBucketName,
                TargetBucketName: targetBucketName,
                SrcObjectName:    sourceObjectName,
                TargetObjectName: targetObjectName,
        }, opt)
        if HandleS3Error(response, request, err, result.GetErrorCode()) != nil </span><span class="cov0" title="0">{
                log.Errorf("unable to copy object, err=%v, errCode=%v\n", err, result.GetErrorCode())
                return
        }</span>

        <span class="cov0" title="0">copyObjRes := GenerateCopyObjectResponse(result.Md5, time.Unix(result.LastModified, 0))
        encodedSuccessResponse := EncodeResponse(copyObjRes)
        // write headers
        if result.Md5 != "" </span><span class="cov0" title="0">{
                response.ResponseWriter.Header()["ETag"] = []string{"\"" + result.Md5 + "\""}
        }</span>

        // write success response.
        <span class="cov0" title="0">WriteSuccessResponse(response, encodedSuccessResponse)
        log.Info("COPY object successfully.")</span>
}
</pre>
		
		<pre class="file" id="file45" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package s3

import (
        "strings"

        "github.com/emicklei/go-restful"
        "github.com/soda/multi-cloud/api/pkg/common"
        . "github.com/soda/multi-cloud/s3/error"
        "github.com/soda/multi-cloud/s3/proto"
        log "github.com/sirupsen/logrus"
)

func (s *APIService) ObjectDelete(request *restful.Request, response *restful.Response) <span class="cov0" title="0">{
        url := request.Request.URL
        bucketName := request.PathParameter("bucketName")
        objectName := request.PathParameter("objectKey")
        version := url.Query().Get("versionId")
        if strings.HasSuffix(url.String(), "/") </span><span class="cov0" title="0">{ // This is for folder.
                objectName = objectName + "/"
        }</span>

        <span class="cov0" title="0">if len(bucketName) == 0 </span><span class="cov0" title="0">{
                log.Errorf("invalid input, bucket=%s\n", bucketName)
                WriteErrorResponse(response, request, ErrInvalidBucketName)
                return
        }</span>
        <span class="cov0" title="0">if len(objectName) == 0 </span><span class="cov0" title="0">{
                log.Errorf("invalid input, object=%s\n", objectName)
                WriteErrorResponse(response, request, ErrInvalidObjectName)
        }</span>

        <span class="cov0" title="0">input := s3.DeleteObjectInput{Bucket: bucketName, Key: objectName}
        if len(version) &gt; 0 </span><span class="cov0" title="0">{
                input.VersioId = version
        }</span>
        <span class="cov0" title="0">ctx := common.InitCtxWithAuthInfo(request)
        rsp, err := s.s3Client.DeleteObject(ctx, &amp;input)
        if HandleS3Error(response, request, err, rsp.GetErrorCode()) != nil </span><span class="cov0" title="0">{
                log.Errorf("delete object[%s] failed, err=%v, errCode=%d\n", objectName, err, rsp.ErrorCode)
                return
        }</span>

        <span class="cov0" title="0">if rsp.DeleteMarker </span><span class="cov0" title="0">{
                response.Header().Set("x-amz-delete-marker", "true")
        }</span> else<span class="cov0" title="0"> {
                response.Header().Set("x-amz-delete-marker", "false")
        }</span>
        <span class="cov0" title="0">if rsp.VersionId != "" </span><span class="cov0" title="0">{
                response.Header().Set("x-amz-version-id", rsp.VersionId)
        }</span>

        <span class="cov0" title="0">log.Infof("delete object[%s] from bucket[%s] succeed.", objectName, bucketName)
        WriteSuccessNoContent(response)</span>
}
</pre>
		
		<pre class="file" id="file46" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package s3

import (
        "io"
        "net/http"
        "net/url"
        "time"

        "github.com/emicklei/go-restful"
        "github.com/micro/go-micro/client"
        "github.com/soda/multi-cloud/api/pkg/common"
        . "github.com/soda/multi-cloud/api/pkg/s3/datatype"
        s3error "github.com/soda/multi-cloud/s3/error"
        pb "github.com/soda/multi-cloud/s3/proto"
        log "github.com/sirupsen/logrus"
)

var MiniSpeed int64 = 5 // 5KByte/Sec

// supportedGetReqParams - supported request parameters for GET presigned request.
var supportedGetReqParams = map[string]string{
        "response-expires":             "Expires",
        "response-content-type":        "Content-Type",
        "response-cache-control":       "Cache-Control",
        "response-content-disposition": "Content-Disposition",
        "response-content-language":    "Content-Language",
        "response-content-encoding":    "Content-Encoding",
}

// setGetRespHeaders - set any requested parameters as response headers.
func setGetRespHeaders(w http.ResponseWriter, reqParams url.Values) <span class="cov0" title="0">{
        for k, v := range reqParams </span><span class="cov0" title="0">{
                if header, ok := supportedGetReqParams[k]; ok </span><span class="cov0" title="0">{
                        w.Header()[header] = v
                }</span>
        }
}

// GetObjectHandler - GET Object
func (s *APIService) ObjectGet(request *restful.Request, response *restful.Response) <span class="cov0" title="0">{
        bucketName := request.PathParameter("bucketName")
        objectKey := request.PathParameter("objectKey")
        rangestr := request.HeaderParameter("Range")
        log.Infof("%v\n", rangestr)

        ctx := common.InitCtxWithAuthInfo(request)
        object, err := s.getObjectMeta(ctx, bucketName, objectKey, "")
        if err != nil </span><span class="cov0" title="0">{
                log.Errorln("get object meta failed. err:", err)
                WriteErrorResponse(response, request, err)
                return
        }</span>

        // Get request range.
        <span class="cov0" title="0">var hrange *HttpRange
        rangeHeader := request.HeaderParameter("Range")
        if rangeHeader != "" </span><span class="cov0" title="0">{
                if hrange, err = ParseRequestRange(rangeHeader, object.Size); err != nil </span><span class="cov0" title="0">{
                        // Handle only ErrorInvalidRange
                        // Ignore other parse error and treat it as regular Get request like Amazon S3.
                        if err == ErrorInvalidRange </span><span class="cov0" title="0">{
                                WriteErrorResponse(response, request, s3error.ErrInvalidRange)
                                return
                        }</span>
                        // log the error.
                        <span class="cov0" title="0">log.Errorln("invalid request range, err:", err)</span>
                }
        }

        // Validate pre-conditions if any.
        <span class="cov0" title="0">if err = checkPreconditions(request.Request.Header, object); err != nil </span><span class="cov0" title="0">{
                // set object-related metadata headers
                response.AddHeader("Last-Modified", time.Unix(object.LastModified, 0).UTC().Format(http.TimeFormat))

                if object.Etag != "" </span><span class="cov0" title="0">{
                        response.ResponseWriter.Header()["ETag"] = []string{"\"" + object.Etag + "\""}
                }</span>
                <span class="cov0" title="0">if err == s3error.ContentNotModified </span><span class="cov0" title="0">{ // write only header if is a 304
                        WriteErrorResponseHeaders(response, err)
                }</span> else<span class="cov0" title="0"> {
                        WriteErrorResponse(response, request, err)
                }</span>
                <span class="cov0" title="0">return</span>
        }

        // Get the object.
        <span class="cov0" title="0">startOffset := int64(0)
        length := object.Size
        if hrange != nil </span><span class="cov0" title="0">{
                startOffset = hrange.OffsetBegin
                length = hrange.GetLength()
        }</span>
        <span class="cov0" title="0">tmoutSec := object.Size / MiniSpeed
        opt := client.WithRequestTimeout(time.Duration(tmoutSec) * time.Second)
        stream, err := s.s3Client.GetObject(ctx, &amp;pb.GetObjectInput{Bucket: bucketName, Key: objectKey, Offset: startOffset, Length: length}, opt)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorln("get object failed, err:%v", err)
                WriteErrorResponse(response, request, err)
                return
        }</span>
        <span class="cov0" title="0">defer stream.Close()

        // Indicates if any data was written to the http.ResponseWriter
        dataWritten := false
        // io.Writer type which keeps track if any data was written.
        writer := func(p []byte) (int, error) </span><span class="cov0" title="0">{
                if !dataWritten </span><span class="cov0" title="0">{
                        // Set headers on the first write.
                        // Set standard object headers.
                        SetObjectHeaders(response, object, hrange)

                        // Set any additional requested response headers.
                        setGetRespHeaders(response.ResponseWriter, request.Request.URL.Query())
                        dataWritten = true
                }</span>
                <span class="cov0" title="0">n, err := response.Write(p)
                return n, err</span>
        }

        <span class="cov0" title="0">s3err := int32(s3error.ErrNoErr)
        eof := false
        left := length
        for !eof &amp;&amp; left &gt; 0 </span><span class="cov0" title="0">{
                rsp, err := stream.Recv()
                if err != nil &amp;&amp; err != io.EOF </span><span class="cov0" title="0">{
                        log.Errorln("recv err", err)
                        break</span>
                }
                // If err is equal to EOF, a non-zero number of bytes may be returned.
                // the err is set EOF, returned data is processed at the subsequent code.
                <span class="cov0" title="0">if err == io.EOF </span><span class="cov0" title="0">{
                        eof = true
                }</span>
                // It indicate that there is a error from grpc server.
                <span class="cov0" title="0">if rsp.ErrorCode != int32(s3error.ErrNoErr) </span><span class="cov0" title="0">{
                        s3err = rsp.ErrorCode
                        log.Errorf("received s3 service error, error code:%v", rsp.ErrorCode)
                        break</span>
                }
                // If there is no data in rsp.Data, it show that there is no more data to receive
                <span class="cov0" title="0">if len(rsp.Data) == 0 </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">_, err = writer(rsp.Data)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorln("failed to write data to client. err:", err)
                        break</span>
                }
                <span class="cov0" title="0">left -= int64(len(rsp.Data))</span>
        }
        <span class="cov0" title="0">log.Debugf("left bytes=%d\n", left)

        if !dataWritten </span><span class="cov0" title="0">{
                if s3err == int32(s3error.ErrNoErr) </span><span class="cov0" title="0">{
                        writer(nil)
                }</span> else<span class="cov0" title="0"> {
                        WriteErrorResponse(response, request, s3error.S3ErrorCode(s3err))
                        return
                }</span>
        }

        <span class="cov0" title="0">log.Infof("Get object[%s] end.\n", objectKey)</span>
}

func (s *APIService) HeadObject(request *restful.Request, response *restful.Response) <span class="cov0" title="0">{
        bucketName := request.PathParameter("bucketName")
        objectKey := request.PathParameter("objectKey")
        versionId := request.Request.URL.Query().Get("versionId")
        log.Infof("Received request for head object: bucket=%s, objectkey=%s, version=%s\n", bucketName, objectKey, versionId)

        ctx := common.InitCtxWithAuthInfo(request)
        object, err := s.getObjectMeta(ctx, bucketName, objectKey, versionId)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("head object[bucketname=%s, key=%s] failed, err=%v\n", bucketName, objectKey, err)
                WriteErrorResponse(response, request, err)
                return
        }</span>

        <span class="cov0" title="0">if object.DeleteMarker </span><span class="cov0" title="0">{
                response.Header().Set("x-amz-delete-marker", "true")
                log.Errorf("object[bucketname=%s, key=%s] is marked as deleted\n", bucketName, objectKey)
                WriteErrorResponse(response, request, s3error.ErrNoSuchKey)
                return
        }</span>

        // Get request range.
        <span class="cov0" title="0">rangeHeader := request.Request.Header.Get("Range")
        if rangeHeader != "" </span><span class="cov0" title="0">{
                if _, err = ParseRequestRange(rangeHeader, object.Size); err != nil </span><span class="cov0" title="0">{
                        // Handle only ErrorInvalidRange
                        // Ignore other parse error and treat it as regular Get request like Amazon S3.
                        if err == ErrorInvalidRange </span><span class="cov0" title="0">{
                                WriteErrorResponse(response, request, s3error.ErrInvalidRange)
                                log.Errorf("invalid request range: %s\n", rangeHeader)
                                return
                        }</span>
                }
        }

        // Validate pre-conditions if any.
        <span class="cov0" title="0">if err = checkPreconditions(request.Request.Header, object); err != nil </span><span class="cov0" title="0">{
                // set object-related metadata headers
                response.Header().Set("Last-Modified", time.Unix(object.LastModified, 0).Format(http.TimeFormat))

                if object.Etag != "" </span><span class="cov0" title="0">{
                        response.Header()["ETag"] = []string{"\"" + object.Etag + "\""}
                }</span>
                <span class="cov0" title="0">if err == s3error.ContentNotModified </span><span class="cov0" title="0">{ // write only header if is a 304
                        log.Infof("content not modifed")
                        WriteErrorResponseHeaders(response, err)
                }</span> else<span class="cov0" title="0"> {
                        log.Errorln("head object failed, err:", err)
                        WriteErrorResponse(response, request, err)
                }</span>
                <span class="cov0" title="0">return</span>
        }

        // TODO: add sse header to response

        <span class="cov0" title="0">log.Debugf("object:%+v\n", object)
        // Set standard object headers.
        SetObjectHeaders(response, object, nil)

        // Successful response.
        response.WriteHeader(http.StatusOK)</span>
}
</pre>
		
		<pre class="file" id="file47" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package s3

import (
        "net/url"
        "strconv"
        "strings"

        "github.com/emicklei/go-restful"
        "github.com/journeymidnight/yig/helper"
        "github.com/soda/multi-cloud/api/pkg/common"
        "github.com/soda/multi-cloud/api/pkg/s3/datatype"
        . "github.com/soda/multi-cloud/s3/error"

        pb "github.com/soda/multi-cloud/s3/proto"
        log "github.com/sirupsen/logrus"
)

// ObjectPartCopy copy object from http header x-amz-copy-source as a part for multipart
func (s *APIService) ObjectPartCopy(request *restful.Request, response *restful.Response) <span class="cov0" title="0">{
        targetBucketName := request.PathParameter(common.REQUEST_PATH_BUCKET_NAME)
        targetObjectName := request.PathParameter(common.REQUEST_PATH_OBJECT_KEY)

        log.Infof("received request: Copy object part, target bucket[%v], target object[%s]", targetBucketName, targetObjectName)

        if !isValidObjectName(targetObjectName) </span><span class="cov0" title="0">{
                log.Errorln("target object name is invalid. ")
                WriteErrorResponse(response, request, ErrInvalidObjectName)
                return
        }</span>

        <span class="cov0" title="0">uploadID := request.QueryParameter("uploadId")
        partIDString := request.QueryParameter("partNumber")
        partID, err := strconv.Atoi(partIDString)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to convert part id string[%s] to integer, err:%v", partIDString, err)
                WriteErrorResponse(response, request, ErrInvalidPart)
                return
        }</span>
        // check partID with maximum part ID for multipart objects
        <span class="cov0" title="0">if isMaxPartID(partID) </span><span class="cov0" title="0">{
                log.Errorln("part ID is greater than the maximum allowed ID.")
                WriteErrorResponse(response, request, ErrInvalidMaxParts)
                return
        }</span>

        // copy source is of form: /bucket-name/object-name?versionId=xxxxxx
        <span class="cov0" title="0">copySource := request.HeaderParameter(common.REQUEST_HEADER_COPY_SOURCE)

        // Skip the first element if it is '/', split the rest.
        if strings.HasPrefix(copySource, "/") </span><span class="cov0" title="0">{
                copySource = copySource[1:]
        }</span>
        <span class="cov0" title="0">splits := strings.SplitN(copySource, "/", 2)

        // Save sourceBucket and sourceObject extracted from url Path.
        var sourceBucketName, sourceObjectName string
        if len(splits) == 2 </span><span class="cov0" title="0">{
                sourceBucketName = splits[0]
                sourceObjectName = splits[1]
        }</span> else<span class="cov0" title="0"> {
                log.Infoln("copy source should be splited at least two parts.")
                WriteErrorResponse(response, request, ErrInvalidCopySource)
                return
        }</span>
        // If source object is empty, reply back error.
        <span class="cov0" title="0">if sourceBucketName == "" || sourceObjectName == "" </span><span class="cov0" title="0">{
                log.Errorln("there is no string for sourceBucketName or sourceObjectName.")
                WriteErrorResponse(response, request, ErrInvalidCopySource)
                return
        }</span>

        <span class="cov0" title="0">splits = strings.SplitN(sourceObjectName, "?", 2)
        if len(splits) &gt; 1 </span><span class="cov0" title="0">{
                // we dont support source object name that has "?"
                log.Errorln("we dont support source object name that has ?")
                WriteErrorResponse(response, request, ErrNotImplemented)
                return
        }</span>

        // X-Amz-Copy-Source should be URL-encoded
        <span class="cov0" title="0">sourceBucketName, err = url.QueryUnescape(sourceBucketName)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorln("failed to QueryUnescape. err:", err)
                WriteErrorResponse(response, request, ErrInvalidCopySource)
                return
        }</span>
        <span class="cov0" title="0">sourceObjectName, err = url.QueryUnescape(sourceObjectName)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorln("failed to QueryUnescape. err:", err)
                WriteErrorResponse(response, request, ErrInvalidCopySource)
                return
        }</span>

        <span class="cov0" title="0">ctx := common.InitCtxWithAuthInfo(request)
        getObjMetaRes, err := s.s3Client.GetObjectMeta(ctx, &amp;pb.Object{
                ObjectKey:  sourceObjectName,
                BucketName: sourceBucketName,
        })
        if HandleS3Error(response, request, err, getObjMetaRes.GetErrorCode()) != nil </span><span class="cov0" title="0">{
                log.Errorf("unable to fetch object meta. err:%v, errCode:%v", err, getObjMetaRes.ErrorCode)
                return
        }</span>

        // Verify before x-amz-copy-source preconditions before continuing with CopyObject.
        <span class="cov0" title="0">if err = checkObjectPreconditions(response.ResponseWriter, request.Request, getObjMetaRes.Object); err != nil </span><span class="cov0" title="0">{
                log.Infof("failed to check object preconditions. err:", err)
                WriteErrorResponse(response, request, err)
                return
        }</span>

        <span class="cov0" title="0">var readOffset, readLength int64
        copySourceRangeString := request.HeaderParameter(common.REQUEST_HEADER_COPY_SOURCE_RANGE)
        if copySourceRangeString == "" </span><span class="cov0" title="0">{
                readOffset = 0
                readLength = getObjMetaRes.Object.Size
        }</span> else<span class="cov0" title="0"> {
                copySourceRange, err := datatype.ParseRequestRange(copySourceRangeString, getObjMetaRes.Object.Size)
                if err != nil </span><span class="cov0" title="0">{
                        helper.ErrorIf(err, "Invalid request range, err:", err)
                        WriteErrorResponse(response, request, ErrInvalidRange)
                        return
                }</span>
                <span class="cov0" title="0">readOffset = copySourceRange.OffsetBegin
                readLength = copySourceRange.GetLength()</span>
        }
        <span class="cov0" title="0">if isMaxObjectSize(readLength) </span><span class="cov0" title="0">{
                log.Errorf("object size is too large. size:%v", readLength)
                WriteErrorResponseWithResource(response, request, ErrEntityTooLarge, copySource)
                return
        }</span>

        <span class="cov0" title="0">result, err := s.s3Client.CopyObjPart(ctx, &amp;pb.CopyObjPartRequest{
                TargetBucket: targetBucketName,
                TargetObject: targetObjectName,
                SourceObject: sourceObjectName,
                SourceBucket: sourceBucketName,
                UploadID:     uploadID,
                PartID:       int64(partID),
                ReadOffset:   readOffset,
                ReadLength:   readLength,
        })
        if HandleS3Error(response, request, err, result.ErrorCode) != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to copy object part s3. err:%v, errCode:%v", err, result.ErrorCode)
                return
        }</span>

        <span class="cov0" title="0">data := GenerateCopyObjectPartResponse(result.Etag, result.LastModified)
        encodedSuccessResponse := EncodeResponse(data)
        // write headers
        if result.Etag != "" </span><span class="cov0" title="0">{
                response.ResponseWriter.Header()["ETag"] = []string{"\"" + result.Etag + "\""}
        }</span>
        <span class="cov0" title="0">log.Infoln("copy object part successfully.")
        // write success response.
        WriteSuccessResponse(response, encodedSuccessResponse)</span>
}
</pre>
		
		<pre class="file" id="file48" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package s3

import (
        "io"
        "net/http"
        "net/url"
        "strconv"

        "github.com/emicklei/go-restful"
        "github.com/soda/multi-cloud/api/pkg/common"
        "github.com/soda/multi-cloud/api/pkg/s3/datatype"
        "github.com/soda/multi-cloud/s3/error"
        "github.com/soda/multi-cloud/s3/pkg/helper"
        "github.com/soda/multi-cloud/s3/proto"
        pb "github.com/soda/multi-cloud/s3/proto"
        log "github.com/sirupsen/logrus"
)

// handle post object according to 'https://docs.aws.amazon.com/AmazonS3/latest/API/RESTObjectPOST.html'
var ValidSuccessActionStatus = []string{"200", "201", "204"}

func (s *APIService) ObjectPost(request *restful.Request, response *restful.Response) <span class="cov0" title="0">{
        var err error
        // Here the parameter is the size of the form data that should
        // be loaded in memory, the remaining being put in temporary files.
        reader, err := request.Request.MultipartReader()
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to get reader from post request, err: %v", err)
                WriteErrorResponse(response, request, s3error.ErrMalformedPOSTRequest)
                return
        }</span>

        <span class="cov0" title="0">fileBody, formValues, err := extractHTTPFormValues(reader)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to extract form values, err: %v", err)
                WriteErrorResponse(response, request, s3error.ErrMalformedPOSTRequest)
                return
        }</span>
        <span class="cov0" title="0">objectKey := formValues[common.REQUEST_FORM_KEY]
        if !isValidObjectName(objectKey) </span><span class="cov0" title="0">{
                log.Errorf("got invalid object key: %s", objectKey)
                WriteErrorResponse(response, request, s3error.ErrInvalidObjectName)
                return
        }</span>

        <span class="cov0" title="0">bucketName := request.PathParameter(common.REQUEST_PATH_BUCKET_NAME)
        backendName := request.HeaderParameter(common.REQUEST_HEADER_STORAGE_CLASS)
        formValues[common.REQUEST_FORM_BUCKET] = bucketName

        // check if specific bucket exist
        ctx := common.InitCtxWithAuthInfo(request)
        bucketMeta, err := s.getBucketMeta(ctx, bucketName)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to get bucket meta. err: %v", err)
                WriteErrorResponse(response, request, err)
                return
        }</span>
        <span class="cov0" title="0">location := bucketMeta.DefaultLocation
        if backendName != "" </span><span class="cov0" title="0">{
                // check if backend exist
                if s.isBackendExist(ctx, backendName) == false </span><span class="cov0" title="0">{
                        log.Errorf("backend %s for bucket %s doesn't exist", backendName, bucketName)
                        WriteErrorResponse(response, request, s3error.ErrGetBackendFailed)
                        return
                }</span>
                <span class="cov0" title="0">location = backendName</span>
        }

        <span class="cov0" title="0">metadata := extractMetadataFromHeader(request)

        acl, err := getAclFromFormValues(formValues)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to get acl from from values, err: %v", err)
                WriteErrorResponse(response, request, s3error.ErrInvalidCannedAcl)
                return
        }</span>

        <span class="cov0" title="0">buf := make([]byte, ChunkSize)
        eof := false
        stream, err := s.s3Client.PutObject(ctx)
        defer stream.Close()
        obj := pb.PutObjectRequest{
                BucketName: bucketName,
                ObjectKey:  objectKey,
                Acl:        &amp;pb.Acl{CannedAcl: acl.CannedAcl},
                Attrs:      metadata,
                Location:   location,
                Size:       -1,
        }
        err = stream.SendMsg(&amp;obj)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to call grpc PutObject(%v), err: %v", obj, err)
                WriteErrorResponse(response, request, s3error.ErrInternalError)
                return
        }</span>
        <span class="cov0" title="0">for !eof </span><span class="cov0" title="0">{
                n, err := fileBody.Read(buf)
                if err != nil &amp;&amp; err != io.EOF </span><span class="cov0" title="0">{
                        log.Errorf("read error:%v", err)
                        break</span>
                }
                <span class="cov0" title="0">if err == io.EOF </span><span class="cov0" title="0">{
                        log.Debugln("finished read")
                        eof = true
                }</span>
                <span class="cov0" title="0">err = stream.Send(&amp;s3.PutDataStream{Data: buf[:n]})
                if err != nil </span><span class="cov0" title="0">{
                        log.Infof("stream send error: %v", err)
                        break</span>
                }
                // make sure that the grpc server receives the EOF.
                <span class="cov0" title="0">if eof </span><span class="cov0" title="0">{
                        stream.Send(&amp;s3.PutDataStream{Data: buf[0:0]})
                }</span>
        }

        // if read or send data failed, then close stream and return error
        <span class="cov0" title="0">if !eof </span><span class="cov0" title="0">{
                log.Errorf("failed to send data to put object.")
                WriteErrorResponse(response, request, s3error.ErrInternalError)
                return
        }</span>

        <span class="cov0" title="0">result := &amp;s3.PutObjectResponse{}
        err = stream.RecvMsg(result)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("stream receive message failed:%v\n", err)
                WriteErrorResponse(response, request, s3error.ErrInternalError)
                return
        }</span>

        <span class="cov0" title="0">log.Info("succeed to put object data for post object request.")
        if result.Md5 != "" </span><span class="cov0" title="0">{
                response.Header().Set("ETag", "\""+result.Md5+"\"")
        }</span>

        <span class="cov0" title="0">var redirect string
        redirect, _ = formValues["Success_action_redirect"]
        if redirect == "" </span><span class="cov0" title="0">{
                redirect, _ = formValues["redirect"]
        }</span>
        <span class="cov0" title="0">if redirect != "" </span><span class="cov0" title="0">{
                redirectUrl, err := url.Parse(redirect)
                if err == nil </span><span class="cov0" title="0">{
                        redirectUrl.Query().Set("bucket", bucketName)
                        redirectUrl.Query().Set("key", objectKey)
                        redirectUrl.Query().Set("etag", result.Md5)
                        http.Redirect(response, request.Request, redirectUrl.String(), http.StatusSeeOther)
                        return
                }</span>
                // If URL is Invalid, ignore the redirect field
        }

        <span class="cov0" title="0">var status string
        status, _ = formValues["Success_action_status"]
        if !helper.StringInSlice(status, ValidSuccessActionStatus) </span><span class="cov0" title="0">{
                status = "204"
        }</span>

        <span class="cov0" title="0">statusCode, _ := strconv.Atoi(status)
        switch statusCode </span>{
        case 200, 204:<span class="cov0" title="0">
                response.WriteHeader(statusCode)</span>
        case 201:<span class="cov0" title="0">
                encodedSuccessResponse := EncodeResponse(datatype.PostResponse{
                        // TODO the full accessable url is needed.
                        Location: "/" + bucketName + "/" + objectKey,
                        Bucket:   bucketName,
                        Key:      objectKey,
                        ETag:     result.Md5,
                })
                response.WriteHeader(201)
                response.Write(encodedSuccessResponse)</span>
        }

}
</pre>
		
		<pre class="file" id="file49" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package s3

import (
        "encoding/hex"
        "errors"
        "fmt"
        "io"
        "strconv"
        "strings"

        "github.com/emicklei/go-restful"
        "github.com/soda/multi-cloud/api/pkg/common"
        "github.com/soda/multi-cloud/s3/error"
        "github.com/soda/multi-cloud/s3/proto"
        pb "github.com/soda/multi-cloud/s3/proto"
        log "github.com/sirupsen/logrus"
)

var ChunkSize int = 2048

//ObjectPut -
func (s *APIService) ObjectPut(request *restful.Request, response *restful.Response) <span class="cov8" title="1">{
        bucketName := request.PathParameter(common.REQUEST_PATH_BUCKET_NAME)
        objectKey := request.PathParameter(common.REQUEST_PATH_OBJECT_KEY)
        backendName := request.HeaderParameter(common.REQUEST_HEADER_STORAGE_CLASS)
        url := request.Request.URL
        if strings.HasSuffix(url.String(), "/") </span><span class="cov0" title="0">{
                objectKey = objectKey + "/"
        }</span>
        <span class="cov8" title="1">log.Infof("received request: PUT object, objectkey=%s, bucketName=%s\n:",
                objectKey, bucketName)

        //var authType = signature.GetRequestAuthType(r)
        var err error
        if !isValidObjectName(objectKey) </span><span class="cov0" title="0">{
                WriteErrorResponse(response, request, s3error.ErrInvalidObjectName)
                return
        }</span>

        // get size
        <span class="cov8" title="1">size, err := getSize(request, response)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if size == -1 </span><span class="cov0" title="0">{
                WriteErrorResponse(response, request, s3error.ErrMissingContentLength)
                return
        }</span>

        // maximum Upload size for objects in a single operation
        <span class="cov8" title="1">if isMaxObjectSize(size) </span><span class="cov0" title="0">{
                WriteErrorResponse(response, request, s3error.ErrEntityTooLarge)
                return
        }</span>

        // Save metadata.
        <span class="cov8" title="1">metadata := extractMetadataFromHeader(request)
        // Get Content-Md5 sent by client and verify if valid
        if _, ok := request.Request.Header["Content-Md5"]; !ok </span><span class="cov8" title="1">{
                metadata["md5Sum"] = ""
        }</span> else<span class="cov0" title="0"> {
                if len(request.Request.Header.Get("Content-Md5")) == 0 </span><span class="cov0" title="0">{
                        log.Infoln("Content Md5 is null!")
                        WriteErrorResponse(response, request, s3error.ErrInvalidDigest)
                        return
                }</span>
                <span class="cov0" title="0">md5Bytes, err := checkValidMD5(request.Request.Header.Get("Content-Md5"))
                if err != nil </span><span class="cov0" title="0">{
                        log.Infoln("Content Md5 is invalid!")
                        WriteErrorResponse(response, request, s3error.ErrInvalidDigest)
                        return
                }</span> else<span class="cov0" title="0"> {
                        metadata["md5Sum"] = hex.EncodeToString(md5Bytes)
                }</span>
        }

        <span class="cov8" title="1">acl, err := getAclFromHeader(request)
        if err != nil </span><span class="cov0" title="0">{
                WriteErrorResponse(response, request, err)
                return
        }</span>

        // check if specific bucket exist
        <span class="cov8" title="1">ctx := common.InitCtxWithAuthInfo(request)
        bucketMeta, err := s.getBucketMeta(ctx, bucketName)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorln("failed to get bucket meta. err:", err)
                WriteErrorResponse(response, request, err)
                return
        }</span>
        //log.Logf("bucket, acl:%f", bucketMeta.Acl.CannedAcl)
        <span class="cov8" title="1">location := bucketMeta.DefaultLocation
        if backendName != "" </span><span class="cov0" title="0">{
                // check if backend exist
                if s.isBackendExist(ctx, backendName) == false </span><span class="cov0" title="0">{
                        WriteErrorResponse(response, request, s3error.ErrGetBackendFailed)
                        return
                }</span>
                <span class="cov0" title="0">location = backendName</span>
        }

        <span class="cov8" title="1">var limitedDataReader io.Reader
        if size &gt; 0 </span><span class="cov8" title="1">{ // request.ContentLength is -1 if length is unknown
                limitedDataReader = io.LimitReader(request.Request.Body, size)
        }</span> else<span class="cov0" title="0"> {
                limitedDataReader = request.Request.Body
        }</span>

        <span class="cov8" title="1">buf := make([]byte, ChunkSize)
        eof := false
        stream, err := s.s3Client.PutObject(ctx)
        defer stream.Close()
        obj := pb.PutObjectRequest{
                BucketName: bucketName,
                ObjectKey:  objectKey,
                Acl:        &amp;pb.Acl{CannedAcl: acl.CannedAcl},
                Attrs:      metadata,
                Location:   location,
                Size:       size,
        }
        err = stream.SendMsg(&amp;obj)
        if err != nil </span><span class="cov0" title="0">{
                WriteErrorResponse(response, request, s3error.ErrInternalError)
                return
        }</span>
        <span class="cov8" title="1">for !eof </span><span class="cov8" title="1">{
                n, err := limitedDataReader.Read(buf)
                if err != nil &amp;&amp; err != io.EOF </span><span class="cov0" title="0">{
                        log.Errorf("read error:%v\n", err)
                        break</span>
                }
                <span class="cov8" title="1">if err == io.EOF </span><span class="cov8" title="1">{
                        log.Debugln("finished read")
                        eof = true
                }</span>
                <span class="cov8" title="1">err = stream.Send(&amp;s3.PutDataStream{Data: buf[:n]})

                if err != nil </span><span class="cov0" title="0">{
                        log.Infof("stream send error: %v\n", err)
                        break</span>
                }
        }

        // if read or send data failed, then close stream and return error
        <span class="cov8" title="1">if !eof </span><span class="cov0" title="0">{
                WriteErrorResponse(response, request, s3error.ErrInternalError)
                return
        }</span>

        // TODO: is this the right way to get response?
        <span class="cov8" title="1">rsp := &amp;s3.PutObjectResponse{}
        err = stream.RecvMsg(rsp)
        if err != nil </span><span class="cov0" title="0">{
                log.Infof("stream receive message failed:%v\n", err)
                WriteErrorResponse(response, request, s3error.ErrInternalError)
        }</span>

        <span class="cov8" title="1">log.Info("PUT object successfully.")
        WriteSuccessResponse(response, nil)</span>
}

func getSize(request *restful.Request, response *restful.Response) (int64, error) <span class="cov8" title="1">{
        // get content-length
        contentLenght := request.HeaderParameter(common.REQUEST_HEADER_CONTENT_LENGTH)
        size, err := strconv.ParseInt(contentLenght, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                log.Infof("parse contentLenght[%s] failed, err:%v\n", contentLenght, err)
                WriteErrorResponse(response, request, s3error.ErrMissingContentLength)
                return 0, err
        }</span>

        <span class="cov8" title="1">log.Infof("object size is %v\n", size)

        if size &gt; common.MaxObjectSize </span><span class="cov0" title="0">{
                log.Infof("invalid contentLenght:%s\n", contentLenght)
                errMsg := fmt.Sprintf("invalid contentLenght[%s], it should be less than %d and more than 0",
                        contentLenght, common.MaxObjectSize)
                err := errors.New(errMsg)
                WriteErrorResponse(response, request, err)
                return size, err
        }</span>

        <span class="cov8" title="1">return size, nil</span>
}
</pre>
		
		<pre class="file" id="file50" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package s3

import (
        "github.com/emicklei/go-restful"
        "github.com/soda/multi-cloud/api/pkg/policy"
)

func (s *APIService) RouteBucketDelete(request *restful.Request, response *restful.Response) <span class="cov0" title="0">{
        if !policy.Authorize(request, response, "bucket:delete") </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if IsQuery(request, "acl") </span>{<span class="cov0" title="0">
                //TODO
        }</span> else<span class="cov0" title="0"> if IsQuery(request, "versioning") </span>{<span class="cov0" title="0">
                //TODO
        }</span> else<span class="cov0" title="0"> if IsQuery(request, "website") </span>{<span class="cov0" title="0">
                //TODO
        }</span> else<span class="cov0" title="0"> if IsQuery(request, "cors") </span>{<span class="cov0" title="0">
                //TODO

        }</span> else<span class="cov0" title="0"> if IsQuery(request, "replication") </span>{<span class="cov0" title="0">
                //TODO

        }</span> else<span class="cov0" title="0"> if IsQuery(request, "lifecycle") </span><span class="cov0" title="0">{
                s.BucketLifecycleDelete(request, response)

        }</span> else<span class="cov0" title="0"> {
                s.BucketDelete(request, response)
        }</span>
}
</pre>
		
		<pre class="file" id="file51" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package s3

import (
        "github.com/emicklei/go-restful"
        "github.com/soda/multi-cloud/api/pkg/policy"
)

func (s *APIService) RouteBucketGet(request *restful.Request, response *restful.Response) <span class="cov8" title="1">{
        if !policy.Authorize(request, response, "bucket:get") </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if IsQuery(request, "acl") </span><span class="cov8" title="1">{
                s.BucketAclGet(request, response)
        }</span> else<span class="cov8" title="1"> if IsQuery(request, "uploads") </span><span class="cov0" title="0">{
                s.ListBucketUploadRecords(request, response)
        }</span> else<span class="cov8" title="1"> if IsQuery(request, "versioning") </span>{<span class="cov0" title="0">
                //TODO
        }</span> else<span class="cov8" title="1"> if IsQuery(request, "website") </span>{<span class="cov0" title="0">
                //TODO
        }</span> else<span class="cov8" title="1"> if IsQuery(request, "cors") </span>{<span class="cov0" title="0">
                //TODO

        }</span> else<span class="cov8" title="1"> if IsQuery(request, "replication") </span>{<span class="cov0" title="0">
                //TODO

        }</span> else<span class="cov8" title="1"> if IsQuery(request, "lifecycle") </span><span class="cov8" title="1">{
                s.BucketLifecycleGet(request, response)

        }</span> else<span class="cov8" title="1"> {
                s.BucketGet(request, response)
        }</span>
}
</pre>
		
		<pre class="file" id="file52" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package s3

import (
        "github.com/emicklei/go-restful"
        "github.com/soda/multi-cloud/api/pkg/policy"
)

func (s *APIService) RouteBucketHead(request *restful.Request, response *restful.Response) <span class="cov0" title="0">{
        if !policy.Authorize(request, response, "bucket:get") </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">s.HeadBucket(request, response)</span>
}
</pre>
		
		<pre class="file" id="file53" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package s3

import (
        "errors"

        "github.com/emicklei/go-restful"
        "github.com/soda/multi-cloud/api/pkg/policy"
        "net/http"
)

func (s *APIService) RouteBucketPut(request *restful.Request, response *restful.Response) <span class="cov8" title="1">{
        if !policy.Authorize(request, response, "bucket:put") </span><span class="cov0" title="0">{
                response.WriteError(http.StatusMethodNotAllowed, errors.New("authorize failed"))
                return
        }</span>

        <span class="cov8" title="1">if IsQuery(request, "acl") </span><span class="cov0" title="0">{
                s.BucketAclPut(request, response)
        }</span> else<span class="cov8" title="1"> if IsQuery(request, "versioning") </span><span class="cov0" title="0">{
                s.BucketVersioningPut(request, response)
        }</span> else<span class="cov8" title="1"> if IsQuery(request, "website") </span>{<span class="cov0" title="0">
                //TODO
        }</span> else<span class="cov8" title="1"> if IsQuery(request, "cors") </span>{<span class="cov0" title="0">
                //TODO

        }</span> else<span class="cov8" title="1"> if IsQuery(request, "replication") </span>{<span class="cov0" title="0">
                //TODO

        }</span> else<span class="cov8" title="1"> if IsQuery(request, "lifecycle") </span><span class="cov0" title="0">{
                s.BucketLifecyclePut(request, response)
        }</span>  else<span class="cov8" title="1"> if IsQuery(request, "DefaultEncryption") </span><span class="cov0" title="0">{
                s.BucketSSEPut(request, response)
        }</span> else<span class="cov8" title="1"> {
                s.BucketPut(request, response)
        }</span>
}
</pre>
		
		<pre class="file" id="file54" style="display: none">package s3

import (
        "github.com/emicklei/go-restful"
        "github.com/soda/multi-cloud/api/pkg/policy"
)

func (s *APIService) RouteObjectDelete(request *restful.Request, response *restful.Response) <span class="cov0" title="0">{
        if !policy.Authorize(request, response, "object:delete") </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if IsQuery(request, "uploadId") </span><span class="cov0" title="0">{
                s.AbortMultipartUpload(request, response)
        }</span> else<span class="cov0" title="0"> {
                s.ObjectDelete(request, response)
        }</span>
}
</pre>
		
		<pre class="file" id="file55" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package s3

import (
        "github.com/emicklei/go-restful"
        "github.com/soda/multi-cloud/api/pkg/policy"
)

func (s *APIService) RouteObjectGet(request *restful.Request, response *restful.Response) <span class="cov0" title="0">{
        if !policy.Authorize(request, response, "object:get") </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">if IsQuery(request, "acl") </span><span class="cov0" title="0">{
                s.ObjectAclGet(request, response)
        }</span> else<span class="cov0" title="0"> if IsQuery(request, "uploadId") </span><span class="cov0" title="0">{
                s.ListObjectParts(request, response)
        }</span> else<span class="cov0" title="0"> {
                s.ObjectGet(request, response)
        }</span>
}</pre>
		
		<pre class="file" id="file56" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package s3

import (
        "github.com/emicklei/go-restful"
        "github.com/soda/multi-cloud/api/pkg/policy"
)

func (s *APIService) RouteObjectHead(request *restful.Request, response *restful.Response) <span class="cov0" title="0">{
        if !policy.Authorize(request, response, "object:delete") </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">s.HeadObject(request, response)</span>
}
</pre>
		
		<pre class="file" id="file57" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package s3

import (
        "regexp"

        "github.com/emicklei/go-restful"
        "github.com/soda/multi-cloud/api/pkg/common"
        "github.com/soda/multi-cloud/api/pkg/policy"
)

func (s *APIService) RouteObjectPost(request *restful.Request, response *restful.Response) <span class="cov0" title="0">{
        if !policy.Authorize(request, response, "object:post") </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if IsQuery(request, "uploads") </span><span class="cov0" title="0">{
                s.MultiPartUploadInit(request, response)
        }</span> else<span class="cov0" title="0"> if IsQuery(request, "uploadId") </span><span class="cov0" title="0">{
                s.CompleteMultipartUpload(request, response)
        }</span> else<span class="cov0" title="0"> {
                // check whether it is the post object operation.
                contentType := request.HeaderParameter(common.REQUEST_HEADER_CONTENT_TYPE)
                objectPostValidate := regexp.MustCompile("multipart/form-data*")
                if contentType != "" &amp;&amp; objectPostValidate.MatchString(contentType) </span><span class="cov0" title="0">{
                        s.ObjectPost(request, response)
                        return
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file58" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package s3

import (
        "github.com/emicklei/go-restful"
        "github.com/soda/multi-cloud/api/pkg/policy"
)

func (s *APIService) RouteObjectPut(request *restful.Request, response *restful.Response) <span class="cov8" title="1">{
        if !policy.Authorize(request, response, "object:put") </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">if IsQuery(request, "acl") </span><span class="cov0" title="0">{
                s.ObjectAclPut(request, response)
        }</span> else<span class="cov8" title="1"> if IsQuery(request, "tagging") </span>{<span class="cov0" title="0">
                //TODO
        }</span> else<span class="cov8" title="1"> if IsQuery(request, "uploads") </span><span class="cov0" title="0">{
                s.MultiPartUploadInit(request, response)
        }</span> else<span class="cov8" title="1"> if IsQuery(request, "partNumber") &amp;&amp; IsQuery(request, "uploadId") &amp;&amp; HasHeader(request, "x-amz-copy-source") </span><span class="cov0" title="0">{
                s.ObjectPartCopy(request, response)
        }</span> else<span class="cov8" title="1"> if IsQuery(request, "partNumber") &amp;&amp; IsQuery(request, "uploadId") </span><span class="cov0" title="0">{
                s.UploadPart(request, response)
        }</span> else<span class="cov8" title="1"> if IsQuery(request, "uploadId") </span><span class="cov0" title="0">{
                s.CompleteMultipartUpload(request, response)
        }</span> else<span class="cov8" title="1"> if HasHeader(request, "x-amz-copy-source") </span><span class="cov0" title="0">{
                s.ObjectCopy(request, response)
        }</span> else<span class="cov8" title="1"> {
                s.ObjectPut(request, response)
        }</span>
}
</pre>
		
		<pre class="file" id="file59" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package s3

import (
        "github.com/emicklei/go-restful"
        "github.com/micro/go-micro/client"
)

//RegisterRouter - route request to appropriate method
func RegisterRouter(ws *restful.WebService) <span class="cov8" title="1">{
        handler := NewAPIService(client.DefaultClient)
        ws.Route(ws.GET("/").To(handler.ListBuckets)).Doc("Return list of buckets for the user")
        ws.Route(ws.GET("/storageClasses").To(handler.GetStorageClasses)).Doc("Return supported storage classes.")
        ws.Route(ws.PUT("/{bucketName}").To(handler.RouteBucketPut)).Doc("Create bucket for the user")
        //ws.Route(ws.HEAD("/s3/{bucketName}").To(handler.BucketHead)).Doc("Determine if bucket exists and if user has permission to access it")
        ws.Route(ws.GET("/{bucketName}").To(handler.RouteBucketGet)).Doc("Return list of objects in bucket")
        ws.Route(ws.DELETE("/{bucketName}").To(handler.RouteBucketDelete)).Doc("Delete bucket")
        ws.Route(ws.HEAD("/{bucketName}").To(handler.RouteBucketHead)).Doc("Head bucket")

        ws.Route(ws.PUT("/{bucketName}/{objectKey:*}").To(handler.RouteObjectPut)).Doc("Put object")
        ws.Route(ws.DELETE("/{bucketName}/{objectKey:*}").To(handler.RouteObjectDelete)).Doc("Delete object")
        ws.Route(ws.GET("/{bucketName}/{objectKey:*}").To(handler.RouteObjectGet)).Doc("Download object")
        ws.Route(ws.DELETE("/{bucketName}/{objectKey:*}").To(handler.RouteObjectDelete)).Doc("AbortMultipartUpload")
        ws.Route(ws.HEAD("/{bucketName}/{objectKey:*}").To(handler.RouteObjectHead)).Doc("Head object")
        ws.Route(ws.POST("/{bucketName}/{objectKey:*}").To(handler.RouteObjectPost)).Doc("Post object")
        ws.Route(ws.POST("/{bucketName}").To(handler.RouteObjectPost)).Doc("Post object")

        //Router for PUT and GET bucket lifecycle
        ws.Route(ws.PUT("/{bucketName}/?lifecycle").To(handler.RouteBucketPut)).Doc("Create lifecycle configuration for the bucket")
        ws.Route(ws.GET("/{bucketName}/?lifecycle").To(handler.RouteBucketGet)).Doc("Get lifecycle configuration from the bucket")
        ws.Route(ws.DELETE("/{bucketName}/?lifecycle").To(handler.RouteBucketDelete)).Doc("Delete lifecycle configuration from the bucket")

        ws.Route(ws.PUT("/{bucketName}/?versioning").To(handler.RouteBucketPut)).Doc("Create Versioning configuration for the bucket")

        // router for SSE
        ws.Route(ws.PUT("/{bucketName}/?DefaultEncryption").To(handler.RouteBucketPut)).Doc("Set default encryption on bucket")
}</span>
</pre>
		
		<pre class="file" id="file60" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package s3

import (
        "context"
        "io"
        "io/ioutil"
        "math"

        "github.com/emicklei/go-restful"
        "github.com/micro/go-micro/client"
        "github.com/soda/multi-cloud/backend/proto"
        backendpb "github.com/soda/multi-cloud/backend/proto"
        . "github.com/soda/multi-cloud/s3/error"
        "github.com/soda/multi-cloud/s3/proto"
        log "github.com/sirupsen/logrus"
)

const (
        s3Service      = "s3"
        backendService = "backend"
)

type APIService struct {
        s3Client      s3.S3Service
        backendClient backend.BackendService
}

func NewAPIService(c client.Client) *APIService <span class="cov8" title="1">{
        return &amp;APIService{
                s3Client:      s3.NewS3Service(s3Service, c),
                backendClient: backend.NewBackendService(backendService, c),
        }
}</span>

func IsQuery(request *restful.Request, name string) bool <span class="cov8" title="1">{
        params := request.Request.URL.Query()
        if params == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">if _, ok := params[name]; ok </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">return false</span>
}
func HasHeader(request *restful.Request, name string) bool <span class="cov8" title="1">{
        param := request.HeaderParameter(name)
        if param == "" </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov0" title="0">return true</span>
}

func ReadBody(r *restful.Request) []byte <span class="cov8" title="1">{
        var reader io.Reader = r.Request.Body
        b, e := ioutil.ReadAll(reader)
        if e != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">return b</span>
}

func (s *APIService) getBucketMeta(ctx context.Context, bucketName string) (*s3.Bucket, error) <span class="cov8" title="1">{
        rsp, err := s.s3Client.GetBucket(ctx, &amp;s3.Bucket{Name: bucketName})
        // according to gRPC framework work mechanism, if gRPC return error, then no response package can be received by
        // gRPC client, so in our codes, gRPC server will return nil and set error code to reponse package while business
        // error happens, and if gRPC client received error, that means some exception happened for gRPC itself.
        if err == nil </span><span class="cov8" title="1">{
                if rsp.ErrorCode != int32(ErrNoErr) </span><span class="cov0" title="0">{
                        err = S3ErrorCode(rsp.ErrorCode)
                }</span>
        }
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                log.Infof("get bucket meta data[bucket=%s] failed, err=%v\n", bucketName, err)
                return nil, err
        }</span>

        <span class="cov8" title="1">return rsp.BucketMeta, nil</span>
}

func (s *APIService) getObjectMeta(ctx context.Context, bucketName, objectName, versiongId string) (*s3.Object, error) <span class="cov0" title="0">{
        rsp, err := s.s3Client.GetObjectMeta(ctx, &amp;s3.Object{BucketName: bucketName, ObjectKey: objectName, VersionId: versiongId})
        // according to gRPC framework work mechanism, if gRPC return error, then no response package can be received by
        // gRPC client, so in our codes, gRPC server will return nil and set error code to reponse package while business
        // error happens, and if gRPC client received error, that means some exception happened for gRPC itself.
        if err == nil </span><span class="cov0" title="0">{
                if rsp.ErrorCode != int32(ErrNoErr) </span><span class="cov0" title="0">{
                        err = S3ErrorCode(rsp.ErrorCode)
                }</span>
        }
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                log.Infof("get object meta data[bucket=%s,key=%s] failed, err=%v\n", bucketName, objectName, err)
                return nil, err
        }</span>

        <span class="cov0" title="0">return rsp.Object, nil</span>
}

func (s *APIService) isBackendExist(ctx context.Context, backendName string) bool <span class="cov8" title="1">{
        flag := false

        backendRep, backendErr := s.backendClient.ListBackend(ctx, &amp;backendpb.ListBackendRequest{
                Offset: 0,
                Limit:  math.MaxInt32,
                Filter: map[string]string{"name": backendName}})
        log.Infof("backendErr is %v:", backendErr)
        if backendErr != nil </span><span class="cov0" title="0">{
                log.Infof("Get backend[name=%s] failed.", backendName)
        }</span> else<span class="cov8" title="1"> {
                log.Infof("backendRep=%+v\n", backendRep)
                if len(backendRep.Backends) &gt; 0 </span><span class="cov8" title="1">{
                        log.Infof("backend[name=%s] exist.", backendName)
                        flag = true
                }</span>
        }

        <span class="cov8" title="1">return flag</span>
}

func HandleS3Error(response *restful.Response, request *restful.Request, err error, errCode int32) error <span class="cov8" title="1">{
        if err != nil </span><span class="cov0" title="0">{
                WriteErrorResponse(response, request, err)
                return err
        }</span>
        <span class="cov8" title="1">if errCode != int32(ErrNoErr) </span><span class="cov8" title="1">{
                err := S3ErrorCode(errCode)
                WriteErrorResponse(response, request, err)
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file61" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package s3

import (
        "encoding/hex"
        "io"
        "strconv"

        "github.com/emicklei/go-restful"
        "github.com/soda/multi-cloud/api/pkg/common"
        . "github.com/soda/multi-cloud/s3/error"
        pb "github.com/soda/multi-cloud/s3/proto"
        log "github.com/sirupsen/logrus"
)

func (s *APIService) UploadPart(request *restful.Request, response *restful.Response) <span class="cov0" title="0">{
        bucketName := request.PathParameter("bucketName")
        objectKey := request.PathParameter("objectKey")

        var incomingMd5 string
        // get Content-Md5 sent by client and verify if valid
        md5Bytes, err := checkValidMD5(request.HeaderParameter(common.REQUEST_HEADER_CONTENT_MD5))
        if err != nil </span><span class="cov0" title="0">{
                incomingMd5 = ""
        }</span> else<span class="cov0" title="0"> {
                incomingMd5 = hex.EncodeToString(md5Bytes)
        }</span>

        <span class="cov0" title="0">size := request.Request.ContentLength
        /// maximum Upload size for multipart objects in a single operation
        if isMaxObjectSize(size) </span><span class="cov0" title="0">{
                log.Errorf("the size of object to upload is too large.")
                WriteErrorResponse(response, request, ErrEntityTooLarge)
                return
        }</span>
        <span class="cov0" title="0">log.Infoln("uploadpart size:", size)

        uploadID := request.QueryParameter("uploadId")
        partIDString := request.QueryParameter("partNumber")
        partID, err := strconv.Atoi(partIDString)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to convert part id string to integer")
                WriteErrorResponse(response, request, ErrInvalidPart)
                return
        }</span>
        // check partID with maximum part ID for multipart objects
        <span class="cov0" title="0">if isMaxPartID(partID) </span><span class="cov0" title="0">{
                log.Errorf("the part id is invalid.")
                WriteErrorResponse(response, request, ErrInvalidMaxParts)
                return
        }</span>

        <span class="cov0" title="0">ctx := common.InitCtxWithAuthInfo(request)
        stream, err := s.s3Client.UploadPart(ctx)
        defer stream.Close()

        uploadRequest := pb.UploadPartRequest{
                BucketName: bucketName,
                ObjectKey:  objectKey,
                UploadId:   uploadID,
                PartId:     int32(partID),
                Size:       size,
                Md5Hex:     incomingMd5,
        }
        err = stream.SendMsg(&amp;uploadRequest)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorln("failed send upload request msg. err:", err)
                WriteErrorResponse(response, request, err)
                return
        }</span>

        <span class="cov0" title="0">var limitedDataReader io.Reader
        if size &gt; 0 </span><span class="cov0" title="0">{ // request.ContentLength is -1 if length is unknown
                limitedDataReader = io.LimitReader(request.Request.Body, size)
        }</span> else<span class="cov0" title="0"> {
                limitedDataReader = request.Request.Body
        }</span>
        <span class="cov0" title="0">buf := make([]byte, ChunkSize)
        eof := false
        for !eof </span><span class="cov0" title="0">{
                n, err := limitedDataReader.Read(buf)
                if err != nil &amp;&amp; err != io.EOF </span><span class="cov0" title="0">{
                        log.Errorf("read error:%v\n", err)
                        break</span>
                }
                <span class="cov0" title="0">if err == io.EOF </span><span class="cov0" title="0">{
                        log.Debugln("finished read")
                        eof = true
                }</span>

                <span class="cov0" title="0">err = stream.Send(&amp;pb.PutDataStream{Data: buf[:n]})
                if err != nil </span><span class="cov0" title="0">{
                        log.Infof("stream send error: %v\n", err)
                        break</span>
                }
        }

        <span class="cov0" title="0">result := pb.UploadPartResponse{}
        err = stream.RecvMsg(&amp;result)
        if HandleS3Error(response, request, err, result.GetErrorCode()) != nil </span><span class="cov0" title="0">{
                log.Errorln("unable to recv message. err:%v, errcode:%v", err, result.ErrorCode)
                return
        }</span>

        <span class="cov0" title="0">if result.ETag != "" </span><span class="cov0" title="0">{
                response.Header()["ETag"] = []string{"\"" + result.ETag + "\""}
        }</span>

        <span class="cov0" title="0">WriteSuccessResponse(response, nil)
        log.Info("Uploadpart successfully.")</span>
}
</pre>
		
		<pre class="file" id="file62" style="display: none">/*
 * Minio Cloud Storage, (C) 2015 Minio, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package s3

import (
        "encoding/base64"
        "encoding/xml"
        "errors"
        "io"
        "net/http"
        "regexp"
        "strings"
)

// xmlDecoder provide decoded value in xml.
func xmlDecoder(body io.Reader, v interface{}) error <span class="cov0" title="0">{
        d := xml.NewDecoder(body)
        return d.Decode(v)
}</span>

// checkValidMD5 - verify if valid md5, returns md5 in bytes.
func checkValidMD5(md5 string) ([]byte, error) <span class="cov0" title="0">{
        return base64.StdEncoding.DecodeString(strings.TrimSpace(md5))
}</span>

/// http://docs.aws.amazon.com/AmazonS3/latest/dev/UploadingObjects.html
const (
        // maximum object size per PUT request is 5GiB
        maxObjectSize = 1024 * 1024 * 1024 * 5
        // minimum Part size for multipart upload is 5MB
        minPartSize = 1024 * 1024 * 5
        // maximum Part ID for multipart upload is 10000 (Acceptable values range from 1 to 10000 inclusive)
        maxPartID = 10000
)

// isMaxObjectSize - verify if max object size
func isMaxObjectSize(size int64) bool <span class="cov8" title="1">{
        return size &gt; maxObjectSize
}</span>

// Check if part size is more than or equal to minimum allowed size.
func isMinAllowedPartSize(size int64) bool <span class="cov0" title="0">{
        return size &gt;= minPartSize
}</span>

// isMaxPartNumber - Check if part ID is greater than the maximum allowed ID.
func isMaxPartID(partID int) bool <span class="cov0" title="0">{
        return partID &gt; maxPartID
}</span>

func contains(stringList []string, element string) bool <span class="cov0" title="0">{
        for _, e := range stringList </span><span class="cov0" title="0">{
                if e == element </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

/*
func requestIdFromContext(ctx context.Context) string {
        if result, ok := ctx.Value(RequestContextKey).(RequestContext); ok {
                return result.RequestId
        }
        return ""
}*/

// We support '.' with bucket names but we fallback to using path
// style requests instead for such buckets.
var (
        validBucketName       = regexp.MustCompile(`^[A-Za-z0-9][A-Za-z0-9\.\-\_\:]{1,61}[A-Za-z0-9]$`)
        validBucketNameStrict = regexp.MustCompile(`^[a-z0-9][a-z0-9\.\-]{1,61}[a-z0-9]$`)
        ipAddress             = regexp.MustCompile(`^(\d+\.){3}\d+$`)
)

// Common checker for both stricter and basic validation.
func checkBucketNameCommon(bucketName string, strict bool) (err error) <span class="cov0" title="0">{
        if strings.TrimSpace(bucketName) == "" </span><span class="cov0" title="0">{
                return errors.New("Bucket name cannot be empty")
        }</span>
        <span class="cov0" title="0">if len(bucketName) &lt; 3 </span><span class="cov0" title="0">{
                return errors.New("Bucket name cannot be smaller than 3 characters")
        }</span>
        <span class="cov0" title="0">if len(bucketName) &gt; 63 </span><span class="cov0" title="0">{
                return errors.New("Bucket name cannot be greater than 63 characters")
        }</span>
        <span class="cov0" title="0">if ipAddress.MatchString(bucketName) </span><span class="cov0" title="0">{
                return errors.New("Bucket name cannot be an ip address")
        }</span>
        <span class="cov0" title="0">if strings.Contains(bucketName, "..") </span><span class="cov0" title="0">{
                return errors.New("Bucket name contains invalid characters")
        }</span>
        <span class="cov0" title="0">if strict </span><span class="cov0" title="0">{
                if !validBucketNameStrict.MatchString(bucketName) </span><span class="cov0" title="0">{
                        err = errors.New("Bucket name contains invalid characters")
                }</span>
                <span class="cov0" title="0">return err</span>
        }
        <span class="cov0" title="0">if !validBucketName.MatchString(bucketName) </span><span class="cov0" title="0">{
                err = errors.New("Bucket name contains invalid characters")
        }</span>
        <span class="cov0" title="0">return err</span>
}

// CheckValidBucketName - checks if we have a valid input bucket name.
func CheckValidBucketName(bucketName string) (err error) <span class="cov0" title="0">{
        return checkBucketNameCommon(bucketName, false)
}</span>

func xmlFormat(data interface{}) ([]byte, error) <span class="cov8" title="1">{
        buffer, err := xml.Marshal(data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        // add XML header
        <span class="cov8" title="1">headerBytes := []byte(xml.Header)
        output := append(headerBytes, buffer...)
        return output, nil</span>
}

func setXmlHeader(w http.ResponseWriter, body []byte) <span class="cov8" title="1">{
        w.Header().Set("Content-Type", "application/xml")
}</span>

// hasServerSideEncryptionHeader returns true if the given HTTP header
// contains server-side-encryption.
/*func hasServerSideEncryptionHeader(header http.Header) bool {
        return crypto.S3.IsRequested(header) || crypto.SSEC.IsRequested(header)
}*/
</pre>
		
		<pre class="file" id="file63" style="display: none">package obs

import (
        "fmt"
        "net/url"
        "sort"
        "strings"
        "time"

        log "github.com/sirupsen/logrus"
)

func (obsClient ObsClient) doAuthTemporary(method, bucketName, objectKey string, params map[string]string,
        headers map[string][]string, expires int64) (requestUrl string, err error) <span class="cov0" title="0">{

        requestUrl, canonicalizedUrl := obsClient.conf.formatUrls(bucketName, objectKey, params, true)
        parsedRequestUrl, err := url.Parse(requestUrl)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">encodeHeaders(headers)
        hostName := parsedRequestUrl.Host

        isV4 := obsClient.conf.signature == SignatureV4
        prepareHostAndDate(headers, hostName, isV4)

        if obsClient.conf.securityProvider == nil || obsClient.conf.securityProvider.ak == "" || obsClient.conf.securityProvider.sk == "" </span><span class="cov0" title="0">{
                log.Warn("No ak/sk provided, skip to construct authorization")
        }</span> else<span class="cov0" title="0"> {
                if obsClient.conf.securityProvider.securityToken != "" </span><span class="cov0" title="0">{
                        params[HEADER_STS_TOKEN_AMZ] = obsClient.conf.securityProvider.securityToken
                }</span>

                <span class="cov0" title="0">if isV4 </span><span class="cov0" title="0">{
                        date, _ := time.Parse(RFC1123_FORMAT, headers[HEADER_DATE_CAMEL][0])
                        delete(headers, HEADER_DATE_CAMEL)
                        shortDate := date.Format(SHORT_DATE_FORMAT)
                        longDate := date.Format(LONG_DATE_FORMAT)

                        signedHeaders, _headers := getSignedHeaders(headers)

                        credential, scope := getCredential(obsClient.conf.securityProvider.ak, obsClient.conf.region, shortDate)
                        params[PARAM_ALGORITHM_AMZ_CAMEL] = V4_HASH_PREFIX
                        params[PARAM_CREDENTIAL_AMZ_CAMEL] = credential
                        params[PARAM_DATE_AMZ_CAMEL] = longDate
                        params[PARAM_EXPIRES_AMZ_CAMEL] = Int64ToString(expires)
                        params[PARAM_SIGNEDHEADERS_AMZ_CAMEL] = strings.Join(signedHeaders, ";")

                        requestUrl, canonicalizedUrl = obsClient.conf.formatUrls(bucketName, objectKey, params, true)
                        parsedRequestUrl, _ = url.Parse(requestUrl)
                        stringToSign := getV4StringToSign(method, canonicalizedUrl, parsedRequestUrl.RawQuery, scope, longDate, UNSIGNED_PAYLOAD, signedHeaders, _headers)
                        signature := getSignature(stringToSign, obsClient.conf.securityProvider.sk, obsClient.conf.region, shortDate)

                        requestUrl += fmt.Sprintf("&amp;%s=%s", PARAM_SIGNATURE_AMZ_CAMEL, UrlEncode(signature, false))

                }</span> else<span class="cov0" title="0"> {
                        originDate := headers[HEADER_DATE_CAMEL][0]
                        date, _ := time.Parse(RFC1123_FORMAT, originDate)
                        expires += date.Unix()
                        headers[HEADER_DATE_CAMEL] = []string{Int64ToString(expires)}

                        stringToSign := getV2StringToSign(method, canonicalizedUrl, headers)
                        signature := UrlEncode(Base64Encode(HmacSha1([]byte(obsClient.conf.securityProvider.sk), []byte(stringToSign))), false)
                        if strings.Index(requestUrl, "?") &lt; 0 </span><span class="cov0" title="0">{
                                requestUrl += "?"
                        }</span> else<span class="cov0" title="0"> {
                                requestUrl += "&amp;"
                        }</span>
                        <span class="cov0" title="0">delete(headers, HEADER_DATE_CAMEL)
                        requestUrl += fmt.Sprintf("AWSAccessKeyId=%s&amp;Expires=%d&amp;Signature=%s", UrlEncode(obsClient.conf.securityProvider.ak, false),
                                expires, signature)</span>
                }
        }

        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) doAuth(method, bucketName, objectKey string, params map[string]string,
        headers map[string][]string, hostName string) (requestUrl string, err error) <span class="cov0" title="0">{

        requestUrl, canonicalizedUrl := obsClient.conf.formatUrls(bucketName, objectKey, params, true)
        parsedRequestUrl, err := url.Parse(requestUrl)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">encodeHeaders(headers)

        if hostName == "" </span><span class="cov0" title="0">{
                hostName = parsedRequestUrl.Host
        }</span>

        <span class="cov0" title="0">isV4 := obsClient.conf.signature == SignatureV4
        prepareHostAndDate(headers, hostName, isV4)

        if obsClient.conf.securityProvider == nil || obsClient.conf.securityProvider.ak == "" || obsClient.conf.securityProvider.sk == "" </span><span class="cov0" title="0">{
                log.Warn("No ak/sk provided, skip to construct authorization")
        }</span> else<span class="cov0" title="0"> {
                if obsClient.conf.securityProvider.securityToken != "" </span><span class="cov0" title="0">{
                        headers[HEADER_STS_TOKEN_AMZ] = []string{obsClient.conf.securityProvider.securityToken}
                }</span>
                <span class="cov0" title="0">ak := obsClient.conf.securityProvider.ak
                sk := obsClient.conf.securityProvider.sk
                var authorization string
                if isV4 </span><span class="cov0" title="0">{
                        headers[HEADER_CONTENT_SHA256_AMZ] = []string{EMPTY_CONTENT_SHA256}
                        ret := v4Auth(ak, sk, obsClient.conf.region, method, canonicalizedUrl, parsedRequestUrl.RawQuery, headers)
                        authorization = fmt.Sprintf("%s Credential=%s,SignedHeaders=%s,Signature=%s", V4_HASH_PREFIX, ret["Credential"], ret["SignedHeaders"], ret["Signature"])
                }</span> else<span class="cov0" title="0"> {
                        ret := v2Auth(ak, sk, method, canonicalizedUrl, headers)
                        authorization = fmt.Sprintf("%s %s:%s", V2_HASH_PREFIX, ak, ret["Signature"])
                }</span>
                <span class="cov0" title="0">headers[HEADER_AUTH_CAMEL] = []string{authorization}</span>
        }

        <span class="cov0" title="0">return</span>
}

func prepareHostAndDate(headers map[string][]string, hostName string, isV4 bool) <span class="cov0" title="0">{
        headers[HEADER_HOST_CAMEL] = []string{hostName}
        if date, ok := headers[HEADER_DATE_AMZ]; ok </span><span class="cov0" title="0">{
                flag := false
                if len(date) == 1 </span><span class="cov0" title="0">{
                        if isV4 </span><span class="cov0" title="0">{
                                if t, err := time.Parse(LONG_DATE_FORMAT, date[0]); err == nil </span><span class="cov0" title="0">{
                                        headers[HEADER_DATE_CAMEL] = []string{FormatUtcToRfc1123(t)}
                                        flag = true
                                }</span>
                        } else<span class="cov0" title="0"> {
                                if strings.HasSuffix(date[0], "GMT") </span><span class="cov0" title="0">{
                                        headers[HEADER_DATE_CAMEL] = []string{date[0]}
                                        flag = true
                                }</span>
                        }
                }
                <span class="cov0" title="0">if !flag </span><span class="cov0" title="0">{
                        delete(headers, HEADER_DATE_AMZ)
                }</span>
        }
        <span class="cov0" title="0">if _, ok := headers[HEADER_DATE_CAMEL]; !ok </span><span class="cov0" title="0">{
                headers[HEADER_DATE_CAMEL] = []string{FormatUtcToRfc1123(time.Now().UTC())}
        }</span>
}

func encodeHeaders(headers map[string][]string) <span class="cov0" title="0">{
        for key, values := range headers </span><span class="cov0" title="0">{
                for index, value := range values </span><span class="cov0" title="0">{
                        values[index] = UrlEncode(value, true)
                }</span>
                <span class="cov0" title="0">headers[key] = values</span>
        }
}

func attachHeaders(headers map[string][]string) string <span class="cov0" title="0">{
        length := len(headers)
        _headers := make(map[string][]string, length)
        keys := make([]string, 0, length)

        for key, value := range headers </span><span class="cov0" title="0">{
                _key := strings.ToLower(strings.TrimSpace(key))
                if _key != "" </span><span class="cov0" title="0">{
                        if _key == "content-md5" || _key == "content-type" || _key == "date" || strings.HasPrefix(_key, HEADER_PREFIX) </span><span class="cov0" title="0">{
                                keys = append(keys, _key)
                                _headers[_key] = value
                        }</span>
                } else<span class="cov0" title="0"> {
                        delete(headers, key)
                }</span>
        }

        <span class="cov0" title="0">for _, interestedHeader := range interested_headers </span><span class="cov0" title="0">{
                if _, ok := _headers[interestedHeader]; !ok </span><span class="cov0" title="0">{
                        _headers[interestedHeader] = []string{""}
                        keys = append(keys, interestedHeader)
                }</span>
        }

        <span class="cov0" title="0">if _, ok := _headers[HEADER_DATE_CAMEL]; ok </span><span class="cov0" title="0">{
                if _, ok := _headers[HEADER_DATE_AMZ]; ok </span><span class="cov0" title="0">{
                        _headers[HEADER_DATE_CAMEL] = []string{""}
                }</span> else<span class="cov0" title="0"> if _, ok := headers[PARAM_DATE_AMZ_CAMEL]; ok </span><span class="cov0" title="0">{
                        _headers[HEADER_DATE_CAMEL] = []string{""}
                }</span>
        } else<span class="cov0" title="0"> if _, ok := _headers[strings.ToLower(HEADER_DATE_CAMEL)]; ok </span><span class="cov0" title="0">{
                if _, ok := _headers[HEADER_DATE_AMZ]; ok </span><span class="cov0" title="0">{
                        _headers[HEADER_DATE_CAMEL] = []string{""}
                }</span> else<span class="cov0" title="0"> if _, ok := headers[PARAM_DATE_AMZ_CAMEL]; ok </span><span class="cov0" title="0">{
                        _headers[HEADER_DATE_CAMEL] = []string{""}
                }</span>
        }

        <span class="cov0" title="0">sort.Strings(keys)

        stringToSign := make([]string, 0, len(keys))
        for _, key := range keys </span><span class="cov0" title="0">{
                var value string
                if strings.HasPrefix(key, HEADER_PREFIX) </span><span class="cov0" title="0">{
                        if strings.HasPrefix(key, HEADER_PREFIX_META) </span><span class="cov0" title="0">{
                                for index, v := range _headers[key] </span><span class="cov0" title="0">{
                                        value += strings.TrimSpace(v)
                                        if index != len(_headers[key])-1 </span><span class="cov0" title="0">{
                                                value += ","
                                        }</span>
                                }
                        } else<span class="cov0" title="0"> {
                                value = strings.Join(_headers[key], ",")
                        }</span>
                        <span class="cov0" title="0">value = fmt.Sprintf("%s:%s", key, value)</span>
                } else<span class="cov0" title="0"> {
                        value = strings.Join(_headers[key], ",")
                }</span>
                <span class="cov0" title="0">stringToSign = append(stringToSign, value)</span>
        }
        <span class="cov0" title="0">return strings.Join(stringToSign, "\n")</span>
}

func getV2StringToSign(method, canonicalizedUrl string, headers map[string][]string) string <span class="cov0" title="0">{
        stringToSign := strings.Join([]string{method, "\n", attachHeaders(headers), "\n", canonicalizedUrl}, "")
        log.Debug("The v2 auth stringToSign:\n%s", stringToSign)
        return stringToSign
}</span>

func v2Auth(ak, sk, method, canonicalizedUrl string, headers map[string][]string) map[string]string <span class="cov0" title="0">{
        stringToSign := getV2StringToSign(method, canonicalizedUrl, headers)
        return map[string]string{"Signature": Base64Encode(HmacSha1([]byte(sk), []byte(stringToSign)))}
}</span>

func getScope(region, shortDate string) string <span class="cov0" title="0">{
        return fmt.Sprintf("%s/%s/%s/%s", shortDate, region, V4_SERVICE_NAME, V4_SERVICE_SUFFIX)
}</span>

func getCredential(ak, region, shortDate string) (string, string) <span class="cov0" title="0">{
        scope := getScope(region, shortDate)
        return fmt.Sprintf("%s/%s", ak, scope), scope
}</span>

func getV4StringToSign(method, canonicalizedUrl, queryUrl, scope, longDate, payload string, signedHeaders []string, headers map[string][]string) string <span class="cov0" title="0">{
        canonicalRequest := make([]string, 0, 10+len(signedHeaders)*4)
        canonicalRequest = append(canonicalRequest, method)
        canonicalRequest = append(canonicalRequest, "\n")
        canonicalRequest = append(canonicalRequest, canonicalizedUrl)
        canonicalRequest = append(canonicalRequest, "\n")
        canonicalRequest = append(canonicalRequest, queryUrl)
        canonicalRequest = append(canonicalRequest, "\n")

        for _, signedHeader := range signedHeaders </span><span class="cov0" title="0">{
                values, _ := headers[signedHeader]
                for _, value := range values </span><span class="cov0" title="0">{
                        canonicalRequest = append(canonicalRequest, signedHeader)
                        canonicalRequest = append(canonicalRequest, ":")
                        canonicalRequest = append(canonicalRequest, value)
                        canonicalRequest = append(canonicalRequest, "\n")
                }</span>
        }
        <span class="cov0" title="0">canonicalRequest = append(canonicalRequest, "\n")
        canonicalRequest = append(canonicalRequest, strings.Join(signedHeaders, ";"))
        canonicalRequest = append(canonicalRequest, "\n")
        canonicalRequest = append(canonicalRequest, payload)

        _canonicalRequest := strings.Join(canonicalRequest, "")
        log.Debug("The v4 auth canonicalRequest:\n%s", _canonicalRequest)

        stringToSign := make([]string, 0, 7)
        stringToSign = append(stringToSign, V4_HASH_PREFIX)
        stringToSign = append(stringToSign, "\n")
        stringToSign = append(stringToSign, longDate)
        stringToSign = append(stringToSign, "\n")
        stringToSign = append(stringToSign, scope)
        stringToSign = append(stringToSign, "\n")
        stringToSign = append(stringToSign, HexSha256([]byte(_canonicalRequest)))

        _stringToSign := strings.Join(stringToSign, "")

        log.Debug("The v4 auth stringToSign:\n%s", _stringToSign)
        return _stringToSign</span>
}

func getSignedHeaders(headers map[string][]string) ([]string, map[string][]string) <span class="cov0" title="0">{
        length := len(headers)
        _headers := make(map[string][]string, length)
        signedHeaders := make([]string, 0, length)
        for key, value := range headers </span><span class="cov0" title="0">{
                _key := strings.ToLower(strings.TrimSpace(key))
                if _key != "" </span><span class="cov0" title="0">{
                        signedHeaders = append(signedHeaders, _key)
                        _headers[_key] = value
                }</span> else<span class="cov0" title="0"> {
                        delete(headers, key)
                }</span>
        }
        <span class="cov0" title="0">sort.Strings(signedHeaders)
        return signedHeaders, _headers</span>
}

func getSignature(stringToSign, sk, region, shortDate string) string <span class="cov0" title="0">{
        key := HmacSha256([]byte(V4_HASH_PRE+sk), []byte(shortDate))
        key = HmacSha256(key, []byte(region))
        key = HmacSha256(key, []byte(V4_SERVICE_NAME))
        key = HmacSha256(key, []byte(V4_SERVICE_SUFFIX))
        return Hex(HmacSha256(key, []byte(stringToSign)))
}</span>

func V4Auth(ak, sk, region, method, canonicalizedUrl, queryUrl string, headers map[string][]string) map[string]string <span class="cov0" title="0">{
        return v4Auth(ak, sk, region, method, canonicalizedUrl, queryUrl, headers)
}</span>

func v4Auth(ak, sk, region, method, canonicalizedUrl, queryUrl string, headers map[string][]string) map[string]string <span class="cov0" title="0">{
        var t time.Time

        if val, ok := headers[HEADER_DATE_AMZ]; ok </span><span class="cov0" title="0">{
                var err error
                t, err = time.Parse(LONG_DATE_FORMAT, val[0])
                if err != nil </span><span class="cov0" title="0">{
                        t = time.Now().UTC()
                }</span>
        } else<span class="cov0" title="0"> if val, ok := headers[PARAM_DATE_AMZ_CAMEL]; ok </span><span class="cov0" title="0">{
                var err error
                t, err = time.Parse(LONG_DATE_FORMAT, val[0])
                if err != nil </span><span class="cov0" title="0">{
                        t = time.Now().UTC()
                }</span>
        } else<span class="cov0" title="0"> if val, ok := headers[HEADER_DATE_CAMEL]; ok </span><span class="cov0" title="0">{
                var err error
                t, err = time.Parse(RFC1123_FORMAT, val[0])
                if err != nil </span><span class="cov0" title="0">{
                        t = time.Now().UTC()
                }</span>
        } else<span class="cov0" title="0"> if val, ok := headers[strings.ToLower(HEADER_DATE_CAMEL)]; ok </span><span class="cov0" title="0">{
                var err error
                t, err = time.Parse(RFC1123_FORMAT, val[0])
                if err != nil </span><span class="cov0" title="0">{
                        t = time.Now().UTC()
                }</span>
        } else<span class="cov0" title="0"> {
                t = time.Now().UTC()
        }</span>
        <span class="cov0" title="0">shortDate := t.Format(SHORT_DATE_FORMAT)
        longDate := t.Format(LONG_DATE_FORMAT)

        signedHeaders, _headers := getSignedHeaders(headers)

        credential, scope := getCredential(ak, region, shortDate)

        stringToSign := getV4StringToSign(method, canonicalizedUrl, queryUrl, scope, longDate, EMPTY_CONTENT_SHA256, signedHeaders, _headers)

        signature := getSignature(stringToSign, sk, region, shortDate)

        ret := make(map[string]string, 3)
        ret["Credential"] = credential
        ret["SignedHeaders"] = strings.Join(signedHeaders, ";")
        ret["Signature"] = signature
        return ret</span>
}
</pre>
		
		<pre class="file" id="file64" style="display: none">package obs

import (
        "errors"
        "fmt"
        "io"
        "net/http"
        "os"
        "sort"
        "strings"

        log "github.com/sirupsen/logrus"
)

type ObsClient struct {
        conf       *config
        httpClient *http.Client
        transport  *http.Transport
}

func New(ak, sk, endpoint string, configurers ...configurer) (*ObsClient, error) <span class="cov0" title="0">{
        conf := &amp;config{securityProvider: &amp;securityProvider{ak: ak, sk: sk}, endpoint: endpoint}
        conf.maxRetryCount = -1
        for _, configurer := range configurers </span><span class="cov0" title="0">{
                configurer(conf)
        }</span>

        <span class="cov0" title="0">if err := conf.initConfigWithDefault(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">transport, err := conf.getTransport()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">info := make([]string, 3)
        info[0] = fmt.Sprintf("[OBS SDK Version=%s", obs_sdk_version)
        info[1] = fmt.Sprintf("Endpoint=%s", conf.endpoint)
        accessMode := "Virtual Hosting"
        if conf.pathStyle </span><span class="cov0" title="0">{
                accessMode = "Path"
        }</span>
        <span class="cov0" title="0">info[2] = fmt.Sprintf("Access Mode=%s]", accessMode)
        log.Warn(strings.Join(info, "];["))

        log.Debug("Create obsclient with config:\n%s\n", conf)
        obsClient := &amp;ObsClient{conf: conf, httpClient: &amp;http.Client{Transport: transport, CheckRedirect: checkRedirectFunc}, transport: transport}
        return obsClient, nil</span>
}

func (obsClient ObsClient) Refresh(ak, sk, securityToken string) <span class="cov0" title="0">{
        sp := &amp;securityProvider{ak: strings.TrimSpace(ak), sk: strings.TrimSpace(sk), securityToken: strings.TrimSpace(securityToken)}
        obsClient.conf.securityProvider = sp
}</span>

func (obsClient ObsClient) Close() <span class="cov0" title="0">{
        obsClient.transport.CloseIdleConnections()
        obsClient.transport = nil
        obsClient.httpClient = nil
        obsClient.conf = nil
}</span>

func (obsClient ObsClient) ListBuckets(input *ListBucketsInput) (output *ListBucketsOutput, err error) <span class="cov0" title="0">{
        if input == nil </span><span class="cov0" title="0">{
                input = &amp;ListBucketsInput{}
        }</span>
        <span class="cov0" title="0">output = &amp;ListBucketsOutput{}
        err = obsClient.doActionWithoutBucket("ListBuckets", HTTP_GET, input, output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) CreateBucket(input *CreateBucketInput) (output *BaseModel, err error) <span class="cov0" title="0">{
        if input == nil </span><span class="cov0" title="0">{
                return nil, errors.New("CreateBucketInput is nil")
        }</span>
        <span class="cov0" title="0">output = &amp;BaseModel{}
        err = obsClient.doActionWithBucket("CreateBucket", HTTP_PUT, input.Bucket, input, output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) DeleteBucket(bucketName string) (output *BaseModel, err error) <span class="cov0" title="0">{
        output = &amp;BaseModel{}
        err = obsClient.doActionWithBucket("DeleteBucket", HTTP_DELETE, bucketName, defaultSerializable, output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) SetBucketStoragePolicy(input *SetBucketStoragePolicyInput) (output *BaseModel, err error) <span class="cov0" title="0">{
        if input == nil </span><span class="cov0" title="0">{
                return nil, errors.New("SetBucketStoragePolicyInput is nil")
        }</span>
        <span class="cov0" title="0">output = &amp;BaseModel{}
        err = obsClient.doActionWithBucket("SetBucketStoragePolicy", HTTP_PUT, input.Bucket, input, output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) GetBucketStoragePolicy(bucketName string) (output *GetBucketStoragePolicyOutput, err error) <span class="cov0" title="0">{
        output = &amp;GetBucketStoragePolicyOutput{}
        err = obsClient.doActionWithBucket("GetBucketStoragePolicy", HTTP_GET, bucketName, newSubResourceSerial(SubResourceStoragePolicy), output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) ListObjects(input *ListObjectsInput) (output *ListObjectsOutput, err error) <span class="cov0" title="0">{
        if input == nil </span><span class="cov0" title="0">{
                return nil, errors.New("ListObjectsInput is nil")
        }</span>
        <span class="cov0" title="0">output = &amp;ListObjectsOutput{}
        err = obsClient.doActionWithBucket("ListObjects", HTTP_GET, input.Bucket, input, output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span> else<span class="cov0" title="0"> {
                if location, ok := output.ResponseHeaders[HEADER_BUCKET_REGION]; ok </span><span class="cov0" title="0">{
                        output.Location = location[0]
                }</span>
        }
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) ListVersions(input *ListVersionsInput) (output *ListVersionsOutput, err error) <span class="cov0" title="0">{
        if input == nil </span><span class="cov0" title="0">{
                return nil, errors.New("ListVersionsInput is nil")
        }</span>
        <span class="cov0" title="0">output = &amp;ListVersionsOutput{}
        err = obsClient.doActionWithBucket("ListVersions", HTTP_GET, input.Bucket, input, output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span> else<span class="cov0" title="0"> {
                if location, ok := output.ResponseHeaders[HEADER_BUCKET_REGION]; ok </span><span class="cov0" title="0">{
                        output.Location = location[0]
                }</span>
        }
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) ListMultipartUploads(input *ListMultipartUploadsInput) (output *ListMultipartUploadsOutput, err error) <span class="cov0" title="0">{
        if input == nil </span><span class="cov0" title="0">{
                return nil, errors.New("ListMultipartUploadsInput is nil")
        }</span>
        <span class="cov0" title="0">output = &amp;ListMultipartUploadsOutput{}
        err = obsClient.doActionWithBucket("ListMultipartUploads", HTTP_GET, input.Bucket, input, output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) SetBucketQuota(input *SetBucketQuotaInput) (output *BaseModel, err error) <span class="cov0" title="0">{
        if input == nil </span><span class="cov0" title="0">{
                return nil, errors.New("SetBucketQuotaInput is nil")
        }</span>
        <span class="cov0" title="0">output = &amp;BaseModel{}
        err = obsClient.doActionWithBucket("SetBucketQuota", HTTP_PUT, input.Bucket, input, output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) GetBucketQuota(bucketName string) (output *GetBucketQuotaOutput, err error) <span class="cov0" title="0">{
        output = &amp;GetBucketQuotaOutput{}
        err = obsClient.doActionWithBucket("GetBucketQuota", HTTP_GET, bucketName, newSubResourceSerial(SubResourceQuota), output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) HeadBucket(bucketName string) (output *BaseModel, err error) <span class="cov0" title="0">{
        output = &amp;BaseModel{}
        err = obsClient.doActionWithBucket("HeadBucket", HTTP_HEAD, bucketName, defaultSerializable, output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) GetBucketMetadata(input *GetBucketMetadataInput) (output *GetBucketMetadataOutput, err error) <span class="cov0" title="0">{
        output = &amp;GetBucketMetadataOutput{}
        err = obsClient.doActionWithBucket("GetBucketMetadata", HTTP_HEAD, input.Bucket, input, output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span> else<span class="cov0" title="0"> {
                ParseGetBucketMetadataOutput(output)
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) GetBucketStorageInfo(bucketName string) (output *GetBucketStorageInfoOutput, err error) <span class="cov0" title="0">{
        output = &amp;GetBucketStorageInfoOutput{}
        err = obsClient.doActionWithBucket("GetBucketStorageInfo", HTTP_GET, bucketName, newSubResourceSerial(SubResourceStorageInfo), output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) GetBucketLocation(bucketName string) (output *GetBucketLocationOutput, err error) <span class="cov0" title="0">{
        output = &amp;GetBucketLocationOutput{}
        err = obsClient.doActionWithBucket("GetBucketLocation", HTTP_GET, bucketName, newSubResourceSerial(SubResourceLocation), output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) SetBucketAcl(input *SetBucketAclInput) (output *BaseModel, err error) <span class="cov0" title="0">{
        if input == nil </span><span class="cov0" title="0">{
                return nil, errors.New("SetBucketAclInput is nil")
        }</span>
        <span class="cov0" title="0">output = &amp;BaseModel{}
        err = obsClient.doActionWithBucket("SetBucketAcl", HTTP_PUT, input.Bucket, input, output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) GetBucketAcl(bucketName string) (output *GetBucketAclOutput, err error) <span class="cov0" title="0">{
        output = &amp;GetBucketAclOutput{}
        err = obsClient.doActionWithBucket("GetBucketAcl", HTTP_GET, bucketName, newSubResourceSerial(SubResourceAcl), output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) SetBucketPolicy(input *SetBucketPolicyInput) (output *BaseModel, err error) <span class="cov0" title="0">{
        if input == nil </span><span class="cov0" title="0">{
                return nil, errors.New("SetBucketPolicy is nil")
        }</span>
        <span class="cov0" title="0">output = &amp;BaseModel{}
        err = obsClient.doActionWithBucket("SetBucketPolicy", HTTP_PUT, input.Bucket, input, output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) GetBucketPolicy(bucketName string) (output *GetBucketPolicyOutput, err error) <span class="cov0" title="0">{
        output = &amp;GetBucketPolicyOutput{}
        err = obsClient.doActionWithBucketV2("GetBucketPolicy", HTTP_GET, bucketName, newSubResourceSerial(SubResourcePolicy), output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) DeleteBucketPolicy(bucketName string) (output *BaseModel, err error) <span class="cov0" title="0">{
        output = &amp;BaseModel{}
        err = obsClient.doActionWithBucket("DeleteBucketPolicy", HTTP_DELETE, bucketName, newSubResourceSerial(SubResourcePolicy), output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) SetBucketCors(input *SetBucketCorsInput) (output *BaseModel, err error) <span class="cov0" title="0">{
        if input == nil </span><span class="cov0" title="0">{
                return nil, errors.New("SetBucketCorsInput is nil")
        }</span>
        <span class="cov0" title="0">output = &amp;BaseModel{}
        err = obsClient.doActionWithBucket("SetBucketCors", HTTP_PUT, input.Bucket, input, output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) GetBucketCors(bucketName string) (output *GetBucketCorsOutput, err error) <span class="cov0" title="0">{
        output = &amp;GetBucketCorsOutput{}
        err = obsClient.doActionWithBucket("GetBucketCors", HTTP_GET, bucketName, newSubResourceSerial(SubResourceCors), output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) DeleteBucketCors(bucketName string) (output *BaseModel, err error) <span class="cov0" title="0">{
        output = &amp;BaseModel{}
        err = obsClient.doActionWithBucket("DeleteBucketCors", HTTP_DELETE, bucketName, newSubResourceSerial(SubResourceCors), output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) SetBucketVersioning(input *SetBucketVersioningInput) (output *BaseModel, err error) <span class="cov0" title="0">{
        if input == nil </span><span class="cov0" title="0">{
                return nil, errors.New("SetBucketVersioningInput is nil")
        }</span>
        <span class="cov0" title="0">output = &amp;BaseModel{}
        err = obsClient.doActionWithBucket("SetBucketVersioning", HTTP_PUT, input.Bucket, input, output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) GetBucketVersioning(bucketName string) (output *GetBucketVersioningOutput, err error) <span class="cov0" title="0">{
        output = &amp;GetBucketVersioningOutput{}
        err = obsClient.doActionWithBucket("GetBucketVersioning", HTTP_GET, bucketName, newSubResourceSerial(SubResourceVersioning), output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) SetBucketWebsiteConfiguration(input *SetBucketWebsiteConfigurationInput) (output *BaseModel, err error) <span class="cov0" title="0">{
        if input == nil </span><span class="cov0" title="0">{
                return nil, errors.New("SetBucketWebsiteConfigurationInput is nil")
        }</span>
        <span class="cov0" title="0">output = &amp;BaseModel{}
        err = obsClient.doActionWithBucket("SetBucketWebsiteConfiguration", HTTP_PUT, input.Bucket, input, output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) GetBucketWebsiteConfiguration(bucketName string) (output *GetBucketWebsiteConfigurationOutput, err error) <span class="cov0" title="0">{
        output = &amp;GetBucketWebsiteConfigurationOutput{}
        err = obsClient.doActionWithBucket("GetBucketWebsiteConfiguration", HTTP_GET, bucketName, newSubResourceSerial(SubResourceWebsite), output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) DeleteBucketWebsiteConfiguration(bucketName string) (output *BaseModel, err error) <span class="cov0" title="0">{
        output = &amp;BaseModel{}
        err = obsClient.doActionWithBucket("DeleteBucketWebsiteConfiguration", HTTP_DELETE, bucketName, newSubResourceSerial(SubResourceWebsite), output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) SetBucketLoggingConfiguration(input *SetBucketLoggingConfigurationInput) (output *BaseModel, err error) <span class="cov0" title="0">{
        if input == nil </span><span class="cov0" title="0">{
                return nil, errors.New("SetBucketLoggingConfigurationInput is nil")
        }</span>
        <span class="cov0" title="0">output = &amp;BaseModel{}
        err = obsClient.doActionWithBucket("SetBucketLoggingConfiguration", HTTP_PUT, input.Bucket, input, output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) GetBucketLoggingConfiguration(bucketName string) (output *GetBucketLoggingConfigurationOutput, err error) <span class="cov0" title="0">{
        output = &amp;GetBucketLoggingConfigurationOutput{}
        err = obsClient.doActionWithBucket("GetBucketLoggingConfiguration", HTTP_GET, bucketName, newSubResourceSerial(SubResourceLogging), output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) SetBucketLifecycleConfiguration(input *SetBucketLifecycleConfigurationInput) (output *BaseModel, err error) <span class="cov0" title="0">{
        if input == nil </span><span class="cov0" title="0">{
                return nil, errors.New("SetBucketLifecycleConfigurationInput is nil")
        }</span>
        <span class="cov0" title="0">output = &amp;BaseModel{}
        err = obsClient.doActionWithBucket("SetBucketLifecycleConfiguration", HTTP_PUT, input.Bucket, input, output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) GetBucketLifecycleConfiguration(bucketName string) (output *GetBucketLifecycleConfigurationOutput, err error) <span class="cov0" title="0">{
        output = &amp;GetBucketLifecycleConfigurationOutput{}
        err = obsClient.doActionWithBucket("GetBucketLifecycleConfiguration", HTTP_GET, bucketName, newSubResourceSerial(SubResourceLifecycle), output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) DeleteBucketLifecycleConfiguration(bucketName string) (output *BaseModel, err error) <span class="cov0" title="0">{
        output = &amp;BaseModel{}
        err = obsClient.doActionWithBucket("DeleteBucketLifecycleConfiguration", HTTP_DELETE, bucketName, newSubResourceSerial(SubResourceLifecycle), output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) SetBucketTagging(input *SetBucketTaggingInput) (output *BaseModel, err error) <span class="cov0" title="0">{
        if input == nil </span><span class="cov0" title="0">{
                return nil, errors.New("SetBucketTaggingInput is nil")
        }</span>
        <span class="cov0" title="0">output = &amp;BaseModel{}
        err = obsClient.doActionWithBucket("SetBucketTagging", HTTP_PUT, input.Bucket, input, output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) GetBucketTagging(bucketName string) (output *GetBucketTaggingOutput, err error) <span class="cov0" title="0">{
        output = &amp;GetBucketTaggingOutput{}
        err = obsClient.doActionWithBucket("GetBucketTagging", HTTP_GET, bucketName, newSubResourceSerial(SubResourceTagging), output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) DeleteBucketTagging(bucketName string) (output *BaseModel, err error) <span class="cov0" title="0">{
        output = &amp;BaseModel{}
        err = obsClient.doActionWithBucket("DeleteBucketTagging", HTTP_DELETE, bucketName, newSubResourceSerial(SubResourceTagging), output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) SetBucketNotification(input *SetBucketNotificationInput) (output *BaseModel, err error) <span class="cov0" title="0">{
        if input == nil </span><span class="cov0" title="0">{
                return nil, errors.New("SetBucketNotificationInput is nil")
        }</span>
        <span class="cov0" title="0">output = &amp;BaseModel{}
        err = obsClient.doActionWithBucket("SetBucketNotification", HTTP_PUT, input.Bucket, input, output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) GetBucketNotification(bucketName string) (output *GetBucketNotificationOutput, err error) <span class="cov0" title="0">{
        output = &amp;GetBucketNotificationOutput{}
        err = obsClient.doActionWithBucket("GetBucketNotification", HTTP_GET, bucketName, newSubResourceSerial(SubResourceNotification), output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) DeleteObject(input *DeleteObjectInput) (output *DeleteObjectOutput, err error) <span class="cov0" title="0">{
        if input == nil </span><span class="cov0" title="0">{
                return nil, errors.New("DeleteObjectInput is nil")
        }</span>
        <span class="cov0" title="0">output = &amp;DeleteObjectOutput{}
        err = obsClient.doActionWithBucketAndKey("DeleteObject", HTTP_DELETE, input.Bucket, input.Key, input, output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span> else<span class="cov0" title="0"> {
                ParseDeleteObjectOutput(output)
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) DeleteObjects(input *DeleteObjectsInput) (output *DeleteObjectsOutput, err error) <span class="cov0" title="0">{
        if input == nil </span><span class="cov0" title="0">{
                return nil, errors.New("DeleteObjectsInput is nil")
        }</span>
        <span class="cov0" title="0">output = &amp;DeleteObjectsOutput{}
        err = obsClient.doActionWithBucket("DeleteObjects", HTTP_POST, input.Bucket, input, output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) SetObjectAcl(input *SetObjectAclInput) (output *BaseModel, err error) <span class="cov0" title="0">{
        if input == nil </span><span class="cov0" title="0">{
                return nil, errors.New("SetObjectAclInput is nil")
        }</span>
        <span class="cov0" title="0">output = &amp;BaseModel{}
        err = obsClient.doActionWithBucketAndKey("SetObjectAcl", HTTP_PUT, input.Bucket, input.Key, input, output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) GetObjectAcl(input *GetObjectAclInput) (output *GetObjectAclOutput, err error) <span class="cov0" title="0">{
        if input == nil </span><span class="cov0" title="0">{
                return nil, errors.New("GetObjectAclInput is nil")
        }</span>
        <span class="cov0" title="0">output = &amp;GetObjectAclOutput{}
        err = obsClient.doActionWithBucketAndKey("GetObjectAcl", HTTP_GET, input.Bucket, input.Key, input, output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span> else<span class="cov0" title="0"> {
                if versionId, ok := output.ResponseHeaders[HEADER_VERSION_ID]; ok </span><span class="cov0" title="0">{
                        output.VersionId = versionId[0]
                }</span>
        }
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) RestoreObject(input *RestoreObjectInput) (output *BaseModel, err error) <span class="cov0" title="0">{
        if input == nil </span><span class="cov0" title="0">{
                return nil, errors.New("RestoreObjectInput is nil")
        }</span>
        <span class="cov0" title="0">output = &amp;BaseModel{}
        err = obsClient.doActionWithBucketAndKey("RestoreObject", HTTP_POST, input.Bucket, input.Key, input, output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) GetObjectMetadata(input *GetObjectMetadataInput) (output *GetObjectMetadataOutput, err error) <span class="cov0" title="0">{
        if input == nil </span><span class="cov0" title="0">{
                return nil, errors.New("GetObjectMetadataInput is nil")
        }</span>
        <span class="cov0" title="0">output = &amp;GetObjectMetadataOutput{}
        err = obsClient.doActionWithBucketAndKey("GetObjectMetadata", HTTP_HEAD, input.Bucket, input.Key, input, output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span> else<span class="cov0" title="0"> {
                ParseGetObjectMetadataOutput(output)
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) GetObject(input *GetObjectInput) (output *GetObjectOutput, err error) <span class="cov0" title="0">{
        if input == nil </span><span class="cov0" title="0">{
                return nil, errors.New("GetObjectInput is nil")
        }</span>
        <span class="cov0" title="0">output = &amp;GetObjectOutput{}
        err = obsClient.doActionWithBucketAndKey("GetObject", HTTP_GET, input.Bucket, input.Key, input, output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span> else<span class="cov0" title="0"> {
                ParseGetObjectOutput(output)
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) PutObject(input *PutObjectInput) (output *PutObjectOutput, err error) <span class="cov0" title="0">{
        if input == nil </span><span class="cov0" title="0">{
                return nil, errors.New("PutObjectInput is nil")
        }</span>

        <span class="cov0" title="0">if input.ContentType == "" &amp;&amp; input.Key != "" </span><span class="cov0" title="0">{
                if contentType, ok := mime_types[input.Key[strings.LastIndex(input.Key, ".")+1:]]; ok </span><span class="cov0" title="0">{
                        input.ContentType = contentType
                }</span>
        }

        <span class="cov0" title="0">output = &amp;PutObjectOutput{}
        var repeatable bool
        if input.Body != nil </span><span class="cov0" title="0">{
                _, repeatable = input.Body.(*strings.Reader)
                if input.ContentLength &gt; 0 </span><span class="cov0" title="0">{
                        input.Body = &amp;readerWrapper{reader: input.Body, totalCount: input.ContentLength}
                }</span>
        }
        <span class="cov0" title="0">if repeatable </span><span class="cov0" title="0">{
                err = obsClient.doActionWithBucketAndKey("PutObject", HTTP_PUT, input.Bucket, input.Key, input, output)
        }</span> else<span class="cov0" title="0"> {
                err = obsClient.doActionWithBucketAndKeyUnRepeatable("PutObject", HTTP_PUT, input.Bucket, input.Key, input, output)
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span> else<span class="cov0" title="0"> {
                ParsePutObjectOutput(output)
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) PutFile(input *PutFileInput) (output *PutObjectOutput, err error) <span class="cov0" title="0">{
        if input == nil </span><span class="cov0" title="0">{
                return nil, errors.New("PutFileInput is nil")
        }</span>

        <span class="cov0" title="0">var body io.Reader
        sourceFile := strings.TrimSpace(input.SourceFile)
        if sourceFile != "" </span><span class="cov0" title="0">{
                fd, err := os.Open(sourceFile)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">defer fd.Close()

                stat, err := fd.Stat()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">fileReaderWrapper := &amp;fileReaderWrapper{filePath: sourceFile}
                fileReaderWrapper.reader = fd
                if input.ContentLength &gt; 0 </span><span class="cov0" title="0">{
                        if input.ContentLength &gt; stat.Size() </span><span class="cov0" title="0">{
                                input.ContentLength = stat.Size()
                        }</span>
                        <span class="cov0" title="0">fileReaderWrapper.totalCount = input.ContentLength</span>
                } else<span class="cov0" title="0"> {
                        fileReaderWrapper.totalCount = stat.Size()
                }</span>
                <span class="cov0" title="0">body = fileReaderWrapper</span>
        }

        <span class="cov0" title="0">_input := &amp;PutObjectInput{}
        _input.PutObjectBasicInput = input.PutObjectBasicInput
        _input.Body = body

        if _input.ContentType == "" &amp;&amp; _input.Key != "" </span><span class="cov0" title="0">{
                if contentType, ok := mime_types[_input.Key[strings.LastIndex(_input.Key, ".")+1:]]; ok </span><span class="cov0" title="0">{
                        _input.ContentType = contentType
                }</span> else<span class="cov0" title="0"> if contentType, ok := mime_types[sourceFile[strings.LastIndex(sourceFile, ".")+1:]]; ok </span><span class="cov0" title="0">{
                        _input.ContentType = contentType
                }</span>
        }

        <span class="cov0" title="0">output = &amp;PutObjectOutput{}
        err = obsClient.doActionWithBucketAndKey("PutFile", HTTP_PUT, _input.Bucket, _input.Key, _input, output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span> else<span class="cov0" title="0"> {
                ParsePutObjectOutput(output)
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) CopyObject(input *CopyObjectInput) (output *CopyObjectOutput, err error) <span class="cov0" title="0">{
        if input == nil </span><span class="cov0" title="0">{
                return nil, errors.New("CopyObjectInput is nil")
        }</span>

        <span class="cov0" title="0">if strings.TrimSpace(input.CopySourceBucket) == "" </span><span class="cov0" title="0">{
                return nil, errors.New("Source bucket is empty")
        }</span>
        <span class="cov0" title="0">if strings.TrimSpace(input.CopySourceKey) == "" </span><span class="cov0" title="0">{
                return nil, errors.New("Source key is empty")
        }</span>

        <span class="cov0" title="0">output = &amp;CopyObjectOutput{}
        err = obsClient.doActionWithBucketAndKey("CopyObject", HTTP_PUT, input.Bucket, input.Key, input, output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span> else<span class="cov0" title="0"> {
                ParseCopyObjectOutput(output)
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) AbortMultipartUpload(input *AbortMultipartUploadInput) (output *BaseModel, err error) <span class="cov0" title="0">{
        if input == nil </span><span class="cov0" title="0">{
                return nil, errors.New("AbortMultipartUploadInput is nil")
        }</span>
        <span class="cov0" title="0">if input.UploadId == "" </span><span class="cov0" title="0">{
                return nil, errors.New("UploadId is empty")
        }</span>
        <span class="cov0" title="0">output = &amp;BaseModel{}
        err = obsClient.doActionWithBucketAndKey("AbortMultipartUpload", HTTP_DELETE, input.Bucket, input.Key, input, output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) InitiateMultipartUpload(input *InitiateMultipartUploadInput) (output *InitiateMultipartUploadOutput, err error) <span class="cov0" title="0">{
        if input == nil </span><span class="cov0" title="0">{
                return nil, errors.New("InitiateMultipartUploadInput is nil")
        }</span>

        <span class="cov0" title="0">if input.ContentType == "" &amp;&amp; input.Key != "" </span><span class="cov0" title="0">{
                if contentType, ok := mime_types[input.Key[strings.LastIndex(input.Key, ".")+1:]]; ok </span><span class="cov0" title="0">{
                        input.ContentType = contentType
                }</span>
        }

        <span class="cov0" title="0">output = &amp;InitiateMultipartUploadOutput{}
        err = obsClient.doActionWithBucketAndKey("InitiateMultipartUpload", HTTP_POST, input.Bucket, input.Key, input, output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span> else<span class="cov0" title="0"> {
                ParseInitiateMultipartUploadOutput(output)
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) UploadPart(input *UploadPartInput) (output *UploadPartOutput, err error) <span class="cov0" title="0">{
        if input == nil </span><span class="cov0" title="0">{
                return nil, errors.New("UploadPartInput is nil")
        }</span>

        <span class="cov0" title="0">if input.UploadId == "" </span><span class="cov0" title="0">{
                return nil, errors.New("UploadId is empty")
        }</span>

        <span class="cov0" title="0">output = &amp;UploadPartOutput{}
        var repeatable bool
        if input.Body != nil </span><span class="cov0" title="0">{
                _, repeatable = input.Body.(*strings.Reader)
                if input.PartSize &gt; 0 </span><span class="cov0" title="0">{
                        input.Body = &amp;readerWrapper{reader: input.Body, totalCount: input.PartSize}
                }</span>
        } else<span class="cov0" title="0"> if sourceFile := strings.TrimSpace(input.SourceFile); sourceFile != "" </span><span class="cov0" title="0">{
                fd, err := os.Open(sourceFile)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">defer fd.Close()

                stat, err := fd.Stat()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">fileSize := stat.Size()
                fileReaderWrapper := &amp;fileReaderWrapper{filePath: sourceFile}
                fileReaderWrapper.reader = fd

                if input.Offset &lt; 0 || input.Offset &gt; fileSize </span><span class="cov0" title="0">{
                        input.Offset = 0
                }</span>

                <span class="cov0" title="0">if input.PartSize &lt;= 0 || input.PartSize &gt; (fileSize-input.Offset) </span><span class="cov0" title="0">{
                        input.PartSize = fileSize - input.Offset
                }</span>
                <span class="cov0" title="0">fileReaderWrapper.totalCount = input.PartSize
                fd.Seek(input.Offset, 0)
                input.Body = fileReaderWrapper
                repeatable = true</span>
        }
        <span class="cov0" title="0">if repeatable </span><span class="cov0" title="0">{
                err = obsClient.doActionWithBucketAndKey("UploadPart", HTTP_PUT, input.Bucket, input.Key, input, output)
        }</span> else<span class="cov0" title="0"> {
                err = obsClient.doActionWithBucketAndKeyUnRepeatable("UploadPart", HTTP_PUT, input.Bucket, input.Key, input, output)
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span> else<span class="cov0" title="0"> {
                ParseUploadPartOutput(output)
                output.PartNumber = input.PartNumber
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) CompleteMultipartUpload(input *CompleteMultipartUploadInput) (output *CompleteMultipartUploadOutput, err error) <span class="cov0" title="0">{
        if input == nil </span><span class="cov0" title="0">{
                return nil, errors.New("CompleteMultipartUploadInput is nil")
        }</span>

        <span class="cov0" title="0">if input.UploadId == "" </span><span class="cov0" title="0">{
                return nil, errors.New("UploadId is empty")
        }</span>

        <span class="cov0" title="0">var parts partSlice = input.Parts
        sort.Sort(parts)

        output = &amp;CompleteMultipartUploadOutput{}
        err = obsClient.doActionWithBucketAndKey("CompleteMultipartUpload", HTTP_POST, input.Bucket, input.Key, input, output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span> else<span class="cov0" title="0"> {
                ParseCompleteMultipartUploadOutput(output)
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) ListParts(input *ListPartsInput) (output *ListPartsOutput, err error) <span class="cov0" title="0">{
        if input == nil </span><span class="cov0" title="0">{
                return nil, errors.New("ListPartsInput is nil")
        }</span>
        <span class="cov0" title="0">if input.UploadId == "" </span><span class="cov0" title="0">{
                return nil, errors.New("UploadId is empty")
        }</span>
        <span class="cov0" title="0">output = &amp;ListPartsOutput{}
        err = obsClient.doActionWithBucketAndKey("ListParts", HTTP_GET, input.Bucket, input.Key, input, output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) CopyPart(input *CopyPartInput) (output *CopyPartOutput, err error) <span class="cov0" title="0">{
        if input == nil </span><span class="cov0" title="0">{
                return nil, errors.New("CopyPartInput is nil")
        }</span>
        <span class="cov0" title="0">if input.UploadId == "" </span><span class="cov0" title="0">{
                return nil, errors.New("UploadId is empty")
        }</span>
        <span class="cov0" title="0">if strings.TrimSpace(input.CopySourceBucket) == "" </span><span class="cov0" title="0">{
                return nil, errors.New("Source bucket is empty")
        }</span>
        <span class="cov0" title="0">if strings.TrimSpace(input.CopySourceKey) == "" </span><span class="cov0" title="0">{
                return nil, errors.New("Source key is empty")
        }</span>

        <span class="cov0" title="0">output = &amp;CopyPartOutput{}
        err = obsClient.doActionWithBucketAndKey("CopyPart", HTTP_PUT, input.Bucket, input.Key, input, output)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span> else<span class="cov0" title="0"> {
                ParseCopyPartOutput(output)
                output.PartNumber = input.PartNumber
        }</span>
        <span class="cov0" title="0">return</span>
}
</pre>
		
		<pre class="file" id="file65" style="display: none">package obs

import (
        "crypto/tls"
        "crypto/x509"
        "errors"
        "fmt"
        "net"
        "net/http"
        "net/url"
        "sort"
        "strconv"
        "strings"
        "time"
)

type securityProvider struct {
        ak            string
        sk            string
        securityToken string
}

type urlHolder struct {
        scheme string
        host   string
        port   int
}

type config struct {
        securityProvider *securityProvider
        urlHolder        *urlHolder
        endpoint         string
        signature        SignatureType
        pathStyle        bool
        region           string
        connectTimeout   int
        socketTimeout    int
        headerTimeout    int
        idleConnTimeout  int
        finalTimeout     int
        maxRetryCount    int
        proxyUrl         string
        maxConnsPerHost  int
        sslVerify        bool
        pemCerts         []byte
}

func (conf config) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("[endpoint:%s, signature:%s, pathStyle:%v, region:%s"+
                "\nconnectTimeout:%d, socketTimeout:%dheaderTimeout:%d, idleConnTimeout:%d"+
                "\nmaxRetryCount:%d, maxConnsPerHost:%d, sslVerify:%v, proxyUrl:%s]",
                conf.endpoint, conf.signature, conf.pathStyle, conf.region,
                conf.connectTimeout, conf.socketTimeout, conf.headerTimeout, conf.idleConnTimeout,
                conf.maxRetryCount, conf.maxConnsPerHost, conf.sslVerify, conf.proxyUrl,
        )
}</span>

type configurer func(conf *config)

func WithSslVerify(sslVerify bool) configurer <span class="cov0" title="0">{
        return WithSslVerifyAndPemCerts(sslVerify, nil)
}</span>

func WithSslVerifyAndPemCerts(sslVerify bool, pemCerts []byte) configurer <span class="cov0" title="0">{
        return func(conf *config) </span><span class="cov0" title="0">{
                conf.sslVerify = sslVerify
                conf.pemCerts = pemCerts
        }</span>
}

func WithHeaderTimeout(headerTimeout int) configurer <span class="cov0" title="0">{
        return func(conf *config) </span><span class="cov0" title="0">{
                conf.headerTimeout = headerTimeout
        }</span>
}

func WithProxyUrl(proxyUrl string) configurer <span class="cov0" title="0">{
        return func(conf *config) </span><span class="cov0" title="0">{
                conf.proxyUrl = proxyUrl
        }</span>
}

func WithMaxConnections(maxConnsPerHost int) configurer <span class="cov0" title="0">{
        return func(conf *config) </span><span class="cov0" title="0">{
                conf.maxConnsPerHost = maxConnsPerHost
        }</span>
}

func WithPathStyle(pathStyle bool) configurer <span class="cov0" title="0">{
        return func(conf *config) </span><span class="cov0" title="0">{
                conf.pathStyle = pathStyle
        }</span>
}

func WithSignature(signature SignatureType) configurer <span class="cov0" title="0">{
        return func(conf *config) </span><span class="cov0" title="0">{
                conf.signature = signature
        }</span>
}

func WithRegion(region string) configurer <span class="cov0" title="0">{
        return func(conf *config) </span><span class="cov0" title="0">{
                conf.region = region
        }</span>
}

func WithConnectTimeout(connectTimeout int) configurer <span class="cov0" title="0">{
        return func(conf *config) </span><span class="cov0" title="0">{
                conf.connectTimeout = connectTimeout
        }</span>
}

func WithSocketTimeout(socketTimeout int) configurer <span class="cov0" title="0">{
        return func(conf *config) </span><span class="cov0" title="0">{
                conf.socketTimeout = socketTimeout
        }</span>
}

func WithIdleConnTimeout(idleConnTimeout int) configurer <span class="cov0" title="0">{
        return func(conf *config) </span><span class="cov0" title="0">{
                conf.idleConnTimeout = idleConnTimeout
        }</span>
}

func WithMaxRetryCount(maxRetryCount int) configurer <span class="cov0" title="0">{
        return func(conf *config) </span><span class="cov0" title="0">{
                conf.maxRetryCount = maxRetryCount
        }</span>
}

func WithSecurityToken(securityToken string) configurer <span class="cov0" title="0">{
        return func(conf *config) </span><span class="cov0" title="0">{
                conf.securityProvider.securityToken = securityToken
        }</span>
}

func (conf *config) initConfigWithDefault() error <span class="cov0" title="0">{
        conf.securityProvider.ak = strings.TrimSpace(conf.securityProvider.ak)
        conf.securityProvider.sk = strings.TrimSpace(conf.securityProvider.sk)
        conf.securityProvider.securityToken = strings.TrimSpace(conf.securityProvider.securityToken)
        conf.endpoint = strings.TrimSpace(conf.endpoint)
        if conf.endpoint == "" </span><span class="cov0" title="0">{
                return errors.New("endpoint is not set")
        }</span>

        <span class="cov0" title="0">if index := strings.Index(conf.endpoint, "?"); index &gt; 0 </span><span class="cov0" title="0">{
                conf.endpoint = conf.endpoint[:index]
        }</span>

        <span class="cov0" title="0">for strings.LastIndex(conf.endpoint, "/") == len(conf.endpoint)-1 </span><span class="cov0" title="0">{
                conf.endpoint = conf.endpoint[:len(conf.endpoint)-1]
        }</span>

        <span class="cov0" title="0">if conf.signature == "" </span><span class="cov0" title="0">{
                conf.signature = DEFAULT_SIGNATURE
        }</span>

        <span class="cov0" title="0">urlHolder := &amp;urlHolder{}
        var address string
        if strings.HasPrefix(conf.endpoint, "https://") </span><span class="cov0" title="0">{
                urlHolder.scheme = "https"
                address = conf.endpoint[len("https://"):]
        }</span> else<span class="cov0" title="0"> if strings.HasPrefix(conf.endpoint, "http://") </span><span class="cov0" title="0">{
                urlHolder.scheme = "http"
                address = conf.endpoint[len("http://"):]
        }</span> else<span class="cov0" title="0"> {
                urlHolder.scheme = "http"
                address = conf.endpoint
        }</span>

        <span class="cov0" title="0">addr := strings.Split(address, ":")
        if len(addr) == 2 </span><span class="cov0" title="0">{
                if port, err := strconv.Atoi(addr[1]); err == nil </span><span class="cov0" title="0">{
                        urlHolder.port = port
                }</span>
        }
        <span class="cov0" title="0">urlHolder.host = addr[0]
        if urlHolder.port == 0 </span><span class="cov0" title="0">{
                if urlHolder.scheme == "https" </span><span class="cov0" title="0">{
                        urlHolder.port = 443
                }</span> else<span class="cov0" title="0"> {
                        urlHolder.port = 80
                }</span>
        }

        <span class="cov0" title="0">if IsIP(urlHolder.host) </span><span class="cov0" title="0">{
                conf.pathStyle = true
        }</span>

        <span class="cov0" title="0">conf.urlHolder = urlHolder

        conf.region = strings.TrimSpace(conf.region)
        if conf.region == "" </span><span class="cov0" title="0">{
                conf.region = DEFAULT_REGION
        }</span>

        <span class="cov0" title="0">if conf.connectTimeout &lt;= 0 </span><span class="cov0" title="0">{
                conf.connectTimeout = DEFAULT_CONNECT_TIMEOUT
        }</span>

        <span class="cov0" title="0">if conf.socketTimeout &lt;= 0 </span><span class="cov0" title="0">{
                conf.socketTimeout = DEFAULT_SOCKET_TIMEOUT
        }</span>

        <span class="cov0" title="0">conf.finalTimeout = conf.socketTimeout * 10

        if conf.headerTimeout &lt;= 0 </span><span class="cov0" title="0">{
                conf.headerTimeout = DEFAULT_HEADER_TIMEOUT
        }</span>

        <span class="cov0" title="0">if conf.idleConnTimeout &lt; 0 </span><span class="cov0" title="0">{
                conf.idleConnTimeout = DEFAULT_IDLE_CONN_TIMEOUT
        }</span>

        <span class="cov0" title="0">if conf.maxRetryCount &lt; 0 </span><span class="cov0" title="0">{
                conf.maxRetryCount = DEFAULT_MAX_RETRY_COUNT
        }</span>

        <span class="cov0" title="0">if conf.maxConnsPerHost &lt;= 0 </span><span class="cov0" title="0">{
                conf.maxConnsPerHost = DEFAULT_MAX_CONN_PER_HOST
        }</span>

        <span class="cov0" title="0">conf.proxyUrl = strings.TrimSpace(conf.proxyUrl)
        return nil</span>
}

func (conf *config) getTransport() (*http.Transport, error) <span class="cov0" title="0">{
        transport := &amp;http.Transport{
                Dial: func(network, addr string) (net.Conn, error) </span><span class="cov0" title="0">{
                        conn, err := net.DialTimeout(network, addr, time.Second*time.Duration(conf.connectTimeout))
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">return getConnDelegate(conn, conf.socketTimeout, conf.finalTimeout), nil</span>
                },
                MaxIdleConns:          conf.maxConnsPerHost,
                MaxIdleConnsPerHost:   conf.maxConnsPerHost,
                ResponseHeaderTimeout: time.Second * time.Duration(conf.headerTimeout),
                IdleConnTimeout:       time.Second * time.Duration(conf.idleConnTimeout),
        }

        <span class="cov0" title="0">if conf.proxyUrl != "" </span><span class="cov0" title="0">{
                proxyUrl, err := url.Parse(conf.proxyUrl)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">transport.Proxy = http.ProxyURL(proxyUrl)</span>
        }

        <span class="cov0" title="0">tlsConfig := &amp;tls.Config{InsecureSkipVerify: !conf.sslVerify}
        if conf.sslVerify &amp;&amp; conf.pemCerts != nil </span><span class="cov0" title="0">{
                pool := x509.NewCertPool()
                pool.AppendCertsFromPEM(conf.pemCerts)
                tlsConfig.RootCAs = pool
        }</span>
        <span class="cov0" title="0">transport.TLSClientConfig = tlsConfig

        return transport, nil</span>
}

func checkRedirectFunc(req *http.Request, via []*http.Request) error <span class="cov0" title="0">{
        return http.ErrUseLastResponse
}</span>

func DummyQueryEscape(s string) string <span class="cov0" title="0">{
        return s
}</span>

func (conf *config) formatUrls(bucketName, objectKey string, params map[string]string, escape bool) (requestUrl string, canonicalizedUrl string) <span class="cov0" title="0">{

        urlHolder := conf.urlHolder

        if bucketName == "" </span><span class="cov0" title="0">{
                requestUrl = fmt.Sprintf("%s://%s:%d", urlHolder.scheme, urlHolder.host, urlHolder.port)
                canonicalizedUrl = "/"
        }</span> else<span class="cov0" title="0"> {
                if conf.pathStyle </span><span class="cov0" title="0">{
                        requestUrl = fmt.Sprintf("%s://%s:%d/%s", urlHolder.scheme, urlHolder.host, urlHolder.port, bucketName)
                        canonicalizedUrl = "/" + bucketName
                }</span> else<span class="cov0" title="0"> {
                        requestUrl = fmt.Sprintf("%s://%s.%s:%d", urlHolder.scheme, bucketName, urlHolder.host, urlHolder.port)
                        if conf.signature == "v2" </span><span class="cov0" title="0">{
                                canonicalizedUrl = "/" + bucketName + "/"
                        }</span> else<span class="cov0" title="0"> {
                                canonicalizedUrl = "/"
                        }</span>
                }
        }
        <span class="cov0" title="0">var escapeFunc func(s string) string
        if escape </span><span class="cov0" title="0">{
                escapeFunc = url.QueryEscape
        }</span> else<span class="cov0" title="0"> {
                escapeFunc = DummyQueryEscape
        }</span>

        <span class="cov0" title="0">if objectKey != "" </span><span class="cov0" title="0">{
                encodeObjectKey := escapeFunc(objectKey)
                requestUrl += "/" + encodeObjectKey
                if !strings.HasSuffix(canonicalizedUrl, "/") </span><span class="cov0" title="0">{
                        canonicalizedUrl += "/"
                }</span>
                <span class="cov0" title="0">canonicalizedUrl += encodeObjectKey</span>
        }

        <span class="cov0" title="0">keys := make([]string, 0, len(params))
        for key, _ := range params </span><span class="cov0" title="0">{
                keys = append(keys, strings.TrimSpace(key))
        }</span>
        <span class="cov0" title="0">sort.Strings(keys)
        i := 0

        for index, key := range keys </span><span class="cov0" title="0">{
                if index == 0 </span><span class="cov0" title="0">{
                        requestUrl += "?"
                }</span> else<span class="cov0" title="0"> {
                        requestUrl += "&amp;"
                }</span>
                <span class="cov0" title="0">_key := url.QueryEscape(key)
                requestUrl += _key

                _value := params[key]

                if conf.signature == "v4" </span><span class="cov0" title="0">{
                        requestUrl += "=" + url.QueryEscape(_value)
                }</span> else<span class="cov0" title="0"> {
                        if _value != "" </span><span class="cov0" title="0">{
                                requestUrl += "=" + url.QueryEscape(_value)
                                _value = "=" + _value
                        }</span> else<span class="cov0" title="0"> {
                                _value = ""
                        }</span>
                        <span class="cov0" title="0">lowerKey := strings.ToLower(key)
                        _, ok := allowed_resource_parameter_names[lowerKey]
                        ok = ok || strings.HasPrefix(lowerKey, HEADER_PREFIX)
                        if ok </span><span class="cov0" title="0">{
                                if i == 0 </span><span class="cov0" title="0">{
                                        canonicalizedUrl += "?"
                                }</span> else<span class="cov0" title="0"> {
                                        canonicalizedUrl += "&amp;"
                                }</span>
                                <span class="cov0" title="0">canonicalizedUrl += getQueryUrl(_key, _value)
                                i++</span>
                        }
                }
        }
        <span class="cov0" title="0">return</span>
}

func getQueryUrl(key, value string) string <span class="cov0" title="0">{
        queryUrl := ""
        queryUrl += key
        queryUrl += value
        return queryUrl
}</span>
</pre>
		
		<pre class="file" id="file66" style="display: none">package obs

import (
        "bytes"
        "fmt"
        "io"
        "io/ioutil"
        "net/http"
        "reflect"
        "strings"
        "time"

        log "github.com/sirupsen/logrus"
)

func cleanHeaderPrefix(header http.Header) map[string][]string <span class="cov0" title="0">{
        responseHeaders := make(map[string][]string)
        for key, value := range header </span><span class="cov0" title="0">{
                if len(value) &gt; 0 </span><span class="cov0" title="0">{
                        key = strings.ToLower(key)
                        if strings.HasPrefix(key, HEADER_PREFIX) </span><span class="cov0" title="0">{
                                key = key[len(HEADER_PREFIX):]
                        }</span>
                        <span class="cov0" title="0">responseHeaders[key] = value</span>
                }
        }
        <span class="cov0" title="0">return responseHeaders</span>
}

func ParseStringToStorageClassType(value string) (ret StorageClassType) <span class="cov0" title="0">{
        switch value </span>{
        case "STANDARD":<span class="cov0" title="0">
                ret = StorageClassStandard</span>
        case "STANDARD_IA":<span class="cov0" title="0">
                ret = StorageClassWarm</span>
        case "GLACIER":<span class="cov0" title="0">
                ret = StorageClassCold</span>
        default:<span class="cov0" title="0">
                ret = ""</span>
        }
        <span class="cov0" title="0">return</span>
}

func convertGrantToXml(grant Grant) string <span class="cov0" title="0">{
        xml := make([]string, 0, 4)
        xml = append(xml, fmt.Sprintf("&lt;Grant&gt;&lt;Grantee xsi:type=\"%s\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"&gt;", grant.Grantee.Type))
        if grant.Grantee.Type == GranteeUser </span><span class="cov0" title="0">{
                xml = append(xml, fmt.Sprintf("&lt;ID&gt;%s&lt;/ID&gt;", grant.Grantee.ID))
                if grant.Grantee.DisplayName != "" </span><span class="cov0" title="0">{
                        xml = append(xml, fmt.Sprintf("&lt;DisplayName&gt;%s&lt;/DisplayName&gt;", grant.Grantee.DisplayName))
                }</span>
        } else<span class="cov0" title="0"> {
                xml = append(xml, fmt.Sprintf("&lt;URI&gt;%s&lt;/URI&gt;", grant.Grantee.URI))
        }</span>
        <span class="cov0" title="0">xml = append(xml, fmt.Sprintf("&lt;/Grantee&gt;&lt;Permission&gt;%s&lt;/Permission&gt;&lt;/Grant&gt;", grant.Permission))
        return strings.Join(xml, "")</span>
}

func ConvertLoggingStatusToXml(input BucketLoggingStatus, returnMd5 bool) (data string, md5 string) <span class="cov0" title="0">{
        grantsLength := len(input.TargetGrants)
        xml := make([]string, 0, 8+grantsLength)

        xml = append(xml, "&lt;BucketLoggingStatus&gt;")
        if input.TargetBucket != "" || input.TargetPrefix != "" </span><span class="cov0" title="0">{
                xml = append(xml, "&lt;LoggingEnabled&gt;")
                xml = append(xml, fmt.Sprintf("&lt;TargetBucket&gt;%s&lt;/TargetBucket&gt;", input.TargetBucket))
                xml = append(xml, fmt.Sprintf("&lt;TargetPrefix&gt;%s&lt;/TargetPrefix&gt;", input.TargetPrefix))

                if grantsLength &gt; 0 </span><span class="cov0" title="0">{
                        xml = append(xml, "&lt;TargetGrants&gt;")
                        for _, grant := range input.TargetGrants </span><span class="cov0" title="0">{
                                xml = append(xml, convertGrantToXml(grant))
                        }</span>
                        <span class="cov0" title="0">xml = append(xml, "&lt;/TargetGrants&gt;")</span>
                }

                <span class="cov0" title="0">xml = append(xml, "&lt;/LoggingEnabled&gt;")</span>
        }
        <span class="cov0" title="0">xml = append(xml, "&lt;/BucketLoggingStatus&gt;")
        data = strings.Join(xml, "")
        if returnMd5 </span><span class="cov0" title="0">{
                md5 = Base64Md5([]byte(data))
        }</span>
        <span class="cov0" title="0">return</span>
}

func ConvertAclToXml(input AccessControlPolicy, returnMd5 bool) (data string, md5 string) <span class="cov0" title="0">{
        xml := make([]string, 0, 4+len(input.Grants))
        xml = append(xml, fmt.Sprintf("&lt;AccessControlPolicy&gt;&lt;Owner&gt;&lt;ID&gt;%s&lt;/ID&gt;", input.Owner.ID))
        if input.Owner.DisplayName != "" </span><span class="cov0" title="0">{
                xml = append(xml, fmt.Sprintf("&lt;DisplayName&gt;%s&lt;/DisplayName&gt;", input.Owner.DisplayName))
        }</span>
        <span class="cov0" title="0">xml = append(xml, "&lt;/Owner&gt;&lt;AccessControlList&gt;")
        for _, grant := range input.Grants </span><span class="cov0" title="0">{
                xml = append(xml, convertGrantToXml(grant))
        }</span>
        <span class="cov0" title="0">xml = append(xml, "&lt;/AccessControlList&gt;&lt;/AccessControlPolicy&gt;")
        data = strings.Join(xml, "")
        if returnMd5 </span><span class="cov0" title="0">{
                md5 = Base64Md5([]byte(data))
        }</span>
        <span class="cov0" title="0">return</span>
}

func convertConditionToXml(condition Condition) string <span class="cov0" title="0">{
        xml := make([]string, 0, 2)
        if condition.KeyPrefixEquals != "" </span><span class="cov0" title="0">{
                xml = append(xml, fmt.Sprintf("&lt;KeyPrefixEquals&gt;%s&lt;/KeyPrefixEquals&gt;", condition.KeyPrefixEquals))
        }</span>
        <span class="cov0" title="0">if condition.HttpErrorCodeReturnedEquals != "" </span><span class="cov0" title="0">{
                xml = append(xml, fmt.Sprintf("&lt;HttpErrorCodeReturnedEquals&gt;%s&lt;/HttpErrorCodeReturnedEquals&gt;", condition.HttpErrorCodeReturnedEquals))
        }</span>
        <span class="cov0" title="0">if len(xml) &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Sprintf("&lt;Condition&gt;%s&lt;/Condition&gt;", strings.Join(xml, ""))
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func ConvertWebsiteConfigurationToXml(input BucketWebsiteConfiguration, returnMd5 bool) (data string, md5 string) <span class="cov0" title="0">{
        routingRuleLength := len(input.RoutingRules)
        xml := make([]string, 0, 6+routingRuleLength*10)
        xml = append(xml, "&lt;WebsiteConfiguration&gt;")

        if input.RedirectAllRequestsTo.HostName != "" </span><span class="cov0" title="0">{
                xml = append(xml, fmt.Sprintf("&lt;RedirectAllRequestsTo&gt;&lt;HostName&gt;%s&lt;/HostName&gt;", input.RedirectAllRequestsTo.HostName))
                if input.RedirectAllRequestsTo.Protocol != "" </span><span class="cov0" title="0">{
                        xml = append(xml, fmt.Sprintf("&lt;Protocol&gt;%s&lt;/Protocol&gt;", input.RedirectAllRequestsTo.Protocol))
                }</span>
                <span class="cov0" title="0">xml = append(xml, "&lt;/RedirectAllRequestsTo&gt;")</span>
        } else<span class="cov0" title="0"> {
                xml = append(xml, fmt.Sprintf("&lt;IndexDocument&gt;&lt;Suffix&gt;%s&lt;/Suffix&gt;&lt;/IndexDocument&gt;", input.IndexDocument.Suffix))
                if input.ErrorDocument.Key != "" </span><span class="cov0" title="0">{
                        xml = append(xml, fmt.Sprintf("&lt;ErrorDocument&gt;&lt;Key&gt;%s&lt;/Key&gt;&lt;/ErrorDocument&gt;", input.ErrorDocument.Key))
                }</span>
                <span class="cov0" title="0">if routingRuleLength &gt; 0 </span><span class="cov0" title="0">{
                        xml = append(xml, "&lt;RoutingRules&gt;")
                        for _, routingRule := range input.RoutingRules </span><span class="cov0" title="0">{
                                xml = append(xml, "&lt;RoutingRule&gt;")
                                xml = append(xml, "&lt;Redirect&gt;")
                                if routingRule.Redirect.Protocol != "" </span><span class="cov0" title="0">{
                                        xml = append(xml, fmt.Sprintf("&lt;Protocol&gt;%s&lt;/Protocol&gt;", routingRule.Redirect.Protocol))
                                }</span>
                                <span class="cov0" title="0">if routingRule.Redirect.HostName != "" </span><span class="cov0" title="0">{
                                        xml = append(xml, fmt.Sprintf("&lt;HostName&gt;%s&lt;/HostName&gt;", routingRule.Redirect.HostName))
                                }</span>
                                <span class="cov0" title="0">if routingRule.Redirect.ReplaceKeyPrefixWith != "" </span><span class="cov0" title="0">{
                                        xml = append(xml, fmt.Sprintf("&lt;ReplaceKeyPrefixWith&gt;%s&lt;/ReplaceKeyPrefixWith&gt;", routingRule.Redirect.ReplaceKeyPrefixWith))
                                }</span>

                                <span class="cov0" title="0">if routingRule.Redirect.ReplaceKeyWith != "" </span><span class="cov0" title="0">{
                                        xml = append(xml, fmt.Sprintf("&lt;ReplaceKeyWith&gt;%s&lt;/ReplaceKeyWith&gt;", routingRule.Redirect.ReplaceKeyWith))
                                }</span>
                                <span class="cov0" title="0">if routingRule.Redirect.HttpRedirectCode != "" </span><span class="cov0" title="0">{
                                        xml = append(xml, fmt.Sprintf("&lt;HttpRedirectCode&gt;%s&lt;/HttpRedirectCode&gt;", routingRule.Redirect.HttpRedirectCode))
                                }</span>
                                <span class="cov0" title="0">xml = append(xml, "&lt;/Redirect&gt;")

                                if ret := convertConditionToXml(routingRule.Condition); ret != "" </span><span class="cov0" title="0">{
                                        xml = append(xml, ret)
                                }</span>
                                <span class="cov0" title="0">xml = append(xml, "&lt;/RoutingRule&gt;")</span>
                        }
                        <span class="cov0" title="0">xml = append(xml, "&lt;/RoutingRules&gt;")</span>
                }
        }

        <span class="cov0" title="0">xml = append(xml, "&lt;/WebsiteConfiguration&gt;")
        data = strings.Join(xml, "")
        if returnMd5 </span><span class="cov0" title="0">{
                md5 = Base64Md5([]byte(data))
        }</span>
        <span class="cov0" title="0">return</span>
}

func convertTransitionsToXml(transitions []Transition) string <span class="cov0" title="0">{
        if length := len(transitions); length &gt; 0 </span><span class="cov0" title="0">{
                xml := make([]string, 0, length)
                for _, transition := range transitions </span><span class="cov0" title="0">{
                        var temp string
                        if transition.Days &gt; 0 </span><span class="cov0" title="0">{
                                temp = fmt.Sprintf("&lt;Days&gt;%d&lt;/Days&gt;", transition.Days)
                        }</span> else<span class="cov0" title="0"> if !transition.Date.IsZero() </span><span class="cov0" title="0">{
                                temp = fmt.Sprintf("&lt;Date&gt;%s&lt;/Date&gt;", transition.Date.UTC().Format(ISO8601_MIDNIGHT_DATE_FORMAT))
                        }</span>
                        <span class="cov0" title="0">if temp != "" </span><span class="cov0" title="0">{
                                xml = append(xml, fmt.Sprintf("&lt;Transition&gt;%s&lt;StorageClass&gt;%s&lt;/StorageClass&gt;&lt;/Transition&gt;", temp, transition.StorageClass))
                        }</span>
                }
                <span class="cov0" title="0">return strings.Join(xml, "")</span>
        }
        <span class="cov0" title="0">return ""</span>
}

func convertExpirationToXml(expiration Expiration) string <span class="cov0" title="0">{
        if expiration.Days &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Sprintf("&lt;Expiration&gt;&lt;Days&gt;%d&lt;/Days&gt;&lt;/Expiration&gt;", expiration.Days)
        }</span> else<span class="cov0" title="0"> if !expiration.Date.IsZero() </span><span class="cov0" title="0">{
                return fmt.Sprintf("&lt;Expiration&gt;&lt;Date&gt;%s&lt;/Date&gt;&lt;/Expiration&gt;", expiration.Date.UTC().Format(ISO8601_MIDNIGHT_DATE_FORMAT))
        }</span>
        <span class="cov0" title="0">return ""</span>
}
func convertNoncurrentVersionTransitionsToXml(noncurrentVersionTransitions []NoncurrentVersionTransition) string <span class="cov0" title="0">{
        if length := len(noncurrentVersionTransitions); length &gt; 0 </span><span class="cov0" title="0">{
                xml := make([]string, 0, length)
                for _, noncurrentVersionTransition := range noncurrentVersionTransitions </span><span class="cov0" title="0">{
                        if noncurrentVersionTransition.NoncurrentDays &gt; 0 </span><span class="cov0" title="0">{
                                xml = append(xml, fmt.Sprintf("&lt;NoncurrentVersionTransition&gt;&lt;NoncurrentDays&gt;%d&lt;/NoncurrentDays&gt;"+
                                        "&lt;StorageClass&gt;%s&lt;/StorageClass&gt;&lt;/NoncurrentVersionTransition&gt;",
                                        noncurrentVersionTransition.NoncurrentDays, noncurrentVersionTransition.StorageClass))
                        }</span>
                }
                <span class="cov0" title="0">return strings.Join(xml, "")</span>
        }
        <span class="cov0" title="0">return ""</span>
}
func convertNoncurrentVersionExpirationToXml(noncurrentVersionExpiration NoncurrentVersionExpiration) string <span class="cov0" title="0">{
        if noncurrentVersionExpiration.NoncurrentDays &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Sprintf("&lt;NoncurrentVersionExpiration&gt;&lt;NoncurrentDays&gt;%d&lt;/NoncurrentDays&gt;&lt;/NoncurrentVersionExpiration&gt;", noncurrentVersionExpiration.NoncurrentDays)
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func ConvertLifecyleConfigurationToXml(input BucketLifecyleConfiguration, returnMd5 bool) (data string, md5 string) <span class="cov0" title="0">{
        xml := make([]string, 0, 2+len(input.LifecycleRules)*9)
        xml = append(xml, "&lt;LifecycleConfiguration&gt;")
        for _, lifecyleRule := range input.LifecycleRules </span><span class="cov0" title="0">{
                xml = append(xml, "&lt;Rule&gt;")
                if lifecyleRule.ID != "" </span><span class="cov0" title="0">{
                        xml = append(xml, fmt.Sprintf("&lt;ID&gt;%s&lt;/ID&gt;", lifecyleRule.ID))
                }</span>
                <span class="cov0" title="0">xml = append(xml, fmt.Sprintf("&lt;Prefix&gt;%s&lt;/Prefix&gt;", lifecyleRule.Prefix))
                xml = append(xml, fmt.Sprintf("&lt;Status&gt;%s&lt;/Status&gt;", lifecyleRule.Status))
                if ret := convertTransitionsToXml(lifecyleRule.Transitions); ret != "" </span><span class="cov0" title="0">{
                        xml = append(xml, ret)
                }</span>
                <span class="cov0" title="0">if ret := convertExpirationToXml(lifecyleRule.Expiration); ret != "" </span><span class="cov0" title="0">{
                        xml = append(xml, ret)
                }</span>
                <span class="cov0" title="0">if ret := convertNoncurrentVersionTransitionsToXml(lifecyleRule.NoncurrentVersionTransitions); ret != "" </span><span class="cov0" title="0">{
                        xml = append(xml, ret)
                }</span>
                <span class="cov0" title="0">if ret := convertNoncurrentVersionExpirationToXml(lifecyleRule.NoncurrentVersionExpiration); ret != "" </span><span class="cov0" title="0">{
                        xml = append(xml, ret)
                }</span>
                <span class="cov0" title="0">xml = append(xml, "&lt;/Rule&gt;")</span>
        }
        <span class="cov0" title="0">xml = append(xml, "&lt;/LifecycleConfiguration&gt;")
        data = strings.Join(xml, "")
        if returnMd5 </span><span class="cov0" title="0">{
                md5 = Base64Md5([]byte(data))
        }</span>
        <span class="cov0" title="0">return</span>
}

func converntFilterRulesToXml(filterRules []FilterRule) string <span class="cov0" title="0">{
        if length := len(filterRules); length &gt; 0 </span><span class="cov0" title="0">{
                xml := make([]string, 0, length*4)
                for _, filterRule := range filterRules </span><span class="cov0" title="0">{
                        xml = append(xml, "&lt;FilterRule&gt;")
                        if filterRule.Name != "" </span><span class="cov0" title="0">{
                                xml = append(xml, fmt.Sprintf("&lt;Name&gt;%s&lt;/Name&gt;", filterRule.Name))
                        }</span>
                        <span class="cov0" title="0">if filterRule.Value != "" </span><span class="cov0" title="0">{
                                xml = append(xml, fmt.Sprintf("&lt;Value&gt;%s&lt;/Value&gt;", filterRule.Value))
                        }</span>
                        <span class="cov0" title="0">xml = append(xml, "&lt;/FilterRule&gt;")</span>
                }
                <span class="cov0" title="0">return fmt.Sprintf("&lt;Filter&gt;&lt;S3Key&gt;%s&lt;/S3Key&gt;&lt;/Filter&gt;", strings.Join(xml, ""))</span>
        }
        <span class="cov0" title="0">return ""</span>
}

func converntEventsToXml(events []string) string <span class="cov0" title="0">{
        if length := len(events); length &gt; 0 </span><span class="cov0" title="0">{
                xml := make([]string, 0, length)
                for _, event := range events </span><span class="cov0" title="0">{
                        xml = append(xml, fmt.Sprintf("&lt;Event&gt;%s&lt;/Event&gt;", event))
                }</span>
                <span class="cov0" title="0">return strings.Join(xml, "")</span>
        }
        <span class="cov0" title="0">return ""</span>
}

func ConvertNotificationToXml(input BucketNotification, returnMd5 bool) (data string, md5 string) <span class="cov0" title="0">{
        xml := make([]string, 0, 2+len(input.TopicConfigurations)*6)
        xml = append(xml, "&lt;NotificationConfiguration&gt;")
        for _, topicConfiguration := range input.TopicConfigurations </span><span class="cov0" title="0">{
                xml = append(xml, "&lt;TopicConfiguration&gt;")
                if topicConfiguration.ID != "" </span><span class="cov0" title="0">{
                        xml = append(xml, fmt.Sprintf("&lt;Id&gt;%s&lt;/Id&gt;", topicConfiguration.ID))
                }</span>
                <span class="cov0" title="0">xml = append(xml, fmt.Sprintf("&lt;Topic&gt;%s&lt;/Topic&gt;", topicConfiguration.Topic))

                if ret := converntEventsToXml(topicConfiguration.Events); ret != "" </span><span class="cov0" title="0">{
                        xml = append(xml, ret)
                }</span>
                <span class="cov0" title="0">if ret := converntFilterRulesToXml(topicConfiguration.FilterRules); ret != "" </span><span class="cov0" title="0">{
                        xml = append(xml, ret)
                }</span>
                <span class="cov0" title="0">xml = append(xml, "&lt;/TopicConfiguration&gt;")</span>
        }
        <span class="cov0" title="0">xml = append(xml, "&lt;/NotificationConfiguration&gt;")
        data = strings.Join(xml, "")
        if returnMd5 </span><span class="cov0" title="0">{
                md5 = Base64Md5([]byte(data))
        }</span>
        <span class="cov0" title="0">return</span>
}

func ConvertCompleteMultipartUploadInputToXml(input CompleteMultipartUploadInput, returnMd5 bool) (data string, md5 string) <span class="cov0" title="0">{
        xml := make([]string, 0, 2+len(input.Parts)*4)
        xml = append(xml, "&lt;CompleteMultipartUpload&gt;")
        for _, part := range input.Parts </span><span class="cov0" title="0">{
                xml = append(xml, "&lt;Part&gt;")
                xml = append(xml, fmt.Sprintf("&lt;PartNumber&gt;%d&lt;/PartNumber&gt;", part.PartNumber))
                xml = append(xml, fmt.Sprintf("&lt;ETag&gt;%s&lt;/ETag&gt;", part.ETag))
                xml = append(xml, "&lt;/Part&gt;")
        }</span>
        <span class="cov0" title="0">xml = append(xml, "&lt;/CompleteMultipartUpload&gt;")
        data = strings.Join(xml, "")
        if returnMd5 </span><span class="cov0" title="0">{
                md5 = Base64Md5([]byte(data))
        }</span>
        <span class="cov0" title="0">return</span>
}

func parseSseHeader(responseHeaders map[string][]string) (sseHeader ISseHeader) <span class="cov0" title="0">{
        if ret, ok := responseHeaders[HEADER_SSEC_ENCRYPTION]; ok </span><span class="cov0" title="0">{
                sseCHeader := SseCHeader{Encryption: ret[0]}
                if ret, ok = responseHeaders[HEADER_SSEC_KEY_MD5]; ok </span><span class="cov0" title="0">{
                        sseCHeader.KeyMD5 = ret[0]
                }</span>
                <span class="cov0" title="0">sseHeader = sseCHeader</span>
        } else<span class="cov0" title="0"> if ret, ok := responseHeaders[HEADER_SSEKMS_ENCRYPTION]; ok </span><span class="cov0" title="0">{
                sseKmsHeader := SseKmsHeader{Encryption: ret[0]}
                if ret, ok = responseHeaders[HEADER_SSEKMS_KEY]; ok </span><span class="cov0" title="0">{
                        sseKmsHeader.Key = ret[0]
                }</span>
                <span class="cov0" title="0">sseHeader = sseKmsHeader</span>
        }
        <span class="cov0" title="0">return</span>
}

func ParseGetObjectMetadataOutput(output *GetObjectMetadataOutput) <span class="cov0" title="0">{
        if ret, ok := output.ResponseHeaders[HEADER_VERSION_ID]; ok </span><span class="cov0" title="0">{
                output.VersionId = ret[0]
        }</span>
        <span class="cov0" title="0">if ret, ok := output.ResponseHeaders[HEADER_WEBSITE_REDIRECT_LOCATION]; ok </span><span class="cov0" title="0">{
                output.WebsiteRedirectLocation = ret[0]
        }</span>
        <span class="cov0" title="0">if ret, ok := output.ResponseHeaders[HEADER_EXPIRATION]; ok </span><span class="cov0" title="0">{
                output.Expiration = ret[0]
        }</span>
        <span class="cov0" title="0">if ret, ok := output.ResponseHeaders[HEADER_RESTORE]; ok </span><span class="cov0" title="0">{
                output.Restore = ret[0]
        }</span>

        <span class="cov0" title="0">if ret, ok := output.ResponseHeaders[HEADER_STORAGE_CLASS2]; ok </span><span class="cov0" title="0">{
                output.StorageClass = ParseStringToStorageClassType(ret[0])
        }</span>
        <span class="cov0" title="0">if ret, ok := output.ResponseHeaders[HEADER_ETAG]; ok </span><span class="cov0" title="0">{
                output.ETag = ret[0]
        }</span>
        <span class="cov0" title="0">if ret, ok := output.ResponseHeaders[HEADER_CONTENT_TYPE]; ok </span><span class="cov0" title="0">{
                output.ContentType = ret[0]
        }</span>
        <span class="cov0" title="0">if ret, ok := output.ResponseHeaders[HEADER_ACCESS_CONRTOL_ALLOW_ORIGIN]; ok </span><span class="cov0" title="0">{
                output.AllowOrigin = ret[0]
        }</span>
        <span class="cov0" title="0">if ret, ok := output.ResponseHeaders[HEADER_ACCESS_CONRTOL_ALLOW_HEADERS]; ok </span><span class="cov0" title="0">{
                output.AllowHeader = ret[0]
        }</span>
        <span class="cov0" title="0">if ret, ok := output.ResponseHeaders[HEADER_ACCESS_CONRTOL_MAX_AGE]; ok </span><span class="cov0" title="0">{
                output.MaxAgeSeconds = StringToInt(ret[0], 0)
        }</span>
        <span class="cov0" title="0">if ret, ok := output.ResponseHeaders[HEADER_ACCESS_CONRTOL_ALLOW_METHODS]; ok </span><span class="cov0" title="0">{
                output.AllowMethod = ret[0]
        }</span>
        <span class="cov0" title="0">if ret, ok := output.ResponseHeaders[HEADER_ACCESS_CONRTOL_EXPOSE_HEADERS]; ok </span><span class="cov0" title="0">{
                output.ExposeHeader = ret[0]
        }</span>

        <span class="cov0" title="0">output.SseHeader = parseSseHeader(output.ResponseHeaders)
        if ret, ok := output.ResponseHeaders[HEADER_LASTMODIFIED]; ok </span><span class="cov0" title="0">{
                ret, err := time.Parse(time.RFC1123, ret[0])
                if err == nil </span><span class="cov0" title="0">{
                        output.LastModified = ret
                }</span>
        }
        <span class="cov0" title="0">if ret, ok := output.ResponseHeaders[HEADER_CONTENT_LENGTH]; ok </span><span class="cov0" title="0">{
                output.ContentLength = StringToInt64(ret[0], 0)
        }</span>

        <span class="cov0" title="0">output.Metadata = make(map[string]string)

        for key, value := range output.ResponseHeaders </span><span class="cov0" title="0">{
                if strings.HasPrefix(key, PREFIX_META) </span><span class="cov0" title="0">{
                        _key := key[len(PREFIX_META):]
                        output.ResponseHeaders[_key] = value
                        output.Metadata[_key] = value[0]
                        delete(output.ResponseHeaders, key)
                }</span>
        }

}

func ParseCopyObjectOutput(output *CopyObjectOutput) <span class="cov0" title="0">{
        if ret, ok := output.ResponseHeaders[HEADER_VERSION_ID]; ok </span><span class="cov0" title="0">{
                output.VersionId = ret[0]
        }</span>
        <span class="cov0" title="0">output.SseHeader = parseSseHeader(output.ResponseHeaders)
        if ret, ok := output.ResponseHeaders[HEADER_COPY_SOURCE_VERSION_ID]; ok </span><span class="cov0" title="0">{
                output.CopySourceVersionId = ret[0]
        }</span>
}

func ParsePutObjectOutput(output *PutObjectOutput) <span class="cov0" title="0">{
        if ret, ok := output.ResponseHeaders[HEADER_VERSION_ID]; ok </span><span class="cov0" title="0">{
                output.VersionId = ret[0]
        }</span>
        <span class="cov0" title="0">output.SseHeader = parseSseHeader(output.ResponseHeaders)
        if ret, ok := output.ResponseHeaders[HEADER_STORAGE_CLASS2]; ok </span><span class="cov0" title="0">{
                output.StorageClass = ParseStringToStorageClassType(ret[0])
        }</span>

        <span class="cov0" title="0">if ret, ok := output.ResponseHeaders[HEADER_ETAG]; ok </span><span class="cov0" title="0">{
                output.ETag = ret[0]
        }</span>
}

func ParseInitiateMultipartUploadOutput(output *InitiateMultipartUploadOutput) <span class="cov0" title="0">{
        output.SseHeader = parseSseHeader(output.ResponseHeaders)
}</span>

func ParseUploadPartOutput(output *UploadPartOutput) <span class="cov0" title="0">{
        output.SseHeader = parseSseHeader(output.ResponseHeaders)
        if ret, ok := output.ResponseHeaders[HEADER_ETAG]; ok </span><span class="cov0" title="0">{
                output.ETag = ret[0]
        }</span>
}

func ParseCompleteMultipartUploadOutput(output *CompleteMultipartUploadOutput) <span class="cov0" title="0">{
        output.SseHeader = parseSseHeader(output.ResponseHeaders)
        if ret, ok := output.ResponseHeaders[HEADER_VERSION_ID]; ok </span><span class="cov0" title="0">{
                output.VersionId = ret[0]
        }</span>
}

func ParseCopyPartOutput(output *CopyPartOutput) <span class="cov0" title="0">{
        output.SseHeader = parseSseHeader(output.ResponseHeaders)
}</span>

func ParseGetBucketMetadataOutput(output *GetBucketMetadataOutput) <span class="cov0" title="0">{
        if ret, ok := output.ResponseHeaders[HEADER_STORAGE_CLASS]; ok </span><span class="cov0" title="0">{
                output.StorageClass = ParseStringToStorageClassType(ret[0])
        }</span>
        <span class="cov0" title="0">if ret, ok := output.ResponseHeaders[HEADER_BUCKET_REGION]; ok </span><span class="cov0" title="0">{
                output.Location = ret[0]
        }</span>
        <span class="cov0" title="0">if ret, ok := output.ResponseHeaders[HEADER_ACCESS_CONRTOL_ALLOW_ORIGIN]; ok </span><span class="cov0" title="0">{
                output.AllowOrigin = ret[0]
        }</span>
        <span class="cov0" title="0">if ret, ok := output.ResponseHeaders[HEADER_ACCESS_CONRTOL_ALLOW_HEADERS]; ok </span><span class="cov0" title="0">{
                output.AllowHeader = ret[0]
        }</span>
        <span class="cov0" title="0">if ret, ok := output.ResponseHeaders[HEADER_ACCESS_CONRTOL_MAX_AGE]; ok </span><span class="cov0" title="0">{
                output.MaxAgeSeconds = StringToInt(ret[0], 0)
        }</span>
        <span class="cov0" title="0">if ret, ok := output.ResponseHeaders[HEADER_ACCESS_CONRTOL_ALLOW_METHODS]; ok </span><span class="cov0" title="0">{
                output.AllowMethod = ret[0]
        }</span>
        <span class="cov0" title="0">if ret, ok := output.ResponseHeaders[HEADER_ACCESS_CONRTOL_EXPOSE_HEADERS]; ok </span><span class="cov0" title="0">{
                output.ExposeHeader = ret[0]
        }</span>
}

func ParseDeleteObjectOutput(output *DeleteObjectOutput) <span class="cov0" title="0">{
        if versionId, ok := output.ResponseHeaders[HEADER_VERSION_ID]; ok </span><span class="cov0" title="0">{
                output.VersionId = versionId[0]
        }</span>

        <span class="cov0" title="0">if deleteMarker, ok := output.ResponseHeaders[HEADER_DELETE_MARKER]; ok </span><span class="cov0" title="0">{
                output.DeleteMarker = deleteMarker[0] == "true"
        }</span>
}

func ParseGetObjectOutput(output *GetObjectOutput) <span class="cov0" title="0">{
        ParseGetObjectMetadataOutput(&amp;output.GetObjectMetadataOutput)
        if ret, ok := output.ResponseHeaders[HEADER_DELETE_MARKER]; ok </span><span class="cov0" title="0">{
                output.DeleteMarker = ret[0] == "true"
        }</span>
        <span class="cov0" title="0">if ret, ok := output.ResponseHeaders[HEADER_CACHE_CONTROL]; ok </span><span class="cov0" title="0">{
                output.CacheControl = ret[0]
        }</span>
        <span class="cov0" title="0">if ret, ok := output.ResponseHeaders[HEADER_CONTENT_DISPOSITION]; ok </span><span class="cov0" title="0">{
                output.ContentDisposition = ret[0]
        }</span>
        <span class="cov0" title="0">if ret, ok := output.ResponseHeaders[HEADER_CONTENT_ENCODING]; ok </span><span class="cov0" title="0">{
                output.ContentEncoding = ret[0]
        }</span>
        <span class="cov0" title="0">if ret, ok := output.ResponseHeaders[HEADER_CONTENT_LANGUAGE]; ok </span><span class="cov0" title="0">{
                output.ContentLanguage = ret[0]
        }</span>
        <span class="cov0" title="0">if ret, ok := output.ResponseHeaders[HEADER_EXPIRES]; ok </span><span class="cov0" title="0">{
                output.Expires = ret[0]
        }</span>
}

func ConvertRequestToIoReaderV2(req interface{}) (io.Reader, string, error) <span class="cov0" title="0">{
        data, err := TransToXml(req)
        if err == nil </span><span class="cov0" title="0">{
                log.Debug("Do http request with data: %s", string(data))
                return bytes.NewReader(data), Base64Md5(data), nil
        }</span>
        <span class="cov0" title="0">return nil, "", err</span>
}

func ConvertRequestToIoReader(req interface{}) (io.Reader, error) <span class="cov0" title="0">{
        body, err := TransToXml(req)
        if err == nil </span><span class="cov0" title="0">{
                log.Debug("Do http request with data: %s", string(body))
                return bytes.NewReader(body), nil
        }</span>
        <span class="cov0" title="0">return nil, err</span>
}

func ParseResponseToBaseModel(resp *http.Response, baseModel IBaseModel, xmlResult bool) (err error) <span class="cov0" title="0">{
        readCloser, ok := baseModel.(IReadCloser)
        if !ok </span><span class="cov0" title="0">{
                defer resp.Body.Close()
                body, err := ioutil.ReadAll(resp.Body)
                if err == nil &amp;&amp; len(body) &gt; 0 </span><span class="cov0" title="0">{
                        if xmlResult </span><span class="cov0" title="0">{
                                err = ParseXml(body, baseModel)
                                if err != nil </span><span class="cov0" title="0">{
                                        log.Error("Unmarshal error: %v", err)
                                }</span>
                        } else<span class="cov0" title="0"> {
                                s := reflect.TypeOf(baseModel).Elem()
                                for i := 0; i &lt; s.NumField(); i++ </span><span class="cov0" title="0">{
                                        if s.Field(i).Tag == "body" </span><span class="cov0" title="0">{
                                                reflect.ValueOf(baseModel).Elem().FieldByName(s.Field(i).Name).SetString(string(body))
                                                break</span>
                                        }
                                }
                        }
                }
        } else<span class="cov0" title="0"> {
                readCloser.setReadCloser(resp.Body)
        }</span>

        <span class="cov0" title="0">baseModel.setStatusCode(resp.StatusCode)
        responseHeaders := cleanHeaderPrefix(resp.Header)
        baseModel.setResponseHeaders(responseHeaders)
        if values, ok := responseHeaders[HEADER_REQUEST_ID]; ok </span><span class="cov0" title="0">{
                baseModel.setRequestId(values[0])
        }</span>
        <span class="cov0" title="0">return</span>
}

func ParseResponseToObsError(resp *http.Response) error <span class="cov0" title="0">{
        obsError := ObsError{}
        ParseResponseToBaseModel(resp, &amp;obsError, true)
        obsError.Status = resp.Status
        return obsError
}</span>
</pre>
		
		<pre class="file" id="file67" style="display: none">package obs

import (
        "encoding/xml"
        "fmt"
)

type ObsError struct {
        BaseModel
        Status   string
        XMLName  xml.Name `xml:"Error"`
        Code     string   `xml:"Code"`
        Message  string   `xml:"Message"`
        Resource string   `xml:"Resource"`
        HostId   string   `xml:"HostId"`
}

func (err ObsError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("obs: service returned error: Status=%s, Code=%s, Message=%s, RequestId=%s",
                err.Status, err.Code, err.Message, err.RequestId)
}</span>
</pre>
		
		<pre class="file" id="file68" style="display: none">package obs

import (
        "bytes"
        "errors"
        "io"
        "math/rand"
        "net"
        "net/http"
        "net/url"
        "os"
        "strings"
        "time"

        log "github.com/sirupsen/logrus"
)

func prepareHeaders(headers map[string][]string, meta bool) map[string][]string <span class="cov0" title="0">{
        _headers := make(map[string][]string, len(headers))
        if headers != nil </span><span class="cov0" title="0">{
                for key, value := range headers </span><span class="cov0" title="0">{
                        key = strings.TrimSpace(key)
                        if key == "" </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">_key := strings.ToLower(key)
                        if _, ok := allowed_request_http_header_metadata_names[_key]; !ok &amp;&amp; !strings.HasPrefix(key, HEADER_PREFIX) </span><span class="cov0" title="0">{
                                if !meta </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov0" title="0">_key = HEADER_PREFIX_META + _key</span>
                        } else<span class="cov0" title="0"> {
                                _key = key
                        }</span>
                        <span class="cov0" title="0">_headers[_key] = value</span>
                }
        }
        <span class="cov0" title="0">return _headers</span>
}

func (obsClient ObsClient) doActionWithoutBucket(action, method string, input ISerializable, output IBaseModel) error <span class="cov0" title="0">{
        return obsClient.doAction(action, method, "", "", input, output, true, true)
}</span>

func (obsClient ObsClient) doActionWithBucketV2(action, method, bucketName string, input ISerializable, output IBaseModel) error <span class="cov0" title="0">{
        if strings.TrimSpace(bucketName) == "" </span><span class="cov0" title="0">{
                return errors.New("Bucket is empty")
        }</span>
        <span class="cov0" title="0">return obsClient.doAction(action, method, bucketName, "", input, output, false, true)</span>
}

func (obsClient ObsClient) doActionWithBucket(action, method, bucketName string, input ISerializable, output IBaseModel) error <span class="cov0" title="0">{
        if strings.TrimSpace(bucketName) == "" </span><span class="cov0" title="0">{
                return errors.New("Bucket is empty")
        }</span>
        <span class="cov0" title="0">return obsClient.doAction(action, method, bucketName, "", input, output, true, true)</span>
}

func (obsClient ObsClient) doActionWithBucketAndKey(action, method, bucketName, objectKey string, input ISerializable, output IBaseModel) error <span class="cov0" title="0">{
        return obsClient._doActionWithBucketAndKey(action, method, bucketName, objectKey, input, output, true)
}</span>

func (obsClient ObsClient) doActionWithBucketAndKeyUnRepeatable(action, method, bucketName, objectKey string, input ISerializable, output IBaseModel) error <span class="cov0" title="0">{
        return obsClient._doActionWithBucketAndKey(action, method, bucketName, objectKey, input, output, false)
}</span>

func (obsClient ObsClient) _doActionWithBucketAndKey(action, method, bucketName, objectKey string, input ISerializable, output IBaseModel, repeatable bool) error <span class="cov0" title="0">{
        if strings.TrimSpace(bucketName) == "" </span><span class="cov0" title="0">{
                return errors.New("Key is empty")
        }</span>
        <span class="cov0" title="0">if strings.TrimSpace(objectKey) == "" </span><span class="cov0" title="0">{
                return errors.New("Key is empty")
        }</span>
        <span class="cov0" title="0">return obsClient.doAction(action, method, bucketName, objectKey, input, output, true, repeatable)</span>
}

func (obsClient ObsClient) doAction(action, method, bucketName, objectKey string, input ISerializable, output IBaseModel, xmlResult bool, repeatable bool) error <span class="cov0" title="0">{

        var resp *http.Response
        var respError error
        log.Info("Enter method %s...", action)
        start := GetCurrentTimestamp()

        params, headers, data := input.trans()

        if params == nil </span><span class="cov0" title="0">{
                params = make(map[string]string)
        }</span>

        <span class="cov0" title="0">if headers == nil </span><span class="cov0" title="0">{
                headers = make(map[string][]string)
        }</span>

        <span class="cov0" title="0">switch method </span>{
        case HTTP_GET:<span class="cov0" title="0">
                resp, respError = obsClient.doHttpGet(bucketName, objectKey, params, headers, data, repeatable)</span>
        case HTTP_POST:<span class="cov0" title="0">
                resp, respError = obsClient.doHttpPost(bucketName, objectKey, params, headers, data, repeatable)</span>
        case HTTP_PUT:<span class="cov0" title="0">
                resp, respError = obsClient.doHttpPut(bucketName, objectKey, params, headers, data, repeatable)</span>
        case HTTP_DELETE:<span class="cov0" title="0">
                resp, respError = obsClient.doHttpDelete(bucketName, objectKey, params, headers, data, repeatable)</span>
        case HTTP_HEAD:<span class="cov0" title="0">
                resp, respError = obsClient.doHttpHead(bucketName, objectKey, params, headers, data, repeatable)</span>
        case HTTP_OPTIONS:<span class="cov0" title="0">
                resp, respError = obsClient.doHttpOptions(bucketName, objectKey, params, headers, data, repeatable)</span>
        default:<span class="cov0" title="0">
                respError = errors.New("Unexpect http method error")</span>
        }
        <span class="cov0" title="0">if respError == nil &amp;&amp; output != nil </span><span class="cov0" title="0">{
                respError = ParseResponseToBaseModel(resp, output, xmlResult)
                if respError != nil </span><span class="cov0" title="0">{
                        log.Warn("Parse response to BaseModel with error: %v", respError)
                }</span>
        } else<span class="cov0" title="0"> {
                log.Warn("Do http request with error: %v", respError)
        }</span>

        <span class="cov0" title="0">log.Debug("End method %s, obsclient cost %d ms", action, (GetCurrentTimestamp() - start))

        return respError</span>
}

func (obsClient ObsClient) doHttpGet(bucketName, objectKey string, params map[string]string,
        headers map[string][]string, data interface{}, repeatable bool) (*http.Response, error) <span class="cov0" title="0">{
        return obsClient.doHttp(HTTP_GET, bucketName, objectKey, params, prepareHeaders(headers, false), data, repeatable)
}</span>

func (obsClient ObsClient) doHttpHead(bucketName, objectKey string, params map[string]string,
        headers map[string][]string, data interface{}, repeatable bool) (*http.Response, error) <span class="cov0" title="0">{
        return obsClient.doHttp(HTTP_HEAD, bucketName, objectKey, params, prepareHeaders(headers, false), data, repeatable)
}</span>

func (obsClient ObsClient) doHttpOptions(bucketName, objectKey string, params map[string]string,
        headers map[string][]string, data interface{}, repeatable bool) (*http.Response, error) <span class="cov0" title="0">{
        return obsClient.doHttp(HTTP_OPTIONS, bucketName, objectKey, params, prepareHeaders(headers, false), data, repeatable)
}</span>

func (obsClient ObsClient) doHttpDelete(bucketName, objectKey string, params map[string]string,
        headers map[string][]string, data interface{}, repeatable bool) (*http.Response, error) <span class="cov0" title="0">{
        return obsClient.doHttp(HTTP_DELETE, bucketName, objectKey, params, prepareHeaders(headers, false), data, repeatable)
}</span>

func (obsClient ObsClient) doHttpPut(bucketName, objectKey string, params map[string]string,
        headers map[string][]string, data interface{}, repeatable bool) (*http.Response, error) <span class="cov0" title="0">{
        return obsClient.doHttp(HTTP_PUT, bucketName, objectKey, params, prepareHeaders(headers, true), data, repeatable)
}</span>

func (obsClient ObsClient) doHttpPost(bucketName, objectKey string, params map[string]string,
        headers map[string][]string, data interface{}, repeatable bool) (*http.Response, error) <span class="cov0" title="0">{
        return obsClient.doHttp(HTTP_POST, bucketName, objectKey, params, prepareHeaders(headers, true), data, repeatable)
}</span>

func (obsClient ObsClient) doHttpWithSignedUrl(action, method string, signedUrl string, actualSignedRequestHeaders http.Header, data io.Reader, output IBaseModel, xmlResult bool) (respError error) <span class="cov0" title="0">{
        req, err := http.NewRequest(method, signedUrl, data)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var resp *http.Response

        log.Info("Do %s with signedUrl %s...", action, signedUrl)

        req.Header = actualSignedRequestHeaders
        if value, ok := req.Header[HEADER_HOST_CAMEL]; ok </span><span class="cov0" title="0">{
                req.Host = value[0]
                delete(req.Header, HEADER_HOST_CAMEL)
        }</span> else<span class="cov0" title="0"> if value, ok := req.Header[HEADER_HOST]; ok </span><span class="cov0" title="0">{
                req.Host = value[0]
                delete(req.Header, HEADER_HOST)
        }</span>

        <span class="cov0" title="0">if value, ok := req.Header[HEADER_CONTENT_LENGTH_CAMEL]; ok </span><span class="cov0" title="0">{
                req.ContentLength = StringToInt64(value[0], -1)
                delete(req.Header, HEADER_CONTENT_LENGTH_CAMEL)
        }</span> else<span class="cov0" title="0"> if value, ok := req.Header[HEADER_CONTENT_LENGTH]; ok </span><span class="cov0" title="0">{
                req.ContentLength = StringToInt64(value[0], -1)
                delete(req.Header, HEADER_CONTENT_LENGTH)
        }</span>

        <span class="cov0" title="0">req.Header[HEADER_USER_AGENT_CAMEL] = []string{USER_AGENT}
        start := GetCurrentTimestamp()
        resp, err = obsClient.httpClient.Do(req)
        log.Info("Do http request cost %d ms", (GetCurrentTimestamp() - start))


        var msg interface{}
        if err != nil </span><span class="cov0" title="0">{
                respError = err
                resp = nil
        }</span> else<span class="cov0" title="0"> {
                log.Debug("Response headers: %v", resp.Header)
                if resp.StatusCode &gt;= 300 </span><span class="cov0" title="0">{
                        respError = ParseResponseToObsError(resp)
                        msg = resp.Status
                        resp = nil
                }</span> else<span class="cov0" title="0"> {
                        if output != nil </span><span class="cov0" title="0">{
                                respError = ParseResponseToBaseModel(resp, output, xmlResult)
                        }</span>
                        <span class="cov0" title="0">if respError != nil </span><span class="cov0" title="0">{
                                log.Warn("Parse response to BaseModel with error: %v", respError)
                        }</span>
                }
        }

        <span class="cov0" title="0">if msg != nil </span><span class="cov0" title="0">{
                log.Error("Failed to send request with reason:%v", msg)
        }</span>

        <span class="cov0" title="0">log.Debug("End method %s, obsclient cost %d ms", action, (GetCurrentTimestamp() - start))

        return</span>
}

func (obsClient ObsClient) doHttp(method, bucketName, objectKey string, params map[string]string,
        headers map[string][]string, data interface{}, repeatable bool) (resp *http.Response, respError error) <span class="cov0" title="0">{

        bucketName = strings.TrimSpace(bucketName)

        objectKey = strings.TrimSpace(objectKey)

        method = strings.ToUpper(method)

        var redirectUrl string
        var requestUrl string
        maxRetryCount := obsClient.conf.maxRetryCount

        var _data io.Reader
        if data != nil </span><span class="cov0" title="0">{
                if dataStr, ok := data.(string); ok </span><span class="cov0" title="0">{
                        log.Debug("Do http request with string: %s", dataStr)
                        headers["Content-Length"] = []string{IntToString(len(dataStr))}
                        _data = strings.NewReader(dataStr)
                }</span> else<span class="cov0" title="0"> if dataByte, ok := data.([]byte); ok </span><span class="cov0" title="0">{
                        log.Debug("Do http request with byte array")
                        headers["Content-Length"] = []string{IntToString(len(dataByte))}
                        _data = bytes.NewReader(dataByte)
                }</span> else<span class="cov0" title="0"> if dataReader, ok := data.(io.Reader); ok </span><span class="cov0" title="0">{
                        _data = dataReader
                }</span> else<span class="cov0" title="0"> {
                        log.Warn("Data is not a valid io.Reader")
                        return nil, errors.New("Data is not a valid io.Reader")
                }</span>
        }

        <span class="cov0" title="0">for i := 0; i &lt;= maxRetryCount; i++ </span><span class="cov0" title="0">{
                if redirectUrl != "" </span><span class="cov0" title="0">{
                        parsedRedirectUrl, err := url.Parse(redirectUrl)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">requestUrl, _ = obsClient.doAuth(method, bucketName, objectKey, params, headers, parsedRedirectUrl.Host)
                        if parsedRequestUrl, _ := url.Parse(requestUrl); parsedRequestUrl.RawQuery != "" &amp;&amp; parsedRedirectUrl.RawQuery == "" </span><span class="cov0" title="0">{
                                redirectUrl += "?" + parsedRequestUrl.RawQuery
                        }</span>
                        <span class="cov0" title="0">requestUrl = redirectUrl</span>
                } else<span class="cov0" title="0"> {
                        var err error
                        requestUrl, err = obsClient.doAuth(method, bucketName, objectKey, params, headers, "")
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                }

                <span class="cov0" title="0">req, err := http.NewRequest(method, requestUrl, _data)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">log.Debug("Do request with url [%s] and method [%s]", requestUrl, method)

                auth := headers[HEADER_AUTH_CAMEL]
                delete(headers, HEADER_AUTH_CAMEL)
                log.Debug("Request headers: %v", headers)
                headers[HEADER_AUTH_CAMEL] = auth

                for key, value := range headers </span><span class="cov0" title="0">{
                        if key == HEADER_HOST_CAMEL </span><span class="cov0" title="0">{
                                req.Host = value[0]
                                delete(headers, key)
                        }</span> else<span class="cov0" title="0"> if key == HEADER_CONTENT_LENGTH_CAMEL </span><span class="cov0" title="0">{
                                req.ContentLength = StringToInt64(value[0], -1)
                                delete(headers, key)
                        }</span> else<span class="cov0" title="0"> {
                                req.Header[key] = value
                        }</span>
                }

                <span class="cov0" title="0">req.Header[HEADER_USER_AGENT_CAMEL] = []string{USER_AGENT}

                start := GetCurrentTimestamp()
                resp, err = obsClient.httpClient.Do(req)
                log.Info("Do http request cost %d ms", (GetCurrentTimestamp() - start))

                var msg interface{}
                if err != nil </span><span class="cov0" title="0">{
                        msg = err
                        respError = err
                        resp = nil
                }</span> else<span class="cov0" title="0"> {
                        log.Debug("Response headers: %v", resp.Header)
                        if resp.StatusCode &lt; 300 </span><span class="cov0" title="0">{
                                break</span>
                        } else<span class="cov0" title="0"> if !repeatable || (resp.StatusCode &gt;= 400 &amp;&amp; resp.StatusCode &lt; 500) || resp.StatusCode == 304 </span><span class="cov0" title="0">{
                                respError = ParseResponseToObsError(resp)
                                resp = nil
                                break</span>
                        } else<span class="cov0" title="0"> if resp.StatusCode &gt;= 300 &amp;&amp; resp.StatusCode &lt; 400 </span><span class="cov0" title="0">{
                                if location := resp.Header.Get(HEADER_LOCATION_CAMEL); location != "" </span><span class="cov0" title="0">{
                                        redirectUrl = location
                                        log.Warn("Redirect request to %s", redirectUrl)
                                        msg = resp.Status
                                        maxRetryCount++
                                }</span> else<span class="cov0" title="0"> {
                                        respError = ParseResponseToObsError(resp)
                                        resp = nil
                                        break</span>
                                }
                        } else<span class="cov0" title="0"> {
                                msg = resp.Status
                        }</span>
                }
                <span class="cov0" title="0">if i != maxRetryCount </span><span class="cov0" title="0">{
                        if resp != nil </span><span class="cov0" title="0">{
                                resp.Body.Close()
                                resp = nil
                        }</span>
                        <span class="cov0" title="0">if _, ok := headers[HEADER_AUTH_CAMEL]; ok </span><span class="cov0" title="0">{
                                delete(headers, HEADER_AUTH_CAMEL)
                        }</span>
                        <span class="cov0" title="0">log.Warn("Failed to send request with reason:%v, will try again", msg)
                        if r, ok := _data.(*strings.Reader); ok </span><span class="cov0" title="0">{
                                r.Seek(0, 0)
                        }</span> else<span class="cov0" title="0"> if r, ok := _data.(*bytes.Reader); ok </span><span class="cov0" title="0">{
                                r.Seek(0, 0)
                        }</span> else<span class="cov0" title="0"> if r, ok := _data.(*fileReaderWrapper); ok </span><span class="cov0" title="0">{
                                fd, err := os.Open(r.filePath)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                                <span class="cov0" title="0">defer fd.Close()
                                fileReaderWrapper := &amp;fileReaderWrapper{filePath: r.filePath}
                                fileReaderWrapper.mark = r.mark
                                fileReaderWrapper.reader = fd
                                fileReaderWrapper.totalCount = r.totalCount
                                _data = fileReaderWrapper
                                fd.Seek(r.mark, 0)</span>
                        } else<span class="cov0" title="0"> if r, ok := _data.(*readerWrapper); ok </span><span class="cov0" title="0">{
                                r.seek(0, 0)
                        }</span>
                        <span class="cov0" title="0">time.Sleep(time.Duration(float64(i+2) * rand.Float64() * float64(time.Second)))</span>
                } else<span class="cov0" title="0"> {
                        log.Error("Failed to send request with reason:%v", msg)
                        if resp != nil </span><span class="cov0" title="0">{
                                respError = ParseResponseToObsError(resp)
                                resp = nil
                        }</span>
                }
        }
        <span class="cov0" title="0">return</span>
}

type connDelegate struct {
        conn          net.Conn
        socketTimeout time.Duration
        finalTimeout  time.Duration
}

func getConnDelegate(conn net.Conn, socketTimeout int, finalTimeout int) *connDelegate <span class="cov0" title="0">{
        return &amp;connDelegate{
                conn:          conn,
                socketTimeout: time.Second * time.Duration(socketTimeout),
                finalTimeout:  time.Second * time.Duration(finalTimeout),
        }
}</span>

func (delegate *connDelegate) Read(b []byte) (n int, err error) <span class="cov0" title="0">{
        delegate.SetReadDeadline(time.Now().Add(delegate.socketTimeout))
        n, err = delegate.conn.Read(b)
        delegate.SetReadDeadline(time.Now().Add(delegate.finalTimeout))
        return n, err
}</span>

func (delegate *connDelegate) Write(b []byte) (n int, err error) <span class="cov0" title="0">{
        delegate.SetWriteDeadline(time.Now().Add(delegate.socketTimeout))
        n, err = delegate.conn.Write(b)
        finalTimeout := time.Now().Add(delegate.finalTimeout)
        delegate.SetWriteDeadline(finalTimeout)
        delegate.SetReadDeadline(finalTimeout)
        return n, err
}</span>

func (delegate *connDelegate) Close() error <span class="cov0" title="0">{
        return delegate.conn.Close()
}</span>

func (delegate *connDelegate) LocalAddr() net.Addr <span class="cov0" title="0">{
        return delegate.conn.LocalAddr()
}</span>

func (delegate *connDelegate) RemoteAddr() net.Addr <span class="cov0" title="0">{
        return delegate.conn.RemoteAddr()
}</span>

func (delegate *connDelegate) SetDeadline(t time.Time) error <span class="cov0" title="0">{
        return delegate.conn.SetDeadline(t)
}</span>

func (delegate *connDelegate) SetReadDeadline(t time.Time) error <span class="cov0" title="0">{
        return delegate.conn.SetReadDeadline(t)
}</span>

func (delegate *connDelegate) SetWriteDeadline(t time.Time) error <span class="cov0" title="0">{
        return delegate.conn.SetWriteDeadline(t)
}</span>
</pre>
		
		<pre class="file" id="file69" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package obs

import (
        "fmt"
        "io"
        "log"
        "os"
        "os/user"
        "path/filepath"
        "strconv"
        "strings"
        "time"

        "github.com/go-ini/ini"
        "github.com/sirupsen/logrus"
        "gopkg.in/natefinch/lumberjack.v2"
)

type LogFormatter struct {
        TimestampFormat string
        LogFormat       string
}

const (
        debugLevel             = "debug"
        infoLevel              = "info"
        warnLevel              = "warn"
        errorLevel             = "error"
        path                   = "path"
        level                  = "level"
        format                 = "format"
        defaultLogPath         = "/var/log/multi-cloud"
        defaultLogLevel        = "info"
        unknownHost            = "unknownhost"
        unknownUser            = "unknownuser"
        configFileName         = "/etc/multi-cloud/multi-cloud.conf"
        defaultLogFormat       = "[%time%] [%level%] [%filename%] [%funcName%():%lineNo%] [PID:%process%] %message%"
        defaultTimestampFormat = time.RFC3339
        logSection             = "log"
        tenMb                  = 10
        threeMonth             = 100
)

func InitLogs() <span class="cov8" title="1">{
        path, level, format := readConfigurationFile()
        configureLogModule(path, level, format)
}</span>

func configureLogModule(path, level, format string) <span class="cov8" title="1">{
        configureWriter(path, format)
        configureLevel(level)
}</span>

func configureWriter(path, format string) <span class="cov8" title="1">{
        logrus.SetFormatter(&amp;LogFormatter{
                TimestampFormat: defaultTimestampFormat,
                LogFormat:       format + "\n",
        })
        fileWriter := &amp;lumberjack.Logger{
                Filename: filepath.Join(path, logName()),
                MaxSize:  tenMb,
                MaxAge:   threeMonth,
                Compress: true,
        }
        multiWriter := io.MultiWriter(os.Stdout, fileWriter)
        logrus.SetOutput(multiWriter)
}</span>

func configureLevel(level string) <span class="cov8" title="1">{
        switch level </span>{
        case debugLevel:<span class="cov8" title="1">
                logrus.SetLevel(logrus.DebugLevel)</span>
        case infoLevel:<span class="cov0" title="0">
                logrus.SetLevel(logrus.InfoLevel)</span>
        case warnLevel:<span class="cov0" title="0">
                logrus.SetLevel(logrus.WarnLevel)</span>
        case errorLevel:<span class="cov0" title="0">
                logrus.SetLevel(logrus.ErrorLevel)</span>
        }
        <span class="cov8" title="1">logrus.SetReportCaller(true)</span>
}

func logName() (name string) <span class="cov8" title="1">{
        name = fmt.Sprintf("%s.%s.%s.log",
                filepath.Base(os.Args[0]),
                hostName(),
                userName())
        return name
}</span>

func shortHostname(hostname string) string <span class="cov8" title="1">{
        if i := strings.Index(hostname, "."); i &gt;= 0 </span><span class="cov0" title="0">{
                return hostname[:i]
        }</span>
        <span class="cov8" title="1">return hostname</span>
}

func hostName() string <span class="cov8" title="1">{
        host := unknownHost
        h, err := os.Hostname()
        if err == nil </span><span class="cov8" title="1">{
                host = shortHostname(h)
        }</span>
        <span class="cov8" title="1">return host</span>
}

func userName() string <span class="cov8" title="1">{
        userName := unknownUser
        current, err := user.Current()
        if err == nil </span><span class="cov8" title="1">{
                userName = current.Username
        }</span>
        // Sanitize userName since it may contain filepath separators on Windows.
        <span class="cov8" title="1">userName = strings.Replace(userName, `\`, "_", -1)
        return userName</span>
}

func readConfigurationFile() (cfgPath, cfgLevel, cfgFormat string) <span class="cov8" title="1">{
        cfgPath = defaultLogPath
        cfgLevel = defaultLogLevel
        cfgFormat = defaultLogFormat
        cfg, err := ini.Load(configFileName)
        if err != nil </span><span class="cov0" title="0">{
                log.Println("Failed to open config file")
                return cfgPath, cfgLevel, cfgFormat
        }</span>
        <span class="cov8" title="1">if cfg.Section(logSection).HasKey(path) </span><span class="cov8" title="1">{
                cfgPath = cfg.Section(logSection).Key(path).String()
        }</span>
        <span class="cov8" title="1">if cfg.Section(logSection).HasKey(level) </span><span class="cov8" title="1">{
                cfgLevel = strings.ToLower(cfg.Section(logSection).Key(level).String())
        }</span>
        <span class="cov8" title="1">if cfg.Section(logSection).HasKey(format) </span><span class="cov8" title="1">{
                cfgFormat = cfg.Section(logSection).Key(format).String()
        }</span>

        <span class="cov8" title="1">return cfgPath, cfgLevel, cfgFormat</span>
}

func (f *LogFormatter) Format(entry *logrus.Entry) ([]byte, error) <span class="cov8" title="1">{
        output := f.LogFormat
        if output == "" </span><span class="cov0" title="0">{
                output = defaultLogFormat
        }</span>

        <span class="cov8" title="1">timestampFormat := f.TimestampFormat
        if timestampFormat == "" </span><span class="cov0" title="0">{
                timestampFormat = defaultTimestampFormat
        }</span>

        <span class="cov8" title="1">output = strings.Replace(output, "%time%", entry.Time.Format(timestampFormat), 1)

        output = strings.Replace(output, "%message%", entry.Message, 1)

        level := strings.ToUpper(entry.Level.String())
        output = strings.Replace(output, "%level%", level, 1)

        output = strings.Replace(output, "%process%", strconv.Itoa(os.Getpid()), 1)

        output = strings.Replace(output, "%filename%", entry.Caller.File, 1)
        output = strings.Replace(output, "%lineNo%", strconv.Itoa(entry.Caller.Line), 1)
        funcName := entry.Caller.Function
        if strings.Contains(funcName, "/") </span><span class="cov8" title="1">{
                funcName = string([]byte(funcName)[strings.LastIndex(funcName, "/")+1:])
        }</span>
        <span class="cov8" title="1">output = strings.Replace(output, "%funcName%", funcName, 1)

        return []byte(output), nil</span>
}
</pre>
		
		<pre class="file" id="file70" style="display: none">package obs

import (
        "errors"
        "fmt"
        "io"
        "net/http"
        "os"
        "strings"
        "time"
)

func (obsClient ObsClient) CreateSignedUrl(input *CreateSignedUrlInput) (output *CreateSignedUrlOutput, err error) <span class="cov0" title="0">{
        if input == nil </span><span class="cov0" title="0">{
                return nil, errors.New("CreateSignedUrlInput is nil")
        }</span>

        <span class="cov0" title="0">params := make(map[string]string, len(input.QueryParams))
        for key, value := range input.QueryParams </span><span class="cov0" title="0">{
                params[key] = value
        }</span>

        <span class="cov0" title="0">if input.SubResource != "" </span><span class="cov0" title="0">{
                params[string(input.SubResource)] = ""
        }</span>

        <span class="cov0" title="0">headers := make(map[string][]string, len(input.Headers))
        for key, value := range input.Headers </span><span class="cov0" title="0">{
                headers[key] = []string{value}
        }</span>

        <span class="cov0" title="0">if input.Expires &lt;= 0 </span><span class="cov0" title="0">{
                input.Expires = 300
        }</span>

        <span class="cov0" title="0">requestUrl, err := obsClient.doAuthTemporary(string(input.Method), input.Bucket, input.Key, params, headers, int64(input.Expires))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">output = &amp;CreateSignedUrlOutput{
                SignedUrl:                  requestUrl,
                ActualSignedRequestHeaders: headers,
        }
        return</span>
}

func (obsClient ObsClient) CreateBrowserBasedSignature(input *CreateBrowserBasedSignatureInput) (output *CreateBrowserBasedSignatureOutput, err error) <span class="cov0" title="0">{
        if input == nil </span><span class="cov0" title="0">{
                return nil, errors.New("CreateBrowserBasedSignatureInput is nil")
        }</span>

        <span class="cov0" title="0">params := make(map[string]string, len(input.FormParams))
        for key, value := range input.FormParams </span><span class="cov0" title="0">{
                params[key] = value
        }</span>

        <span class="cov0" title="0">date := time.Now().UTC()
        shortDate := date.Format(SHORT_DATE_FORMAT)
        longDate := date.Format(LONG_DATE_FORMAT)

        credential, _ := getCredential(obsClient.conf.securityProvider.ak, obsClient.conf.region, shortDate)

        if input.Expires &lt;= 0 </span><span class="cov0" title="0">{
                input.Expires = 300
        }</span>

        <span class="cov0" title="0">expiration := date.Add(time.Second * time.Duration(input.Expires)).Format(ISO8601_DATE_FORMAT)
        params[PARAM_ALGORITHM_AMZ_CAMEL] = V4_HASH_PREFIX
        params[PARAM_CREDENTIAL_AMZ_CAMEL] = credential
        params[PARAM_DATE_AMZ_CAMEL] = longDate

        if obsClient.conf.securityProvider.securityToken != "" </span><span class="cov0" title="0">{
                params[HEADER_STS_TOKEN_AMZ] = obsClient.conf.securityProvider.securityToken
        }</span>

        <span class="cov0" title="0">matchAnyBucket := true
        matchAnyKey := true
        count := 5
        if bucket := strings.TrimSpace(input.Bucket); bucket != "" </span><span class="cov0" title="0">{
                params["bucket"] = bucket
                matchAnyBucket = false
                count--
        }</span>

        <span class="cov0" title="0">if key := strings.TrimSpace(input.Key); key != "" </span><span class="cov0" title="0">{
                params["key"] = key
                matchAnyKey = false
                count--
        }</span>

        <span class="cov0" title="0">originPolicySlice := make([]string, 0, len(params)+count)
        originPolicySlice = append(originPolicySlice, fmt.Sprintf("{\"expiration\":\"%s\",", expiration))
        originPolicySlice = append(originPolicySlice, "\"conditions\":[")
        for key, value := range params </span><span class="cov0" title="0">{
                if _key := strings.TrimSpace(strings.ToLower(key)); _key != "" </span><span class="cov0" title="0">{
                        originPolicySlice = append(originPolicySlice, fmt.Sprintf("{\"%s\":\"%s\"},", _key, value))
                }</span>
        }

        <span class="cov0" title="0">if matchAnyBucket </span><span class="cov0" title="0">{
                originPolicySlice = append(originPolicySlice, "[\"starts-with\", \"$bucket\", \"\"],")
        }</span>

        <span class="cov0" title="0">if matchAnyKey </span><span class="cov0" title="0">{
                originPolicySlice = append(originPolicySlice, "[\"starts-with\", \"$key\", \"\"],")
        }</span>

        <span class="cov0" title="0">originPolicySlice = append(originPolicySlice, "]}")

        originPolicy := strings.Join(originPolicySlice, "")
        policy := Base64Encode([]byte(originPolicy))
        signature := getSignature(policy, obsClient.conf.securityProvider.sk, obsClient.conf.region, shortDate)

        output = &amp;CreateBrowserBasedSignatureOutput{
                OriginPolicy: originPolicy,
                Policy:       policy,
                Algorithm:    params[PARAM_ALGORITHM_AMZ_CAMEL],
                Credential:   params[PARAM_CREDENTIAL_AMZ_CAMEL],
                Date:         params[PARAM_DATE_AMZ_CAMEL],
                Signature:    signature,
        }
        return</span>
}

func (obsClient ObsClient) ListBucketsWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header) (output *ListBucketsOutput, err error) <span class="cov0" title="0">{
        output = &amp;ListBucketsOutput{}
        err = obsClient.doHttpWithSignedUrl("ListBuckets", HTTP_GET, signedUrl, actualSignedRequestHeaders, nil, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) CreateBucketWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header, data io.Reader) (output *BaseModel, err error) <span class="cov0" title="0">{
        output = &amp;BaseModel{}
        err = obsClient.doHttpWithSignedUrl("CreateBucket", HTTP_PUT, signedUrl, actualSignedRequestHeaders, data, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) DeleteBucketWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header) (output *BaseModel, err error) <span class="cov0" title="0">{
        output = &amp;BaseModel{}
        err = obsClient.doHttpWithSignedUrl("DeleteBucket", HTTP_DELETE, signedUrl, actualSignedRequestHeaders, nil, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) SetBucketStoragePolicyWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header, data io.Reader) (output *BaseModel, err error) <span class="cov0" title="0">{
        output = &amp;BaseModel{}
        err = obsClient.doHttpWithSignedUrl("SetBucketStoragePolicy", HTTP_PUT, signedUrl, actualSignedRequestHeaders, data, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) GetBucketStoragePolicyWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header) (output *GetBucketStoragePolicyOutput, err error) <span class="cov0" title="0">{
        output = &amp;GetBucketStoragePolicyOutput{}
        err = obsClient.doHttpWithSignedUrl("GetBucketStoragePolicy", HTTP_GET, signedUrl, actualSignedRequestHeaders, nil, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) ListObjectsWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header) (output *ListObjectsOutput, err error) <span class="cov0" title="0">{
        output = &amp;ListObjectsOutput{}
        err = obsClient.doHttpWithSignedUrl("ListObjects", HTTP_GET, signedUrl, actualSignedRequestHeaders, nil, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span> else<span class="cov0" title="0"> {
                if location, ok := output.ResponseHeaders[HEADER_BUCKET_REGION]; ok </span><span class="cov0" title="0">{
                        output.Location = location[0]
                }</span>
        }
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) ListVersionsWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header) (output *ListVersionsOutput, err error) <span class="cov0" title="0">{
        output = &amp;ListVersionsOutput{}
        err = obsClient.doHttpWithSignedUrl("ListVersions", HTTP_GET, signedUrl, actualSignedRequestHeaders, nil, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span> else<span class="cov0" title="0"> {
                if location, ok := output.ResponseHeaders[HEADER_BUCKET_REGION]; ok </span><span class="cov0" title="0">{
                        output.Location = location[0]
                }</span>
        }
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) ListMultipartUploadsWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header) (output *ListMultipartUploadsOutput, err error) <span class="cov0" title="0">{
        output = &amp;ListMultipartUploadsOutput{}
        err = obsClient.doHttpWithSignedUrl("ListMultipartUploads", HTTP_GET, signedUrl, actualSignedRequestHeaders, nil, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) SetBucketQuotaWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header, data io.Reader) (output *BaseModel, err error) <span class="cov0" title="0">{
        output = &amp;BaseModel{}
        err = obsClient.doHttpWithSignedUrl("SetBucketQuota", HTTP_PUT, signedUrl, actualSignedRequestHeaders, data, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) GetBucketQuotaWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header) (output *GetBucketQuotaOutput, err error) <span class="cov0" title="0">{
        output = &amp;GetBucketQuotaOutput{}
        err = obsClient.doHttpWithSignedUrl("GetBucketQuota", HTTP_GET, signedUrl, actualSignedRequestHeaders, nil, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) HeadBucketWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header) (output *BaseModel, err error) <span class="cov0" title="0">{
        output = &amp;BaseModel{}
        err = obsClient.doHttpWithSignedUrl("HeadBucket", HTTP_HEAD, signedUrl, actualSignedRequestHeaders, nil, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) GetBucketMetadataWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header) (output *GetBucketMetadataOutput, err error) <span class="cov0" title="0">{
        output = &amp;GetBucketMetadataOutput{}
        err = obsClient.doHttpWithSignedUrl("GetBucketMetadata", HTTP_HEAD, signedUrl, actualSignedRequestHeaders, nil, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span> else<span class="cov0" title="0"> {
                ParseGetBucketMetadataOutput(output)
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) GetBucketStorageInfoWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header) (output *GetBucketStorageInfoOutput, err error) <span class="cov0" title="0">{
        output = &amp;GetBucketStorageInfoOutput{}
        err = obsClient.doHttpWithSignedUrl("GetBucketStorageInfo", HTTP_GET, signedUrl, actualSignedRequestHeaders, nil, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) GetBucketLocationWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header) (output *GetBucketLocationOutput, err error) <span class="cov0" title="0">{
        output = &amp;GetBucketLocationOutput{}
        err = obsClient.doHttpWithSignedUrl("GetBucketLocation", HTTP_GET, signedUrl, actualSignedRequestHeaders, nil, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) SetBucketAclWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header, data io.Reader) (output *BaseModel, err error) <span class="cov0" title="0">{
        output = &amp;BaseModel{}
        err = obsClient.doHttpWithSignedUrl("SetBucketAcl", HTTP_PUT, signedUrl, actualSignedRequestHeaders, data, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) GetBucketAclWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header) (output *GetBucketAclOutput, err error) <span class="cov0" title="0">{
        output = &amp;GetBucketAclOutput{}
        err = obsClient.doHttpWithSignedUrl("GetBucketAcl", HTTP_GET, signedUrl, actualSignedRequestHeaders, nil, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) SetBucketPolicyWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header, data io.Reader) (output *BaseModel, err error) <span class="cov0" title="0">{
        output = &amp;BaseModel{}
        err = obsClient.doHttpWithSignedUrl("SetBucketPolicy", HTTP_PUT, signedUrl, actualSignedRequestHeaders, data, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) GetBucketPolicyWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header) (output *GetBucketPolicyOutput, err error) <span class="cov0" title="0">{
        output = &amp;GetBucketPolicyOutput{}
        err = obsClient.doHttpWithSignedUrl("GetBucketPolicy", HTTP_GET, signedUrl, actualSignedRequestHeaders, nil, output, false)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) DeleteBucketPolicyWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header) (output *BaseModel, err error) <span class="cov0" title="0">{
        output = &amp;BaseModel{}
        err = obsClient.doHttpWithSignedUrl("DeleteBucketPolicy", HTTP_DELETE, signedUrl, actualSignedRequestHeaders, nil, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) SetBucketCorsWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header, data io.Reader) (output *BaseModel, err error) <span class="cov0" title="0">{
        output = &amp;BaseModel{}
        err = obsClient.doHttpWithSignedUrl("SetBucketCors", HTTP_PUT, signedUrl, actualSignedRequestHeaders, data, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) GetBucketCorsWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header) (output *GetBucketCorsOutput, err error) <span class="cov0" title="0">{
        output = &amp;GetBucketCorsOutput{}
        err = obsClient.doHttpWithSignedUrl("GetBucketCors", HTTP_GET, signedUrl, actualSignedRequestHeaders, nil, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) DeleteBucketCorsWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header) (output *BaseModel, err error) <span class="cov0" title="0">{
        output = &amp;BaseModel{}
        err = obsClient.doHttpWithSignedUrl("DeleteBucketCors", HTTP_DELETE, signedUrl, actualSignedRequestHeaders, nil, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) SetBucketVersioningWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header, data io.Reader) (output *BaseModel, err error) <span class="cov0" title="0">{
        output = &amp;BaseModel{}
        err = obsClient.doHttpWithSignedUrl("SetBucketVersioning", HTTP_PUT, signedUrl, actualSignedRequestHeaders, data, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) GetBucketVersioningWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header) (output *GetBucketVersioningOutput, err error) <span class="cov0" title="0">{
        output = &amp;GetBucketVersioningOutput{}
        err = obsClient.doHttpWithSignedUrl("GetBucketVersioning", HTTP_GET, signedUrl, actualSignedRequestHeaders, nil, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) SetBucketWebsiteConfigurationWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header, data io.Reader) (output *BaseModel, err error) <span class="cov0" title="0">{
        output = &amp;BaseModel{}
        err = obsClient.doHttpWithSignedUrl("SetBucketWebsiteConfiguration", HTTP_PUT, signedUrl, actualSignedRequestHeaders, data, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) GetBucketWebsiteConfigurationWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header) (output *GetBucketWebsiteConfigurationOutput, err error) <span class="cov0" title="0">{
        output = &amp;GetBucketWebsiteConfigurationOutput{}
        err = obsClient.doHttpWithSignedUrl("GetBucketWebsiteConfiguration", HTTP_GET, signedUrl, actualSignedRequestHeaders, nil, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) DeleteBucketWebsiteConfigurationWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header) (output *BaseModel, err error) <span class="cov0" title="0">{
        output = &amp;BaseModel{}
        err = obsClient.doHttpWithSignedUrl("DeleteBucketWebsiteConfiguration", HTTP_DELETE, signedUrl, actualSignedRequestHeaders, nil, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) SetBucketLoggingConfigurationWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header, data io.Reader) (output *BaseModel, err error) <span class="cov0" title="0">{
        output = &amp;BaseModel{}
        err = obsClient.doHttpWithSignedUrl("SetBucketLoggingConfiguration", HTTP_PUT, signedUrl, actualSignedRequestHeaders, data, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) GetBucketLoggingConfigurationWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header) (output *GetBucketLoggingConfigurationOutput, err error) <span class="cov0" title="0">{
        output = &amp;GetBucketLoggingConfigurationOutput{}
        err = obsClient.doHttpWithSignedUrl("GetBucketLoggingConfiguration", HTTP_GET, signedUrl, actualSignedRequestHeaders, nil, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) SetBucketLifecycleConfigurationWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header, data io.Reader) (output *BaseModel, err error) <span class="cov0" title="0">{
        output = &amp;BaseModel{}
        err = obsClient.doHttpWithSignedUrl("SetBucketLifecycleConfiguration", HTTP_PUT, signedUrl, actualSignedRequestHeaders, data, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) GetBucketLifecycleConfigurationWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header) (output *GetBucketLifecycleConfigurationOutput, err error) <span class="cov0" title="0">{
        output = &amp;GetBucketLifecycleConfigurationOutput{}
        err = obsClient.doHttpWithSignedUrl("GetBucketLifecycleConfiguration", HTTP_GET, signedUrl, actualSignedRequestHeaders, nil, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) DeleteBucketLifecycleConfigurationWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header) (output *BaseModel, err error) <span class="cov0" title="0">{
        output = &amp;BaseModel{}
        err = obsClient.doHttpWithSignedUrl("DeleteBucketLifecycleConfiguration", HTTP_DELETE, signedUrl, actualSignedRequestHeaders, nil, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) SetBucketTaggingWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header, data io.Reader) (output *BaseModel, err error) <span class="cov0" title="0">{
        output = &amp;BaseModel{}
        err = obsClient.doHttpWithSignedUrl("SetBucketTagging", HTTP_PUT, signedUrl, actualSignedRequestHeaders, data, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) GetBucketTaggingWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header) (output *GetBucketTaggingOutput, err error) <span class="cov0" title="0">{
        output = &amp;GetBucketTaggingOutput{}
        err = obsClient.doHttpWithSignedUrl("GetBucketTagging", HTTP_GET, signedUrl, actualSignedRequestHeaders, nil, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) DeleteBucketTaggingWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header) (output *BaseModel, err error) <span class="cov0" title="0">{
        output = &amp;BaseModel{}
        err = obsClient.doHttpWithSignedUrl("DeleteBucketTagging", HTTP_DELETE, signedUrl, actualSignedRequestHeaders, nil, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) SetBucketNotificationWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header, data io.Reader) (output *BaseModel, err error) <span class="cov0" title="0">{
        output = &amp;BaseModel{}
        err = obsClient.doHttpWithSignedUrl("SetBucketNotification", HTTP_PUT, signedUrl, actualSignedRequestHeaders, data, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) GetBucketNotificationWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header) (output *GetBucketNotificationOutput, err error) <span class="cov0" title="0">{
        output = &amp;GetBucketNotificationOutput{}
        err = obsClient.doHttpWithSignedUrl("GetBucketNotification", HTTP_GET, signedUrl, actualSignedRequestHeaders, nil, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) DeleteObjectWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header) (output *DeleteObjectOutput, err error) <span class="cov0" title="0">{
        output = &amp;DeleteObjectOutput{}
        err = obsClient.doHttpWithSignedUrl("DeleteObject", HTTP_DELETE, signedUrl, actualSignedRequestHeaders, nil, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span> else<span class="cov0" title="0"> {
                ParseDeleteObjectOutput(output)
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) DeleteObjectsWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header, data io.Reader) (output *DeleteObjectsOutput, err error) <span class="cov0" title="0">{
        output = &amp;DeleteObjectsOutput{}
        err = obsClient.doHttpWithSignedUrl("DeleteObjects", HTTP_POST, signedUrl, actualSignedRequestHeaders, data, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) SetObjectAclWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header, data io.Reader) (output *BaseModel, err error) <span class="cov0" title="0">{
        output = &amp;BaseModel{}
        err = obsClient.doHttpWithSignedUrl("SetObjectAcl", HTTP_PUT, signedUrl, actualSignedRequestHeaders, data, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) GetObjectAclWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header) (output *GetObjectAclOutput, err error) <span class="cov0" title="0">{
        output = &amp;GetObjectAclOutput{}
        err = obsClient.doHttpWithSignedUrl("GetObjectAcl", HTTP_GET, signedUrl, actualSignedRequestHeaders, nil, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span> else<span class="cov0" title="0"> {
                if versionId, ok := output.ResponseHeaders[HEADER_VERSION_ID]; ok </span><span class="cov0" title="0">{
                        output.VersionId = versionId[0]
                }</span>
        }
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) RestoreObjectWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header, data io.Reader) (output *BaseModel, err error) <span class="cov0" title="0">{
        output = &amp;BaseModel{}
        err = obsClient.doHttpWithSignedUrl("RestoreObject", HTTP_POST, signedUrl, actualSignedRequestHeaders, data, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) GetObjectMetadataWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header) (output *GetObjectMetadataOutput, err error) <span class="cov0" title="0">{
        output = &amp;GetObjectMetadataOutput{}
        err = obsClient.doHttpWithSignedUrl("GetObjectMetadata", HTTP_HEAD, signedUrl, actualSignedRequestHeaders, nil, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span> else<span class="cov0" title="0"> {
                ParseGetObjectMetadataOutput(output)
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) GetObjectWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header) (output *GetObjectOutput, err error) <span class="cov0" title="0">{
        output = &amp;GetObjectOutput{}
        err = obsClient.doHttpWithSignedUrl("GetObject", HTTP_GET, signedUrl, actualSignedRequestHeaders, nil, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span> else<span class="cov0" title="0"> {
                ParseGetObjectOutput(output)
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) PutObjectWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header, data io.Reader) (output *PutObjectOutput, err error) <span class="cov0" title="0">{
        output = &amp;PutObjectOutput{}
        err = obsClient.doHttpWithSignedUrl("PutObject", HTTP_PUT, signedUrl, actualSignedRequestHeaders, data, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span> else<span class="cov0" title="0"> {
                ParsePutObjectOutput(output)
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) PutFileWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header, sourceFile string) (output *PutObjectOutput, err error) <span class="cov0" title="0">{
        var data io.Reader
        sourceFile = strings.TrimSpace(sourceFile)
        if sourceFile != "" </span><span class="cov0" title="0">{
                fd, err := os.Open(sourceFile)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">defer fd.Close()

                stat, err := fd.Stat()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">fileReaderWrapper := &amp;fileReaderWrapper{filePath: sourceFile}
                fileReaderWrapper.reader = fd

                var contentLength int64
                if value, ok := actualSignedRequestHeaders[HEADER_CONTENT_LENGTH_CAMEL]; ok </span><span class="cov0" title="0">{
                        contentLength = StringToInt64(value[0], -1)
                }</span> else<span class="cov0" title="0"> if value, ok := actualSignedRequestHeaders[HEADER_CONTENT_LENGTH]; ok </span><span class="cov0" title="0">{
                        contentLength = StringToInt64(value[0], -1)
                }</span> else<span class="cov0" title="0"> {
                        contentLength = stat.Size()
                }</span>
                <span class="cov0" title="0">if contentLength &gt; stat.Size() </span><span class="cov0" title="0">{
                        return nil, errors.New("ContentLength is larger than fileSize")
                }</span>
                <span class="cov0" title="0">fileReaderWrapper.totalCount = contentLength
                data = fileReaderWrapper</span>
        }

        <span class="cov0" title="0">output = &amp;PutObjectOutput{}
        err = obsClient.doHttpWithSignedUrl("PutObject", HTTP_PUT, signedUrl, actualSignedRequestHeaders, data, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span> else<span class="cov0" title="0"> {
                ParsePutObjectOutput(output)
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) CopyObjectWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header) (output *CopyObjectOutput, err error) <span class="cov0" title="0">{
        output = &amp;CopyObjectOutput{}
        err = obsClient.doHttpWithSignedUrl("CopyObject", HTTP_PUT, signedUrl, actualSignedRequestHeaders, nil, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span> else<span class="cov0" title="0"> {
                ParseCopyObjectOutput(output)
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) AbortMultipartUploadWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header) (output *BaseModel, err error) <span class="cov0" title="0">{
        output = &amp;BaseModel{}
        err = obsClient.doHttpWithSignedUrl("AbortMultipartUpload", HTTP_DELETE, signedUrl, actualSignedRequestHeaders, nil, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) InitiateMultipartUploadWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header) (output *InitiateMultipartUploadOutput, err error) <span class="cov0" title="0">{
        output = &amp;InitiateMultipartUploadOutput{}
        err = obsClient.doHttpWithSignedUrl("InitiateMultipartUpload", HTTP_POST, signedUrl, actualSignedRequestHeaders, nil, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span> else<span class="cov0" title="0"> {
                ParseInitiateMultipartUploadOutput(output)
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) UploadPartWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header, data io.Reader) (output *UploadPartOutput, err error) <span class="cov0" title="0">{
        output = &amp;UploadPartOutput{}
        err = obsClient.doHttpWithSignedUrl("UploadPart", HTTP_PUT, signedUrl, actualSignedRequestHeaders, data, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span> else<span class="cov0" title="0"> {
                ParseUploadPartOutput(output)
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) CompleteMultipartUploadWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header, data io.Reader) (output *CompleteMultipartUploadOutput, err error) <span class="cov0" title="0">{
        output = &amp;CompleteMultipartUploadOutput{}
        err = obsClient.doHttpWithSignedUrl("CompleteMultipartUpload", HTTP_POST, signedUrl, actualSignedRequestHeaders, data, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span> else<span class="cov0" title="0"> {
                ParseCompleteMultipartUploadOutput(output)
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) ListPartsWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header) (output *ListPartsOutput, err error) <span class="cov0" title="0">{
        output = &amp;ListPartsOutput{}
        err = obsClient.doHttpWithSignedUrl("ListParts", HTTP_GET, signedUrl, actualSignedRequestHeaders, nil, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span>
        <span class="cov0" title="0">return</span>
}

func (obsClient ObsClient) CopyPartWithSignedUrl(signedUrl string, actualSignedRequestHeaders http.Header) (output *CopyPartOutput, err error) <span class="cov0" title="0">{
        output = &amp;CopyPartOutput{}
        err = obsClient.doHttpWithSignedUrl("CopyPart", HTTP_PUT, signedUrl, actualSignedRequestHeaders, nil, output, true)
        if err != nil </span><span class="cov0" title="0">{
                output = nil
        }</span> else<span class="cov0" title="0"> {
                ParseCopyPartOutput(output)
        }</span>
        <span class="cov0" title="0">return</span>
}
</pre>
		
		<pre class="file" id="file71" style="display: none">package obs

import (
        "bytes"
        "fmt"
        "io"
        "os"
        "strings"
)

type IReadCloser interface {
        setReadCloser(body io.ReadCloser)
}

func (output *GetObjectOutput) setReadCloser(body io.ReadCloser) <span class="cov0" title="0">{
        output.Body = body
}</span>

type IBaseModel interface {
        setStatusCode(statusCode int)

        setRequestId(requestId string)

        setResponseHeaders(responseHeaders map[string][]string)
}

type ISerializable interface {
        trans() (map[string]string, map[string][]string, interface{})
}

type DefaultSerializable struct {
        params  map[string]string
        headers map[string][]string
        data    interface{}
}

func (input DefaultSerializable) trans() (map[string]string, map[string][]string, interface{}) <span class="cov0" title="0">{
        return input.params, input.headers, input.data
}</span>

var defaultSerializable = &amp;DefaultSerializable{}

func newSubResourceSerial(subResource SubResourceType) *DefaultSerializable <span class="cov0" title="0">{
        return &amp;DefaultSerializable{map[string]string{string(subResource): ""}, nil, nil}
}</span>

func trans(subResource SubResourceType, input interface{}) (params map[string]string, headers map[string][]string, data interface{}) <span class="cov0" title="0">{
        params = map[string]string{string(subResource): ""}
        data, _ = ConvertRequestToIoReader(input)
        return
}</span>

func (baseModel *BaseModel) setStatusCode(statusCode int) <span class="cov0" title="0">{
        baseModel.StatusCode = statusCode
}</span>

func (baseModel *BaseModel) setRequestId(requestId string) <span class="cov0" title="0">{
        baseModel.RequestId = requestId
}</span>

func (baseModel *BaseModel) setResponseHeaders(responseHeaders map[string][]string) <span class="cov0" title="0">{
        baseModel.ResponseHeaders = responseHeaders
}</span>

func (input ListBucketsInput) trans() (params map[string]string, headers map[string][]string, data interface{}) <span class="cov0" title="0">{
        headers = make(map[string][]string)
        if input.QueryLocation </span><span class="cov0" title="0">{
                headers[HEADER_LOCATION_AMZ] = []string{"true"}
        }</span>
        <span class="cov0" title="0">return</span>
}

func (input CreateBucketInput) trans() (params map[string]string, headers map[string][]string, data interface{}) <span class="cov0" title="0">{
        headers = make(map[string][]string)
        if acl := string(input.ACL); acl != "" </span><span class="cov0" title="0">{
                headers[HEADER_ACL_AMZ] = []string{acl}
        }</span>

        <span class="cov0" title="0">if storageClass := string(input.StorageClass); storageClass != "" </span><span class="cov0" title="0">{
                headers[HEADER_STORAGE_CLASS] = []string{storageClass}
        }</span>

        <span class="cov0" title="0">if location := strings.TrimSpace(input.Location); location != "" </span><span class="cov0" title="0">{
                input.Location = location
                data, _ = ConvertRequestToIoReader(input)
        }</span>
        <span class="cov0" title="0">return</span>
}

func (input SetBucketStoragePolicyInput) trans() (params map[string]string, headers map[string][]string, data interface{}) <span class="cov0" title="0">{
        return trans(SubResourceStoragePolicy, input)
}</span>

func (input ListObjsInput) trans() (params map[string]string, headers map[string][]string, data interface{}) <span class="cov0" title="0">{
        params = make(map[string]string)
        if input.Prefix != "" </span><span class="cov0" title="0">{
                params["prefix"] = input.Prefix
        }</span>
        <span class="cov0" title="0">if input.Delimiter != "" </span><span class="cov0" title="0">{
                params["delimiter"] = input.Delimiter
        }</span>
        <span class="cov0" title="0">if input.MaxKeys &gt; 0 </span><span class="cov0" title="0">{
                params["max-keys"] = IntToString(input.MaxKeys)
        }</span>
        <span class="cov0" title="0">headers = make(map[string][]string)
        if origin := strings.TrimSpace(input.Origin); origin != "" </span><span class="cov0" title="0">{
                headers[HEADER_ORIGIN_CAMEL] = []string{origin}
        }</span>
        <span class="cov0" title="0">if requestHeader := strings.TrimSpace(input.RequestHeader); requestHeader != "" </span><span class="cov0" title="0">{
                headers[HEADER_ACCESS_CONTROL_REQUEST_HEADER_CAMEL] = []string{requestHeader}
        }</span>
        <span class="cov0" title="0">return</span>
}

func (input ListObjectsInput) trans() (params map[string]string, headers map[string][]string, data interface{}) <span class="cov0" title="0">{
        params, headers, data = input.ListObjsInput.trans()
        if input.Marker != "" </span><span class="cov0" title="0">{
                params["marker"] = input.Marker
        }</span>
        <span class="cov0" title="0">return</span>
}

func (input ListVersionsInput) trans() (params map[string]string, headers map[string][]string, data interface{}) <span class="cov0" title="0">{
        params, headers, data = input.ListObjsInput.trans()
        params[string(SubResourceVersions)] = ""
        if input.KeyMarker != "" </span><span class="cov0" title="0">{
                params["key-marker"] = input.KeyMarker
        }</span>
        <span class="cov0" title="0">if input.VersionIdMarker != "" </span><span class="cov0" title="0">{
                params["version-id-marker"] = input.VersionIdMarker
        }</span>
        <span class="cov0" title="0">return</span>
}

func (input ListMultipartUploadsInput) trans() (params map[string]string, headers map[string][]string, data interface{}) <span class="cov0" title="0">{
        params = map[string]string{string(SubResourceUploads): ""}
        if input.Prefix != "" </span><span class="cov0" title="0">{
                params["prefix"] = input.Prefix
        }</span>
        <span class="cov0" title="0">if input.Delimiter != "" </span><span class="cov0" title="0">{
                params["delimiter"] = input.Delimiter
        }</span>
        <span class="cov0" title="0">if input.MaxUploads &gt; 0 </span><span class="cov0" title="0">{
                params["max-uploads"] = IntToString(input.MaxUploads)
        }</span>
        <span class="cov0" title="0">if input.KeyMarker != "" </span><span class="cov0" title="0">{
                params["key-marker"] = input.KeyMarker
        }</span>
        <span class="cov0" title="0">if input.UploadIdMarker != "" </span><span class="cov0" title="0">{
                params["upload-id-marker"] = input.UploadIdMarker
        }</span>
        <span class="cov0" title="0">return</span>
}

func (input SetBucketQuotaInput) trans() (params map[string]string, headers map[string][]string, data interface{}) <span class="cov0" title="0">{
        return trans(SubResourceQuota, input)
}</span>

func (input SetBucketAclInput) trans() (params map[string]string, headers map[string][]string, data interface{}) <span class="cov0" title="0">{
        params = map[string]string{string(SubResourceAcl): ""}
        headers = make(map[string][]string)

        if acl := string(input.ACL); acl != "" </span><span class="cov0" title="0">{
                headers[HEADER_ACL_AMZ] = []string{acl}
        }</span> else<span class="cov0" title="0"> {
                data, _ = ConvertAclToXml(input.AccessControlPolicy, false)
        }</span>
        <span class="cov0" title="0">return</span>
}

func (input SetBucketPolicyInput) trans() (params map[string]string, headers map[string][]string, data interface{}) <span class="cov0" title="0">{
        params = map[string]string{string(SubResourcePolicy): ""}
        data = strings.NewReader(input.Policy)
        return
}</span>

func (input SetBucketCorsInput) trans() (params map[string]string, headers map[string][]string, data interface{}) <span class="cov0" title="0">{
        params = map[string]string{string(SubResourceCors): ""}
        data, md5, _ := ConvertRequestToIoReaderV2(input)
        headers = map[string][]string{HEADER_MD5_CAMEL: []string{md5}}
        return
}</span>

func (input SetBucketVersioningInput) trans() (params map[string]string, headers map[string][]string, data interface{}) <span class="cov0" title="0">{
        return trans(SubResourceVersioning, input)
}</span>

func (input SetBucketWebsiteConfigurationInput) trans() (params map[string]string, headers map[string][]string, data interface{}) <span class="cov0" title="0">{
        params = map[string]string{string(SubResourceWebsite): ""}
        data, _ = ConvertWebsiteConfigurationToXml(input.BucketWebsiteConfiguration, false)
        return
}</span>

func (input GetBucketMetadataInput) trans() (params map[string]string, headers map[string][]string, data interface{}) <span class="cov0" title="0">{
        headers = make(map[string][]string)
        if origin := strings.TrimSpace(input.Origin); origin != "" </span><span class="cov0" title="0">{
                headers[HEADER_ORIGIN_CAMEL] = []string{origin}
        }</span>
        <span class="cov0" title="0">if requestHeader := strings.TrimSpace(input.RequestHeader); requestHeader != "" </span><span class="cov0" title="0">{
                headers[HEADER_ACCESS_CONTROL_REQUEST_HEADER_CAMEL] = []string{requestHeader}
        }</span>
        <span class="cov0" title="0">return</span>
}

func (input SetBucketLoggingConfigurationInput) trans() (params map[string]string, headers map[string][]string, data interface{}) <span class="cov0" title="0">{
        params = map[string]string{string(SubResourceLogging): ""}
        data, _ = ConvertLoggingStatusToXml(input.BucketLoggingStatus, false)
        return
}</span>

func (input SetBucketLifecycleConfigurationInput) trans() (params map[string]string, headers map[string][]string, data interface{}) <span class="cov0" title="0">{
        params = map[string]string{string(SubResourceLifecycle): ""}
        data, md5 := ConvertLifecyleConfigurationToXml(input.BucketLifecyleConfiguration, true)
        headers = map[string][]string{HEADER_MD5_CAMEL: []string{md5}}
        return
}</span>

func (input SetBucketTaggingInput) trans() (params map[string]string, headers map[string][]string, data interface{}) <span class="cov0" title="0">{
        params = map[string]string{string(SubResourceTagging): ""}
        data, md5, _ := ConvertRequestToIoReaderV2(input)
        headers = map[string][]string{HEADER_MD5_CAMEL: []string{md5}}
        return
}</span>

func (input SetBucketNotificationInput) trans() (params map[string]string, headers map[string][]string, data interface{}) <span class="cov0" title="0">{
        params = map[string]string{string(SubResourceNotification): ""}
        data, _ = ConvertNotificationToXml(input.BucketNotification, false)
        return
}</span>

func (input DeleteObjectInput) trans() (params map[string]string, headers map[string][]string, data interface{}) <span class="cov0" title="0">{
        params = make(map[string]string)
        if input.VersionId != "" </span><span class="cov0" title="0">{
                params[PARAM_VERSION_ID] = input.VersionId
        }</span>
        <span class="cov0" title="0">return</span>
}

func (input DeleteObjectsInput) trans() (params map[string]string, headers map[string][]string, data interface{}) <span class="cov0" title="0">{
        params = map[string]string{string(SubResourceDelete): ""}
        data, md5, _ := ConvertRequestToIoReaderV2(input)
        headers = map[string][]string{HEADER_MD5_CAMEL: []string{md5}}
        return
}</span>

func (input SetObjectAclInput) trans() (params map[string]string, headers map[string][]string, data interface{}) <span class="cov0" title="0">{
        params = map[string]string{string(SubResourceAcl): ""}
        if input.VersionId != "" </span><span class="cov0" title="0">{
                params[PARAM_VERSION_ID] = input.VersionId
        }</span>
        <span class="cov0" title="0">headers = make(map[string][]string)
        if acl := string(input.ACL); acl != "" </span><span class="cov0" title="0">{
                headers[HEADER_ACL_AMZ] = []string{acl}
        }</span> else<span class="cov0" title="0"> {
                data, _ = ConvertAclToXml(input.AccessControlPolicy, false)
        }</span>
        <span class="cov0" title="0">return</span>
}

func (input GetObjectAclInput) trans() (params map[string]string, headers map[string][]string, data interface{}) <span class="cov0" title="0">{
        params = map[string]string{string(SubResourceAcl): ""}
        if input.VersionId != "" </span><span class="cov0" title="0">{
                params[PARAM_VERSION_ID] = input.VersionId
        }</span>
        <span class="cov0" title="0">return</span>
}

func (input RestoreObjectInput) trans() (params map[string]string, headers map[string][]string, data interface{}) <span class="cov0" title="0">{
        params = map[string]string{string(SubResourceRestore): ""}
        if input.VersionId != "" </span><span class="cov0" title="0">{
                params[PARAM_VERSION_ID] = input.VersionId
        }</span>
        <span class="cov0" title="0">data, _ = ConvertRequestToIoReader(input)
        return</span>
}

func (header SseKmsHeader) GetEncryption() string <span class="cov0" title="0">{
        if header.Encryption != "" </span><span class="cov0" title="0">{
                return header.Encryption
        }</span>
        <span class="cov0" title="0">return DEFAULT_SSE_KMS_ENCRYPTION</span>
}

func (header SseKmsHeader) GetKey() string <span class="cov0" title="0">{
        return header.Key
}</span>

func (header SseCHeader) GetEncryption() string <span class="cov0" title="0">{
        if header.Encryption != "" </span><span class="cov0" title="0">{
                return header.Encryption
        }</span>
        <span class="cov0" title="0">return DEFAULT_SSE_C_ENCRYPTION</span>
}

func (header SseCHeader) GetKey() string <span class="cov0" title="0">{
        return header.Key
}</span>

func (header SseCHeader) GetKeyMD5() string <span class="cov0" title="0">{
        if header.KeyMD5 != "" </span><span class="cov0" title="0">{
                return header.KeyMD5
        }</span>

        <span class="cov0" title="0">if ret, err := Base64Decode(header.GetKey()); err == nil </span><span class="cov0" title="0">{
                return Base64Md5(ret)
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func setSseHeader(headers map[string][]string, sseHeader ISseHeader, sseCOnly bool) <span class="cov0" title="0">{
        if sseHeader != nil </span><span class="cov0" title="0">{
                if sseCHeader, ok := sseHeader.(SseCHeader); ok </span><span class="cov0" title="0">{
                        headers[HEADER_SSEC_ENCRYPTION_AMZ] = []string{sseCHeader.GetEncryption()}
                        headers[HEADER_SSEC_KEY_AMZ] = []string{sseCHeader.GetKey()}
                        headers[HEADER_SSEC_KEY_MD5_AMZ] = []string{sseCHeader.GetKeyMD5()}
                }</span> else<span class="cov0" title="0"> if sseKmsHeader, ok := sseHeader.(SseKmsHeader); !sseCOnly &amp;&amp; ok </span><span class="cov0" title="0">{
                        headers[HEADER_SSEKMS_ENCRYPTION_AMZ] = []string{sseKmsHeader.GetEncryption()}
                        headers[HEADER_SSEKMS_KEY_AMZ] = []string{sseKmsHeader.GetKey()}
                }</span>
        }
}

func (input GetObjectMetadataInput) trans() (params map[string]string, headers map[string][]string, data interface{}) <span class="cov0" title="0">{
        params = make(map[string]string)
        if input.VersionId != "" </span><span class="cov0" title="0">{
                params[PARAM_VERSION_ID] = input.VersionId
        }</span>
        <span class="cov0" title="0">headers = make(map[string][]string)

        if input.Origin != "" </span><span class="cov0" title="0">{
                headers[HEADER_ORIGIN_CAMEL] = []string{input.Origin}
        }</span>

        <span class="cov0" title="0">if input.RequestHeader != "" </span><span class="cov0" title="0">{
                headers[HEADER_ACCESS_CONTROL_REQUEST_HEADER_CAMEL] = []string{input.RequestHeader}
        }</span>
        <span class="cov0" title="0">setSseHeader(headers, input.SseHeader, true)
        return</span>
}

func (input GetObjectInput) trans() (params map[string]string, headers map[string][]string, data interface{}) <span class="cov0" title="0">{
        params, headers, data = input.GetObjectMetadataInput.trans()
        if input.ResponseCacheControl != "" </span><span class="cov0" title="0">{
                params[PARAM_RESPONSE_CACHE_CONTROL] = input.ResponseCacheControl
        }</span>
        <span class="cov0" title="0">if input.ResponseContentDisposition != "" </span><span class="cov0" title="0">{
                params[PARAM_RESPONSE_CONTENT_DISPOSITION] = input.ResponseContentDisposition
        }</span>
        <span class="cov0" title="0">if input.ResponseContentEncoding != "" </span><span class="cov0" title="0">{
                params[PARAM_RESPONSE_CONTENT_ENCODING] = input.ResponseContentEncoding
        }</span>
        <span class="cov0" title="0">if input.ResponseContentLanguage != "" </span><span class="cov0" title="0">{
                params[PARAM_RESPONSE_CONTENT_LANGUAGE] = input.ResponseContentLanguage
        }</span>
        <span class="cov0" title="0">if input.ResponseContentType != "" </span><span class="cov0" title="0">{
                params[PARAM_RESPONSE_CONTENT_TYPE] = input.ResponseContentType
        }</span>
        <span class="cov0" title="0">if input.ResponseExpires != "" </span><span class="cov0" title="0">{
                params[PARAM_RESPONSE_EXPIRES] = input.ResponseExpires
        }</span>
        <span class="cov0" title="0">if input.ImageProcess != "" </span><span class="cov0" title="0">{
                params[PARAM_IMAGE_PROCESS] = input.ImageProcess
        }</span>
        <span class="cov0" title="0">if input.RangeStart &gt;= 0 &amp;&amp; input.RangeEnd &gt; input.RangeStart </span><span class="cov0" title="0">{
                headers[HEADER_RANGE] = []string{fmt.Sprintf("bytes=%d-%d", input.RangeStart, input.RangeEnd)}
        }</span>

        <span class="cov0" title="0">if input.IfMatch != "" </span><span class="cov0" title="0">{
                headers[HEADER_IF_MATCH] = []string{input.IfMatch}
        }</span>
        <span class="cov0" title="0">if input.IfNoneMatch != "" </span><span class="cov0" title="0">{
                headers[HEADER_IF_NONE_MATCH] = []string{input.IfNoneMatch}
        }</span>
        <span class="cov0" title="0">if !input.IfModifiedSince.IsZero() </span><span class="cov0" title="0">{
                headers[HEADER_IF_MODIFIED_SINCE] = []string{FormatUtcToRfc1123(input.IfModifiedSince)}
        }</span>
        <span class="cov0" title="0">if !input.IfUnmodifiedSince.IsZero() </span><span class="cov0" title="0">{
                headers[HEADER_IF_UNMODIFIED_SINCE] = []string{FormatUtcToRfc1123(input.IfUnmodifiedSince)}
        }</span>
        <span class="cov0" title="0">return</span>
}

func (input ObjectOperationInput) trans() (params map[string]string, headers map[string][]string, data interface{}) <span class="cov0" title="0">{
        headers = make(map[string][]string)
        params = make(map[string]string)
        if acl := string(input.ACL); acl != "" </span><span class="cov0" title="0">{
                headers[HEADER_ACL_AMZ] = []string{acl}
        }</span>
        <span class="cov0" title="0">if storageClass := string(input.StorageClass); storageClass != "" </span><span class="cov0" title="0">{
                headers[HEADER_STORAGE_CLASS2_AMZ] = []string{storageClass}
        }</span>
        <span class="cov0" title="0">if input.WebsiteRedirectLocation != "" </span><span class="cov0" title="0">{
                headers[HEADER_WEBSITE_REDIRECT_LOCATION_AMZ] = []string{input.WebsiteRedirectLocation}
        }</span>
        <span class="cov0" title="0">setSseHeader(headers, input.SseHeader, false)
        if input.Metadata != nil </span><span class="cov0" title="0">{
                for key, value := range input.Metadata </span><span class="cov0" title="0">{
                        key = strings.TrimSpace(key)
                        if !strings.HasPrefix(key, HEADER_PREFIX_META) </span><span class="cov0" title="0">{
                                key = HEADER_PREFIX_META + key
                        }</span>
                        <span class="cov0" title="0">headers[key] = []string{value}</span>
                }
        }
        <span class="cov0" title="0">return</span>
}

func (input PutObjectBasicInput) trans() (params map[string]string, headers map[string][]string, data interface{}) <span class="cov0" title="0">{
        params, headers, data = input.ObjectOperationInput.trans()

        if input.ContentMD5 != "" </span><span class="cov0" title="0">{
                headers[HEADER_MD5_CAMEL] = []string{input.ContentMD5}
        }</span>

        <span class="cov0" title="0">if input.ContentLength &gt; 0 </span><span class="cov0" title="0">{
                headers[HEADER_CONTENT_LENGTH_CAMEL] = []string{Int64ToString(input.ContentLength)}
        }</span>
        <span class="cov0" title="0">if input.ContentType != "" </span><span class="cov0" title="0">{
                headers[HEADER_CONTENT_TYPE_CAML] = []string{input.ContentType}
        }</span>

        <span class="cov0" title="0">return</span>
}

func (input PutObjectInput) trans() (params map[string]string, headers map[string][]string, data interface{}) <span class="cov0" title="0">{
        params, headers, data = input.PutObjectBasicInput.trans()
        if input.Body != nil </span><span class="cov0" title="0">{
                data = input.Body
        }</span>
        <span class="cov0" title="0">return</span>
}

func (input CopyObjectInput) trans() (params map[string]string, headers map[string][]string, data interface{}) <span class="cov0" title="0">{
        params, headers, data = input.ObjectOperationInput.trans()

        var copySource string
        if input.CopySourceVersionId != "" </span><span class="cov0" title="0">{
                copySource = fmt.Sprintf("%s/%s?versionId=%s", input.CopySourceBucket, UrlEncode(input.CopySourceKey, false), input.CopySourceVersionId)
        }</span> else<span class="cov0" title="0"> {
                copySource = fmt.Sprintf("%s/%s", input.CopySourceBucket, UrlEncode(input.CopySourceKey, false))
        }</span>
        <span class="cov0" title="0">headers[HEADER_COPY_SOURCE_AMZ] = []string{copySource}

        if directive := string(input.MetadataDirective); directive != "" </span><span class="cov0" title="0">{
                headers[HEADER_METADATA_DIRECTIVE_AMZ] = []string{directive}
        }</span>

        <span class="cov0" title="0">if input.MetadataDirective == ReplaceMetadata </span><span class="cov0" title="0">{
                if input.CacheControl != "" </span><span class="cov0" title="0">{
                        headers[HEADER_CACHE_CONTROL] = []string{input.CacheControl}
                }</span>
                <span class="cov0" title="0">if input.ContentDisposition != "" </span><span class="cov0" title="0">{
                        headers[HEADER_CONTENT_DISPOSITION] = []string{input.ContentDisposition}
                }</span>
                <span class="cov0" title="0">if input.ContentEncoding != "" </span><span class="cov0" title="0">{
                        headers[HEADER_CONTENT_ENCODING] = []string{input.ContentEncoding}
                }</span>
                <span class="cov0" title="0">if input.ContentLanguage != "" </span><span class="cov0" title="0">{
                        headers[HEADER_CONTENT_LANGUAGE] = []string{input.ContentLanguage}
                }</span>
                <span class="cov0" title="0">if input.ContentType != "" </span><span class="cov0" title="0">{
                        headers[HEADER_CONTENT_TYPE] = []string{input.ContentType}
                }</span>
                <span class="cov0" title="0">if input.Expires != "" </span><span class="cov0" title="0">{
                        headers[HEADER_EXPIRES] = []string{input.Expires}
                }</span>
        }

        <span class="cov0" title="0">if input.CopySourceIfMatch != "" </span><span class="cov0" title="0">{
                headers[HEADER_COPY_SOURCE_IF_MATCH_AMZ] = []string{input.CopySourceIfMatch}
        }</span>
        <span class="cov0" title="0">if input.CopySourceIfNoneMatch != "" </span><span class="cov0" title="0">{
                headers[HEADER_COPY_SOURCE_IF_NONE_MATCH_AMZ] = []string{input.CopySourceIfNoneMatch}
        }</span>
        <span class="cov0" title="0">if !input.CopySourceIfModifiedSince.IsZero() </span><span class="cov0" title="0">{
                headers[HEADER_COPY_SOURCE_IF_MODIFIED_SINCE_AMZ] = []string{FormatUtcToRfc1123(input.CopySourceIfModifiedSince)}
        }</span>
        <span class="cov0" title="0">if !input.CopySourceIfUnmodifiedSince.IsZero() </span><span class="cov0" title="0">{
                headers[HEADER_COPY_SOURCE_IF_UNMODIFIED_SINCE_AMZ] = []string{FormatUtcToRfc1123(input.CopySourceIfUnmodifiedSince)}
        }</span>
        <span class="cov0" title="0">if input.SourceSseHeader != nil </span><span class="cov0" title="0">{
                if sseCHeader, ok := input.SourceSseHeader.(SseCHeader); ok </span><span class="cov0" title="0">{
                        headers[HEADER_SSEC_COPY_SOURCE_ENCRYPTION_AMZ] = []string{sseCHeader.GetEncryption()}
                        headers[HEADER_SSEC_COPY_SOURCE_KEY_AMZ] = []string{sseCHeader.GetKey()}
                        headers[HEADER_SSEC_COPY_SOURCE_KEY_MD5_AMZ] = []string{sseCHeader.GetKeyMD5()}
                }</span>
        }
        <span class="cov0" title="0">return</span>
}

func (input AbortMultipartUploadInput) trans() (params map[string]string, headers map[string][]string, data interface{}) <span class="cov0" title="0">{
        params = map[string]string{"uploadId": input.UploadId}
        return
}</span>

func (input InitiateMultipartUploadInput) trans() (params map[string]string, headers map[string][]string, data interface{}) <span class="cov0" title="0">{
        params, headers, data = input.ObjectOperationInput.trans()
        params[string(SubResourceUploads)] = ""
        return
}</span>

func (input UploadPartInput) trans() (params map[string]string, headers map[string][]string, data interface{}) <span class="cov0" title="0">{
        params = map[string]string{"uploadId": input.UploadId, "partNumber": IntToString(input.PartNumber)}
        headers = make(map[string][]string)
        setSseHeader(headers, input.SseHeader, true)
        if input.Body != nil </span><span class="cov0" title="0">{
                data = input.Body
        }</span>
        <span class="cov0" title="0">return</span>
}

func (input CompleteMultipartUploadInput) trans() (params map[string]string, headers map[string][]string, data interface{}) <span class="cov0" title="0">{
        params = map[string]string{"uploadId": input.UploadId}
        data, _ = ConvertCompleteMultipartUploadInputToXml(input, false)
        return
}</span>

func (input ListPartsInput) trans() (params map[string]string, headers map[string][]string, data interface{}) <span class="cov0" title="0">{
        params = map[string]string{"uploadId": input.UploadId}
        if input.MaxParts &gt; 0 </span><span class="cov0" title="0">{
                params["max-parts"] = IntToString(input.MaxParts)
        }</span>
        <span class="cov0" title="0">if input.PartNumberMarker &gt; 0 </span><span class="cov0" title="0">{
                params["part-number-marker"] = IntToString(input.PartNumberMarker)
        }</span>
        <span class="cov0" title="0">return</span>
}

func (input CopyPartInput) trans() (params map[string]string, headers map[string][]string, data interface{}) <span class="cov0" title="0">{
        params = map[string]string{"uploadId": input.UploadId, "partNumber": IntToString(input.PartNumber)}
        headers = make(map[string][]string, 1)
        var copySource string
        if input.CopySourceVersionId != "" </span><span class="cov0" title="0">{
                copySource = fmt.Sprintf("%s/%s?versionId=%s", input.CopySourceBucket, UrlEncode(input.CopySourceKey, false), input.CopySourceVersionId)
        }</span> else<span class="cov0" title="0"> {
                copySource = fmt.Sprintf("%s/%s", input.CopySourceBucket, UrlEncode(input.CopySourceKey, false))
        }</span>
        <span class="cov0" title="0">headers[HEADER_COPY_SOURCE_AMZ] = []string{copySource}

        if input.CopySourceRangeStart &gt;= 0 &amp;&amp; input.CopySourceRangeEnd &gt; input.CopySourceRangeStart </span><span class="cov0" title="0">{
                headers[HEADER_COPY_SOURCE_RANGE_AMZ] = []string{fmt.Sprintf("bytes=%d-%d", input.CopySourceRangeStart, input.CopySourceRangeEnd)}
        }</span>

        <span class="cov0" title="0">setSseHeader(headers, input.SseHeader, true)
        if input.SourceSseHeader != nil </span><span class="cov0" title="0">{
                if sseCHeader, ok := input.SourceSseHeader.(SseCHeader); ok </span><span class="cov0" title="0">{
                        headers[HEADER_SSEC_COPY_SOURCE_ENCRYPTION_AMZ] = []string{sseCHeader.GetEncryption()}
                        headers[HEADER_SSEC_COPY_SOURCE_KEY_AMZ] = []string{sseCHeader.GetKey()}
                        headers[HEADER_SSEC_COPY_SOURCE_KEY_MD5_AMZ] = []string{sseCHeader.GetKeyMD5()}
                }</span>
        }
        <span class="cov0" title="0">return</span>
}

type partSlice []Part

func (parts partSlice) Len() int <span class="cov0" title="0">{
        return len(parts)
}</span>

func (parts partSlice) Less(i, j int) bool <span class="cov0" title="0">{
        return parts[i].PartNumber &lt; parts[j].PartNumber
}</span>

func (parts partSlice) Swap(i, j int) <span class="cov0" title="0">{
        parts[i], parts[j] = parts[j], parts[i]
}</span>

type readerWrapper struct {
        reader      io.Reader
        mark        int64
        totalCount  int64
        readedCount int64
}

func (rw *readerWrapper) seek(offset int64, whence int) (int64, error) <span class="cov0" title="0">{
        if r, ok := rw.reader.(*strings.Reader); ok </span><span class="cov0" title="0">{
                return r.Seek(offset, whence)
        }</span> else<span class="cov0" title="0"> if r, ok := rw.reader.(*bytes.Reader); ok </span><span class="cov0" title="0">{
                return r.Seek(offset, whence)
        }</span> else<span class="cov0" title="0"> if r, ok := rw.reader.(*os.File); ok </span><span class="cov0" title="0">{
                return r.Seek(offset, whence)
        }</span>
        <span class="cov0" title="0">return offset, nil</span>
}

func (rw *readerWrapper) Read(p []byte) (n int, err error) <span class="cov0" title="0">{
        if rw.totalCount == 0 </span><span class="cov0" title="0">{
                return 0, io.EOF
        }</span>
        <span class="cov0" title="0">if rw.totalCount &gt; 0 </span><span class="cov0" title="0">{
                n, err = rw.reader.Read(p)
                readedOnce := int64(n)
                if remainCount := rw.totalCount - rw.readedCount; remainCount &gt; readedOnce </span><span class="cov0" title="0">{
                        rw.readedCount += readedOnce
                        return n, err
                }</span> else<span class="cov0" title="0"> {
                        rw.readedCount += remainCount
                        return int(remainCount), io.EOF
                }</span>
        }
        <span class="cov0" title="0">return rw.reader.Read(p)</span>
}

type fileReaderWrapper struct {
        readerWrapper
        filePath string
}
</pre>
		
		<pre class="file" id="file72" style="display: none">package obs

import (
        "crypto/hmac"
        "crypto/md5"
        "crypto/sha1"
        "crypto/sha256"
        "encoding/base64"
        "encoding/hex"
        "encoding/xml"
        "fmt"
        "net/url"
        "regexp"
        "strconv"
        "strings"
        "time"
)

var regex = regexp.MustCompile("^[\u4e00-\u9fa5]$")
var ipRegex = regexp.MustCompile("^((2[0-4]\\d|25[0-5]|[01]?\\d\\d?)\\.){3}(2[0-4]\\d|25[0-5]|[01]?\\d\\d?)$")
var v4AuthRegex = regexp.MustCompile("Credential=(.+?),SignedHeaders=(.+?),Signature=.+")
var regionRegex = regexp.MustCompile(".+/\\d+/(.+?)/.+")

func StringToInt(value string, def int) int <span class="cov0" title="0">{
        ret, err := strconv.Atoi(value)
        if err != nil </span><span class="cov0" title="0">{
                ret = def
        }</span>
        <span class="cov0" title="0">return ret</span>
}

func StringToInt64(value string, def int64) int64 <span class="cov0" title="0">{
        ret, err := strconv.ParseInt(value, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                ret = def
        }</span>
        <span class="cov0" title="0">return ret</span>
}

func IntToString(value int) string <span class="cov0" title="0">{
        return strconv.Itoa(value)
}</span>

func Int64ToString(value int64) string <span class="cov0" title="0">{
        return strconv.FormatInt(value, 10)
}</span>

func GetCurrentTimestamp() int64 <span class="cov0" title="0">{
        return time.Now().UnixNano() / 1000000
}</span>

func FormatUtcNow(format string) string <span class="cov0" title="0">{
        return time.Now().UTC().Format(format)
}</span>

func FormatUtcToRfc1123(t time.Time) string <span class="cov0" title="0">{
        ret := t.UTC().Format(time.RFC1123)
        return ret[:strings.LastIndex(ret, "UTC")] + "GMT"
}</span>

func Md5(value []byte) []byte <span class="cov0" title="0">{
        m := md5.New()
        m.Write(value)
        return m.Sum(nil)
}</span>

func HmacSha1(key, value []byte) []byte <span class="cov0" title="0">{
        mac := hmac.New(sha1.New, key)
        mac.Write(value)
        return mac.Sum(nil)
}</span>

func HmacSha256(key, value []byte) []byte <span class="cov0" title="0">{
        mac := hmac.New(sha256.New, key)
        mac.Write(value)
        return mac.Sum(nil)
}</span>

func Base64Encode(value []byte) string <span class="cov0" title="0">{
        return base64.StdEncoding.EncodeToString(value)
}</span>

func Base64Decode(value string) ([]byte, error) <span class="cov0" title="0">{
        return base64.StdEncoding.DecodeString(value)
}</span>

func HexMd5(value []byte) string <span class="cov0" title="0">{
        return Hex(Md5(value))
}</span>

func Base64Md5(value []byte) string <span class="cov0" title="0">{
        return Base64Encode(Md5(value))
}</span>

func Sha256Hash(value []byte) []byte <span class="cov0" title="0">{
        hash := sha256.New()
        hash.Write(value)
        return hash.Sum(nil)
}</span>

func ParseXml(value []byte, result interface{}) error <span class="cov0" title="0">{
        if len(value) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return xml.Unmarshal(value, result)</span>
}

func TransToXml(value interface{}) ([]byte, error) <span class="cov0" title="0">{
        if value == nil </span><span class="cov0" title="0">{
                return []byte{}, nil
        }</span>
        <span class="cov0" title="0">return xml.Marshal(value)</span>
}

func Hex(value []byte) string <span class="cov0" title="0">{
        return hex.EncodeToString(value)
}</span>

func HexSha256(value []byte) string <span class="cov0" title="0">{
        return Hex(Sha256Hash(value))
}</span>

func UrlDecode(value string) (string, error) <span class="cov0" title="0">{
        ret, err := url.QueryUnescape(value)
        if err == nil </span><span class="cov0" title="0">{
                return ret, nil
        }</span>
        <span class="cov0" title="0">return "", err</span>
}

func IsIP(value string) bool <span class="cov0" title="0">{
        return ipRegex.MatchString(value)
}</span>

func UrlEncode(value string, chineseOnly bool) string <span class="cov0" title="0">{
        if chineseOnly </span><span class="cov0" title="0">{
                values := make([]string, 0, len(value))
                for _, val := range value </span><span class="cov0" title="0">{
                        _value := string(val)
                        if regex.MatchString(_value) </span><span class="cov0" title="0">{
                                _value = url.QueryEscape(_value)
                        }</span>
                        <span class="cov0" title="0">values = append(values, _value)</span>
                }
                <span class="cov0" title="0">return strings.Join(values, "")</span>
        }
        <span class="cov0" title="0">return url.QueryEscape(value)</span>
}

func copyHeaders(m map[string][]string) (ret map[string][]string) <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                ret = make(map[string][]string, len(m))
                for key, values := range m </span><span class="cov0" title="0">{
                        _values := make([]string, 0, len(values))
                        for _, value := range values </span><span class="cov0" title="0">{
                                _values = append(_values, value)
                        }</span>
                        <span class="cov0" title="0">ret[strings.ToLower(key)] = _values</span>
                }
        } else<span class="cov0" title="0"> {
                ret = make(map[string][]string)
        }</span>

        <span class="cov0" title="0">return</span>
}

func parseHeaders(headers map[string][]string) (signature string, region string, signedHeaders string) <span class="cov0" title="0">{
        signature = "v2"
        if receviedAuthorization, ok := headers[strings.ToLower(HEADER_AUTH_CAMEL)]; ok &amp;&amp; len(receviedAuthorization) &gt; 0 </span><span class="cov0" title="0">{
                if strings.HasPrefix(receviedAuthorization[0], V4_HASH_PREFIX) </span><span class="cov0" title="0">{
                        signature = "v4"
                        matches := v4AuthRegex.FindStringSubmatch(receviedAuthorization[0])
                        if len(matches) &gt;= 3 </span><span class="cov0" title="0">{
                                region = matches[1]
                                regions := regionRegex.FindStringSubmatch(region)
                                if len(regions) &gt;= 2 </span><span class="cov0" title="0">{
                                        region = regions[1]
                                }</span>
                                <span class="cov0" title="0">signedHeaders = matches[2]</span>
                        }

                } else<span class="cov0" title="0"> if strings.HasPrefix(receviedAuthorization[0], V2_HASH_PREFIX) </span><span class="cov0" title="0">{
                        signature = "v2"
                }</span>
        }
        <span class="cov0" title="0">return</span>
}

func getTemporaryKeys() []string <span class="cov0" title="0">{
        return []string{
                "Signature",
                "signature",
                "X-Amz-Signature",
                "x-amz-signature",
        }
}</span>

func GetAuthorization(ak, sk, method, bucketName, objectKey, queryUrl string, headers map[string][]string) (ret map[string]string) <span class="cov0" title="0">{

        if strings.HasPrefix(queryUrl, "?") </span><span class="cov0" title="0">{
                queryUrl = queryUrl[1:]
        }</span>

        <span class="cov0" title="0">method = strings.ToUpper(method)

        querys := strings.Split(queryUrl, "&amp;")

        params := make(map[string]string)

        for _, value := range querys </span><span class="cov0" title="0">{
                kv := strings.Split(value, "=")
                length := len(kv)
                if length == 1 </span><span class="cov0" title="0">{
                        key, _ := UrlDecode(kv[0])
                        params[key] = ""
                }</span> else<span class="cov0" title="0"> if length &gt;= 2 </span><span class="cov0" title="0">{
                        key, _ := UrlDecode(kv[0])
                        vals := make([]string, 0, length-1)
                        for i := 1; i &lt; length; i++ </span><span class="cov0" title="0">{
                                val, _ := UrlDecode(kv[i])
                                vals = append(vals, val)
                        }</span>
                        <span class="cov0" title="0">params[key] = strings.Join(vals, "=")</span>
                }
        }

        <span class="cov0" title="0">isTemporary := false
        signature := "v2"
        temporaryKeys := getTemporaryKeys()
        for _, key := range temporaryKeys </span><span class="cov0" title="0">{
                if _, ok := params[key]; ok </span><span class="cov0" title="0">{
                        isTemporary = true
                        if strings.ToLower(key) == "signature" </span><span class="cov0" title="0">{
                                signature = "v2"
                        }</span> else<span class="cov0" title="0"> if strings.ToLower(key) == "x-amz-signature" </span><span class="cov0" title="0">{
                                signature = "v4"
                        }</span>
                        <span class="cov0" title="0">break</span>
                }
        }
        <span class="cov0" title="0">headers = copyHeaders(headers)
        pathStyle := false
        if receviedHost, ok := headers[HEADER_HOST]; ok &amp;&amp; len(receviedHost) &gt; 0 &amp;&amp; !strings.HasPrefix(receviedHost[0], bucketName+".") </span><span class="cov0" title="0">{
                pathStyle = true
        }</span>
        <span class="cov0" title="0">conf := &amp;config{securityProvider: &amp;securityProvider{ak: ak, sk: sk},
                urlHolder: &amp;urlHolder{scheme: "https", host: "dummy", port: 443},
                pathStyle: pathStyle}

        if isTemporary </span><span class="cov0" title="0">{
                return getTemporaryAuthorization(ak, sk, method, bucketName, objectKey, signature, conf, params, headers)
        }</span> else<span class="cov0" title="0"> {
                signature, region, signedHeaders := parseHeaders(headers)
                if signature == "v4" </span><span class="cov0" title="0">{
                        conf.signature = SignatureV4
                        requestUrl, canonicalizedUrl := conf.formatUrls(bucketName, objectKey, params, false)
                        parsedRequestUrl, _ := url.Parse(requestUrl)
                        headerKeys := strings.Split(signedHeaders, ";")
                        _headers := make(map[string][]string, len(headerKeys))
                        for _, headerKey := range headerKeys </span><span class="cov0" title="0">{
                                _headers[headerKey] = headers[headerKey]
                        }</span>
                        <span class="cov0" title="0">ret = v4Auth(ak, sk, region, method, canonicalizedUrl, parsedRequestUrl.RawQuery, _headers)
                        ret[HEADER_AUTH_CAMEL] = fmt.Sprintf("%s Credential=%s,SignedHeaders=%s,Signature=%s", V4_HASH_PREFIX, ret["Credential"], ret["SignedHeaders"], ret["Signature"])</span>
                } else<span class="cov0" title="0"> if signature == "v2" </span><span class="cov0" title="0">{
                        conf.signature = SignatureV2
                        _, canonicalizedUrl := conf.formatUrls(bucketName, objectKey, params, false)
                        ret = v2Auth(ak, sk, method, canonicalizedUrl, headers)
                        ret[HEADER_AUTH_CAMEL] = fmt.Sprintf("%s %s:%s", V2_HASH_PREFIX, ak, ret["Signature"])
                }</span>
                <span class="cov0" title="0">return</span>
        }

}

func getTemporaryAuthorization(ak, sk, method, bucketName, objectKey, signature string, conf *config, params map[string]string,
        headers map[string][]string) (ret map[string]string) <span class="cov0" title="0">{

        if signature == "v4" </span><span class="cov0" title="0">{
                conf.signature = SignatureV4

                longDate, ok := params[PARAM_DATE_AMZ_CAMEL]
                if !ok </span><span class="cov0" title="0">{
                        longDate = params[HEADER_DATE_AMZ]
                }</span>
                <span class="cov0" title="0">shortDate := longDate[:8]

                credential, ok := params[PARAM_CREDENTIAL_AMZ_CAMEL]
                if !ok </span><span class="cov0" title="0">{
                        credential = params[strings.ToLower(PARAM_CREDENTIAL_AMZ_CAMEL)]
                }</span>

                <span class="cov0" title="0">_credential, _ := UrlDecode(credential)

                regions := regionRegex.FindStringSubmatch(_credential)
                var region string
                if len(regions) &gt;= 2 </span><span class="cov0" title="0">{
                        region = regions[1]
                }</span>

                <span class="cov0" title="0">_, scope := getCredential(ak, region, shortDate)

                expires, ok := params[PARAM_EXPIRES_AMZ_CAMEL]
                if !ok </span><span class="cov0" title="0">{
                        expires = params[strings.ToLower(PARAM_EXPIRES_AMZ_CAMEL)]
                }</span>

                <span class="cov0" title="0">signedHeaders, ok := params[PARAM_SIGNEDHEADERS_AMZ_CAMEL]
                if !ok </span><span class="cov0" title="0">{
                        signedHeaders = params[strings.ToLower(PARAM_SIGNEDHEADERS_AMZ_CAMEL)]
                }</span>

                <span class="cov0" title="0">algorithm, ok := params[PARAM_ALGORITHM_AMZ_CAMEL]
                if !ok </span><span class="cov0" title="0">{
                        algorithm = params[strings.ToLower(PARAM_ALGORITHM_AMZ_CAMEL)]
                }</span>

                <span class="cov0" title="0">if _, ok := params[PARAM_SIGNATURE_AMZ_CAMEL]; ok </span><span class="cov0" title="0">{
                        delete(params, PARAM_SIGNATURE_AMZ_CAMEL)
                }</span> else<span class="cov0" title="0"> if _, ok := params[strings.ToLower(PARAM_SIGNATURE_AMZ_CAMEL)]; ok </span><span class="cov0" title="0">{
                        delete(params, strings.ToLower(PARAM_SIGNATURE_AMZ_CAMEL))
                }</span>

                <span class="cov0" title="0">ret = make(map[string]string, 6)
                ret[PARAM_ALGORITHM_AMZ_CAMEL] = algorithm
                ret[PARAM_CREDENTIAL_AMZ_CAMEL] = credential
                ret[PARAM_DATE_AMZ_CAMEL] = longDate
                ret[PARAM_EXPIRES_AMZ_CAMEL] = expires
                ret[PARAM_SIGNEDHEADERS_AMZ_CAMEL] = signedHeaders

                requestUrl, canonicalizedUrl := conf.formatUrls(bucketName, objectKey, params, false)
                parsedRequestUrl, _ := url.Parse(requestUrl)
                stringToSign := getV4StringToSign(method, canonicalizedUrl, parsedRequestUrl.RawQuery, scope, longDate, UNSIGNED_PAYLOAD, strings.Split(signedHeaders, ";"), headers)
                ret[PARAM_SIGNATURE_AMZ_CAMEL] = UrlEncode(getSignature(stringToSign, sk, region, shortDate), false)</span>
        } else<span class="cov0" title="0"> if signature == "v2" </span><span class="cov0" title="0">{
                conf.signature = SignatureV2
                _, canonicalizedUrl := conf.formatUrls(bucketName, objectKey, params, false)
                expires, ok := params["Expires"]
                if !ok </span><span class="cov0" title="0">{
                        expires = params["expires"]
                }</span>
                <span class="cov0" title="0">headers[HEADER_DATE_CAMEL] = []string{expires}
                stringToSign := getV2StringToSign(method, canonicalizedUrl, headers)
                ret = make(map[string]string, 3)
                ret["Signature"] = UrlEncode(Base64Encode(HmacSha1([]byte(sk), []byte(stringToSign))), false)
                ret["AWSAccessKeyId"] = UrlEncode(ak, false)
                ret["Expires"] = UrlEncode(expires, false)</span>
        }

        <span class="cov0" title="0">return</span>
}
</pre>
		
		<pre class="file" id="file73" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package utils

import (
        "encoding/json"
        "errors"
        "math/rand"
        "os"
        "reflect"

        log "github.com/sirupsen/logrus"
)

//remove redundant elements
func RvRepElement(arr []string) []string <span class="cov0" title="0">{
        result := []string{}
        for i := 0; i &lt; len(arr); i++ </span><span class="cov0" title="0">{
                flag := true
                for j := range result </span><span class="cov0" title="0">{
                        if arr[i] == result[j] </span><span class="cov0" title="0">{
                                flag = false
                                break</span>
                        }
                }
                <span class="cov0" title="0">if flag == true </span><span class="cov0" title="0">{
                        result = append(result, arr[i])
                }</span>
        }
        <span class="cov0" title="0">return result</span>
}

func Contained(obj, target interface{}) bool <span class="cov8" title="1">{
        targetValue := reflect.ValueOf(target)
        switch reflect.TypeOf(target).Kind() </span>{
        case reflect.Slice, reflect.Array:<span class="cov8" title="1">
                for i := 0; i &lt; targetValue.Len(); i++ </span><span class="cov8" title="1">{
                        if targetValue.Index(i).Interface() == obj </span><span class="cov8" title="1">{
                                return true
                        }</span>
                }
        case reflect.Map:<span class="cov0" title="0">
                if targetValue.MapIndex(reflect.ValueOf(obj)).IsValid() </span><span class="cov0" title="0">{
                        return true
                }</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
        <span class="cov8" title="1">return false</span>
}

func MergeGeneralMaps(maps ...map[string]interface{}) map[string]interface{} <span class="cov0" title="0">{
        var out = make(map[string]interface{})
        for _, m := range maps </span><span class="cov0" title="0">{
                for k, v := range m </span><span class="cov0" title="0">{
                        out[k] = v
                }</span>
        }
        <span class="cov0" title="0">return out</span>
}

func MergeStringMaps(maps ...map[string]string) map[string]string <span class="cov0" title="0">{
        var out = make(map[string]string)
        for _, m := range maps </span><span class="cov0" title="0">{
                for k, v := range m </span><span class="cov0" title="0">{
                        out[k] = v
                }</span>
        }
        <span class="cov0" title="0">return out</span>
}

func PathExists(path string) (bool, error) <span class="cov0" title="0">{
        _, err := os.Stat(path)
        if err == nil </span><span class="cov0" title="0">{
                return true, nil
        }</span>
        <span class="cov0" title="0">if os.IsNotExist(err) </span><span class="cov0" title="0">{
                return false, nil
        }</span>
        <span class="cov0" title="0">return false, err</span>
}

func Retry(retryNum int, desc string, silent bool, fn func(retryIdx int, lastErr error) error) error <span class="cov8" title="1">{
        var err error
        for i := 0; i &lt; retryNum; i++ </span><span class="cov8" title="1">{
                if err = fn(i, err); err != nil </span><span class="cov0" title="0">{
                        if !silent </span><span class="cov0" title="0">{
                                log.Errorf("%s:%s, retry %d time(s)", desc, err, i+1)
                        }</span>
                } else<span class="cov8" title="1"> {
                        return nil
                }</span>
        }
        <span class="cov0" title="0">if !silent </span><span class="cov0" title="0">{
                log.Errorf("%s retry exceed the max retry times(%d).", desc, retryNum)
        }</span>
        <span class="cov0" title="0">return err</span>
}

// StructToMap ...
func StructToMap(structObj interface{}) (map[string]interface{}, error) <span class="cov0" title="0">{
        jsonStr, err := json.Marshal(structObj)
        if nil != err </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var result map[string]interface{}
        err = json.Unmarshal(jsonStr, &amp;result)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

// Epsilon ...
const Epsilon float64 = 0.00000001

// IsFloatEqual ...
func IsFloatEqual(a, b float64) bool <span class="cov0" title="0">{
        if (a-b) &lt; Epsilon &amp;&amp; (b-a) &lt; Epsilon </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">return false</span>
}

// IsEqual ...
func IsEqual(key string, value interface{}, reqValue interface{}) (bool, error) <span class="cov0" title="0">{
        switch value.(type) </span>{
        case bool:<span class="cov0" title="0">
                v, ok1 := value.(bool)
                r, ok2 := reqValue.(bool)

                if ok1 &amp;&amp; ok2 </span><span class="cov0" title="0">{
                        if v == r </span><span class="cov0" title="0">{
                                return true, nil
                        }</span>

                        <span class="cov0" title="0">return false, nil</span>
                }

                <span class="cov0" title="0">return false, errors.New("the type of " + key + " must be bool")</span>
        case float64:<span class="cov0" title="0">
                v, ok1 := value.(float64)
                r, ok2 := reqValue.(float64)

                if ok1 &amp;&amp; ok2 </span><span class="cov0" title="0">{
                        if IsFloatEqual(v, r) </span><span class="cov0" title="0">{
                                return true, nil
                        }</span>

                        <span class="cov0" title="0">return false, nil</span>
                }

                <span class="cov0" title="0">return false, errors.New("the type of " + key + " must be float64")</span>
        case string:<span class="cov0" title="0">
                v, ok1 := value.(string)
                r, ok2 := reqValue.(string)
                if ok1 &amp;&amp; ok2 </span><span class="cov0" title="0">{
                        if v == r </span><span class="cov0" title="0">{
                                return true, nil
                        }</span>

                        <span class="cov0" title="0">return false, nil</span>
                }

                <span class="cov0" title="0">return false, errors.New("the type of " + key + " must be string")</span>
        default:<span class="cov0" title="0">
                return false, errors.New("the type of " + key + " must be bool or float64 or string")</span>
        }
}

func RandSeqWithAlnum(n int) string <span class="cov0" title="0">{
        alnum := []rune("1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ")
        return RandSeq(n, alnum)
}</span>

func RandSeq(n int, chs []rune) string <span class="cov0" title="0">{
        b := make([]rune, n)
        for i := range b </span><span class="cov0" title="0">{
                b[i] = chs[rand.Intn(len(chs))]
        }</span>
        <span class="cov0" title="0">return string(b)</span>
}
</pre>
		
		<pre class="file" id="file74" style="display: none">// Code generated by protoc-gen-micro. DO NOT EDIT.
// source: backend.proto

/*
Package backend is a generated protocol buffer package.

It is generated from these files:
        backend.proto

It has these top-level messages:
        CreateBackendRequest
        CreateBackendResponse
        GetBackendRequest
        GetBackendResponse
        ListBackendRequest
        ListBackendResponse
        UpdateBackendRequest
        UpdateBackendResponse
        DeleteBackendRequest
        DeleteBackendResponse
        BackendDetail
        ListTypeRequest
        ListTypeResponse
        TypeDetail
*/
package backend

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
        context "context"

        client "github.com/micro/go-micro/client"
        server "github.com/micro/go-micro/server"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ client.Option
var _ server.Option

// Client API for Backend service

type BackendService interface {
        CreateBackend(ctx context.Context, in *CreateBackendRequest, opts ...client.CallOption) (*CreateBackendResponse, error)
        GetBackend(ctx context.Context, in *GetBackendRequest, opts ...client.CallOption) (*GetBackendResponse, error)
        ListBackend(ctx context.Context, in *ListBackendRequest, opts ...client.CallOption) (*ListBackendResponse, error)
        UpdateBackend(ctx context.Context, in *UpdateBackendRequest, opts ...client.CallOption) (*UpdateBackendResponse, error)
        DeleteBackend(ctx context.Context, in *DeleteBackendRequest, opts ...client.CallOption) (*DeleteBackendResponse, error)
        ListType(ctx context.Context, in *ListTypeRequest, opts ...client.CallOption) (*ListTypeResponse, error)
}

type backendService struct {
        c    client.Client
        name string
}

func NewBackendService(name string, c client.Client) BackendService <span class="cov8" title="1">{
        if c == nil </span><span class="cov0" title="0">{
                c = client.NewClient()
        }</span>
        <span class="cov8" title="1">if len(name) == 0 </span><span class="cov0" title="0">{
                name = "backend"
        }</span>
        <span class="cov8" title="1">return &amp;backendService{
                c:    c,
                name: name,
        }</span>
}

func (c *backendService) CreateBackend(ctx context.Context, in *CreateBackendRequest, opts ...client.CallOption) (*CreateBackendResponse, error) <span class="cov0" title="0">{
        req := c.c.NewRequest(c.name, "Backend.CreateBackend", in)
        out := new(CreateBackendResponse)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *backendService) GetBackend(ctx context.Context, in *GetBackendRequest, opts ...client.CallOption) (*GetBackendResponse, error) <span class="cov0" title="0">{
        req := c.c.NewRequest(c.name, "Backend.GetBackend", in)
        out := new(GetBackendResponse)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *backendService) ListBackend(ctx context.Context, in *ListBackendRequest, opts ...client.CallOption) (*ListBackendResponse, error) <span class="cov8" title="1">{
        req := c.c.NewRequest(c.name, "Backend.ListBackend", in)
        out := new(ListBackendResponse)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (c *backendService) UpdateBackend(ctx context.Context, in *UpdateBackendRequest, opts ...client.CallOption) (*UpdateBackendResponse, error) <span class="cov0" title="0">{
        req := c.c.NewRequest(c.name, "Backend.UpdateBackend", in)
        out := new(UpdateBackendResponse)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *backendService) DeleteBackend(ctx context.Context, in *DeleteBackendRequest, opts ...client.CallOption) (*DeleteBackendResponse, error) <span class="cov0" title="0">{
        req := c.c.NewRequest(c.name, "Backend.DeleteBackend", in)
        out := new(DeleteBackendResponse)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *backendService) ListType(ctx context.Context, in *ListTypeRequest, opts ...client.CallOption) (*ListTypeResponse, error) <span class="cov8" title="1">{
        req := c.c.NewRequest(c.name, "Backend.ListType", in)
        out := new(ListTypeResponse)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

// Server API for Backend service

type BackendHandler interface {
        CreateBackend(context.Context, *CreateBackendRequest, *CreateBackendResponse) error
        GetBackend(context.Context, *GetBackendRequest, *GetBackendResponse) error
        ListBackend(context.Context, *ListBackendRequest, *ListBackendResponse) error
        UpdateBackend(context.Context, *UpdateBackendRequest, *UpdateBackendResponse) error
        DeleteBackend(context.Context, *DeleteBackendRequest, *DeleteBackendResponse) error
        ListType(context.Context, *ListTypeRequest, *ListTypeResponse) error
}

func RegisterBackendHandler(s server.Server, hdlr BackendHandler, opts ...server.HandlerOption) error <span class="cov0" title="0">{
        type backend interface {
                CreateBackend(ctx context.Context, in *CreateBackendRequest, out *CreateBackendResponse) error
                GetBackend(ctx context.Context, in *GetBackendRequest, out *GetBackendResponse) error
                ListBackend(ctx context.Context, in *ListBackendRequest, out *ListBackendResponse) error
                UpdateBackend(ctx context.Context, in *UpdateBackendRequest, out *UpdateBackendResponse) error
                DeleteBackend(ctx context.Context, in *DeleteBackendRequest, out *DeleteBackendResponse) error
                ListType(ctx context.Context, in *ListTypeRequest, out *ListTypeResponse) error
        }
        type Backend struct {
                backend
        }
        h := &amp;backendHandler{hdlr}
        return s.Handle(s.NewHandler(&amp;Backend{h}, opts...))
}</span>

type backendHandler struct {
        BackendHandler
}

func (h *backendHandler) CreateBackend(ctx context.Context, in *CreateBackendRequest, out *CreateBackendResponse) error <span class="cov0" title="0">{
        return h.BackendHandler.CreateBackend(ctx, in, out)
}</span>

func (h *backendHandler) GetBackend(ctx context.Context, in *GetBackendRequest, out *GetBackendResponse) error <span class="cov0" title="0">{
        return h.BackendHandler.GetBackend(ctx, in, out)
}</span>

func (h *backendHandler) ListBackend(ctx context.Context, in *ListBackendRequest, out *ListBackendResponse) error <span class="cov0" title="0">{
        return h.BackendHandler.ListBackend(ctx, in, out)
}</span>

func (h *backendHandler) UpdateBackend(ctx context.Context, in *UpdateBackendRequest, out *UpdateBackendResponse) error <span class="cov0" title="0">{
        return h.BackendHandler.UpdateBackend(ctx, in, out)
}</span>

func (h *backendHandler) DeleteBackend(ctx context.Context, in *DeleteBackendRequest, out *DeleteBackendResponse) error <span class="cov0" title="0">{
        return h.BackendHandler.DeleteBackend(ctx, in, out)
}</span>

func (h *backendHandler) ListType(ctx context.Context, in *ListTypeRequest, out *ListTypeResponse) error <span class="cov0" title="0">{
        return h.BackendHandler.ListType(ctx, in, out)
}</span>
</pre>
		
		<pre class="file" id="file75" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// source: backend.proto

/*
Package backend is a generated protocol buffer package.

It is generated from these files:
        backend.proto

It has these top-level messages:
        CreateBackendRequest
        CreateBackendResponse
        GetBackendRequest
        GetBackendResponse
        ListBackendRequest
        ListBackendResponse
        UpdateBackendRequest
        UpdateBackendResponse
        DeleteBackendRequest
        DeleteBackendResponse
        BackendDetail
        ListTypeRequest
        ListTypeResponse
        TypeDetail
*/
package backend

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type CreateBackendRequest struct {
        Backend *BackendDetail `protobuf:"bytes,1,opt,name=backend" json:"backend,omitempty"`
}

func (m *CreateBackendRequest) Reset()                    <span class="cov0" title="0">{ *m = CreateBackendRequest{} }</span>
func (m *CreateBackendRequest) String() string            <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*CreateBackendRequest) ProtoMessage()               {<span class="cov0" title="0">}</span>
func (*CreateBackendRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{ return fileDescriptor0, []int{0} }</span>

func (m *CreateBackendRequest) GetBackend() *BackendDetail <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Backend
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type CreateBackendResponse struct {
        Backend *BackendDetail `protobuf:"bytes,1,opt,name=backend" json:"backend,omitempty"`
}

func (m *CreateBackendResponse) Reset()                    <span class="cov0" title="0">{ *m = CreateBackendResponse{} }</span>
func (m *CreateBackendResponse) String() string            <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*CreateBackendResponse) ProtoMessage()               {<span class="cov0" title="0">}</span>
func (*CreateBackendResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{ return fileDescriptor0, []int{1} }</span>

func (m *CreateBackendResponse) GetBackend() *BackendDetail <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Backend
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type GetBackendRequest struct {
        Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
}

func (m *GetBackendRequest) Reset()                    <span class="cov0" title="0">{ *m = GetBackendRequest{} }</span>
func (m *GetBackendRequest) String() string            <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*GetBackendRequest) ProtoMessage()               {<span class="cov0" title="0">}</span>
func (*GetBackendRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{ return fileDescriptor0, []int{2} }</span>

func (m *GetBackendRequest) GetId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type GetBackendResponse struct {
        Backend *BackendDetail `protobuf:"bytes,1,opt,name=backend" json:"backend,omitempty"`
}

func (m *GetBackendResponse) Reset()                    <span class="cov0" title="0">{ *m = GetBackendResponse{} }</span>
func (m *GetBackendResponse) String() string            <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*GetBackendResponse) ProtoMessage()               {<span class="cov0" title="0">}</span>
func (*GetBackendResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{ return fileDescriptor0, []int{3} }</span>

func (m *GetBackendResponse) GetBackend() *BackendDetail <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Backend
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type ListBackendRequest struct {
        Limit    int32             `protobuf:"varint,1,opt,name=limit" json:"limit,omitempty"`
        Offset   int32             `protobuf:"varint,2,opt,name=offset" json:"offset,omitempty"`
        SortKeys []string          `protobuf:"bytes,3,rep,name=sortKeys" json:"sortKeys,omitempty"`
        SortDirs []string          `protobuf:"bytes,4,rep,name=sortDirs" json:"sortDirs,omitempty"`
        Filter   map[string]string `protobuf:"bytes,5,rep,name=Filter" json:"Filter,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *ListBackendRequest) Reset()                    <span class="cov0" title="0">{ *m = ListBackendRequest{} }</span>
func (m *ListBackendRequest) String() string            <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*ListBackendRequest) ProtoMessage()               {<span class="cov0" title="0">}</span>
func (*ListBackendRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{ return fileDescriptor0, []int{4} }</span>

func (m *ListBackendRequest) GetLimit() int32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Limit
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *ListBackendRequest) GetOffset() int32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Offset
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *ListBackendRequest) GetSortKeys() []string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.SortKeys
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *ListBackendRequest) GetSortDirs() []string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.SortDirs
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *ListBackendRequest) GetFilter() map[string]string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Filter
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type ListBackendResponse struct {
        Backends []*BackendDetail `protobuf:"bytes,1,rep,name=backends" json:"backends,omitempty"`
        Next     int32            `protobuf:"varint,2,opt,name=next" json:"next,omitempty"`
}

func (m *ListBackendResponse) Reset()                    <span class="cov8" title="1">{ *m = ListBackendResponse{} }</span>
func (m *ListBackendResponse) String() string            <span class="cov8" title="1">{ return proto.CompactTextString(m) }</span>
func (*ListBackendResponse) ProtoMessage()               {<span class="cov0" title="0">}</span>
func (*ListBackendResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{ return fileDescriptor0, []int{5} }</span>

func (m *ListBackendResponse) GetBackends() []*BackendDetail <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Backends
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *ListBackendResponse) GetNext() int32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Next
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type UpdateBackendRequest struct {
        Id       string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
        Access   string `protobuf:"bytes,2,opt,name=access" json:"access,omitempty"`
        Security string `protobuf:"bytes,3,opt,name=security" json:"security,omitempty"`
}

func (m *UpdateBackendRequest) Reset()                    <span class="cov0" title="0">{ *m = UpdateBackendRequest{} }</span>
func (m *UpdateBackendRequest) String() string            <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*UpdateBackendRequest) ProtoMessage()               {<span class="cov0" title="0">}</span>
func (*UpdateBackendRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{ return fileDescriptor0, []int{6} }</span>

func (m *UpdateBackendRequest) GetId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *UpdateBackendRequest) GetAccess() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Access
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *UpdateBackendRequest) GetSecurity() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Security
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type UpdateBackendResponse struct {
        Backend *BackendDetail `protobuf:"bytes,1,opt,name=backend" json:"backend,omitempty"`
}

func (m *UpdateBackendResponse) Reset()                    <span class="cov0" title="0">{ *m = UpdateBackendResponse{} }</span>
func (m *UpdateBackendResponse) String() string            <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*UpdateBackendResponse) ProtoMessage()               {<span class="cov0" title="0">}</span>
func (*UpdateBackendResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{ return fileDescriptor0, []int{7} }</span>

func (m *UpdateBackendResponse) GetBackend() *BackendDetail <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Backend
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type DeleteBackendRequest struct {
        Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
}

func (m *DeleteBackendRequest) Reset()                    <span class="cov0" title="0">{ *m = DeleteBackendRequest{} }</span>
func (m *DeleteBackendRequest) String() string            <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*DeleteBackendRequest) ProtoMessage()               {<span class="cov0" title="0">}</span>
func (*DeleteBackendRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{ return fileDescriptor0, []int{8} }</span>

func (m *DeleteBackendRequest) GetId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type DeleteBackendResponse struct {
}

func (m *DeleteBackendResponse) Reset()                    <span class="cov0" title="0">{ *m = DeleteBackendResponse{} }</span>
func (m *DeleteBackendResponse) String() string            <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*DeleteBackendResponse) ProtoMessage()               {<span class="cov0" title="0">}</span>
func (*DeleteBackendResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{ return fileDescriptor0, []int{9} }</span>

type BackendDetail struct {
        Id         string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
        TenantId   string `protobuf:"bytes,2,opt,name=tenantId" json:"tenantId,omitempty"`
        UserId     string `protobuf:"bytes,3,opt,name=userId" json:"userId,omitempty"`
        Name       string `protobuf:"bytes,4,opt,name=name" json:"name,omitempty"`
        Type       string `protobuf:"bytes,5,opt,name=type" json:"type,omitempty"`
        Region     string `protobuf:"bytes,6,opt,name=region" json:"region,omitempty"`
        Endpoint   string `protobuf:"bytes,7,opt,name=endpoint" json:"endpoint,omitempty"`
        BucketName string `protobuf:"bytes,8,opt,name=bucketName" json:"bucketName,omitempty"`
        Access     string `protobuf:"bytes,9,opt,name=access" json:"access,omitempty"`
        Security   string `protobuf:"bytes,10,opt,name=security" json:"security,omitempty"`
}

func (m *BackendDetail) Reset()                    <span class="cov0" title="0">{ *m = BackendDetail{} }</span>
func (m *BackendDetail) String() string            <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*BackendDetail) ProtoMessage()               {<span class="cov0" title="0">}</span>
func (*BackendDetail) Descriptor() ([]byte, []int) <span class="cov0" title="0">{ return fileDescriptor0, []int{10} }</span>

func (m *BackendDetail) GetId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *BackendDetail) GetTenantId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.TenantId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *BackendDetail) GetUserId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.UserId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *BackendDetail) GetName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *BackendDetail) GetType() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Type
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *BackendDetail) GetRegion() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Region
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *BackendDetail) GetEndpoint() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Endpoint
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *BackendDetail) GetBucketName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.BucketName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *BackendDetail) GetAccess() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Access
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *BackendDetail) GetSecurity() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Security
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type ListTypeRequest struct {
        Limit    int32             `protobuf:"varint,1,opt,name=limit" json:"limit,omitempty"`
        Offset   int32             `protobuf:"varint,2,opt,name=offset" json:"offset,omitempty"`
        SortKeys []string          `protobuf:"bytes,3,rep,name=sortKeys" json:"sortKeys,omitempty"`
        SortDirs []string          `protobuf:"bytes,4,rep,name=sortDirs" json:"sortDirs,omitempty"`
        Filter   map[string]string `protobuf:"bytes,5,rep,name=Filter" json:"Filter,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *ListTypeRequest) Reset()                    <span class="cov0" title="0">{ *m = ListTypeRequest{} }</span>
func (m *ListTypeRequest) String() string            <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*ListTypeRequest) ProtoMessage()               {<span class="cov0" title="0">}</span>
func (*ListTypeRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{ return fileDescriptor0, []int{11} }</span>

func (m *ListTypeRequest) GetLimit() int32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Limit
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *ListTypeRequest) GetOffset() int32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Offset
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *ListTypeRequest) GetSortKeys() []string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.SortKeys
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *ListTypeRequest) GetSortDirs() []string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.SortDirs
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *ListTypeRequest) GetFilter() map[string]string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Filter
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type ListTypeResponse struct {
        Types []*TypeDetail `protobuf:"bytes,1,rep,name=types" json:"types,omitempty"`
        Next  int32         `protobuf:"varint,2,opt,name=next" json:"next,omitempty"`
}

func (m *ListTypeResponse) Reset()                    <span class="cov8" title="1">{ *m = ListTypeResponse{} }</span>
func (m *ListTypeResponse) String() string            <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*ListTypeResponse) ProtoMessage()               {<span class="cov0" title="0">}</span>
func (*ListTypeResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{ return fileDescriptor0, []int{12} }</span>

func (m *ListTypeResponse) GetTypes() []*TypeDetail <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Types
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *ListTypeResponse) GetNext() int32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Next
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type TypeDetail struct {
        Name        string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
        Description string `protobuf:"bytes,2,opt,name=description" json:"description,omitempty"`
}

func (m *TypeDetail) Reset()                    <span class="cov0" title="0">{ *m = TypeDetail{} }</span>
func (m *TypeDetail) String() string            <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*TypeDetail) ProtoMessage()               {<span class="cov0" title="0">}</span>
func (*TypeDetail) Descriptor() ([]byte, []int) <span class="cov0" title="0">{ return fileDescriptor0, []int{13} }</span>

func (m *TypeDetail) GetName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *TypeDetail) GetDescription() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Description
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func init() <span class="cov8" title="1">{
        proto.RegisterType((*CreateBackendRequest)(nil), "CreateBackendRequest")
        proto.RegisterType((*CreateBackendResponse)(nil), "CreateBackendResponse")
        proto.RegisterType((*GetBackendRequest)(nil), "GetBackendRequest")
        proto.RegisterType((*GetBackendResponse)(nil), "GetBackendResponse")
        proto.RegisterType((*ListBackendRequest)(nil), "ListBackendRequest")
        proto.RegisterType((*ListBackendResponse)(nil), "ListBackendResponse")
        proto.RegisterType((*UpdateBackendRequest)(nil), "UpdateBackendRequest")
        proto.RegisterType((*UpdateBackendResponse)(nil), "UpdateBackendResponse")
        proto.RegisterType((*DeleteBackendRequest)(nil), "DeleteBackendRequest")
        proto.RegisterType((*DeleteBackendResponse)(nil), "DeleteBackendResponse")
        proto.RegisterType((*BackendDetail)(nil), "BackendDetail")
        proto.RegisterType((*ListTypeRequest)(nil), "ListTypeRequest")
        proto.RegisterType((*ListTypeResponse)(nil), "ListTypeResponse")
        proto.RegisterType((*TypeDetail)(nil), "TypeDetail")
}</span>

func init() <span class="cov8" title="1">{ proto.RegisterFile("backend.proto", fileDescriptor0) }</span>

var fileDescriptor0 = []byte{
        // 630 bytes of a gzipped FileDescriptorProto
        0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x55, 0x4d, 0x6f, 0xd3, 0x40,
        0x10, 0x8d, 0x93, 0x26, 0x4d, 0xc6, 0x6a, 0x69, 0xb7, 0x49, 0xb0, 0x2c, 0x04, 0xc1, 0x48, 0x28,
        0xe2, 0xb0, 0x12, 0x05, 0xa9, 0xd0, 0x03, 0x2a, 0xa5, 0x80, 0x2a, 0x10, 0x07, 0x8b, 0x5e, 0xb8,
        0xb9, 0xf6, 0x14, 0xad, 0x9a, 0xda, 0xc6, 0xbb, 0x41, 0xf8, 0xcc, 0x9f, 0xe5, 0xc4, 0x95, 0x2b,
        0xda, 0x0f, 0x27, 0xce, 0xc6, 0x08, 0x45, 0x42, 0xdc, 0xfc, 0x66, 0x66, 0x77, 0x66, 0xe7, 0xcd,
        0x3c, 0xc3, 0xce, 0x65, 0x14, 0x5f, 0x63, 0x9a, 0xd0, 0xbc, 0xc8, 0x44, 0x16, 0x9c, 0xc0, 0xf0,
        0x55, 0x81, 0x91, 0xc0, 0x53, 0x6d, 0x0e, 0xf1, 0xcb, 0x1c, 0xb9, 0x20, 0x53, 0xd8, 0x36, 0x81,
        0x9e, 0x33, 0x71, 0xa6, 0xee, 0xe1, 0x2e, 0x35, 0x11, 0x67, 0x28, 0x22, 0x36, 0x0b, 0x2b, 0x77,
        0xf0, 0x12, 0x46, 0xd6, 0x0d, 0x3c, 0xcf, 0x52, 0x8e, 0x1b, 0x5c, 0xf1, 0x00, 0xf6, 0xdf, 0xa2,
        0xb0, 0x2a, 0xd8, 0x85, 0x36, 0xd3, 0x27, 0x07, 0x61, 0x9b, 0x25, 0xc1, 0x0b, 0x20, 0xf5, 0xa0,
        0x8d, 0x93, 0xfc, 0x74, 0x80, 0xbc, 0x67, 0xdc, 0x4e, 0x33, 0x84, 0xee, 0x8c, 0xdd, 0x30, 0xa1,
        0x8e, 0x77, 0x43, 0x0d, 0xc8, 0x18, 0x7a, 0xd9, 0xd5, 0x15, 0x47, 0xe1, 0xb5, 0x95, 0xd9, 0x20,
        0xe2, 0x43, 0x9f, 0x67, 0x85, 0x78, 0x87, 0x25, 0xf7, 0x3a, 0x93, 0xce, 0x74, 0x10, 0x2e, 0x70,
        0xe5, 0x3b, 0x63, 0x05, 0xf7, 0xb6, 0x96, 0x3e, 0x89, 0xc9, 0x11, 0xf4, 0xde, 0xb0, 0x99, 0xc0,
        0xc2, 0xeb, 0x4e, 0x3a, 0x53, 0xf7, 0xf0, 0x1e, 0x5d, 0x2f, 0x85, 0xea, 0x88, 0xd7, 0xa9, 0x28,
        0xca, 0xd0, 0x84, 0xfb, 0xcf, 0xc1, 0xad, 0x99, 0xc9, 0x1e, 0x74, 0xae, 0xb1, 0x34, 0x5d, 0x91,
        0x9f, 0xb2, 0xfe, 0xaf, 0xd1, 0x6c, 0x8e, 0xaa, 0xd0, 0x41, 0xa8, 0xc1, 0x71, 0xfb, 0x99, 0x13,
        0x5c, 0xc0, 0xc1, 0x4a, 0x12, 0xd3, 0xb1, 0x47, 0xd0, 0x37, 0x2d, 0xe1, 0x9e, 0xa3, 0x8a, 0xb1,
        0x5b, 0xb6, 0xf0, 0x13, 0x02, 0x5b, 0x29, 0x7e, 0xab, 0x9a, 0xa0, 0xbe, 0x83, 0x4f, 0x30, 0xbc,
        0xc8, 0x93, 0xf5, 0x89, 0xb1, 0xf8, 0x92, 0x2d, 0x8c, 0xe2, 0x18, 0x39, 0x37, 0x95, 0x19, 0xa4,
        0xda, 0x84, 0xf1, 0xbc, 0x60, 0xa2, 0xf4, 0x3a, 0xca, 0xb3, 0xc0, 0x72, 0x96, 0xac, 0xbb, 0x37,
        0xa6, 0xf9, 0x21, 0x0c, 0xcf, 0x70, 0x86, 0x7f, 0x2b, 0x2f, 0xb8, 0x0d, 0x23, 0x2b, 0x4e, 0xa7,
        0x0a, 0xbe, 0xb7, 0x61, 0x67, 0xe5, 0xee, 0xb5, 0x97, 0xf9, 0xd0, 0x17, 0x98, 0x46, 0xa9, 0x38,
        0x4f, 0xcc, 0xdb, 0x16, 0x58, 0xbe, 0x7a, 0xce, 0xb1, 0x38, 0x4f, 0xcc, 0xdb, 0x0c, 0x52, 0x9d,
        0x8c, 0x6e, 0xd0, 0xdb, 0x52, 0x56, 0xf5, 0x2d, 0x6d, 0xa2, 0xcc, 0xd1, 0xeb, 0x6a, 0x9b, 0xfc,
        0x96, 0xe7, 0x0b, 0xfc, 0xcc, 0xb2, 0xd4, 0xeb, 0xe9, 0xf3, 0x1a, 0xc9, 0x9c, 0x98, 0x26, 0x79,
        0xc6, 0x52, 0xe1, 0x6d, 0xeb, 0x9c, 0x15, 0x26, 0x77, 0x01, 0x2e, 0xe7, 0xf1, 0x35, 0x8a, 0x0f,
        0x32, 0x43, 0x5f, 0x79, 0x6b, 0x96, 0x1a, 0x13, 0x83, 0x3f, 0x32, 0x01, 0x16, 0x13, 0x3f, 0x1c,
        0xb8, 0x25, 0xa7, 0xe7, 0x63, 0x99, 0xe3, 0xff, 0x5d, 0x95, 0xa7, 0xd6, 0xaa, 0xdc, 0xa1, 0x56,
        0x1d, 0xff, 0x7a, 0x4f, 0xce, 0x61, 0x6f, 0x99, 0xc1, 0xcc, 0xdb, 0x7d, 0xe8, 0x4a, 0x3a, 0xaa,
        0x0d, 0x71, 0xa9, 0xf4, 0x9a, 0x51, 0xd3, 0x9e, 0xc6, 0xdd, 0x38, 0x05, 0x58, 0x06, 0x2e, 0x38,
        0x77, 0x6a, 0x9c, 0x4f, 0xc0, 0x4d, 0x90, 0xc7, 0x05, 0xcb, 0x85, 0x24, 0x59, 0x17, 0x53, 0x37,
        0x1d, 0xfe, 0x6a, 0xc3, 0xb6, 0x99, 0x3f, 0x72, 0x02, 0x3b, 0x2b, 0xda, 0x4a, 0x46, 0xb4, 0x49,
        0xad, 0xfd, 0x31, 0x6d, 0x94, 0xe0, 0xa0, 0x45, 0x8e, 0x00, 0x96, 0xaa, 0x49, 0x08, 0x5d, 0xd3,
        0x59, 0xff, 0x80, 0xae, 0xcb, 0x6a, 0xd0, 0x22, 0xc7, 0xe0, 0xd6, 0xd4, 0x83, 0x1c, 0x34, 0x08,
        0x96, 0x3f, 0xa4, 0x0d, 0x02, 0x13, 0xb4, 0x64, 0xd9, 0x2b, 0x6b, 0x4c, 0x46, 0xb4, 0x49, 0x32,
        0xfc, 0x31, 0x6d, 0xdc, 0x76, 0x7d, 0xc3, 0xca, 0x76, 0x92, 0x11, 0x6d, 0xda, 0x6a, 0x7f, 0x4c,
        0x9b, 0x97, 0xb8, 0x45, 0x1e, 0x43, 0xbf, 0x62, 0x95, 0xec, 0xd9, 0x23, 0xe4, 0xef, 0x53, 0x9b,
        0xf2, 0xa0, 0x75, 0xd9, 0x53, 0xbf, 0xc4, 0x27, 0xbf, 0x03, 0x00, 0x00, 0xff, 0xff, 0x50, 0xb6,
        0xe0, 0x3d, 0x23, 0x07, 0x00, 0x00,
}
</pre>
		
		<pre class="file" id="file76" style="display: none">// Code generated by protoc-gen-micro. DO NOT EDIT.
// source: dataflow.proto

/*
Package dataflow is a generated protocol buffer package.

It is generated from these files:
        dataflow.proto

It has these top-level messages:
        Schedule
        Policy
        GetPolicyRequest
        GetPolicyResponse
        ListPolicyRequest
        ListPolicyResponse
        CreatePolicyRequest
        CreatePolicyResponse
        UpdatePolicyRequest
        UpdatePolicyResponse
        DeletePolicyRequest
        DeletePolicyResponse
        KV
        Filter
        Connector
        Plan
        CreatePlanRequest
        CreatePlanResponse
        GetPlanRequest
        GetPlanResponse
        ListPlanRequest
        ListPlanResponse
        UpdatePlanRequest
        UpdatePlanResponse
        DeletePlanRequest
        DeletePlanResponse
        RunPlanRequest
        RunPlanResponse
        Job
        GetJobRequest
        GetJobResponse
        ListJobRequest
        ListJobResponse
*/
package dataflow

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
        client "github.com/micro/go-micro/client"
        server "github.com/micro/go-micro/server"
        context "context"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ client.Option
var _ server.Option

// Client API for DataFlow service

type DataFlowService interface {
        GetPolicy(ctx context.Context, in *GetPolicyRequest, opts ...client.CallOption) (*GetPolicyResponse, error)
        ListPolicy(ctx context.Context, in *ListPolicyRequest, opts ...client.CallOption) (*ListPolicyResponse, error)
        CreatePolicy(ctx context.Context, in *CreatePolicyRequest, opts ...client.CallOption) (*CreatePolicyResponse, error)
        UpdatePolicy(ctx context.Context, in *UpdatePolicyRequest, opts ...client.CallOption) (*UpdatePolicyResponse, error)
        DeletePolicy(ctx context.Context, in *DeletePolicyRequest, opts ...client.CallOption) (*DeletePolicyResponse, error)
        GetPlan(ctx context.Context, in *GetPlanRequest, opts ...client.CallOption) (*GetPlanResponse, error)
        ListPlan(ctx context.Context, in *ListPlanRequest, opts ...client.CallOption) (*ListPlanResponse, error)
        CreatePlan(ctx context.Context, in *CreatePlanRequest, opts ...client.CallOption) (*CreatePlanResponse, error)
        UpdatePlan(ctx context.Context, in *UpdatePlanRequest, opts ...client.CallOption) (*UpdatePlanResponse, error)
        DeletePlan(ctx context.Context, in *DeletePlanRequest, opts ...client.CallOption) (*DeletePlanResponse, error)
        GetJob(ctx context.Context, in *GetJobRequest, opts ...client.CallOption) (*GetJobResponse, error)
        ListJob(ctx context.Context, in *ListJobRequest, opts ...client.CallOption) (*ListJobResponse, error)
        RunPlan(ctx context.Context, in *RunPlanRequest, opts ...client.CallOption) (*RunPlanResponse, error)
}

type dataFlowService struct {
        c    client.Client
        name string
}

func NewDataFlowService(name string, c client.Client) DataFlowService <span class="cov8" title="1">{
        if c == nil </span><span class="cov0" title="0">{
                c = client.NewClient()
        }</span>
        <span class="cov8" title="1">if len(name) == 0 </span><span class="cov0" title="0">{
                name = "dataflow"
        }</span>
        <span class="cov8" title="1">return &amp;dataFlowService{
                c:    c,
                name: name,
        }</span>
}

func (c *dataFlowService) GetPolicy(ctx context.Context, in *GetPolicyRequest, opts ...client.CallOption) (*GetPolicyResponse, error) <span class="cov0" title="0">{
        req := c.c.NewRequest(c.name, "DataFlow.GetPolicy", in)
        out := new(GetPolicyResponse)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *dataFlowService) ListPolicy(ctx context.Context, in *ListPolicyRequest, opts ...client.CallOption) (*ListPolicyResponse, error) <span class="cov0" title="0">{
        req := c.c.NewRequest(c.name, "DataFlow.ListPolicy", in)
        out := new(ListPolicyResponse)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *dataFlowService) CreatePolicy(ctx context.Context, in *CreatePolicyRequest, opts ...client.CallOption) (*CreatePolicyResponse, error) <span class="cov0" title="0">{
        req := c.c.NewRequest(c.name, "DataFlow.CreatePolicy", in)
        out := new(CreatePolicyResponse)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *dataFlowService) UpdatePolicy(ctx context.Context, in *UpdatePolicyRequest, opts ...client.CallOption) (*UpdatePolicyResponse, error) <span class="cov0" title="0">{
        req := c.c.NewRequest(c.name, "DataFlow.UpdatePolicy", in)
        out := new(UpdatePolicyResponse)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *dataFlowService) DeletePolicy(ctx context.Context, in *DeletePolicyRequest, opts ...client.CallOption) (*DeletePolicyResponse, error) <span class="cov0" title="0">{
        req := c.c.NewRequest(c.name, "DataFlow.DeletePolicy", in)
        out := new(DeletePolicyResponse)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *dataFlowService) GetPlan(ctx context.Context, in *GetPlanRequest, opts ...client.CallOption) (*GetPlanResponse, error) <span class="cov0" title="0">{
        req := c.c.NewRequest(c.name, "DataFlow.GetPlan", in)
        out := new(GetPlanResponse)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *dataFlowService) ListPlan(ctx context.Context, in *ListPlanRequest, opts ...client.CallOption) (*ListPlanResponse, error) <span class="cov8" title="1">{
        req := c.c.NewRequest(c.name, "DataFlow.ListPlan", in)
        out := new(ListPlanResponse)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *dataFlowService) CreatePlan(ctx context.Context, in *CreatePlanRequest, opts ...client.CallOption) (*CreatePlanResponse, error) <span class="cov0" title="0">{
        req := c.c.NewRequest(c.name, "DataFlow.CreatePlan", in)
        out := new(CreatePlanResponse)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *dataFlowService) UpdatePlan(ctx context.Context, in *UpdatePlanRequest, opts ...client.CallOption) (*UpdatePlanResponse, error) <span class="cov0" title="0">{
        req := c.c.NewRequest(c.name, "DataFlow.UpdatePlan", in)
        out := new(UpdatePlanResponse)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *dataFlowService) DeletePlan(ctx context.Context, in *DeletePlanRequest, opts ...client.CallOption) (*DeletePlanResponse, error) <span class="cov0" title="0">{
        req := c.c.NewRequest(c.name, "DataFlow.DeletePlan", in)
        out := new(DeletePlanResponse)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *dataFlowService) GetJob(ctx context.Context, in *GetJobRequest, opts ...client.CallOption) (*GetJobResponse, error) <span class="cov0" title="0">{
        req := c.c.NewRequest(c.name, "DataFlow.GetJob", in)
        out := new(GetJobResponse)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *dataFlowService) ListJob(ctx context.Context, in *ListJobRequest, opts ...client.CallOption) (*ListJobResponse, error) <span class="cov0" title="0">{
        req := c.c.NewRequest(c.name, "DataFlow.ListJob", in)
        out := new(ListJobResponse)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *dataFlowService) RunPlan(ctx context.Context, in *RunPlanRequest, opts ...client.CallOption) (*RunPlanResponse, error) <span class="cov0" title="0">{
        req := c.c.NewRequest(c.name, "DataFlow.RunPlan", in)
        out := new(RunPlanResponse)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// Server API for DataFlow service

type DataFlowHandler interface {
        GetPolicy(context.Context, *GetPolicyRequest, *GetPolicyResponse) error
        ListPolicy(context.Context, *ListPolicyRequest, *ListPolicyResponse) error
        CreatePolicy(context.Context, *CreatePolicyRequest, *CreatePolicyResponse) error
        UpdatePolicy(context.Context, *UpdatePolicyRequest, *UpdatePolicyResponse) error
        DeletePolicy(context.Context, *DeletePolicyRequest, *DeletePolicyResponse) error
        GetPlan(context.Context, *GetPlanRequest, *GetPlanResponse) error
        ListPlan(context.Context, *ListPlanRequest, *ListPlanResponse) error
        CreatePlan(context.Context, *CreatePlanRequest, *CreatePlanResponse) error
        UpdatePlan(context.Context, *UpdatePlanRequest, *UpdatePlanResponse) error
        DeletePlan(context.Context, *DeletePlanRequest, *DeletePlanResponse) error
        GetJob(context.Context, *GetJobRequest, *GetJobResponse) error
        ListJob(context.Context, *ListJobRequest, *ListJobResponse) error
        RunPlan(context.Context, *RunPlanRequest, *RunPlanResponse) error
}

func RegisterDataFlowHandler(s server.Server, hdlr DataFlowHandler, opts ...server.HandlerOption) error <span class="cov0" title="0">{
        type dataFlow interface {
                GetPolicy(ctx context.Context, in *GetPolicyRequest, out *GetPolicyResponse) error
                ListPolicy(ctx context.Context, in *ListPolicyRequest, out *ListPolicyResponse) error
                CreatePolicy(ctx context.Context, in *CreatePolicyRequest, out *CreatePolicyResponse) error
                UpdatePolicy(ctx context.Context, in *UpdatePolicyRequest, out *UpdatePolicyResponse) error
                DeletePolicy(ctx context.Context, in *DeletePolicyRequest, out *DeletePolicyResponse) error
                GetPlan(ctx context.Context, in *GetPlanRequest, out *GetPlanResponse) error
                ListPlan(ctx context.Context, in *ListPlanRequest, out *ListPlanResponse) error
                CreatePlan(ctx context.Context, in *CreatePlanRequest, out *CreatePlanResponse) error
                UpdatePlan(ctx context.Context, in *UpdatePlanRequest, out *UpdatePlanResponse) error
                DeletePlan(ctx context.Context, in *DeletePlanRequest, out *DeletePlanResponse) error
                GetJob(ctx context.Context, in *GetJobRequest, out *GetJobResponse) error
                ListJob(ctx context.Context, in *ListJobRequest, out *ListJobResponse) error
                RunPlan(ctx context.Context, in *RunPlanRequest, out *RunPlanResponse) error
        }
        type DataFlow struct {
                dataFlow
        }
        h := &amp;dataFlowHandler{hdlr}
        return s.Handle(s.NewHandler(&amp;DataFlow{h}, opts...))
}</span>

type dataFlowHandler struct {
        DataFlowHandler
}

func (h *dataFlowHandler) GetPolicy(ctx context.Context, in *GetPolicyRequest, out *GetPolicyResponse) error <span class="cov0" title="0">{
        return h.DataFlowHandler.GetPolicy(ctx, in, out)
}</span>

func (h *dataFlowHandler) ListPolicy(ctx context.Context, in *ListPolicyRequest, out *ListPolicyResponse) error <span class="cov0" title="0">{
        return h.DataFlowHandler.ListPolicy(ctx, in, out)
}</span>

func (h *dataFlowHandler) CreatePolicy(ctx context.Context, in *CreatePolicyRequest, out *CreatePolicyResponse) error <span class="cov0" title="0">{
        return h.DataFlowHandler.CreatePolicy(ctx, in, out)
}</span>

func (h *dataFlowHandler) UpdatePolicy(ctx context.Context, in *UpdatePolicyRequest, out *UpdatePolicyResponse) error <span class="cov0" title="0">{
        return h.DataFlowHandler.UpdatePolicy(ctx, in, out)
}</span>

func (h *dataFlowHandler) DeletePolicy(ctx context.Context, in *DeletePolicyRequest, out *DeletePolicyResponse) error <span class="cov0" title="0">{
        return h.DataFlowHandler.DeletePolicy(ctx, in, out)
}</span>

func (h *dataFlowHandler) GetPlan(ctx context.Context, in *GetPlanRequest, out *GetPlanResponse) error <span class="cov0" title="0">{
        return h.DataFlowHandler.GetPlan(ctx, in, out)
}</span>

func (h *dataFlowHandler) ListPlan(ctx context.Context, in *ListPlanRequest, out *ListPlanResponse) error <span class="cov0" title="0">{
        return h.DataFlowHandler.ListPlan(ctx, in, out)
}</span>

func (h *dataFlowHandler) CreatePlan(ctx context.Context, in *CreatePlanRequest, out *CreatePlanResponse) error <span class="cov0" title="0">{
        return h.DataFlowHandler.CreatePlan(ctx, in, out)
}</span>

func (h *dataFlowHandler) UpdatePlan(ctx context.Context, in *UpdatePlanRequest, out *UpdatePlanResponse) error <span class="cov0" title="0">{
        return h.DataFlowHandler.UpdatePlan(ctx, in, out)
}</span>

func (h *dataFlowHandler) DeletePlan(ctx context.Context, in *DeletePlanRequest, out *DeletePlanResponse) error <span class="cov0" title="0">{
        return h.DataFlowHandler.DeletePlan(ctx, in, out)
}</span>

func (h *dataFlowHandler) GetJob(ctx context.Context, in *GetJobRequest, out *GetJobResponse) error <span class="cov0" title="0">{
        return h.DataFlowHandler.GetJob(ctx, in, out)
}</span>

func (h *dataFlowHandler) ListJob(ctx context.Context, in *ListJobRequest, out *ListJobResponse) error <span class="cov0" title="0">{
        return h.DataFlowHandler.ListJob(ctx, in, out)
}</span>

func (h *dataFlowHandler) RunPlan(ctx context.Context, in *RunPlanRequest, out *RunPlanResponse) error <span class="cov0" title="0">{
        return h.DataFlowHandler.RunPlan(ctx, in, out)
}</span>
</pre>
		
		<pre class="file" id="file77" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// source: dataflow.proto

package dataflow

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Schedule struct {
        Type                 string   `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
        TiggerProperties     string   `protobuf:"bytes,2,opt,name=tiggerProperties,proto3" json:"tiggerProperties,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *Schedule) Reset()         <span class="cov0" title="0">{ *m = Schedule{} }</span>
func (m *Schedule) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*Schedule) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*Schedule) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_dataflow_63b5ce1c78fcbb67, []int{0}
}</span>
func (m *Schedule) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_Schedule.Unmarshal(m, b)
}</span>
func (m *Schedule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_Schedule.Marshal(b, m, deterministic)
}</span>
func (dst *Schedule) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_Schedule.Merge(dst, src)
}</span>
func (m *Schedule) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_Schedule.Size(m)
}</span>
func (m *Schedule) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_Schedule.DiscardUnknown(m)
}</span>

var xxx_messageInfo_Schedule proto.InternalMessageInfo

func (m *Schedule) GetType() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Type
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Schedule) GetTiggerProperties() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.TiggerProperties
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type Policy struct {
        Id                   string    `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
        TenantId             string    `protobuf:"bytes,2,opt,name=tenantId,proto3" json:"tenantId,omitempty"`
        UserId               string    `protobuf:"bytes,3,opt,name=userId,proto3" json:"userId,omitempty"`
        Name                 string    `protobuf:"bytes,4,opt,name=name,proto3" json:"name,omitempty"`
        Tenant               string    `protobuf:"bytes,5,opt,name=tenant,proto3" json:"tenant,omitempty"`
        Description          string    `protobuf:"bytes,6,opt,name=description,proto3" json:"description,omitempty"`
        Schedule             *Schedule `protobuf:"bytes,7,opt,name=schedule,proto3" json:"schedule,omitempty"`
        XXX_NoUnkeyedLiteral struct{}  `json:"-"`
        XXX_unrecognized     []byte    `json:"-"`
        XXX_sizecache        int32     `json:"-"`
}

func (m *Policy) Reset()         <span class="cov0" title="0">{ *m = Policy{} }</span>
func (m *Policy) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*Policy) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*Policy) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_dataflow_63b5ce1c78fcbb67, []int{1}
}</span>
func (m *Policy) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_Policy.Unmarshal(m, b)
}</span>
func (m *Policy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_Policy.Marshal(b, m, deterministic)
}</span>
func (dst *Policy) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_Policy.Merge(dst, src)
}</span>
func (m *Policy) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_Policy.Size(m)
}</span>
func (m *Policy) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_Policy.DiscardUnknown(m)
}</span>

var xxx_messageInfo_Policy proto.InternalMessageInfo

func (m *Policy) GetId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Policy) GetTenantId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.TenantId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Policy) GetUserId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.UserId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Policy) GetName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Policy) GetTenant() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Tenant
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Policy) GetDescription() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Description
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Policy) GetSchedule() *Schedule <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Schedule
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type GetPolicyRequest struct {
        Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *GetPolicyRequest) Reset()         <span class="cov0" title="0">{ *m = GetPolicyRequest{} }</span>
func (m *GetPolicyRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*GetPolicyRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*GetPolicyRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_dataflow_63b5ce1c78fcbb67, []int{2}
}</span>
func (m *GetPolicyRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_GetPolicyRequest.Unmarshal(m, b)
}</span>
func (m *GetPolicyRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_GetPolicyRequest.Marshal(b, m, deterministic)
}</span>
func (dst *GetPolicyRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_GetPolicyRequest.Merge(dst, src)
}</span>
func (m *GetPolicyRequest) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_GetPolicyRequest.Size(m)
}</span>
func (m *GetPolicyRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_GetPolicyRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_GetPolicyRequest proto.InternalMessageInfo

func (m *GetPolicyRequest) GetId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type GetPolicyResponse struct {
        Err                  string   `protobuf:"bytes,1,opt,name=err,proto3" json:"err,omitempty"`
        Policy               *Policy  `protobuf:"bytes,2,opt,name=policy,proto3" json:"policy,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *GetPolicyResponse) Reset()         <span class="cov0" title="0">{ *m = GetPolicyResponse{} }</span>
func (m *GetPolicyResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*GetPolicyResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*GetPolicyResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_dataflow_63b5ce1c78fcbb67, []int{3}
}</span>
func (m *GetPolicyResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_GetPolicyResponse.Unmarshal(m, b)
}</span>
func (m *GetPolicyResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_GetPolicyResponse.Marshal(b, m, deterministic)
}</span>
func (dst *GetPolicyResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_GetPolicyResponse.Merge(dst, src)
}</span>
func (m *GetPolicyResponse) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_GetPolicyResponse.Size(m)
}</span>
func (m *GetPolicyResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_GetPolicyResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_GetPolicyResponse proto.InternalMessageInfo

func (m *GetPolicyResponse) GetErr() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Err
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *GetPolicyResponse) GetPolicy() *Policy <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Policy
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type ListPolicyRequest struct {
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *ListPolicyRequest) Reset()         <span class="cov0" title="0">{ *m = ListPolicyRequest{} }</span>
func (m *ListPolicyRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*ListPolicyRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*ListPolicyRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_dataflow_63b5ce1c78fcbb67, []int{4}
}</span>
func (m *ListPolicyRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_ListPolicyRequest.Unmarshal(m, b)
}</span>
func (m *ListPolicyRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_ListPolicyRequest.Marshal(b, m, deterministic)
}</span>
func (dst *ListPolicyRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_ListPolicyRequest.Merge(dst, src)
}</span>
func (m *ListPolicyRequest) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_ListPolicyRequest.Size(m)
}</span>
func (m *ListPolicyRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_ListPolicyRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_ListPolicyRequest proto.InternalMessageInfo

type ListPolicyResponse struct {
        Err                  string    `protobuf:"bytes,1,opt,name=err,proto3" json:"err,omitempty"`
        Policies             []*Policy `protobuf:"bytes,2,rep,name=policies,proto3" json:"policies,omitempty"`
        XXX_NoUnkeyedLiteral struct{}  `json:"-"`
        XXX_unrecognized     []byte    `json:"-"`
        XXX_sizecache        int32     `json:"-"`
}

func (m *ListPolicyResponse) Reset()         <span class="cov0" title="0">{ *m = ListPolicyResponse{} }</span>
func (m *ListPolicyResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*ListPolicyResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*ListPolicyResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_dataflow_63b5ce1c78fcbb67, []int{5}
}</span>
func (m *ListPolicyResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_ListPolicyResponse.Unmarshal(m, b)
}</span>
func (m *ListPolicyResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_ListPolicyResponse.Marshal(b, m, deterministic)
}</span>
func (dst *ListPolicyResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_ListPolicyResponse.Merge(dst, src)
}</span>
func (m *ListPolicyResponse) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_ListPolicyResponse.Size(m)
}</span>
func (m *ListPolicyResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_ListPolicyResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_ListPolicyResponse proto.InternalMessageInfo

func (m *ListPolicyResponse) GetErr() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Err
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *ListPolicyResponse) GetPolicies() []*Policy <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Policies
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type CreatePolicyRequest struct {
        Policy               *Policy  `protobuf:"bytes,1,opt,name=policy,proto3" json:"policy,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *CreatePolicyRequest) Reset()         <span class="cov0" title="0">{ *m = CreatePolicyRequest{} }</span>
func (m *CreatePolicyRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*CreatePolicyRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*CreatePolicyRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_dataflow_63b5ce1c78fcbb67, []int{6}
}</span>
func (m *CreatePolicyRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_CreatePolicyRequest.Unmarshal(m, b)
}</span>
func (m *CreatePolicyRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_CreatePolicyRequest.Marshal(b, m, deterministic)
}</span>
func (dst *CreatePolicyRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_CreatePolicyRequest.Merge(dst, src)
}</span>
func (m *CreatePolicyRequest) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_CreatePolicyRequest.Size(m)
}</span>
func (m *CreatePolicyRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_CreatePolicyRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_CreatePolicyRequest proto.InternalMessageInfo

func (m *CreatePolicyRequest) GetPolicy() *Policy <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Policy
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type CreatePolicyResponse struct {
        Err                  string   `protobuf:"bytes,1,opt,name=err,proto3" json:"err,omitempty"`
        Policy               *Policy  `protobuf:"bytes,2,opt,name=policy,proto3" json:"policy,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *CreatePolicyResponse) Reset()         <span class="cov0" title="0">{ *m = CreatePolicyResponse{} }</span>
func (m *CreatePolicyResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*CreatePolicyResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*CreatePolicyResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_dataflow_63b5ce1c78fcbb67, []int{7}
}</span>
func (m *CreatePolicyResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_CreatePolicyResponse.Unmarshal(m, b)
}</span>
func (m *CreatePolicyResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_CreatePolicyResponse.Marshal(b, m, deterministic)
}</span>
func (dst *CreatePolicyResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_CreatePolicyResponse.Merge(dst, src)
}</span>
func (m *CreatePolicyResponse) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_CreatePolicyResponse.Size(m)
}</span>
func (m *CreatePolicyResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_CreatePolicyResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_CreatePolicyResponse proto.InternalMessageInfo

func (m *CreatePolicyResponse) GetErr() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Err
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *CreatePolicyResponse) GetPolicy() *Policy <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Policy
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type UpdatePolicyRequest struct {
        PolicyId             string   `protobuf:"bytes,1,opt,name=policyId,proto3" json:"policyId,omitempty"`
        Body                 string   `protobuf:"bytes,2,opt,name=body,proto3" json:"body,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *UpdatePolicyRequest) Reset()         <span class="cov0" title="0">{ *m = UpdatePolicyRequest{} }</span>
func (m *UpdatePolicyRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*UpdatePolicyRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*UpdatePolicyRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_dataflow_63b5ce1c78fcbb67, []int{8}
}</span>
func (m *UpdatePolicyRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_UpdatePolicyRequest.Unmarshal(m, b)
}</span>
func (m *UpdatePolicyRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_UpdatePolicyRequest.Marshal(b, m, deterministic)
}</span>
func (dst *UpdatePolicyRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_UpdatePolicyRequest.Merge(dst, src)
}</span>
func (m *UpdatePolicyRequest) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_UpdatePolicyRequest.Size(m)
}</span>
func (m *UpdatePolicyRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_UpdatePolicyRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_UpdatePolicyRequest proto.InternalMessageInfo

func (m *UpdatePolicyRequest) GetPolicyId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.PolicyId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *UpdatePolicyRequest) GetBody() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Body
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type UpdatePolicyResponse struct {
        Err                  string   `protobuf:"bytes,1,opt,name=err,proto3" json:"err,omitempty"`
        Policy               *Policy  `protobuf:"bytes,2,opt,name=policy,proto3" json:"policy,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *UpdatePolicyResponse) Reset()         <span class="cov0" title="0">{ *m = UpdatePolicyResponse{} }</span>
func (m *UpdatePolicyResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*UpdatePolicyResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*UpdatePolicyResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_dataflow_63b5ce1c78fcbb67, []int{9}
}</span>
func (m *UpdatePolicyResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_UpdatePolicyResponse.Unmarshal(m, b)
}</span>
func (m *UpdatePolicyResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_UpdatePolicyResponse.Marshal(b, m, deterministic)
}</span>
func (dst *UpdatePolicyResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_UpdatePolicyResponse.Merge(dst, src)
}</span>
func (m *UpdatePolicyResponse) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_UpdatePolicyResponse.Size(m)
}</span>
func (m *UpdatePolicyResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_UpdatePolicyResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_UpdatePolicyResponse proto.InternalMessageInfo

func (m *UpdatePolicyResponse) GetErr() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Err
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *UpdatePolicyResponse) GetPolicy() *Policy <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Policy
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type DeletePolicyRequest struct {
        Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *DeletePolicyRequest) Reset()         <span class="cov0" title="0">{ *m = DeletePolicyRequest{} }</span>
func (m *DeletePolicyRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*DeletePolicyRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*DeletePolicyRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_dataflow_63b5ce1c78fcbb67, []int{10}
}</span>
func (m *DeletePolicyRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_DeletePolicyRequest.Unmarshal(m, b)
}</span>
func (m *DeletePolicyRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_DeletePolicyRequest.Marshal(b, m, deterministic)
}</span>
func (dst *DeletePolicyRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_DeletePolicyRequest.Merge(dst, src)
}</span>
func (m *DeletePolicyRequest) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_DeletePolicyRequest.Size(m)
}</span>
func (m *DeletePolicyRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_DeletePolicyRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_DeletePolicyRequest proto.InternalMessageInfo

func (m *DeletePolicyRequest) GetId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type DeletePolicyResponse struct {
        Err                  string   `protobuf:"bytes,1,opt,name=err,proto3" json:"err,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *DeletePolicyResponse) Reset()         <span class="cov0" title="0">{ *m = DeletePolicyResponse{} }</span>
func (m *DeletePolicyResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*DeletePolicyResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*DeletePolicyResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_dataflow_63b5ce1c78fcbb67, []int{11}
}</span>
func (m *DeletePolicyResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_DeletePolicyResponse.Unmarshal(m, b)
}</span>
func (m *DeletePolicyResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_DeletePolicyResponse.Marshal(b, m, deterministic)
}</span>
func (dst *DeletePolicyResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_DeletePolicyResponse.Merge(dst, src)
}</span>
func (m *DeletePolicyResponse) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_DeletePolicyResponse.Size(m)
}</span>
func (m *DeletePolicyResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_DeletePolicyResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_DeletePolicyResponse proto.InternalMessageInfo

func (m *DeletePolicyResponse) GetErr() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Err
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type KV struct {
        Key                  string   `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
        Value                string   `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *KV) Reset()         <span class="cov0" title="0">{ *m = KV{} }</span>
func (m *KV) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*KV) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*KV) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_dataflow_63b5ce1c78fcbb67, []int{12}
}</span>
func (m *KV) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_KV.Unmarshal(m, b)
}</span>
func (m *KV) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_KV.Marshal(b, m, deterministic)
}</span>
func (dst *KV) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_KV.Merge(dst, src)
}</span>
func (m *KV) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_KV.Size(m)
}</span>
func (m *KV) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_KV.DiscardUnknown(m)
}</span>

var xxx_messageInfo_KV proto.InternalMessageInfo

func (m *KV) GetKey() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Key
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *KV) GetValue() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Value
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type Filter struct {
        Prefix               string   `protobuf:"bytes,1,opt,name=prefix,proto3" json:"prefix,omitempty"`
        Tag                  []*KV    `protobuf:"bytes,2,rep,name=tag,proto3" json:"tag,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *Filter) Reset()         <span class="cov0" title="0">{ *m = Filter{} }</span>
func (m *Filter) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*Filter) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*Filter) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_dataflow_63b5ce1c78fcbb67, []int{13}
}</span>
func (m *Filter) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_Filter.Unmarshal(m, b)
}</span>
func (m *Filter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_Filter.Marshal(b, m, deterministic)
}</span>
func (dst *Filter) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_Filter.Merge(dst, src)
}</span>
func (m *Filter) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_Filter.Size(m)
}</span>
func (m *Filter) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_Filter.DiscardUnknown(m)
}</span>

var xxx_messageInfo_Filter proto.InternalMessageInfo

func (m *Filter) GetPrefix() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Prefix
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Filter) GetTag() []*KV <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Tag
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type Connector struct {
        StorType             string   `protobuf:"bytes,1,opt,name=storType,proto3" json:"storType,omitempty"`
        BucketName           string   `protobuf:"bytes,2,opt,name=bucketName,proto3" json:"bucketName,omitempty"`
        ConnConfig           []*KV    `protobuf:"bytes,3,rep,name=connConfig,proto3" json:"connConfig,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *Connector) Reset()         <span class="cov0" title="0">{ *m = Connector{} }</span>
func (m *Connector) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*Connector) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*Connector) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_dataflow_63b5ce1c78fcbb67, []int{14}
}</span>
func (m *Connector) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_Connector.Unmarshal(m, b)
}</span>
func (m *Connector) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_Connector.Marshal(b, m, deterministic)
}</span>
func (dst *Connector) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_Connector.Merge(dst, src)
}</span>
func (m *Connector) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_Connector.Size(m)
}</span>
func (m *Connector) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_Connector.DiscardUnknown(m)
}</span>

var xxx_messageInfo_Connector proto.InternalMessageInfo

func (m *Connector) GetStorType() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.StorType
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Connector) GetBucketName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.BucketName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Connector) GetConnConfig() []*KV <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ConnConfig
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type Plan struct {
        Id                   string     `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
        Name                 string     `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
        Description          string     `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
        Type                 string     `protobuf:"bytes,4,opt,name=type,proto3" json:"type,omitempty"`
        PolicyId             string     `protobuf:"bytes,5,opt,name=policyId,proto3" json:"policyId,omitempty"`
        PolicyName           string     `protobuf:"bytes,6,opt,name=policyName,proto3" json:"policyName,omitempty"`
        SourceConn           *Connector `protobuf:"bytes,7,opt,name=sourceConn,proto3" json:"sourceConn,omitempty"`
        DestConn             *Connector `protobuf:"bytes,8,opt,name=destConn,proto3" json:"destConn,omitempty"`
        Filter               *Filter    `protobuf:"bytes,9,opt,name=filter,proto3" json:"filter,omitempty"`
        RemainSource         bool       `protobuf:"varint,10,opt,name=remainSource,proto3" json:"remainSource,omitempty"`
        TenantId             string     `protobuf:"bytes,11,opt,name=tenantId,proto3" json:"tenantId,omitempty"`
        UserId               string     `protobuf:"bytes,12,opt,name=userId,proto3" json:"userId,omitempty"`
        PolicyEnabled        bool       `protobuf:"varint,13,opt,name=policyEnabled,proto3" json:"policyEnabled,omitempty"`
        XXX_NoUnkeyedLiteral struct{}   `json:"-"`
        XXX_unrecognized     []byte     `json:"-"`
        XXX_sizecache        int32      `json:"-"`
}

func (m *Plan) Reset()         <span class="cov0" title="0">{ *m = Plan{} }</span>
func (m *Plan) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*Plan) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*Plan) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_dataflow_63b5ce1c78fcbb67, []int{15}
}</span>
func (m *Plan) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_Plan.Unmarshal(m, b)
}</span>
func (m *Plan) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_Plan.Marshal(b, m, deterministic)
}</span>
func (dst *Plan) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_Plan.Merge(dst, src)
}</span>
func (m *Plan) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_Plan.Size(m)
}</span>
func (m *Plan) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_Plan.DiscardUnknown(m)
}</span>

var xxx_messageInfo_Plan proto.InternalMessageInfo

func (m *Plan) GetId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Plan) GetName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Plan) GetDescription() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Description
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Plan) GetType() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Type
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Plan) GetPolicyId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.PolicyId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Plan) GetPolicyName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.PolicyName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Plan) GetSourceConn() *Connector <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.SourceConn
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *Plan) GetDestConn() *Connector <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.DestConn
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *Plan) GetFilter() *Filter <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Filter
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *Plan) GetRemainSource() bool <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.RemainSource
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (m *Plan) GetTenantId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.TenantId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Plan) GetUserId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.UserId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Plan) GetPolicyEnabled() bool <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.PolicyEnabled
        }</span>
        <span class="cov0" title="0">return false</span>
}

type CreatePlanRequest struct {
        Plan                 *Plan    `protobuf:"bytes,1,opt,name=plan,proto3" json:"plan,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *CreatePlanRequest) Reset()         <span class="cov0" title="0">{ *m = CreatePlanRequest{} }</span>
func (m *CreatePlanRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*CreatePlanRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*CreatePlanRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_dataflow_63b5ce1c78fcbb67, []int{16}
}</span>
func (m *CreatePlanRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_CreatePlanRequest.Unmarshal(m, b)
}</span>
func (m *CreatePlanRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_CreatePlanRequest.Marshal(b, m, deterministic)
}</span>
func (dst *CreatePlanRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_CreatePlanRequest.Merge(dst, src)
}</span>
func (m *CreatePlanRequest) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_CreatePlanRequest.Size(m)
}</span>
func (m *CreatePlanRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_CreatePlanRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_CreatePlanRequest proto.InternalMessageInfo

func (m *CreatePlanRequest) GetPlan() *Plan <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Plan
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type CreatePlanResponse struct {
        Err                  string   `protobuf:"bytes,1,opt,name=err,proto3" json:"err,omitempty"`
        Plan                 *Plan    `protobuf:"bytes,2,opt,name=plan,proto3" json:"plan,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *CreatePlanResponse) Reset()         <span class="cov0" title="0">{ *m = CreatePlanResponse{} }</span>
func (m *CreatePlanResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*CreatePlanResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*CreatePlanResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_dataflow_63b5ce1c78fcbb67, []int{17}
}</span>
func (m *CreatePlanResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_CreatePlanResponse.Unmarshal(m, b)
}</span>
func (m *CreatePlanResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_CreatePlanResponse.Marshal(b, m, deterministic)
}</span>
func (dst *CreatePlanResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_CreatePlanResponse.Merge(dst, src)
}</span>
func (m *CreatePlanResponse) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_CreatePlanResponse.Size(m)
}</span>
func (m *CreatePlanResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_CreatePlanResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_CreatePlanResponse proto.InternalMessageInfo

func (m *CreatePlanResponse) GetErr() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Err
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *CreatePlanResponse) GetPlan() *Plan <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Plan
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type GetPlanRequest struct {
        Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *GetPlanRequest) Reset()         <span class="cov0" title="0">{ *m = GetPlanRequest{} }</span>
func (m *GetPlanRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*GetPlanRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*GetPlanRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_dataflow_63b5ce1c78fcbb67, []int{18}
}</span>
func (m *GetPlanRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_GetPlanRequest.Unmarshal(m, b)
}</span>
func (m *GetPlanRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_GetPlanRequest.Marshal(b, m, deterministic)
}</span>
func (dst *GetPlanRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_GetPlanRequest.Merge(dst, src)
}</span>
func (m *GetPlanRequest) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_GetPlanRequest.Size(m)
}</span>
func (m *GetPlanRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_GetPlanRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_GetPlanRequest proto.InternalMessageInfo

func (m *GetPlanRequest) GetId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type GetPlanResponse struct {
        Err                  string   `protobuf:"bytes,1,opt,name=err,proto3" json:"err,omitempty"`
        Plan                 *Plan    `protobuf:"bytes,2,opt,name=plan,proto3" json:"plan,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *GetPlanResponse) Reset()         <span class="cov0" title="0">{ *m = GetPlanResponse{} }</span>
func (m *GetPlanResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*GetPlanResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*GetPlanResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_dataflow_63b5ce1c78fcbb67, []int{19}
}</span>
func (m *GetPlanResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_GetPlanResponse.Unmarshal(m, b)
}</span>
func (m *GetPlanResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_GetPlanResponse.Marshal(b, m, deterministic)
}</span>
func (dst *GetPlanResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_GetPlanResponse.Merge(dst, src)
}</span>
func (m *GetPlanResponse) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_GetPlanResponse.Size(m)
}</span>
func (m *GetPlanResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_GetPlanResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_GetPlanResponse proto.InternalMessageInfo

func (m *GetPlanResponse) GetErr() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Err
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *GetPlanResponse) GetPlan() *Plan <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Plan
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type ListPlanRequest struct {
        Limit                int32             `protobuf:"varint,1,opt,name=limit,proto3" json:"limit,omitempty"`
        Offset               int32             `protobuf:"varint,2,opt,name=offset,proto3" json:"offset,omitempty"`
        SortKeys             []string          `protobuf:"bytes,3,rep,name=sortKeys,proto3" json:"sortKeys,omitempty"`
        SortDirs             []string          `protobuf:"bytes,4,rep,name=sortDirs,proto3" json:"sortDirs,omitempty"`
        Filter               map[string]string `protobuf:"bytes,5,rep,name=Filter,proto3" json:"Filter,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
        XXX_NoUnkeyedLiteral struct{}          `json:"-"`
        XXX_unrecognized     []byte            `json:"-"`
        XXX_sizecache        int32             `json:"-"`
}

func (m *ListPlanRequest) Reset()         <span class="cov0" title="0">{ *m = ListPlanRequest{} }</span>
func (m *ListPlanRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*ListPlanRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*ListPlanRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_dataflow_63b5ce1c78fcbb67, []int{20}
}</span>
func (m *ListPlanRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_ListPlanRequest.Unmarshal(m, b)
}</span>
func (m *ListPlanRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_ListPlanRequest.Marshal(b, m, deterministic)
}</span>
func (dst *ListPlanRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_ListPlanRequest.Merge(dst, src)
}</span>
func (m *ListPlanRequest) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_ListPlanRequest.Size(m)
}</span>
func (m *ListPlanRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_ListPlanRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_ListPlanRequest proto.InternalMessageInfo

func (m *ListPlanRequest) GetLimit() int32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Limit
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *ListPlanRequest) GetOffset() int32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Offset
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *ListPlanRequest) GetSortKeys() []string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.SortKeys
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *ListPlanRequest) GetSortDirs() []string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.SortDirs
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *ListPlanRequest) GetFilter() map[string]string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Filter
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type ListPlanResponse struct {
        Plans                []*Plan  `protobuf:"bytes,1,rep,name=plans,proto3" json:"plans,omitempty"`
        Next                 int32    `protobuf:"varint,2,opt,name=next,proto3" json:"next,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *ListPlanResponse) Reset()         <span class="cov0" title="0">{ *m = ListPlanResponse{} }</span>
func (m *ListPlanResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*ListPlanResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*ListPlanResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_dataflow_63b5ce1c78fcbb67, []int{21}
}</span>
func (m *ListPlanResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_ListPlanResponse.Unmarshal(m, b)
}</span>
func (m *ListPlanResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_ListPlanResponse.Marshal(b, m, deterministic)
}</span>
func (dst *ListPlanResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_ListPlanResponse.Merge(dst, src)
}</span>
func (m *ListPlanResponse) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_ListPlanResponse.Size(m)
}</span>
func (m *ListPlanResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_ListPlanResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_ListPlanResponse proto.InternalMessageInfo

func (m *ListPlanResponse) GetPlans() []*Plan <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Plans
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *ListPlanResponse) GetNext() int32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Next
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type UpdatePlanRequest struct {
        PlanId               string   `protobuf:"bytes,1,opt,name=planId,proto3" json:"planId,omitempty"`
        Body                 string   `protobuf:"bytes,2,opt,name=body,proto3" json:"body,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *UpdatePlanRequest) Reset()         <span class="cov0" title="0">{ *m = UpdatePlanRequest{} }</span>
func (m *UpdatePlanRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*UpdatePlanRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*UpdatePlanRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_dataflow_63b5ce1c78fcbb67, []int{22}
}</span>
func (m *UpdatePlanRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_UpdatePlanRequest.Unmarshal(m, b)
}</span>
func (m *UpdatePlanRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_UpdatePlanRequest.Marshal(b, m, deterministic)
}</span>
func (dst *UpdatePlanRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_UpdatePlanRequest.Merge(dst, src)
}</span>
func (m *UpdatePlanRequest) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_UpdatePlanRequest.Size(m)
}</span>
func (m *UpdatePlanRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_UpdatePlanRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_UpdatePlanRequest proto.InternalMessageInfo

func (m *UpdatePlanRequest) GetPlanId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.PlanId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *UpdatePlanRequest) GetBody() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Body
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type UpdatePlanResponse struct {
        Err                  string   `protobuf:"bytes,1,opt,name=err,proto3" json:"err,omitempty"`
        Plan                 *Plan    `protobuf:"bytes,2,opt,name=plan,proto3" json:"plan,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *UpdatePlanResponse) Reset()         <span class="cov0" title="0">{ *m = UpdatePlanResponse{} }</span>
func (m *UpdatePlanResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*UpdatePlanResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*UpdatePlanResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_dataflow_63b5ce1c78fcbb67, []int{23}
}</span>
func (m *UpdatePlanResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_UpdatePlanResponse.Unmarshal(m, b)
}</span>
func (m *UpdatePlanResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_UpdatePlanResponse.Marshal(b, m, deterministic)
}</span>
func (dst *UpdatePlanResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_UpdatePlanResponse.Merge(dst, src)
}</span>
func (m *UpdatePlanResponse) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_UpdatePlanResponse.Size(m)
}</span>
func (m *UpdatePlanResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_UpdatePlanResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_UpdatePlanResponse proto.InternalMessageInfo

func (m *UpdatePlanResponse) GetErr() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Err
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *UpdatePlanResponse) GetPlan() *Plan <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Plan
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type DeletePlanRequest struct {
        Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *DeletePlanRequest) Reset()         <span class="cov0" title="0">{ *m = DeletePlanRequest{} }</span>
func (m *DeletePlanRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*DeletePlanRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*DeletePlanRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_dataflow_63b5ce1c78fcbb67, []int{24}
}</span>
func (m *DeletePlanRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_DeletePlanRequest.Unmarshal(m, b)
}</span>
func (m *DeletePlanRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_DeletePlanRequest.Marshal(b, m, deterministic)
}</span>
func (dst *DeletePlanRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_DeletePlanRequest.Merge(dst, src)
}</span>
func (m *DeletePlanRequest) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_DeletePlanRequest.Size(m)
}</span>
func (m *DeletePlanRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_DeletePlanRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_DeletePlanRequest proto.InternalMessageInfo

func (m *DeletePlanRequest) GetId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type DeletePlanResponse struct {
        Err                  string   `protobuf:"bytes,1,opt,name=err,proto3" json:"err,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *DeletePlanResponse) Reset()         <span class="cov0" title="0">{ *m = DeletePlanResponse{} }</span>
func (m *DeletePlanResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*DeletePlanResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*DeletePlanResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_dataflow_63b5ce1c78fcbb67, []int{25}
}</span>
func (m *DeletePlanResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_DeletePlanResponse.Unmarshal(m, b)
}</span>
func (m *DeletePlanResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_DeletePlanResponse.Marshal(b, m, deterministic)
}</span>
func (dst *DeletePlanResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_DeletePlanResponse.Merge(dst, src)
}</span>
func (m *DeletePlanResponse) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_DeletePlanResponse.Size(m)
}</span>
func (m *DeletePlanResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_DeletePlanResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_DeletePlanResponse proto.InternalMessageInfo

func (m *DeletePlanResponse) GetErr() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Err
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type RunPlanRequest struct {
        Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *RunPlanRequest) Reset()         <span class="cov0" title="0">{ *m = RunPlanRequest{} }</span>
func (m *RunPlanRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*RunPlanRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*RunPlanRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_dataflow_63b5ce1c78fcbb67, []int{26}
}</span>
func (m *RunPlanRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_RunPlanRequest.Unmarshal(m, b)
}</span>
func (m *RunPlanRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_RunPlanRequest.Marshal(b, m, deterministic)
}</span>
func (dst *RunPlanRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_RunPlanRequest.Merge(dst, src)
}</span>
func (m *RunPlanRequest) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_RunPlanRequest.Size(m)
}</span>
func (m *RunPlanRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_RunPlanRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_RunPlanRequest proto.InternalMessageInfo

func (m *RunPlanRequest) GetId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type RunPlanResponse struct {
        Err                  string   `protobuf:"bytes,1,opt,name=err,proto3" json:"err,omitempty"`
        JobId                string   `protobuf:"bytes,2,opt,name=jobId,proto3" json:"jobId,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *RunPlanResponse) Reset()         <span class="cov0" title="0">{ *m = RunPlanResponse{} }</span>
func (m *RunPlanResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*RunPlanResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*RunPlanResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_dataflow_63b5ce1c78fcbb67, []int{27}
}</span>
func (m *RunPlanResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_RunPlanResponse.Unmarshal(m, b)
}</span>
func (m *RunPlanResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_RunPlanResponse.Marshal(b, m, deterministic)
}</span>
func (dst *RunPlanResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_RunPlanResponse.Merge(dst, src)
}</span>
func (m *RunPlanResponse) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_RunPlanResponse.Size(m)
}</span>
func (m *RunPlanResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_RunPlanResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_RunPlanResponse proto.InternalMessageInfo

func (m *RunPlanResponse) GetErr() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Err
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *RunPlanResponse) GetJobId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.JobId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type Job struct {
        Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
        TenantId             string   `protobuf:"bytes,2,opt,name=tenantId,proto3" json:"tenantId,omitempty"`
        UserId               string   `protobuf:"bytes,3,opt,name=userId,proto3" json:"userId,omitempty"`
        Type                 string   `protobuf:"bytes,4,opt,name=type,proto3" json:"type,omitempty"`
        PlanName             string   `protobuf:"bytes,5,opt,name=planName,proto3" json:"planName,omitempty"`
        PlanId               string   `protobuf:"bytes,6,opt,name=planId,proto3" json:"planId,omitempty"`
        Description          string   `protobuf:"bytes,7,opt,name=description,proto3" json:"description,omitempty"`
        SourceLocation       string   `protobuf:"bytes,8,opt,name=sourceLocation,proto3" json:"sourceLocation,omitempty"`
        DestLocation         string   `protobuf:"bytes,9,opt,name=destLocation,proto3" json:"destLocation,omitempty"`
        Status               string   `protobuf:"bytes,10,opt,name=status,proto3" json:"status,omitempty"`
        CreateTime           int64    `protobuf:"varint,11,opt,name=createTime,proto3" json:"createTime,omitempty"`
        StartTime            int64    `protobuf:"varint,12,opt,name=startTime,proto3" json:"startTime,omitempty"`
        EndTime              int64    `protobuf:"varint,13,opt,name=endTime,proto3" json:"endTime,omitempty"`
        RemainSource         bool     `protobuf:"varint,14,opt,name=remainSource,proto3" json:"remainSource,omitempty"`
        TotalCapacity        int64    `protobuf:"varint,15,opt,name=totalCapacity,proto3" json:"totalCapacity,omitempty"`
        PassedCapacity       int64    `protobuf:"varint,16,opt,name=passedCapacity,proto3" json:"passedCapacity,omitempty"`
        TotalCount           int64    `protobuf:"varint,17,opt,name=totalCount,proto3" json:"totalCount,omitempty"`
        PassedCount          int64    `protobuf:"varint,18,opt,name=passedCount,proto3" json:"passedCount,omitempty"`
        Progress             int64    `protobuf:"varint,19,opt,name=progress,proto3" json:"progress,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *Job) Reset()         <span class="cov0" title="0">{ *m = Job{} }</span>
func (m *Job) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*Job) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*Job) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_dataflow_63b5ce1c78fcbb67, []int{28}
}</span>
func (m *Job) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_Job.Unmarshal(m, b)
}</span>
func (m *Job) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_Job.Marshal(b, m, deterministic)
}</span>
func (dst *Job) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_Job.Merge(dst, src)
}</span>
func (m *Job) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_Job.Size(m)
}</span>
func (m *Job) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_Job.DiscardUnknown(m)
}</span>

var xxx_messageInfo_Job proto.InternalMessageInfo

func (m *Job) GetId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Job) GetTenantId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.TenantId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Job) GetUserId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.UserId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Job) GetType() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Type
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Job) GetPlanName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.PlanName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Job) GetPlanId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.PlanId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Job) GetDescription() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Description
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Job) GetSourceLocation() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.SourceLocation
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Job) GetDestLocation() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.DestLocation
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Job) GetStatus() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Status
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Job) GetCreateTime() int64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.CreateTime
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *Job) GetStartTime() int64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.StartTime
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *Job) GetEndTime() int64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.EndTime
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *Job) GetRemainSource() bool <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.RemainSource
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (m *Job) GetTotalCapacity() int64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.TotalCapacity
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *Job) GetPassedCapacity() int64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.PassedCapacity
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *Job) GetTotalCount() int64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.TotalCount
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *Job) GetPassedCount() int64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.PassedCount
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *Job) GetProgress() int64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Progress
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type GetJobRequest struct {
        Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *GetJobRequest) Reset()         <span class="cov0" title="0">{ *m = GetJobRequest{} }</span>
func (m *GetJobRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*GetJobRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*GetJobRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_dataflow_63b5ce1c78fcbb67, []int{29}
}</span>
func (m *GetJobRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_GetJobRequest.Unmarshal(m, b)
}</span>
func (m *GetJobRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_GetJobRequest.Marshal(b, m, deterministic)
}</span>
func (dst *GetJobRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_GetJobRequest.Merge(dst, src)
}</span>
func (m *GetJobRequest) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_GetJobRequest.Size(m)
}</span>
func (m *GetJobRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_GetJobRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_GetJobRequest proto.InternalMessageInfo

func (m *GetJobRequest) GetId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type GetJobResponse struct {
        Err                  string   `protobuf:"bytes,1,opt,name=err,proto3" json:"err,omitempty"`
        Job                  *Job     `protobuf:"bytes,2,opt,name=job,proto3" json:"job,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *GetJobResponse) Reset()         <span class="cov0" title="0">{ *m = GetJobResponse{} }</span>
func (m *GetJobResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*GetJobResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*GetJobResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_dataflow_63b5ce1c78fcbb67, []int{30}
}</span>
func (m *GetJobResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_GetJobResponse.Unmarshal(m, b)
}</span>
func (m *GetJobResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_GetJobResponse.Marshal(b, m, deterministic)
}</span>
func (dst *GetJobResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_GetJobResponse.Merge(dst, src)
}</span>
func (m *GetJobResponse) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_GetJobResponse.Size(m)
}</span>
func (m *GetJobResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_GetJobResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_GetJobResponse proto.InternalMessageInfo

func (m *GetJobResponse) GetErr() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Err
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *GetJobResponse) GetJob() *Job <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Job
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type ListJobRequest struct {
        Limit                int32             `protobuf:"varint,1,opt,name=limit,proto3" json:"limit,omitempty"`
        Offset               int32             `protobuf:"varint,2,opt,name=offset,proto3" json:"offset,omitempty"`
        SortKeys             []string          `protobuf:"bytes,3,rep,name=sortKeys,proto3" json:"sortKeys,omitempty"`
        SortDirs             []string          `protobuf:"bytes,4,rep,name=sortDirs,proto3" json:"sortDirs,omitempty"`
        Filter               map[string]string `protobuf:"bytes,5,rep,name=Filter,proto3" json:"Filter,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
        XXX_NoUnkeyedLiteral struct{}          `json:"-"`
        XXX_unrecognized     []byte            `json:"-"`
        XXX_sizecache        int32             `json:"-"`
}

func (m *ListJobRequest) Reset()         <span class="cov0" title="0">{ *m = ListJobRequest{} }</span>
func (m *ListJobRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*ListJobRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*ListJobRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_dataflow_63b5ce1c78fcbb67, []int{31}
}</span>
func (m *ListJobRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_ListJobRequest.Unmarshal(m, b)
}</span>
func (m *ListJobRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_ListJobRequest.Marshal(b, m, deterministic)
}</span>
func (dst *ListJobRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_ListJobRequest.Merge(dst, src)
}</span>
func (m *ListJobRequest) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_ListJobRequest.Size(m)
}</span>
func (m *ListJobRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_ListJobRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_ListJobRequest proto.InternalMessageInfo

func (m *ListJobRequest) GetLimit() int32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Limit
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *ListJobRequest) GetOffset() int32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Offset
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *ListJobRequest) GetSortKeys() []string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.SortKeys
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *ListJobRequest) GetSortDirs() []string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.SortDirs
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *ListJobRequest) GetFilter() map[string]string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Filter
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type ListJobResponse struct {
        Jobs                 []*Job   `protobuf:"bytes,1,rep,name=jobs,proto3" json:"jobs,omitempty"`
        Next                 int32    `protobuf:"varint,2,opt,name=next,proto3" json:"next,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *ListJobResponse) Reset()         <span class="cov0" title="0">{ *m = ListJobResponse{} }</span>
func (m *ListJobResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*ListJobResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*ListJobResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_dataflow_63b5ce1c78fcbb67, []int{32}
}</span>
func (m *ListJobResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_ListJobResponse.Unmarshal(m, b)
}</span>
func (m *ListJobResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_ListJobResponse.Marshal(b, m, deterministic)
}</span>
func (dst *ListJobResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_ListJobResponse.Merge(dst, src)
}</span>
func (m *ListJobResponse) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_ListJobResponse.Size(m)
}</span>
func (m *ListJobResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_ListJobResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_ListJobResponse proto.InternalMessageInfo

func (m *ListJobResponse) GetJobs() []*Job <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Jobs
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *ListJobResponse) GetNext() int32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Next
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func init() <span class="cov8" title="1">{
        proto.RegisterType((*Schedule)(nil), "Schedule")
        proto.RegisterType((*Policy)(nil), "Policy")
        proto.RegisterType((*GetPolicyRequest)(nil), "GetPolicyRequest")
        proto.RegisterType((*GetPolicyResponse)(nil), "GetPolicyResponse")
        proto.RegisterType((*ListPolicyRequest)(nil), "ListPolicyRequest")
        proto.RegisterType((*ListPolicyResponse)(nil), "ListPolicyResponse")
        proto.RegisterType((*CreatePolicyRequest)(nil), "CreatePolicyRequest")
        proto.RegisterType((*CreatePolicyResponse)(nil), "CreatePolicyResponse")
        proto.RegisterType((*UpdatePolicyRequest)(nil), "UpdatePolicyRequest")
        proto.RegisterType((*UpdatePolicyResponse)(nil), "UpdatePolicyResponse")
        proto.RegisterType((*DeletePolicyRequest)(nil), "DeletePolicyRequest")
        proto.RegisterType((*DeletePolicyResponse)(nil), "DeletePolicyResponse")
        proto.RegisterType((*KV)(nil), "KV")
        proto.RegisterType((*Filter)(nil), "Filter")
        proto.RegisterType((*Connector)(nil), "Connector")
        proto.RegisterType((*Plan)(nil), "Plan")
        proto.RegisterType((*CreatePlanRequest)(nil), "CreatePlanRequest")
        proto.RegisterType((*CreatePlanResponse)(nil), "CreatePlanResponse")
        proto.RegisterType((*GetPlanRequest)(nil), "GetPlanRequest")
        proto.RegisterType((*GetPlanResponse)(nil), "GetPlanResponse")
        proto.RegisterType((*ListPlanRequest)(nil), "ListPlanRequest")
        proto.RegisterMapType((map[string]string)(nil), "ListPlanRequest.FilterEntry")
        proto.RegisterType((*ListPlanResponse)(nil), "ListPlanResponse")
        proto.RegisterType((*UpdatePlanRequest)(nil), "UpdatePlanRequest")
        proto.RegisterType((*UpdatePlanResponse)(nil), "UpdatePlanResponse")
        proto.RegisterType((*DeletePlanRequest)(nil), "DeletePlanRequest")
        proto.RegisterType((*DeletePlanResponse)(nil), "DeletePlanResponse")
        proto.RegisterType((*RunPlanRequest)(nil), "RunPlanRequest")
        proto.RegisterType((*RunPlanResponse)(nil), "RunPlanResponse")
        proto.RegisterType((*Job)(nil), "Job")
        proto.RegisterType((*GetJobRequest)(nil), "GetJobRequest")
        proto.RegisterType((*GetJobResponse)(nil), "GetJobResponse")
        proto.RegisterType((*ListJobRequest)(nil), "ListJobRequest")
        proto.RegisterMapType((map[string]string)(nil), "ListJobRequest.FilterEntry")
        proto.RegisterType((*ListJobResponse)(nil), "ListJobResponse")
}</span>

func init() <span class="cov8" title="1">{ proto.RegisterFile("dataflow.proto", fileDescriptor_dataflow_63b5ce1c78fcbb67) }</span>

var fileDescriptor_dataflow_63b5ce1c78fcbb67 = []byte{
        // 1295 bytes of a gzipped FileDescriptorProto
        0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x57, 0xe9, 0x6e, 0xdb, 0x46,
        0x10, 0xb6, 0x4e, 0x4b, 0x63, 0x5b, 0xc7, 0x48, 0x0e, 0x58, 0x26, 0x48, 0x84, 0xcd, 0x01, 0x23,
        0x2d, 0x16, 0x68, 0x12, 0x34, 0x4d, 0x80, 0x36, 0x08, 0x9c, 0x03, 0x8e, 0x83, 0x22, 0x60, 0xd2,
        0xfc, 0xa7, 0xc4, 0x95, 0xcb, 0x98, 0xe6, 0xaa, 0xe4, 0xaa, 0x89, 0x9e, 0xa2, 0x8f, 0x54, 0xf4,
        0x11, 0xfa, 0x12, 0x45, 0x1f, 0xa3, 0xd8, 0x83, 0xd4, 0x92, 0x94, 0x82, 0xc2, 0x08, 0xfa, 0x8f,
        0x73, 0xec, 0xec, 0xcc, 0xec, 0xcc, 0x37, 0x43, 0xe8, 0x05, 0xbe, 0xf0, 0xe7, 0x11, 0xff, 0x48,
        0x17, 0x09, 0x17, 0x9c, 0xbc, 0x82, 0xce, 0xdb, 0xd9, 0x2f, 0x2c, 0x58, 0x46, 0x0c, 0x11, 0x9a,
        0x62, 0xb5, 0x60, 0x4e, 0x6d, 0x52, 0x3b, 0xea, 0x7a, 0xea, 0x1b, 0xef, 0xc2, 0x40, 0x84, 0x67,
        0x67, 0x2c, 0x79, 0x93, 0xf0, 0x05, 0x4b, 0x44, 0xc8, 0x52, 0xa7, 0xae, 0xe4, 0x15, 0x3e, 0xf9,
        0xb3, 0x06, 0xed, 0x37, 0x3c, 0x0a, 0x67, 0x2b, 0xec, 0x41, 0x3d, 0x0c, 0x8c, 0xa1, 0x7a, 0x18,
        0xa0, 0x0b, 0x1d, 0xc1, 0x62, 0x3f, 0x16, 0x27, 0x81, 0x39, 0x9e, 0xd3, 0x78, 0x05, 0xda, 0xcb,
        0x94, 0x25, 0x27, 0x81, 0xd3, 0x50, 0x12, 0x43, 0x49, 0x77, 0x62, 0xff, 0x82, 0x39, 0x4d, 0xed,
        0x8e, 0xfc, 0x96, 0xba, 0xfa, 0x9c, 0xd3, 0xd2, 0xba, 0x9a, 0xc2, 0x09, 0xec, 0x05, 0x2c, 0x9d,
        0x25, 0xe1, 0x42, 0x84, 0x3c, 0x76, 0xda, 0x4a, 0x68, 0xb3, 0xf0, 0x36, 0x74, 0x52, 0x13, 0xa8,
        0xb3, 0x3b, 0xa9, 0x1d, 0xed, 0xdd, 0xeb, 0xd2, 0x2c, 0x72, 0x2f, 0x17, 0x11, 0x02, 0x83, 0x97,
        0x4c, 0xe8, 0x28, 0x3c, 0xf6, 0xeb, 0x92, 0xa5, 0xa2, 0x1c, 0x0c, 0x79, 0x01, 0x43, 0x4b, 0x27,
        0x5d, 0xf0, 0x38, 0x65, 0x38, 0x80, 0x06, 0x4b, 0x12, 0xa3, 0x25, 0x3f, 0xf1, 0x06, 0xb4, 0x17,
        0x4a, 0x47, 0x45, 0xbc, 0x77, 0x6f, 0x97, 0x9a, 0x23, 0x86, 0x4d, 0x46, 0x30, 0x7c, 0x1d, 0xa6,
        0xc5, 0xcb, 0xc8, 0x29, 0xa0, 0xcd, 0xdc, 0x6a, 0xfd, 0x26, 0x74, 0x94, 0x19, 0xfd, 0x20, 0x0d,
        0xdb, 0x7e, 0x2e, 0x20, 0xdf, 0xc1, 0xe8, 0x38, 0x61, 0xbe, 0x60, 0xc5, 0x80, 0xd6, 0x9e, 0xd5,
        0x36, 0x7b, 0x76, 0x02, 0xe3, 0xe2, 0xb9, 0xcb, 0x07, 0xf9, 0x1c, 0x46, 0x3f, 0x2f, 0x82, 0x8a,
        0x0b, 0xae, 0x71, 0x7f, 0x75, 0x92, 0x65, 0x36, 0xa7, 0xe5, 0xc3, 0x4f, 0x79, 0xb0, 0x32, 0x85,
        0xa2, 0xbe, 0xa5, 0x47, 0x45, 0x33, 0x97, 0xf7, 0xe8, 0x36, 0x8c, 0x9e, 0xb1, 0x88, 0x95, 0x3d,
        0x2a, 0xbf, 0xf2, 0x11, 0x8c, 0x8b, 0x6a, 0xdb, 0x6e, 0x24, 0xdf, 0x40, 0xfd, 0xf4, 0xbd, 0xe4,
        0x9f, 0xb3, 0x55, 0xc6, 0x3f, 0x67, 0x2b, 0x1c, 0x43, 0xeb, 0x37, 0x3f, 0x5a, 0x32, 0x13, 0x88,
        0x26, 0xc8, 0x43, 0x68, 0xbf, 0x08, 0x23, 0xc1, 0x12, 0x59, 0xcc, 0x8b, 0x84, 0xcd, 0xc3, 0x4f,
        0xe6, 0x90, 0xa1, 0xf0, 0x10, 0x1a, 0xc2, 0x3f, 0x33, 0xaf, 0xda, 0xa0, 0xa7, 0xef, 0x3d, 0x49,
        0x93, 0x08, 0xba, 0xc7, 0x3c, 0x8e, 0xd9, 0x4c, 0xf0, 0x44, 0xe6, 0x2f, 0x15, 0x3c, 0x79, 0xb7,
        0xee, 0xd7, 0x9c, 0xc6, 0xeb, 0x00, 0xd3, 0xe5, 0xec, 0x9c, 0x89, 0x9f, 0x64, 0xfb, 0xe8, 0xcb,
        0x2d, 0x0e, 0xde, 0x04, 0x98, 0xf1, 0x38, 0x3e, 0xe6, 0xf1, 0x3c, 0x3c, 0x73, 0x1a, 0xeb, 0x6b,
        0x2c, 0x36, 0xf9, 0xbd, 0x01, 0xcd, 0x37, 0x91, 0x1f, 0x57, 0x5a, 0x39, 0x6b, 0xcb, 0xba, 0xd5,
        0x96, 0xa5, 0xf6, 0x6b, 0x54, 0xdb, 0x2f, 0xc3, 0x96, 0xa6, 0x85, 0x2d, 0x76, 0x0d, 0xb4, 0x4a,
        0x35, 0x70, 0x1d, 0x40, 0x7f, 0xab, 0x18, 0x74, 0x3f, 0x5b, 0x1c, 0xbc, 0x0b, 0x90, 0xf2, 0x65,
        0x32, 0x63, 0x32, 0x25, 0xa6, 0xa1, 0x81, 0xe6, 0xf9, 0xf1, 0x2c, 0x29, 0xde, 0x81, 0x4e, 0xc0,
        0x52, 0xa1, 0x34, 0x3b, 0x15, 0xcd, 0x5c, 0x26, 0x2b, 0x67, 0xae, 0x5e, 0xc6, 0xe9, 0x9a, 0xca,
        0xd1, 0x0f, 0xe5, 0x19, 0x36, 0x12, 0xd8, 0x4f, 0xd8, 0x85, 0x1f, 0xc6, 0x6f, 0x95, 0x71, 0x07,
        0x26, 0xb5, 0xa3, 0x8e, 0x57, 0xe0, 0x15, 0x90, 0x6e, 0x6f, 0x2b, 0xd2, 0xed, 0x17, 0x90, 0xee,
        0x16, 0x1c, 0xe8, 0xd0, 0x9e, 0xc7, 0xfe, 0x34, 0x62, 0x81, 0x73, 0xa0, 0x0c, 0x17, 0x99, 0x84,
        0xc2, 0xd0, 0x34, 0x65, 0xe4, 0xc7, 0x59, 0xd5, 0x7e, 0x05, 0xcd, 0x45, 0xe4, 0xc7, 0xa6, 0x91,
        0x5b, 0x54, 0xc9, 0x14, 0x8b, 0x3c, 0x05, 0xb4, 0xf5, 0xb7, 0x36, 0x4c, 0x66, 0xa2, 0x5e, 0x35,
        0x31, 0x81, 0x9e, 0x44, 0x3a, 0xeb, 0xbe, 0x72, 0x97, 0xfc, 0x08, 0xfd, 0x5c, 0xe3, 0x32, 0x37,
        0xfc, 0x53, 0x83, 0xbe, 0xc2, 0x3b, 0xeb, 0x8e, 0x31, 0xb4, 0xa2, 0xf0, 0x22, 0x14, 0xca, 0x44,
        0xcb, 0xd3, 0x84, 0x4c, 0x1e, 0x9f, 0xcf, 0x53, 0x26, 0x94, 0x99, 0x96, 0x67, 0x28, 0xd5, 0x09,
        0x3c, 0x11, 0xa7, 0x6c, 0x95, 0xaa, 0x5a, 0x96, 0x9d, 0x60, 0xe8, 0x4c, 0xf6, 0x2c, 0x4c, 0x52,
        0xa7, 0xb9, 0x96, 0x49, 0x1a, 0x1f, 0x64, 0x7d, 0xe8, 0xb4, 0x54, 0x07, 0x5c, 0xa3, 0x25, 0x3f,
        0xcc, 0xeb, 0x3f, 0x8f, 0x45, 0xb2, 0xf2, 0x8c, 0xae, 0xfb, 0x08, 0xf6, 0x2c, 0xf6, 0x7f, 0x6d,
        0xfa, 0xc7, 0xf5, 0xef, 0x6b, 0xe4, 0x18, 0x06, 0xeb, 0x1b, 0x4c, 0xae, 0xae, 0x42, 0x4b, 0xa6,
        0x21, 0x75, 0x6a, 0xca, 0x07, 0x93, 0x1a, 0xcd, 0x53, 0x9d, 0xc6, 0x3e, 0x65, 0xf1, 0xaa, 0x6f,
        0xf2, 0x04, 0x86, 0x06, 0x07, 0xad, 0x84, 0x49, 0x20, 0x89, 0xfc, 0x38, 0x87, 0x52, 0x43, 0x6d,
        0x04, 0xd2, 0xa7, 0x80, 0xb6, 0x81, 0xcb, 0xbc, 0xd9, 0x4d, 0x18, 0x1a, 0x64, 0xfc, 0x4c, 0x61,
        0xdc, 0x01, 0xb4, 0x95, 0xb6, 0x82, 0xe7, 0x04, 0x7a, 0xde, 0x32, 0xfe, 0x9c, 0xa5, 0x47, 0xd0,
        0xcf, 0x35, 0xb6, 0xba, 0x3b, 0x86, 0xd6, 0x07, 0x3e, 0xcd, 0xb7, 0x0b, 0x4d, 0x90, 0x3f, 0x9a,
        0xd0, 0x78, 0xc5, 0xa7, 0x5f, 0x6a, 0x1d, 0xd9, 0x88, 0x60, 0x91, 0x1f, 0x2b, 0x8c, 0xca, 0x10,
        0xcc, 0xd0, 0xd6, 0xa3, 0xb4, 0x0b, 0x8f, 0x52, 0xc2, 0xca, 0xdd, 0x2a, 0x56, 0xde, 0x81, 0x9e,
        0x46, 0xaf, 0xd7, 0x7c, 0xe6, 0x2b, 0xa5, 0x8e, 0x52, 0x2a, 0x71, 0x25, 0x1c, 0x49, 0xec, 0xca,
        0xb5, 0xba, 0x4a, 0xab, 0xc0, 0x93, 0x5e, 0xa4, 0xc2, 0x17, 0xcb, 0x54, 0x81, 0x55, 0xd7, 0x33,
        0x94, 0xc4, 0xd7, 0x99, 0x02, 0x87, 0x77, 0xe1, 0x05, 0x53, 0x40, 0xd5, 0xf0, 0x2c, 0x0e, 0x5e,
        0x83, 0x6e, 0x2a, 0xfc, 0x44, 0x28, 0xf1, 0xbe, 0x12, 0xaf, 0x19, 0xe8, 0xc0, 0x2e, 0x8b, 0x03,
        0x25, 0x3b, 0x50, 0xb2, 0x8c, 0xac, 0x40, 0x64, 0x6f, 0x03, 0x44, 0xde, 0x82, 0x03, 0xc1, 0x85,
        0x1f, 0x1d, 0xfb, 0x0b, 0x7f, 0x16, 0x8a, 0x95, 0xd3, 0x57, 0x36, 0x8a, 0x4c, 0x99, 0x85, 0x85,
        0x9f, 0xa6, 0x2c, 0xc8, 0xd5, 0x06, 0x4a, 0xad, 0xc4, 0x95, 0x91, 0xe8, 0x83, 0x7c, 0x19, 0x0b,
        0x67, 0xa8, 0x23, 0x59, 0x73, 0x64, 0xbe, 0xcd, 0x09, 0xa5, 0x80, 0x4a, 0xc1, 0x66, 0xa9, 0x57,
        0x4c, 0xf8, 0x59, 0xc2, 0xd2, 0xd4, 0x19, 0x29, 0x71, 0x4e, 0x93, 0x1b, 0x70, 0xf0, 0x92, 0x89,
        0x57, 0x7c, 0xba, 0xad, 0x3a, 0x1f, 0x2b, 0x88, 0x54, 0x0a, 0x5b, 0x8b, 0xf3, 0x0a, 0x34, 0x3e,
        0xf0, 0xa9, 0x69, 0xa5, 0x26, 0x95, 0xca, 0x92, 0x41, 0xfe, 0xae, 0x41, 0x4f, 0x42, 0x82, 0x65,
        0xfe, 0xff, 0xc1, 0xbe, 0xfb, 0x25, 0xec, 0xbb, 0x4a, 0x8b, 0x6e, 0x7c, 0x69, 0xe8, 0x7b, 0xa2,
        0x41, 0xde, 0xce, 0x92, 0x03, 0xcd, 0x0f, 0x7c, 0x9a, 0x01, 0x9f, 0x4e, 0x8a, 0xe2, 0x6c, 0x82,
        0xbd, 0x7b, 0x7f, 0xb5, 0xa0, 0xf3, 0xcc, 0x17, 0xfe, 0x8b, 0x88, 0x7f, 0xc4, 0x07, 0xd0, 0xcd,
        0xf7, 0x6f, 0x1c, 0xd2, 0xf2, 0xbe, 0xee, 0x22, 0xad, 0xac, 0xe7, 0x64, 0x07, 0x1f, 0x02, 0xac,
        0x17, 0x6b, 0x44, 0x5a, 0x59, 0xbd, 0xdd, 0x11, 0xad, 0x6e, 0xde, 0x64, 0x07, 0x7f, 0x80, 0x7d,
        0x7b, 0x19, 0xc6, 0x31, 0xdd, 0xb0, 0x53, 0xbb, 0x87, 0x74, 0xd3, 0xc6, 0xac, 0x8f, 0xdb, 0x9b,
        0x2b, 0x8e, 0xe9, 0x86, 0x7d, 0xd8, 0x3d, 0xa4, 0x9b, 0xd6, 0x5b, 0x7d, 0xdc, 0x5e, 0x43, 0x71,
        0x4c, 0x37, 0x2c, 0xaf, 0xee, 0x21, 0xdd, 0xb4, 0xab, 0x92, 0x1d, 0xa4, 0xb0, 0x6b, 0xe6, 0x33,
        0xf6, 0x69, 0x71, 0x96, 0xbb, 0x03, 0x5a, 0x1a, 0xdd, 0x64, 0x07, 0xbf, 0x85, 0x4e, 0x36, 0xa4,
        0x70, 0x50, 0x9e, 0x88, 0xee, 0x90, 0x96, 0x27, 0x98, 0x4e, 0xec, 0x7a, 0xcf, 0x40, 0xa4, 0x95,
        0x25, 0xc5, 0x1d, 0xd1, 0xea, 0x22, 0xa2, 0x0f, 0xae, 0x47, 0x11, 0x22, 0xad, 0x0c, 0x36, 0x77,
        0x44, 0xab, 0xb3, 0x4a, 0x1f, 0x5c, 0xcf, 0x16, 0x44, 0x5a, 0x99, 0x46, 0xee, 0x88, 0x56, 0x87,
        0x0f, 0xd9, 0xc1, 0xaf, 0xa1, 0xad, 0x9b, 0x15, 0x7b, 0xb4, 0xd0, 0xd6, 0x6e, 0x9f, 0x16, 0xbb,
        0x58, 0xa7, 0xce, 0x14, 0x2d, 0xf6, 0x4b, 0xfd, 0xe1, 0x0e, 0x68, 0xa9, 0x9e, 0xb5, 0xbe, 0x99,
        0x53, 0xd8, 0xa7, 0xc5, 0x99, 0xe6, 0x0e, 0x68, 0x69, 0x84, 0x91, 0x9d, 0x69, 0x5b, 0xfd, 0x81,
        0xdf, 0xff, 0x37, 0x00, 0x00, 0xff, 0xff, 0x7d, 0xe7, 0xed, 0xfe, 0x93, 0x0f, 0x00, 0x00,
}
</pre>
		
		<pre class="file" id="file78" style="display: none">/*
 * Minio Cloud Storage, (C) 2015 Minio, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package s3error

import (
        "net/http"
)

type S3Error interface {
        error
        AwsErrorCode() string
        Description() string
        HttpStatusCode() int
}

type S3ErrorStruct struct {
        AwsErrorCode   string
        Description    string
        HttpStatusCode int
}

// APIErrorCode type of error status.
type S3ErrorCode int

// Error codes, non exhaustive list - http://docs.aws.amazon.com/AmazonS3/latest/API/ErrorResponses.html
const (
        ErrNoErr S3ErrorCode = iota
        ErrAccessDenied
        ErrBadDigest
        ErrBucketAlreadyExists
        ErrEmptyEntity
        ErrEntityTooLarge
        ErrIncompleteBody
        ErrInternalError
        ErrInvalidAccessKeyID
        ErrInvalidBucketName
        ErrInvalidObjectName
        ErrInvalidDigest
        ErrInvalidRange
        ErrInvalidEncodingType
        ErrInvalidContinuationToken
        ErrInvalidMaxKeys
        ErrInvalidMaxUploads
        ErrInvalidMaxParts
        ErrInvalidPartNumberMarker
        ErrInvalidRequestBody
        ErrInvalidCopySource
        ErrInvalidCopySourceStorageClass
        ErrInvalidCopyDest
        ErrInvalidPrecondition
        ErrInvalidPolicyDocument
        ErrInvalidCorsDocument
        ErrInvalidVersioning
        ErrMalformedXML
        ErrMissingContentLength
        ErrMissingContentMD5
        ErrMissingRequestBodyError
        ErrNoSuchBucket
        ErrNoSuchBucketPolicy
        ErrNoSuchKey
        ErrNoSuchUpload
        ErrNoSuchVersion
        ErrNotImplemented
        ErrPreconditionFailed
        ErrRequestTimeTooSkewed
        ErrSignatureDoesNotMatch
        ErrMethodNotAllowed
        ErrInvalidPart
        ErrInvalidPartOrder
        ErrAuthorizationHeaderMalformed
        ErrMalformedPOSTRequest
        ErrSignatureVersionNotSupported
        ErrBucketNotEmpty
        ErrBucketAccessForbidden
        ErrMalformedPolicy
        ErrMissingFields
        ErrMissingCredTag
        ErrCredMalformed
        ErrInvalidRegion
        ErrInvalidService
        ErrInvalidRequestVersion
        ErrMissingSignTag
        ErrMissingSignHeadersTag
        ErrMissingRequiredSignedHeader
        ErrSignedHeadersNotSorted
        ErrPolicyAlreadyExpired
        ErrPolicyViolation
        ErrMalformedDate
        ErrMalformedExpires
        ErrAuthHeaderEmpty
        ErrExpiredPresignRequest
        ErrMissingDateHeader
        ErrInvalidQuerySignatureAlgo
        ErrInvalidQueryParams
        ErrBucketAlreadyOwnedByYou
        ErrInvalidCannedAcl
        ErrInvalidSseHeader
        ErrTooManyBuckets
        ErrInvalidPosition
        ErrObjectNotAppendable
        ErrPositionNotEqualToLength
        // Add new error codes here.

        // SSE-S3 related API errors
        ErrInvalidEncryptionMethod

        // Server-Side-Encryption (with Customer provided key) related API errors.
        ErrInsecureSSECustomerRequest
        ErrSSEMultipartEncrypted
        ErrSSEEncryptedObject
        ErrInvalidEncryptionParameters
        ErrInvalidSSECustomerAlgorithm
        ErrInvalidSSECustomerKey
        ErrMissingSSECustomerKey
        ErrMissingSSECustomerKeyMD5
        ErrSSECustomerKeyMD5Mismatch
        ErrInvalidSSECustomerParameters
        ErrIncompatibleEncryptionMethod
        ErrKMSNotConfigured
        ErrKMSAuthFailure

        // S3 extended errors.
        ErrContentSHA256Mismatch
        // Add new extended error codes here.

        // Add new extended error codes here.
        ContentNotModified // actually not an error
        ErrInvalidHeader   // supplementary error for golang http lib
        ErrNoSuchBucketCors
        ErrPolicyMissingFields
        ErrInvalidAcl
        ErrUnsupportedAcl
        ErrNonUTF8Encode
        ErrInvalidLc
        ErrNoSuchBucketLc
        ErrInvalidStorageClass
        ErrPutToBackendFailed
        ErrGetFromBackendFailed
        ErrDeleteFromBackendFailed
        ErrBackendInitMultipartFailed
        ErrBackendCompleteMultipartFailed
        ErrBackendAbortMultipartFailed
        ErrGetBackendFailed
        ErrUnmarshalFailed
        ErrGetBucketFailed
        ErrDBError
)

// error code to APIError structure, these fields carry respective
// descriptions for all the error responses.
var ErrorCodeResponse = map[S3ErrorCode]S3ErrorStruct{
        ErrNoErr: {
                AwsErrorCode:   "OK",
                Description:    "OK",
                HttpStatusCode: http.StatusOK,
        },
        ErrInvalidCopyDest: {
                AwsErrorCode:   "InvalidRequest",
                Description:    "This copy request is illegal because it is trying to copy an object to itself.",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrInvalidCopySource: {
                AwsErrorCode:   "InvalidArgument",
                Description:    "Copy Source must mention the source bucket and key: sourcebucket/sourcekey.",
                HttpStatusCode: http.StatusBadRequest,
        },

        ErrInvalidCopySourceStorageClass: {
                AwsErrorCode:   "InvalidCopySourceStorageClass",
                Description:    "Storage class of copy source cannot be GLACIER or DEEP_ARCHIVE.",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrInvalidPrecondition: {
                AwsErrorCode:   "InvalidArgument",
                Description:    "The provided preconditions are not valid(bad time format, rule combination, etc)",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrInvalidRequestBody: {
                AwsErrorCode:   "InvalidArgument",
                Description:    "Body shouldn't be set for this request.",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrInvalidEncodingType: {
                AwsErrorCode:   "InvalidEncodingType",
                Description:    "The encoding type you provided is not allowed.",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrInvalidContinuationToken: {
                AwsErrorCode:   "ErrInvalidContinuationToken",
                Description:    "The continuation token you provided is invalid.",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrInvalidMaxUploads: {
                AwsErrorCode:   "InvalidArgument",
                Description:    "Argument max-uploads must be an integer between 1 and 1000",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrInvalidMaxKeys: {
                AwsErrorCode:   "InvalidArgument",
                Description:    "Argument maxKeys must be an integer between 1 and 1000",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrInvalidMaxParts: {
                AwsErrorCode:   "InvalidArgument",
                Description:    "Argument max-parts must be an integer between 1 and 1000",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrInvalidPartNumberMarker: {
                AwsErrorCode:   "InvalidArgument",
                Description:    "Argument partNumberMarker must be an integer.",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrInvalidPolicyDocument: {
                AwsErrorCode:   "InvalidPolicyDocument",
                Description:    "The content of the form does not meet the conditions specified in the policy document.",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrInvalidCorsDocument: {
                AwsErrorCode:   "InvalidCorsDocument",
                Description:    "The CORS XML you provided is invalid",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrInvalidVersioning: {
                AwsErrorCode:   "IllegalVersioningConfigurationException",
                Description:    "The versioning configuration specified in the request is invalid.",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrAccessDenied: {
                AwsErrorCode:   "AccessDenied",
                Description:    "Access Denied.",
                HttpStatusCode: http.StatusForbidden,
        },
        ErrBadDigest: {
                AwsErrorCode:   "BadDigest",
                Description:    "The Content-Md5 you specified did not match what we received.",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrBucketAlreadyExists: {
                AwsErrorCode:   "BucketAlreadyExists",
                Description:    "The requested bucket name is not available.",
                HttpStatusCode: http.StatusConflict,
        },
        ErrEmptyEntity: {
                AwsErrorCode:   "EmptyEntity",
                Description:    "Your upload does not include a valid object",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrEntityTooLarge: {
                AwsErrorCode:   "EntityTooLarge",
                Description:    "Your proposed upload exceeds the maximum allowed object size.",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrIncompleteBody: {
                AwsErrorCode:   "IncompleteBody",
                Description:    "You did not provide the number of bytes specified by the Content-Length HTTP header.",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrInternalError: {
                AwsErrorCode:   "InternalError",
                Description:    "We encountered an internal error, please try again.",
                HttpStatusCode: http.StatusInternalServerError,
        },
        ErrInvalidAccessKeyID: {
                AwsErrorCode:   "InvalidAccessKeyId",
                Description:    "The access key ID you provided does not exist in our records.",
                HttpStatusCode: http.StatusForbidden,
        },
        ErrInvalidBucketName: {
                AwsErrorCode:   "InvalidBucketName",
                Description:    "The specified bucket name is not valid.",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrInvalidObjectName: {
                AwsErrorCode:   "InvalidObjectName",
                Description:    "The specified object name is not valid",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrInvalidDigest: {
                AwsErrorCode:   "InvalidDigest",
                Description:    "The Content-Md5 you specified is not valid.",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrInvalidRange: {
                AwsErrorCode:   "InvalidRange",
                Description:    "The requested range is not satisfiable",
                HttpStatusCode: http.StatusRequestedRangeNotSatisfiable,
        },
        ErrMalformedXML: {
                AwsErrorCode:   "MalformedXML",
                Description:    "The XML you provided was not well-formed or did not validate against our published schema.",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrMissingContentLength: {
                AwsErrorCode:   "MissingContentLength",
                Description:    "You must provide the Content-Length HTTP header.",
                HttpStatusCode: http.StatusLengthRequired,
        },
        ErrMissingContentMD5: {
                AwsErrorCode:   "MissingContentMD5",
                Description:    "Missing required header for this request: Content-Md5.",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrMissingRequestBodyError: {
                AwsErrorCode:   "MissingRequestBodyError",
                Description:    "Request body is empty.",
                HttpStatusCode: http.StatusLengthRequired,
        },
        ErrNoSuchBucket: {
                AwsErrorCode:   "NoSuchBucket",
                Description:    "The specified bucket does not exist",
                HttpStatusCode: http.StatusNotFound,
        },
        ErrNoSuchBucketPolicy: {
                AwsErrorCode:   "NoSuchBucketPolicy",
                Description:    "The specified bucket does not have a bucket policy.",
                HttpStatusCode: http.StatusNotFound,
        },
        ErrNoSuchKey: {
                AwsErrorCode:   "NoSuchKey",
                Description:    "The specified key does not exist.",
                HttpStatusCode: http.StatusNotFound,
        },
        ErrNoSuchUpload: {
                AwsErrorCode:   "NoSuchUpload",
                Description:    "The specified multipart upload does not exist.",
                HttpStatusCode: http.StatusNotFound,
        },
        ErrNoSuchVersion: {
                AwsErrorCode:   "NoSuchVersion",
                Description:    "The version ID specified in the request does not match an existing version.",
                HttpStatusCode: http.StatusNotFound,
        },
        ErrNotImplemented: {
                AwsErrorCode:   "NotImplemented",
                Description:    "A header you provided implies functionality that is not implemented",
                HttpStatusCode: http.StatusNotImplemented,
        },
        ErrPreconditionFailed: {
                AwsErrorCode:   "PreconditionFailed",
                Description:    "At least one of the pre-conditions you specified did not hold",
                HttpStatusCode: http.StatusPreconditionFailed,
        },
        ErrRequestTimeTooSkewed: {
                AwsErrorCode:   "RequestTimeTooSkewed",
                Description:    "The difference between the request time and the server's time is too large.",
                HttpStatusCode: http.StatusForbidden,
        },
        ErrSignatureDoesNotMatch: {
                AwsErrorCode:   "SignatureDoesNotMatch",
                Description:    "The request signature we calculated does not match the signature you provided. Check your key and signing method.",
                HttpStatusCode: http.StatusForbidden,
        },
        ErrMethodNotAllowed: {
                AwsErrorCode:   "MethodNotAllowed",
                Description:    "The specified method is not allowed against this resource.",
                HttpStatusCode: http.StatusMethodNotAllowed,
        },
        ErrInvalidPart: {
                AwsErrorCode:   "InvalidPart",
                Description:    "One or more of the specified parts could not be found. The part might not have been uploaded, or the specified entity tag might not have matched the part's entity tag.",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrInvalidPartOrder: {
                AwsErrorCode:   "InvalidPartOrder",
                Description:    "The list of parts was not in ascending order. The parts list must be specified in order by part number.",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrAuthorizationHeaderMalformed: {
                AwsErrorCode:   "AuthorizationHeaderMalformed",
                Description:    "The authorization header is malformed.",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrMalformedPOSTRequest: {
                AwsErrorCode:   "MalformedPOSTRequest",
                Description:    "The body of your POST request is not well-formed multipart/form-data.",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrSignatureVersionNotSupported: {
                AwsErrorCode:   "AccessDenied",
                Description:    "The authorization mechanism you have provided is not supported. Please use AWS4-HMAC-SHA256.",
                HttpStatusCode: http.StatusForbidden,
        },
        ErrBucketNotEmpty: {
                AwsErrorCode:   "BucketNotEmpty",
                Description:    "The bucket you tried to delete is not empty.",
                HttpStatusCode: http.StatusConflict,
        },
        ErrBucketAccessForbidden: {
                AwsErrorCode:   "AccessDenied",
                Description:    "You have no access to this bucket.",
                HttpStatusCode: http.StatusForbidden,
        },
        ErrMalformedPolicy: {
                AwsErrorCode:   "MalformedPolicy",
                Description:    "Policy has invalid resource.",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrMissingFields: {
                AwsErrorCode:   "MissingFields",
                Description:    "Missing fields in request.",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrMissingCredTag: {
                AwsErrorCode:   "InvalidRequest",
                Description:    "Missing Credential field for this request.",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrCredMalformed: {
                AwsErrorCode:   "CredentialMalformed",
                Description:    "Credential field does not follow accessKeyID/credentialScope.",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrMalformedDate: {
                AwsErrorCode:   "MalformedDate",
                Description:    "Invalid date format header, expected to be in ISO8601, RFC1123 or RFC1123Z time format.",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrInvalidRegion: {
                AwsErrorCode:   "InvalidRegion",
                Description:    "Region does not match.",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrInvalidService: {
                AwsErrorCode:   "AccessDenied",
                Description:    "Service scope should be of value 's3'.",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrInvalidRequestVersion: {
                AwsErrorCode:   "AccessDenied",
                Description:    "Request scope should be of value 'aws4_request'.",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrMissingSignTag: {
                AwsErrorCode:   "AccessDenied",
                Description:    "Signature header missing Signature field.",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrMissingSignHeadersTag: {
                AwsErrorCode:   "InvalidArgument",
                Description:    "Signature header missing SignedHeaders field.",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrMissingRequiredSignedHeader: {
                AwsErrorCode:   "InvalidArgument",
                Description:    "Missing one or more required signed header",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrSignedHeadersNotSorted: {
                AwsErrorCode:   "InvalidArgument",
                Description:    "Signed headers are not ordered",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrPolicyAlreadyExpired: {
                AwsErrorCode:   "AccessDenied",
                Description:    "Invalid according to Policy: Policy expired.",
                HttpStatusCode: http.StatusForbidden,
        },
        ErrPolicyViolation: {
                AwsErrorCode:   "AccessDenied",
                Description:    "File uploading policy violated.",
                HttpStatusCode: http.StatusForbidden,
        },
        ErrMalformedExpires: {
                AwsErrorCode:   "MalformedExpires",
                Description:    "Malformed expires value, should be between 1 and 604800(seven days)",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrAuthHeaderEmpty: {
                AwsErrorCode:   "InvalidArgument",
                Description:    "Authorization header is invalid -- one and only one ' ' (space) required.",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrMissingDateHeader: {
                AwsErrorCode:   "AccessDenied",
                Description:    "AWS authentication requires a valid Date or x-amz-date header",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrInvalidQuerySignatureAlgo: {
                AwsErrorCode:   "AuthorizationQueryParametersError",
                Description:    "X-Amz-Algorithm only supports \"AWS4-HMAC-SHA256\".",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrExpiredPresignRequest: {
                AwsErrorCode:   "ExpiredToken",
                Description:    "Request has expired.",
                HttpStatusCode: http.StatusForbidden,
        },
        ErrInvalidQueryParams: {
                AwsErrorCode:   "AuthorizationQueryParametersError",
                Description:    "Query-string authentication version 4 requires the X-Amz-Algorithm, X-Amz-Credential, X-Amz-Signature, X-Amz-Date, X-Amz-SignedHeaders, and X-Amz-Expires parameters.",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrBucketAlreadyOwnedByYou: {
                AwsErrorCode:   "BucketAlreadyOwnedByYou",
                Description:    "Your previous request to create the named bucket succeeded and you already own it.",
                HttpStatusCode: http.StatusConflict,
        },
        ErrTooManyBuckets: {
                AwsErrorCode:   "TooManyBuckets",
                Description:    "You have attempted to create more buckets than allowed.",
                HttpStatusCode: http.StatusBadRequest,
        },

        // SSE-S3 related API errors
        ErrInvalidEncryptionMethod: {
                AwsErrorCode:   "InvalidRequest",
                Description:    "The encryption method specified is not supported",
                HttpStatusCode: http.StatusBadRequest,
        },

        // Server-Side-Encryption (with Customer provided key) related API errors.
        ErrInsecureSSECustomerRequest: {
                AwsErrorCode:   "InvalidRequest",
                Description:    "Requests specifying Server Side Encryption with Customer provided keys must be made over a secure connection.",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrSSEMultipartEncrypted: {
                AwsErrorCode:   "InvalidRequest",
                Description:    "The multipart upload initiate requested encryption. Subsequent part requests must include the appropriate encryption parameters.",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrSSEEncryptedObject: {
                AwsErrorCode:   "InvalidRequest",
                Description:    "The object was stored using a form of Server Side Encryption. The correct parameters must be provided to retrieve the object.",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrInvalidEncryptionParameters: {
                AwsErrorCode:   "InvalidRequest",
                Description:    "The encryption parameters are not applicable to this object.",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrInvalidSSECustomerAlgorithm: {
                AwsErrorCode:   "InvalidArgument",
                Description:    "Requests specifying Server Side Encryption with Customer provided keys must provide a valid encryption algorithm.",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrInvalidSSECustomerKey: {
                AwsErrorCode:   "InvalidArgument",
                Description:    "The secret key was invalid for the specified algorithm.",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrMissingSSECustomerKey: {
                AwsErrorCode:   "InvalidArgument",
                Description:    "Requests specifying Server Side Encryption with Customer provided keys must provide an appropriate secret key.",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrMissingSSECustomerKeyMD5: {
                AwsErrorCode:   "InvalidArgument",
                Description:    "Requests specifying Server Side Encryption with Customer provided keys must provide the client calculated MD5 of the secret key.",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrSSECustomerKeyMD5Mismatch: {
                AwsErrorCode:   "InvalidArgument",
                Description:    "The calculated MD5 hash of the key did not match the hash that was provided.",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrInvalidSSECustomerParameters: {
                AwsErrorCode:   "InvalidArgument",
                Description:    "The provided encryption parameters did not match the ones used originally.",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrIncompatibleEncryptionMethod: {
                AwsErrorCode:   "InvalidArgument",
                Description:    "Server side encryption specified with both SSE-C and SSE-S3 headers",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrKMSNotConfigured: {
                AwsErrorCode:   "InvalidArgument",
                Description:    "Server side encryption specified but KMS is not configured",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrKMSAuthFailure: {
                AwsErrorCode:   "InvalidArgument",
                Description:    "Server side encryption specified but KMS authorization failed",
                HttpStatusCode: http.StatusBadRequest,
        },
        /// S3 extensions.
        ErrContentSHA256Mismatch: {
                AwsErrorCode:   "XAmzContentSHA256Mismatch",
                Description:    "The provided 'x-amz-content-sha256' header does not match what was computed.",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrInvalidCannedAcl: {
                AwsErrorCode:   "InvalidAcl",
                Description:    "The canned ACL you provided is not valid",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrInvalidSseHeader: {
                AwsErrorCode:   "InvalidSseHeader",
                Description:    "The Server-side Encryption configuration is corrupted or invalid",
                HttpStatusCode: http.StatusBadRequest,
        },

        ContentNotModified: { // FIXME: This is actually not an error
                AwsErrorCode:   "",
                Description:    "",
                HttpStatusCode: http.StatusNotModified,
        },
        ErrInvalidHeader: {
                AwsErrorCode:   "InvalidRequest",
                Description:    "This request is illegal because some header is malformed.",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrNoSuchBucketCors: {
                AwsErrorCode:   "NoSuchBucketCors",
                Description:    "The specified bucket does not have CORS configured.",
                HttpStatusCode: http.StatusNotFound,
        },
        ErrPolicyMissingFields: {
                AwsErrorCode:   "AccessDenied",
                Description:    "Missing policy condition",
                HttpStatusCode: http.StatusForbidden,
        },
        ErrInvalidAcl: {
                AwsErrorCode:   "IllegalAclConfigurationException",
                Description:    "The ACL configuration specified in the request is invalid.",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrUnsupportedAcl: {
                AwsErrorCode:   "UnsupportedAclConfigurationException",
                Description:    "The ACL configuration specified in the request is unsupported.",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrNonUTF8Encode: {
                AwsErrorCode:   "InvalidArgument",
                Description:    "URL Argument must be UTF8 encoded.",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrNoSuchBucketLc: {
                AwsErrorCode:   "NoSuchBucketLc",
                Description:    "The specified bucket does not have LifeCycle configured.",
                HttpStatusCode: http.StatusNotFound,
        },
        ErrInvalidLc: {
                AwsErrorCode:   "IllegalLcConfigurationException",
                Description:    "The LC configuration specified in the request is invalid.",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrInvalidPosition: {
                AwsErrorCode:   "InvalidPosition",
                Description:    "The argument position specified in the request must be non-negative integer.",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrObjectNotAppendable: {
                AwsErrorCode:   "ObjectNotAppendable",
                Description:    "Cannot perform an AppendObject operation on a non-Appendable Object.",
                HttpStatusCode: http.StatusConflict,
        },
        ErrPositionNotEqualToLength: {
                AwsErrorCode:   "PositionNotEqualToLength",
                Description:    "The value of position does not match the length of the current Object.",
                HttpStatusCode: http.StatusConflict,
        },
        ErrInvalidStorageClass: {
                AwsErrorCode:   "InvalidStorageClass",
                Description:    "The storage class you specified in header is invalid.",
                HttpStatusCode: http.StatusBadRequest,
        },
        ErrPutToBackendFailed: {
                AwsErrorCode:   "PutToBackendFailed",
                Description:    "Put object to backend failed.",
                HttpStatusCode: http.StatusInternalServerError,
        },
        ErrGetFromBackendFailed: {
                AwsErrorCode:   "GetFromBackendFailed",
                Description:    "Get object from backend failed.",
                HttpStatusCode: http.StatusInternalServerError,
        },
        ErrDeleteFromBackendFailed: {
                AwsErrorCode:   "DeleteFromBackendFailed",
                Description:    "Delete object from backend failed.",
                HttpStatusCode: http.StatusInternalServerError,
        },
        ErrBackendInitMultipartFailed: {
                AwsErrorCode:   "BackendInitMultipartFailed",
                Description:    "Backend init multipart upload failed.",
                HttpStatusCode: http.StatusInternalServerError,
        },
        ErrBackendCompleteMultipartFailed: {
                AwsErrorCode:   "BackendCompleteMultipartFailed",
                Description:    "Backend complete multipart upload failed.",
                HttpStatusCode: http.StatusInternalServerError,
        },
        ErrBackendAbortMultipartFailed: {
                AwsErrorCode:   "BackendAbortMultipartFailed",
                Description:    "Backend abort multipart upload failed.",
                HttpStatusCode: http.StatusInternalServerError,
        },
        ErrGetBackendFailed: {
                AwsErrorCode:   "GetBackendFailed",
                Description:    "Backend is not exist, or get it failed.",
                HttpStatusCode: http.StatusInternalServerError,
        },
        ErrUnmarshalFailed: {
                AwsErrorCode:   "UnmarshalFailed",
                Description:    "Unmarshal failed.",
                HttpStatusCode: http.StatusInternalServerError,
        },
        ErrGetBucketFailed: {
                AwsErrorCode:   "GetBucketFailed",
                Description:    "Bucket is not exist, or get it failed.",
                HttpStatusCode: http.StatusInternalServerError,
        },
        ErrDBError: {
                AwsErrorCode:   "InternalError",
                Description:    "DB error.",
                HttpStatusCode: http.StatusInternalServerError,
        },
}

func (e S3ErrorCode) AwsErrorCode() string <span class="cov8" title="1">{
        awsError, ok := ErrorCodeResponse[e]
        if !ok </span><span class="cov0" title="0">{
                return "InternalError"
        }</span>
        <span class="cov8" title="1">return awsError.AwsErrorCode</span>
}

func (e S3ErrorCode) Description() string <span class="cov8" title="1">{
        awsError, ok := ErrorCodeResponse[e]
        if !ok </span><span class="cov0" title="0">{
                return "We encountered an internal error, please try again."
        }</span>
        <span class="cov8" title="1">return awsError.Description</span>
}

func (e S3ErrorCode) Error() string <span class="cov0" title="0">{
        return e.Description()
}</span>

func (e S3ErrorCode) HttpStatusCode() int <span class="cov8" title="1">{
        awsError, ok := ErrorCodeResponse[e]
        if !ok </span><span class="cov0" title="0">{
                return http.StatusInternalServerError
        }</span>
        <span class="cov8" title="1">return awsError.HttpStatusCode</span>
}
</pre>
		
		<pre class="file" id="file79" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package _exception

import (
        "errors"
        "fmt"
)

type S3Error struct {
        Code        int
        Description string
}

func (err *S3Error) Error() error <span class="cov0" title="0">{
        s := fmt.Sprintf("{\"code\":\"%d\",\"message\":\"%s\"}", err.Code, err.Description)
        return errors.New(s)
}</span>

var ERR_OK = 200
var NoError = S3Error{Code: ERR_OK}
var InternalError = S3Error{Code: 500, Description: "Internal error. Please retry"}
var NoSuchBucket = S3Error{Code: 404, Description: "The specified bucket does not exist."}
var DBError = S3Error{Code: 500, Description: "DB occured exception."}
var NoSuchObject = S3Error{Code: 404, Description: "The specified object does not exist."}
var BucketAlreadyExists = S3Error{Code: 409, Description: "The requested bucket name already exist. Bucket namespace is shared by all users in the system. Select a different name and retry."}

var NoSuchBackend = S3Error{Code: 404, Description: "The specified backend does not exists."}
var NoSuchType = S3Error{Code: 404, Description: "The specified backend type does not exists."}
var BucketDeleteError = S3Error{Code: 500, Description: "The bucket can not be deleted. please delete object first"}
var BackendDeleteError = S3Error{Code: 500, Description: "The backend can not be deleted. please delete bucket first"}

var InvalidQueryParameter = S3Error{Code:400, Description:"invalid query parameter"}
var InvalidContentLength = S3Error{Code:400, Description:"invalid content length"}
var InvalidStorageClass = S3Error{Code: 400, Description: "the storage class you specified is not valid"}
var BadRequest = S3Error{Code:400, Description:"request is invalid"}
</pre>
		
		<pre class="file" id="file80" style="display: none">package helper

import (
        "fmt"
        "io/ioutil"
        "time"

        "github.com/BurntSushi/toml"
)

const (
        S3_CONF_PATH              = "/etc/multi-cloud/s3.toml"
        MIN_DOWNLOAD_BUFPOOL_SIZE = 512 &lt;&lt; 10 // 512k
        MAX_DOWNLOAD_BUFPOOL_SIZE = 8 &lt;&lt; 20   // 8M
)

type Config struct {
        S3Domain         []string                `toml:"s3domain"` // Domain name of YIG
        Region           string                  `toml:"region"`   // Region name this instance belongs to, e.g cn-bj-1
        Plugins          map[string]PluginConfig `toml:"plugins"`
        LogPath          string                  `toml:"log_path"`
        AccessLogPath    string                  `toml:"access_log_path"`
        AccessLogFormat  string                  `toml:"access_log_format"`
        PanicLogPath     string                  `toml:"panic_log_path"`
        PidFile          string                  `toml:"pid_file"`
        BindApiAddress   string                  `toml:"api_listener"`
        BindAdminAddress string                  `toml:"admin_listener"`
        SSLKeyPath       string                  `toml:"ssl_key_path"`
        SSLCertPath      string                  `toml:"ssl_cert_path"`
        ZookeeperAddress string                  `toml:"zk_address"`

        InstanceId             string // if empty, generated one at server startup
        ConcurrentRequestLimit int
        HbaseZnodeParent       string        // won't change default("/hbase") if leave this option empty
        HbaseTimeout           time.Duration // in seconds
        DebugMode              bool          `toml:"debug_mode"`
        AdminKey               string        `toml:"admin_key"` //used for tools/admin to communicate with yig
        GcThread               int           `toml:"gc_thread"`
        LcThread               int           //used for tools/lc only, set worker numbers to do lc
        LcDebug                bool          //used for tools/lc only, if this was set true, will treat days as seconds
        LogLevel               int           `toml:"log_level"` //1-20
        CephConfigPattern      string        `toml:"ceph_config_pattern"`
        ReservedOrigins        string        `toml:"reserved_origins"` // www.ccc.com,www.bbb.com,127.0.0.1
        MetaStore              string        `toml:"meta_store"`
        TidbInfo               string        `toml:"tidb_info"`
        KeepAlive              bool          `toml:"keepalive"`

        //About cache
        RedisAddress            string   `toml:"redis_address"`           // redis connection string, e.g localhost:1234
        RedisConnectionNumber   int      `toml:"redis_connection_number"` // number of connections to redis(i.e max concurrent request number)
        RedisPassword           string   `toml:"redis_password"`          // redis auth password
        MetaCacheType           int      `toml:"meta_cache_type"`
        EnableDataCache         bool     `toml:"enable_data_cache"`
        RedisMode               int      `toml:"redis_mode"`
        RedisNodes              []string `toml:"redis_nodes"`
        RedisSentinelMasterName string   `toml:"redis_sentinel_master_name"`
        RedisConnectTimeout     int      `toml:"redis_connect_timeout"`
        RedisReadTimeout        int      `toml:"redis_read_timeout"`
        RedisWriteTimeout       int      `toml:"redis_write_timeout"`
        RedisKeepAlive          int      `toml:"redis_keepalive"`
        RedisPoolMaxIdle        int      `toml:"redis_pool_max_idle"`
        RedisPoolIdleTimeout    int      `toml:"redis_pool_idle_timeout"`

        // If the value is not 0, the cached ping detection will be turned on, and the interval is the number of seconds.
        CacheCircuitCheckInterval int `toml:"cache_circuit_check_interval"`
        // This property sets the amount of seconds, after tripping the circuit,
        // to reject requests before allowing attempts again to determine if the circuit should again be closed.
        CacheCircuitCloseSleepWindow int `toml:"cache_circuit_close_sleep_window"`
        // This value is how may consecutive passing requests are required before the circuit is closed
        CacheCircuitCloseRequiredCount int `toml:"cache_circuit_close_required_count"`
        // This property sets the minimum number of requests in a rolling window that will trip the circuit.
        CacheCircuitOpenThreshold int `toml:"cache_circuit_open_threshold"`

        DownLoadBufPoolSize int `toml:"download_buf_pool_size"`

        KMS KMSConfig `toml:"kms"`

        // Message Bus
        MsgBus MsgBusConfig `toml:"msg_bus"`
}

type PluginConfig struct {
        Path   string                 `toml:"path"`
        Enable bool                   `toml:"enable"`
        Args   map[string]interface{} `toml:"args"`
}

type KMSConfig struct {
        Type     string
        Endpoint string
        Id       string `toml:"kms_id"`
        Secret   string `toml:"kms_secret"`
        Version  int
        Keyname  string
}

type MsgBusConfig struct {
        // Controls whether to enable message bus when receive the request.
        Enabled bool `toml:"msg_bus_enable"`
        // Controls the under implementation of message bus: 1 for kafka.
        Type int `toml:"msg_bus_type"`
        // Controls the message topic used by message bus.
        Topic string `toml:"msg_bus_topic"`
        // Controls the request timeout for sending a req through message bus.
        RequestTimeoutMs int `toml:"msg_bus_request_timeout_ms"`
        // Controls the total timeout for sending a req through message bus.
        // It will timeout if min(MessageTimeoutMs, SendMaxRetries * RequestTimeoutMs) meets.
        MessageTimeoutMs int `toml:"msg_bus_message_timeout_ms"`
        // Controls the retry time used by message bus if it fails to send a req.
        SendMaxRetries int `toml:"msg_bus_send_max_retries"`
        // Controls the settings for the implementation of message bus.
        // For kafka, the 'broker_list' must be set, like 'broker_list = "kafka:29092"'
        Server map[string]interface{} `toml:"msg_bus_server"`
}

var CONFIG Config

func SetupConfig() <span class="cov0" title="0">{
        MarshalTOMLConfig()
}</span>

func MarshalTOMLConfig() error <span class="cov0" title="0">{
        data, err := ioutil.ReadFile(S3_CONF_PATH)
        if err != nil </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        panic(fmt.Sprintf("failed to open %s, err: %v", S3_CONF_PATH, err))</span>
                }
        }

        <span class="cov0" title="0">fmt.Printf("config data: \n%s\n", string(data))
        var c Config
        _, err = toml.Decode(string(data), &amp;c)
        if err != nil </span><span class="cov0" title="0">{
                panic("load yig.toml error: " + err.Error())</span>
        }
        <span class="cov0" title="0">fmt.Printf("c: %+v\n", c)
        // setup CONFIG with defaults
        CONFIG.S3Domain = c.S3Domain
        CONFIG.Region = c.Region
        CONFIG.Plugins = c.Plugins
        CONFIG.LogPath = c.LogPath
        CONFIG.AccessLogPath = c.AccessLogPath
        CONFIG.AccessLogFormat = c.AccessLogFormat
        CONFIG.PanicLogPath = c.PanicLogPath
        CONFIG.PidFile = c.PidFile
        CONFIG.BindApiAddress = c.BindApiAddress
        CONFIG.BindAdminAddress = c.BindAdminAddress
        CONFIG.SSLKeyPath = c.SSLKeyPath
        CONFIG.SSLCertPath = c.SSLCertPath
        CONFIG.ZookeeperAddress = c.ZookeeperAddress
        CONFIG.DebugMode = c.DebugMode
        CONFIG.AdminKey = c.AdminKey
        CONFIG.LcDebug = c.LcDebug
        CONFIG.CephConfigPattern = c.CephConfigPattern
        CONFIG.ReservedOrigins = c.ReservedOrigins
        CONFIG.TidbInfo = c.TidbInfo
        CONFIG.KeepAlive = c.KeepAlive
        CONFIG.InstanceId = Ternary(c.InstanceId == "",
                string(GenerateRandomId()), c.InstanceId).(string)
        CONFIG.ConcurrentRequestLimit = Ternary(c.ConcurrentRequestLimit == 0,
                10000, c.ConcurrentRequestLimit).(int)
        CONFIG.HbaseZnodeParent = Ternary(c.HbaseZnodeParent == "",
                "/hbase", c.HbaseZnodeParent).(string)
        CONFIG.HbaseTimeout = Ternary(c.HbaseTimeout == 0, 30*time.Second,
                c.HbaseTimeout).(time.Duration)
        CONFIG.GcThread = Ternary(c.GcThread == 0,
                1, c.GcThread).(int)
        CONFIG.LcThread = Ternary(c.LcThread == 0,
                1, c.LcThread).(int)
        CONFIG.LogLevel = Ternary(c.LogLevel == 0, 5, c.LogLevel).(int)
        CONFIG.MetaStore = Ternary(c.MetaStore == "", "tidb", c.MetaStore).(string)

        CONFIG.RedisAddress = c.RedisAddress
        CONFIG.RedisPassword = c.RedisPassword
        CONFIG.RedisMode = c.RedisMode
        CONFIG.RedisNodes = c.RedisNodes
        CONFIG.RedisSentinelMasterName = c.RedisSentinelMasterName
        CONFIG.RedisConnectionNumber = Ternary(c.RedisConnectionNumber == 0,
                10, c.RedisConnectionNumber).(int)
        CONFIG.EnableDataCache = c.EnableDataCache
        CONFIG.MetaCacheType = c.MetaCacheType
        CONFIG.RedisConnectTimeout = Ternary(c.RedisConnectTimeout &lt; 0, 0, c.RedisConnectTimeout).(int)
        CONFIG.RedisReadTimeout = Ternary(c.RedisReadTimeout &lt; 0, 0, c.RedisReadTimeout).(int)
        CONFIG.RedisWriteTimeout = Ternary(c.RedisWriteTimeout &lt; 0, 0, c.RedisWriteTimeout).(int)
        CONFIG.RedisKeepAlive = Ternary(c.RedisKeepAlive &lt; 0, 0, c.RedisKeepAlive).(int)
        CONFIG.RedisPoolMaxIdle = Ternary(c.RedisPoolMaxIdle &lt; 0, 0, c.RedisPoolMaxIdle).(int)
        CONFIG.RedisPoolIdleTimeout = Ternary(c.RedisPoolIdleTimeout &lt; 0, 0, c.RedisPoolIdleTimeout).(int)

        CONFIG.CacheCircuitCheckInterval = Ternary(c.CacheCircuitCheckInterval &lt; 0, 0, c.CacheCircuitCheckInterval).(int)
        CONFIG.CacheCircuitCloseSleepWindow = Ternary(c.CacheCircuitCloseSleepWindow &lt; 0, 0, c.CacheCircuitCloseSleepWindow).(int)
        CONFIG.CacheCircuitCloseRequiredCount = Ternary(c.CacheCircuitCloseRequiredCount &lt; 0, 0, c.CacheCircuitCloseRequiredCount).(int)
        CONFIG.CacheCircuitOpenThreshold = Ternary(c.CacheCircuitOpenThreshold &lt; 0, 0, c.CacheCircuitOpenThreshold).(int)

        CONFIG.DownLoadBufPoolSize = Ternary(c.DownLoadBufPoolSize &lt; MIN_DOWNLOAD_BUFPOOL_SIZE || c.DownLoadBufPoolSize &gt; MAX_DOWNLOAD_BUFPOOL_SIZE, MIN_DOWNLOAD_BUFPOOL_SIZE, c.DownLoadBufPoolSize).(int)

        CONFIG.KMS = c.KMS

        CONFIG.MsgBus = c.MsgBus
        CONFIG.MsgBus.RequestTimeoutMs = Ternary(c.MsgBus.RequestTimeoutMs == 0, 3000, c.MsgBus.RequestTimeoutMs).(int)
        CONFIG.MsgBus.MessageTimeoutMs = Ternary(c.MsgBus.MessageTimeoutMs == 0, 5000, c.MsgBus.MessageTimeoutMs).(int)
        CONFIG.MsgBus.SendMaxRetries = Ternary(c.MsgBus.SendMaxRetries == 0, 2, c.MsgBus.SendMaxRetries).(int)

        return nil</span>
}
</pre>
		
		<pre class="file" id="file81" style="display: none">package helper

import (
        "bytes"
)

func EscapeColon(s string) string <span class="cov0" title="0">{
        //Byte loop is OK for utf8
        buf := new(bytes.Buffer)
        l := len(s)
        for i := 0; i &lt; l; i++ </span><span class="cov0" title="0">{
                if s[i] == '%' </span><span class="cov0" title="0">{
                        buf.WriteString("%%")
                }</span> else<span class="cov0" title="0"> if s[i] == ':' </span><span class="cov0" title="0">{
                        buf.WriteString("%n")
                }</span> else<span class="cov0" title="0"> {
                        buf.WriteByte(s[i])
                }</span>
        }
        <span class="cov0" title="0">return buf.String()</span>
}

func UnescapeColon(s string) string <span class="cov0" title="0">{
        buf := new(bytes.Buffer)
        l := len(s)
        for i := 0; i &lt; l; i++ </span><span class="cov0" title="0">{
                if s[i] == '%' </span><span class="cov0" title="0">{
                        i++
                        if i == l </span><span class="cov0" title="0">{
                                panic("never be here")</span>
                        }
                        <span class="cov0" title="0">if s[i] == '%' </span><span class="cov0" title="0">{
                                buf.WriteString("%")
                        }</span> else<span class="cov0" title="0"> if s[i] == 'n' </span><span class="cov0" title="0">{
                                buf.WriteString(":")
                        }</span> else<span class="cov0" title="0"> {
                                panic("never be here")</span>
                        }
                } else<span class="cov0" title="0"> {
                        buf.WriteByte(s[i])
                }</span>
        }
        <span class="cov0" title="0">return buf.String()</span>
}
</pre>
		
		<pre class="file" id="file82" style="display: none">package helper

import (
        "os"
)

func FileExists(path string) bool <span class="cov0" title="0">{
        st, e := os.Stat(path)
        // If file exists and is regular return true.
        if e == nil &amp;&amp; st.Mode().IsRegular() </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file83" style="display: none">package helper

func Filter(xs []string, f func(string) bool) []string <span class="cov0" title="0">{
        ans := make([]string, 0, len(xs))
        for _, x := range xs </span><span class="cov0" title="0">{
                if f(x) </span><span class="cov0" title="0">{
                        ans = append(ans, x)
                }</span>
        }
        <span class="cov0" title="0">return ans</span>
}

func Map(xs []string, f func(string) string) []string <span class="cov0" title="0">{
        ans := make([]string, 0, len(xs))
        for _, x := range xs </span><span class="cov0" title="0">{
                ans = append(ans, f(x))
        }</span>
        <span class="cov0" title="0">return ans</span>
}
</pre>
		
		<pre class="file" id="file84" style="display: none">package helper

import (
        "math/rand"
        "reflect"
)

// mimic `?:` operator
// Need type assertion to convert output to expected type
func Ternary(IF bool, THEN interface{}, ELSE interface{}) interface{} <span class="cov0" title="0">{
        if IF </span><span class="cov0" title="0">{
                return THEN
        }</span> else<span class="cov0" title="0"> {
                return ELSE
        }</span>
}

// Get keys of a map, i.e.
// map[string]interface{} -&gt; []string
// Note that some type checks are omitted for efficiency, you need to ensure them yourself,
// otherwise your program should panic
func Keys(v interface{}) []string <span class="cov0" title="0">{
        rv := reflect.ValueOf(v)
        result := make([]string, 0, rv.Len())
        for _, kv := range rv.MapKeys() </span><span class="cov0" title="0">{
                result = append(result, kv.String())
        }</span>
        <span class="cov0" title="0">return result</span>
}

// Static alphaNumeric table used for generating unique request ids
var alphaNumericTable = []byte("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ")

func GenerateRandomId() []byte <span class="cov0" title="0">{
        alpha := make([]byte, 16, 16)
        for i := 0; i &lt; 16; i++ </span><span class="cov0" title="0">{
                n := rand.Intn(len(alphaNumericTable))
                alpha[i] = alphaNumericTable[n]
        }</span>
        <span class="cov0" title="0">return alpha</span>
}
</pre>
		
		<pre class="file" id="file85" style="display: none">package helper

import (
        "encoding/json"
        "io"
        "io/ioutil"
)

// read from ReadCloser and unmarshal to out;
// `out` should be of POINTER type
func ReadJsonBody(body io.ReadCloser, out interface{}) (err error) <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                _ = body.Close()
        }</span>()
        <span class="cov0" title="0">jsonBytes, err := ioutil.ReadAll(body)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">err = json.Unmarshal(jsonBytes, out)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

</pre>
		
		<pre class="file" id="file86" style="display: none">package helper

import (
        "bytes"

        "github.com/ugorji/go/codec"
)

func MsgPackMarshal(v interface{}) ([]byte, error) <span class="cov0" title="0">{
        var buf = new(bytes.Buffer)
        enc := codec.NewEncoder(buf, new(codec.MsgpackHandle))
        err := enc.Encode(v)
        return buf.Bytes(), err
}</span>
func MsgPackUnMarshal(data []byte, v interface{}) error <span class="cov0" title="0">{
        var buf = bytes.NewBuffer(data)
        dec := codec.NewDecoder(buf, new(codec.MsgpackHandle))
        return dec.Decode(v)
}</span>
</pre>
		
		<pre class="file" id="file87" style="display: none">package helper

import "strings"

func HasBucketInDomain(host string, prefix string, domains []string) (ok bool, bucket string)  <span class="cov0" title="0">{
        for _, d := range domains </span><span class="cov0" title="0">{
                if strings.HasSuffix(host, prefix+d) </span><span class="cov0" title="0">{
                        return true, strings.TrimSuffix(host, prefix+d)
                }</span>
        }
        <span class="cov0" title="0">return false, ""</span>
}

func StringInSlice(s string, ss []string) bool <span class="cov8" title="1">{
        for _, x := range ss </span><span class="cov8" title="1">{
                if s == x </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func CopiedBytes(source []byte) (destination []byte) <span class="cov0" title="0">{
        destination = make([]byte, len(source), len(source))
        copy(destination, source)
        return destination
}</span>

func UnicodeIndex(str, substr string) int <span class="cov0" title="0">{
        result := strings.Index(str, substr)
        if result &gt;= 0 </span><span class="cov0" title="0">{
                prefix := []byte(str)[0:result]
                rs := []rune(string(prefix))
                result = len(rs)
        }</span>
        <span class="cov0" title="0">return result</span>
}

func SubString(str string, begin, length int) (substr string) <span class="cov0" title="0">{
        rs := []rune(str)
        lth := len(rs)
        if begin &lt; 0 </span><span class="cov0" title="0">{
                begin = 0
        }</span>
        <span class="cov0" title="0">if begin &gt;= lth </span><span class="cov0" title="0">{
                begin = lth
        }</span>
        <span class="cov0" title="0">var end int
        if length == -1 </span><span class="cov0" title="0">{
                end = lth
        }</span> else<span class="cov0" title="0"> {
                end = begin + length
        }</span>
        <span class="cov0" title="0">if end &gt; lth </span><span class="cov0" title="0">{
                end = lth
        }</span>
        <span class="cov0" title="0">return string(rs[begin:end])</span>
}
</pre>
		
		<pre class="file" id="file88" style="display: none">package types

import (
        "bytes"
        "encoding/binary"
        "encoding/json"
        "errors"
        "fmt"
        "strconv"
        "time"

        "github.com/dustin/go-humanize"
        "github.com/soda/multi-cloud/s3/pkg/helper"
        pb "github.com/soda/multi-cloud/s3/proto"
        log "github.com/sirupsen/logrus"
)

const (
        FIELD_NAME_BODY       = "body"
        FIELD_NAME_USAGE      = "usage"
        FIELD_NAME_FILECOUNTS = "file_counts"
)

type Bucket struct {
        *pb.Bucket
}

// implements the Serializable interface
func (b *Bucket) Serialize() (map[string]interface{}, error) <span class="cov0" title="0">{
        fields := make(map[string]interface{})
        bytes, err := helper.MsgPackMarshal(b)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">fields[FIELD_NAME_BODY] = string(bytes)
        fields[FIELD_NAME_USAGE] = b.Usages
        return fields, nil</span>
}

func (b *Bucket) Deserialize(fields map[string]string) (interface{}, error) <span class="cov0" title="0">{
        body, ok := fields[FIELD_NAME_BODY]
        if !ok </span><span class="cov0" title="0">{
                return nil, errors.New(fmt.Sprintf("no field %s found", FIELD_NAME_BODY))
        }</span>

        <span class="cov0" title="0">err := helper.MsgPackUnMarshal([]byte(body), b)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if usageStr, ok := fields[FIELD_NAME_USAGE]; ok </span><span class="cov0" title="0">{
                b.Usages, err = strconv.ParseInt(usageStr, 10, 64)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">return b, nil</span>
}

func (b *Bucket) String() (s string) <span class="cov0" title="0">{
        s += "Name: " + b.Name + "\n"
        s += "CreateTime: " + time.Unix(b.CreateTime, 0).Format(CREATE_TIME_LAYOUT) + "\n"
        s += "TenantId: " + b.TenantId + "\n"
        s += "DefaultLocation: " + b.DefaultLocation + "\n"
        s += "CORS: " + fmt.Sprintf("%+v", b.Cors) + "\n"
        s += "ACL: " + fmt.Sprintf("%+v", b.Acl) + "\n"
        s += "LifeCycle: " + fmt.Sprintf("%+v", b.LifecycleConfiguration) + "\n"
        s += "Policy: " + fmt.Sprintf("%+v", b.BucketPolicy) + "\n"
        s += "Versioning: " + fmt.Sprintf("%+v", b.Versioning) + "\n"
        s += "Usage: " + humanize.Bytes(uint64(b.Usages)) + "\n"
        return
}</span>

/* Learn from this, http://stackoverflow.com/questions/33587227/golang-method-sets-pointer-vs-value-receiver */
/* If you have a T and it is addressable you can call methods that have a receiver type of *T as well as methods that have a receiver type of T */
func (b *Bucket) GetValues() (values map[string]map[string][]byte, err error) <span class="cov0" title="0">{
        cors, err := json.Marshal(b.Cors)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">lc, err := json.Marshal(b.LifecycleConfiguration)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">var usage bytes.Buffer
        err = binary.Write(&amp;usage, binary.BigEndian, b.Usages)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">values = map[string]map[string][]byte{
                BUCKET_COLUMN_FAMILY: map[string][]byte{
                        "UID":        []byte(b.TenantId),
                        "ACL":        []byte(b.Acl.CannedAcl),
                        "CORS":       cors,
                        "LC":         lc,
                        "createTime": []byte(time.Unix(b.CreateTime, 0).Format(CREATE_TIME_LAYOUT)),
                        "usage":      usage.Bytes(),
                },
                // TODO fancy ACL
        }
        return</span>
}

func (b Bucket) GetCreateSql() (string, []interface{}) <span class="cov0" title="0">{
        acl, _ := json.Marshal(b.Acl)
        cors, _ := json.Marshal(b.Cors)
        lc, _ := json.Marshal(b.LifecycleConfiguration)
        bucket_policy, _ := json.Marshal(b.BucketPolicy)
        replia, _ := json.Marshal(b.ReplicationConfiguration)
        //createTime := time.Unix(b.CreateTime, 0).Format(TIME_LAYOUT_TIDB)
        createTime := time.Now().Format(TIME_LAYOUT_TIDB)
        log.Infof("createTime=%v\n", createTime)

        sql := "insert into buckets(bucketname,tenantid,userid,createtime,usages,location,acl,cors,lc,policy,versioning," +
                "replication) values(?,?,?,?,?,?,?,?,?,?,?,?);"
        args := []interface{}{b.Name, b.TenantId, b.UserId, createTime, b.Usages, b.DefaultLocation, acl, cors, lc,
                bucket_policy, b.Versioning.Status, replia}
        return sql, args
}</span>
</pre>
		
		<pre class="file" id="file89" style="display: none">package types

import (
        "errors"
        "fmt"
        "strconv"

        "github.com/soda/multi-cloud/s3/pkg/helper"
)

type Cluster struct {
        Fsid   string
        Pool   string
        Weight int
}

func (c *Cluster) Serialize() (map[string]interface{}, error) <span class="cov0" title="0">{
        fields := make(map[string]interface{})
        bytes, err := helper.MsgPackMarshal(c)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">fields[FIELD_NAME_BODY] = string(bytes)
        return fields, nil</span>
}

func (c *Cluster) Deserialize(fields map[string]string) (interface{}, error) <span class="cov0" title="0">{
        body, ok := fields[FIELD_NAME_BODY]
        if !ok </span><span class="cov0" title="0">{
                return nil, errors.New(fmt.Sprintf("no field %s found", FIELD_NAME_BODY))
        }</span>

        <span class="cov0" title="0">err := helper.MsgPackUnMarshal([]byte(body), c)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return c, nil</span>
}

func (c *Cluster) GetValues() (values map[string]map[string][]byte, err error) <span class="cov0" title="0">{
        values = map[string]map[string][]byte{
                CLUSTER_COLUMN_FAMILY: map[string][]byte{
                        "weight": []byte(strconv.Itoa(c.Weight)),
                },
        }
        return
}</span>
</pre>
		
		<pre class="file" id="file90" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package types

import (
        "bytes"
        "encoding/binary"
        "strconv"
        "time"
)

type GarbageCollection struct {
        Rowkey      string // rowkey cache
        BucketName  string
        ObjectName  string
        Location    string
        ObjectId    string
        Status      string    // status of this entry, in Pending/Deleting
        StorageMeta string    // meta data used by storage driver, different storage driver may have different information
        MTime       time.Time // last modify time of status
        Parts       map[int]*Part
        TriedTimes  int
}

func (gc GarbageCollection) GetValues() (values map[string]map[string][]byte, err error) <span class="cov0" title="0">{
        values = map[string]map[string][]byte{
                GARBAGE_COLLECTION_COLUMN_FAMILY: map[string][]byte{
                        "location":    []byte(gc.Location),
                        "storagemeta": []byte(gc.StorageMeta),
                        "oid":         []byte(gc.ObjectId),
                        "status":      []byte(gc.Status),
                        "mtime":       []byte(gc.MTime.Format(CREATE_TIME_LAYOUT)),
                        "tried":       []byte(strconv.Itoa(gc.TriedTimes)),
                },
        }
        if len(gc.Parts) != 0 </span><span class="cov0" title="0">{
                values[GARBAGE_COLLECTION_PART_COLUMN_FAMILY], err = valuesForParts(gc.Parts)
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
        }
        <span class="cov0" title="0">return</span>
}

func (gc GarbageCollection) GetValuesForDelete() map[string]map[string][]byte <span class="cov0" title="0">{
        return map[string]map[string][]byte{
                GARBAGE_COLLECTION_COLUMN_FAMILY:      map[string][]byte{},
                GARBAGE_COLLECTION_PART_COLUMN_FAMILY: map[string][]byte{},
        }
}</span>

// Rowkey format:
// bigEndian(unixNanoTimestamp) + BucketName + ObjectName
func (gc GarbageCollection) GetRowkey() (string, error) <span class="cov0" title="0">{
        var rowkey bytes.Buffer
        err := binary.Write(&amp;rowkey, binary.BigEndian,
                uint64(time.Now().UnixNano()))
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">rowkey.WriteString(gc.BucketName)
        rowkey.WriteString(gc.ObjectName)
        return rowkey.String(), nil</span>
}
</pre>
		
		<pre class="file" id="file91" style="display: none">package types

import (
        "encoding/hex"
        "encoding/json"
        "errors"
        "math"
        "strconv"
        "time"

        "github.com/soda/multi-cloud/api/pkg/s3/datatype"
        "github.com/soda/multi-cloud/s3/proto"
        "github.com/xxtea/xxtea-go/xxtea"
)

type Part struct {
        PartNumber int
        Size       int64
        ObjectId   string

        // offset of this part in whole object, calculated when moving parts from
        // `multiparts` table to `objects` table
        Offset               int64
        Etag                 string
        LastModified         string // time string of format "2006-01-02T15:04:05.000Z"
        InitializationVector []byte
}

type MultipartMetadata struct {
        InitiatorId   string //TenantId
        TenantId      string
        UserId        string
        ContentType   string
        Location      string
        Pool          string
        Acl           s3.Acl
        SseRequest    datatype.SseRequest
        EncryptionKey []byte
        CipherKey     []byte
        Attrs         map[string]string
        Tier          int32
}

type Multipart struct {
        BucketName  string
        ObjectKey   string
        InitialTime time.Time
        UploadId    string // upload id cache
        ObjectId    string
        StorageMeta string
        Metadata    MultipartMetadata
        Parts       map[int]*Part
}

func (m *Multipart) GetUploadId() (string, error) <span class="cov0" title="0">{
        if m.UploadId != "" </span><span class="cov0" title="0">{
                return m.UploadId, nil
        }</span>
        <span class="cov0" title="0">if m.InitialTime.IsZero() </span><span class="cov0" title="0">{
                return "", errors.New("Zero value InitialTime for Multipart")
        }</span>
        <span class="cov0" title="0">m.UploadId = getMultipartUploadId(m.InitialTime)
        return m.UploadId, nil</span>
}
func getMultipartUploadId(t time.Time) string <span class="cov0" title="0">{
        timeData := []byte(strconv.FormatUint(uint64(t.UnixNano()), 10))
        return hex.EncodeToString(xxtea.Encrypt(timeData, XXTEA_KEY))
}</span>

func GetMultipartUploadIdForTidb(uploadtime uint64) string <span class="cov0" title="0">{
        realUploadTime := math.MaxUint64 - uploadtime
        timeData := []byte(strconv.FormatUint(realUploadTime, 10))
        return hex.EncodeToString(xxtea.Encrypt(timeData, XXTEA_KEY))
}</span>

func (m *Multipart) GetValuesForDelete() map[string]map[string][]byte <span class="cov0" title="0">{
        return map[string]map[string][]byte{
                MULTIPART_COLUMN_FAMILY: map[string][]byte{},
        }
}</span>

func valuesForParts(parts map[int]*Part) (values map[string][]byte, err error) <span class="cov0" title="0">{
        for partNumber, part := range parts </span><span class="cov0" title="0">{
                var marshaled []byte
                marshaled, err = json.Marshal(part)
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">if values == nil </span><span class="cov0" title="0">{
                        values = make(map[string][]byte)
                }</span>
                <span class="cov0" title="0">values[strconv.Itoa(partNumber)] = marshaled</span>
        }
        <span class="cov0" title="0">return</span>
}
</pre>
		
		<pre class="file" id="file92" style="display: none">/*
 * Minio Cloud Storage, (C) 2015 Minio, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package types

import (
        "fmt"
)

// PartTooSmall - error if part size is less than 5MB.
type PartTooSmall struct {
        PartSize   int64
        PartNumber int
        PartETag   string
}

func (e PartTooSmall) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("Part size for %d should be atleast 5MB. The part size is %d. Etag: %s",
                e.PartNumber, e.PartNumber, e.PartETag)
}</span>
</pre>
		
		<pre class="file" id="file93" style="display: none">package types

import (
        "bytes"
        "crypto/aes"
        "crypto/cipher"
        "crypto/rand"
        "encoding/binary"
        "encoding/hex"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "math"
        "strconv"
        "time"

        "github.com/soda/multi-cloud/s3/pkg/helper"
        "github.com/soda/multi-cloud/s3/pkg/meta/util"
        pb "github.com/soda/multi-cloud/s3/proto"
        "github.com/xxtea/xxtea-go/xxtea"
)

type Object struct {
        *pb.Object
}

type ObjectType string

const (
        ObjectTypeNormal = iota
        ObjectTypeAppendable
        ObjectTypeMultipart
)

func (o *Object) Serialize() (map[string]interface{}, error) <span class="cov0" title="0">{
        fields := make(map[string]interface{})
        body, err := helper.MsgPackMarshal(o)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">fields[FIELD_NAME_BODY] = string(body)
        return fields, nil</span>
}

func (o *Object) Deserialize(fields map[string]string) (interface{}, error) <span class="cov0" title="0">{
        body, ok := fields[FIELD_NAME_BODY]
        if !ok </span><span class="cov0" title="0">{
                return nil, errors.New(fmt.Sprintf("no field %s", FIELD_NAME_BODY))
        }</span>

        <span class="cov0" title="0">err := helper.MsgPackUnMarshal([]byte(body), o)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return o, nil</span>
}

func (o *Object) ObjectTypeToString() string <span class="cov0" title="0">{
        switch o.Type </span>{
        case ObjectTypeNormal:<span class="cov0" title="0">
                return "Normal"</span>
        case ObjectTypeAppendable:<span class="cov0" title="0">
                return "Appendable"</span>
        case ObjectTypeMultipart:<span class="cov0" title="0">
                return "Multipart"</span>
        default:<span class="cov0" title="0">
                return "Unknown"</span>
        }
}

func (o *Object) String() (s string) <span class="cov0" title="0">{
        s += "Name: " + o.ObjectKey + "\n"
        s += "Bucket: " + o.BucketName + "\n"
        s += "Location: " + o.Location + "\n"
        //s += "Pool: " + o.Pool + "\n"
        s += "Object ID: " + o.ObjectId + "\n"
        s += "Last Modified Time: " + time.Unix(o.LastModified, 0).Format(CREATE_TIME_LAYOUT) + "\n"
        s += "Version: " + o.VersionId + "\n"
        s += "Type: " + o.ObjectTypeToString() + "\n"
        s += "Tier: " + fmt.Sprintf("%d", o.Tier) + "\n"
        // TODO: multi-part handle

        return s
}</span>

func (o *Object) GetVersionNumber() (uint64, error) <span class="cov0" title="0">{
        decrypted, err := util.Decrypt(o.VersionId)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">version, err := strconv.ParseUint(decrypted, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">return version, nil</span>
}

func (o *Object) GetValues() (values map[string]map[string][]byte, err error) <span class="cov0" title="0">{
        var size, tier bytes.Buffer
        err = binary.Write(&amp;size, binary.BigEndian, o.Size)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">err = binary.Write(&amp;tier, binary.BigEndian, o.Tier)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">err = o.encryptSseKey()
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if o.ServerSideEncryption.EncryptionKey == nil </span><span class="cov0" title="0">{
                o.ServerSideEncryption.EncryptionKey = []byte{}
        }</span>
        <span class="cov0" title="0">if o.ServerSideEncryption.InitilizationVector == nil </span><span class="cov0" title="0">{
                o.ServerSideEncryption.InitilizationVector = []byte{}
        }</span>
        <span class="cov0" title="0">var attrsData []byte
        if o.CustomAttributes != nil </span><span class="cov0" title="0">{
                attrsData, err = json.Marshal(o.CustomAttributes)
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
        }
        <span class="cov0" title="0">values = map[string]map[string][]byte{
                OBJECT_COLUMN_FAMILY: map[string][]byte{
                        "bucket":        []byte(o.BucketName),
                        "location":      []byte(o.Location),
                        "owner":         []byte(o.UserId),
                        "oid":           []byte(o.ObjectId),
                        "size":          size.Bytes(),
                        "lastModified":  []byte(time.Unix(o.LastModified, 0).Format(CREATE_TIME_LAYOUT)),
                        "etag":          []byte(o.Etag),
                        "content-type":  []byte(o.ContentType),
                        "attributes":    attrsData, // TODO
                        "ACL":           []byte(o.Acl.CannedAcl),
                        "nullVersion":   []byte(helper.Ternary(o.NullVersion, "true", "false").(string)),
                        "deleteMarker":  []byte(helper.Ternary(o.DeleteMarker, "true", "false").(string)),
                        "sseType":       []byte(o.ServerSideEncryption.SseType),
                        "encryptionKey": o.ServerSideEncryption.EncryptionKey,
                        "IV":            o.ServerSideEncryption.InitilizationVector,
                        "type":          []byte(o.ObjectTypeToString()),
                        "tier":          tier.Bytes(),
                },
        }
        // TODO: multipart handle

        return</span>
}

func (o *Object) GetValuesForDelete() (values map[string]map[string][]byte) <span class="cov0" title="0">{
        return map[string]map[string][]byte{
                OBJECT_COLUMN_FAMILY:      map[string][]byte{},
                OBJECT_PART_COLUMN_FAMILY: map[string][]byte{},
        }
}</span>

func (o *Object) encryptSseKey() (err error) <span class="cov0" title="0">{
        // Don't encrypt if `EncryptionKey` is not set
        if len(o.ServerSideEncryption.EncryptionKey) == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">if len(o.ServerSideEncryption.InitilizationVector) == 0 </span><span class="cov0" title="0">{
                o.ServerSideEncryption.InitilizationVector = make([]byte, INITIALIZATION_VECTOR_LENGTH)
                _, err = io.ReadFull(rand.Reader, o.ServerSideEncryption.InitilizationVector)
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
        }

        <span class="cov0" title="0">block, err := aes.NewCipher(SSE_S3_MASTER_KEY)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">aesGcm, err := cipher.NewGCM(block)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // InitializationVector is 16 bytes(because of CTR), but use only first 12 bytes in GCM
        // for performance
        <span class="cov0" title="0">o.ServerSideEncryption.EncryptionKey = aesGcm.Seal(nil, o.ServerSideEncryption.InitilizationVector[:12], o.ServerSideEncryption.EncryptionKey, nil)
        return nil</span>
}

func (o *Object) GetVersionId() string <span class="cov0" title="0">{
        if o.NullVersion </span><span class="cov0" title="0">{
                return "null"
        }</span>
        <span class="cov0" title="0">if o.VersionId != "" </span><span class="cov0" title="0">{
                return o.VersionId
        }</span>
        <span class="cov0" title="0">timeData := []byte(strconv.FormatUint(uint64(o.LastModified), 10))
        o.VersionId = hex.EncodeToString(xxtea.Encrypt(timeData, XXTEA_KEY))
        return o.VersionId</span>
}

//Tidb related function

func (o *Object) GetCreateSql() (string, []interface{}) <span class="cov0" title="0">{
        version := math.MaxUint64 - uint64(o.LastModified)
        customAttributes, _ := json.Marshal(o.CustomAttributes)
        acl, _ := json.Marshal(o.Acl)
        var sseType string
        var encryptionKey, initVector []byte
        if o.ServerSideEncryption != nil </span><span class="cov0" title="0">{
                sseType = o.ServerSideEncryption.SseType
                encryptionKey = o.ServerSideEncryption.EncryptionKey
                initVector = o.ServerSideEncryption.InitilizationVector
        }</span>

        <span class="cov0" title="0">lastModifiedTime := time.Unix(o.LastModified, 0).Format(TIME_LAYOUT_TIDB)
        sql := "insert into objects (bucketname, name, version, location, tenantid, userid, size, objectid, " +
                " lastmodifiedtime, etag, contenttype, customattributes, acl, nullversion, deletemarker, ssetype, " +
                " encryptionkey, initializationvector, type, tier, storageMeta) " +
                "values(?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)"
        args := []interface{}{o.BucketName, o.ObjectKey, version, o.Location, o.TenantId, o.UserId, o.Size, o.ObjectId,
                lastModifiedTime, o.Etag, o.ContentType, customAttributes, acl, o.NullVersion, o.DeleteMarker, sseType,
                encryptionKey, initVector, o.Type, o.Tier, o.StorageMeta}

        return sql, args</span>
}

func (o *Object) GetUpdateMetaSql() (string, []interface{}) <span class="cov0" title="0">{
        version := math.MaxUint64 - uint64(o.LastModified)
        attrs, _ := json.Marshal(o.CustomAttributes)
        acl, _ := json.Marshal(o.Acl)
        sql := "update objects set acl = ?, contenttype = ?, customattributes =? where bucketname=? and name=? and version=?"
        args := []interface{}{acl, o.ContentType, attrs, o.BucketName, o.ObjectKey, version}
        return sql, args

}</span>

</pre>
		
		<pre class="file" id="file94" style="display: none">package types

import (
        "bytes"
        "encoding/binary"
)

type ObjMap struct {
        Rowkey     []byte // Rowkey cache
        Name       string
        BucketName string
        NullVerNum uint64
        NullVerId  string
}

func (om *ObjMap) GetRowKey() (string, error) <span class="cov0" title="0">{
        if len(om.Rowkey) != 0 </span><span class="cov0" title="0">{
                return string(om.Rowkey), nil
        }</span>
        <span class="cov0" title="0">var rowkey bytes.Buffer
        rowkey.WriteString(om.BucketName + ObjectNameSeparator)

        rowkey.WriteString(om.Name + ObjectNameSeparator)

        om.Rowkey = rowkey.Bytes()
        return string(om.Rowkey), nil</span>
}

func (om *ObjMap) GetValues() (values map[string]map[string][]byte, err error) <span class="cov0" title="0">{
        var nullVerNum bytes.Buffer
        err = binary.Write(&amp;nullVerNum, binary.BigEndian, om.NullVerNum)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">values = map[string]map[string][]byte{
                OBJMAP_COLUMN_FAMILY: map[string][]byte{
                        "nullVerNum": nullVerNum.Bytes(),
                },
        }
        return</span>
}

func (om *ObjMap) GetValuesForDelete() (values map[string]map[string][]byte) <span class="cov0" title="0">{
        return map[string]map[string][]byte{
                OBJMAP_COLUMN_FAMILY: map[string][]byte{},
        }
}</span>
</pre>
		
		<pre class="file" id="file95" style="display: none">package types

type SimpleIndex struct {
        Index []int64
}

func (array *SimpleIndex) SearchLowerBound(key int64) int <span class="cov0" title="0">{
        var low int = 0
        var high int = len(array.Index) - 1
        var mid = (low + high) / 2

        if array.Index[low] &gt; key </span><span class="cov0" title="0">{
                return -1
        }</span>

        <span class="cov0" title="0">for low &lt;= high </span><span class="cov0" title="0">{

                if array.Index[mid] == key </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">if array.Index[mid] &gt; key </span><span class="cov0" title="0">{
                        high = mid - 1
                }</span> else<span class="cov0" title="0"> {
                        low = mid + 1
                }</span>
                <span class="cov0" title="0">mid = (low + high) / 2</span>

        }

        <span class="cov0" title="0">return mid</span>

}

func (array *SimpleIndex) SearchUpperBound(key int64) int <span class="cov0" title="0">{
        var low int = 0
        var high int = len(array.Index) - 1
        var mid = (low + high) / 2

        if array.Index[high] &lt;= key </span><span class="cov0" title="0">{
                return -1
        }</span>

        <span class="cov0" title="0">for low &lt;= high </span><span class="cov0" title="0">{
                if array.Index[mid] &gt; key </span><span class="cov0" title="0">{
                        if mid-1 &gt;= low &amp;&amp; key &gt;= array.Index[mid-1] </span><span class="cov0" title="0">{
                                return mid
                        }</span> else<span class="cov0" title="0"> {
                                high = mid - 1
                        }</span>
                } else<span class="cov0" title="0"> {
                        if mid+1 &lt;= high &amp;&amp; key &lt; array.Index[mid+1] </span><span class="cov0" title="0">{
                                return mid + 1
                        }</span> else<span class="cov0" title="0"> {
                                low = mid + 1
                        }</span>
                }
                <span class="cov0" title="0">mid = (low + high) / 2</span>
        }

        <span class="cov0" title="0">return mid</span>
}
</pre>
		
		<pre class="file" id="file96" style="display: none">package types

import (
        . "github.com/soda/multi-cloud/s3/error"
        "github.com/soda/multi-cloud/s3/pkg/utils"
)

type StorageClass int32

var (
        StorageClassIndexMap = map[StorageClass]string{
                utils.Tier1:   "STANDARD",
                utils.Tier99:  "STANDARD_IA",
                utils.Tier999: "GLACIER",
        }

        StorageClassStringMap = map[string]StorageClass{
                "STANDARD":    utils.Tier1,
                "STANDARD_IA": utils.Tier99,
                "GLACIER":     utils.Tier999,
        }
)

func (s StorageClass) ToString() string <span class="cov0" title="0">{
        return StorageClassIndexMap[s]
}</span>

func MatchStorageClassIndex(storageClass string) (StorageClass, error) <span class="cov0" title="0">{
        if index, ok := StorageClassStringMap[storageClass]; ok </span><span class="cov0" title="0">{
                return index, nil
        }</span> else<span class="cov0" title="0"> {
                return 0, ErrInvalidStorageClass
        }</span>
}
</pre>
		
		<pre class="file" id="file97" style="display: none">package util

import (
        "context"
        "encoding/hex"
        "github.com/micro/go-micro/metadata"
        "github.com/soda/multi-cloud/api/pkg/common"
        . "github.com/soda/multi-cloud/s3/error"
        log "github.com/sirupsen/logrus"
        "github.com/xxtea/xxtea-go/xxtea"
)

var XXTEA_KEY = []byte("hehehehe")

func Decrypt(value string) (string, error) <span class="cov0" title="0">{
        bytes, err := hex.DecodeString(value)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return string(xxtea.Decrypt(bytes, XXTEA_KEY)), nil</span>
}

func Encrypt(value string) string <span class="cov0" title="0">{
        return hex.EncodeToString(xxtea.Encrypt([]byte(value), XXTEA_KEY))
}</span>

func GetCredentialFromCtx(ctx context.Context) (isAdmin bool, tenantId string, userId string, err error) <span class="cov0" title="0">{
        var ok bool
        var md map[string]string
        md, ok = metadata.FromContext(ctx)
        if !ok </span><span class="cov0" title="0">{
                log.Error("get metadata from ctx failed.")
                err = ErrInternalError
                return
        }</span>

        <span class="cov0" title="0">isAdmin = false
        isAdminStr, _ := md[common.CTX_KEY_IS_ADMIN]
        if isAdminStr == common.CTX_VAL_TRUE </span><span class="cov0" title="0">{
                isAdmin = true
        }</span>

        <span class="cov0" title="0">tenantId, ok = md[common.CTX_KEY_TENANT_ID]
        userId, ok = md[common.CTX_KEY_USER_ID]

        log.Debugf("isAdmin=%v, tenantId=%s, userId=%s, err=%v\n", isAdmin, tenantId, userId, err)
        return</span>
}
</pre>
		
		<pre class="file" id="file98" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package model

import "encoding/xml"

var Xmlns = "http://s3.amazonaws.com/doc/2006-03-01"

type CreateBucketConfiguration struct {
        Xmlns              string `xml:"xmlns,attr"`
        LocationConstraint string `xml:"LocationConstraint"`
        SSEOpts            SSEConfiguration
}

type Owner struct {
        ID          string `xml:"ID"`
        DisplayName string `xml:"DisplayName"`
}

type Bucket struct {
        Name               string `xml:"Name"`
        CreateTime         string `xml:"CreateTime"`
        LocationConstraint string `xml:"LocationConstraint"`
        VersionOpts        VersioningConfiguration
        SSEOpts            SSEConfiguration
}

type ListAllMyBucketsResult struct {
        Xmlns   string   `xml:"xmlns,attr"`
        Owner   Owner    `xml:"Owner"`
        Buckets []Bucket `xml:"Buckets"`
}

type InitiateMultipartUploadResult struct {
        Xmlns    string `xml:"xmlns,attr"`
        Bucket   string `xml:"Bucket"`
        Key      string `xml:"Key"`
        UploadId string `xml:"UploadId"`
}

//PartNumber should be between 1 and 10000.
//Please refer to https://docs.aws.amazon.com/zh_cn/AmazonS3/latest/dev/qfacts.html
type UploadPartResult struct {
        Xmlns      string `xml:"xmlns,attr"`
        PartNumber int64  `xml:"PartNumber"`
        ETag       string `xml:"ETag"`
}

// completedParts - is a collection satisfying sort.Interface.
type CompletedParts []Part

func (a CompletedParts) Len() int           <span class="cov0" title="0">{ return len(a) }</span>
func (a CompletedParts) Swap(i, j int)      <span class="cov0" title="0">{ a[i], a[j] = a[j], a[i] }</span>
func (a CompletedParts) Less(i, j int) bool <span class="cov0" title="0">{ return a[i].PartNumber &lt; a[j].PartNumber }</span>

type Part struct {
        PartNumber     int64  `xml:"PartNumber"`
        ETag           string `xml:"ETag"`
        Size           int64  `xml:"Size"`
        LastModifyTime int64  `xml:"LastModifyTime"`
}

type CompleteMultipartUpload struct {
        Xmlns string `xml:"xmlns,attr"`
        Parts []Part `xml:"Part"`
}

type CompleteMultipartUploadResult struct {
        Xmlns    string `xml:"xmlns,attr"`
        Location string `xml:"Location"`
        Bucket   string `xml:"Bucket"`
        Key      string `xml:"Key"`
        Size     int64  `xml:"Size"`
        ETag     string `xml:"ETag"`
}

type ListPartsOutput struct {
        Xmlns       string `xml:"xmlns,attr"`
        Bucket      string `xml:"Bucket"`
        Key         string `xml:"Key"`
        UploadId    string `xml:"UploadId"`
        MaxParts    int    `xml:"MaxParts"`
        IsTruncated bool   `xml:"IsTruncated"`
        Owner       Owner  `xml:"Owner"`
        Parts       []Part `xml:"Part"`
}

type LifecycleConfiguration struct {
        Rule []Rule `xml:"Rule"`
}

type SSEConfiguration struct {
        XMLName xml.Name `xml:"SSEConfiguration"`
        Text    string   `xml:",chardata"`
        SSE     struct {
                Text    string `xml:",chardata"`
                Enabled string `xml:"enabled"`
        } `xml:"SSE"`
        SSEKMS struct {
                Text                string `xml:",chardata"`
                Enabled             string `xml:"enabled"`
                DefaultKMSMasterKey string `xml:"DefaultKMSMasterKey"`
        } `xml:"SSE-KMS"`
}

type Rule struct {
        ID                             string                         `xml:"ID"`
        Filter                         Filter                         `xml:"Filter"`
        Status                         string                         `xml:"Status"`
        Transition                     []Transition                   `xml:"Transition"`
        Expiration                     []Expiration                   `xml:"Expiration"`
        AbortIncompleteMultipartUpload AbortIncompleteMultipartUpload `xml:"AbortIncompleteMultipartUpload"`
}

type Filter struct {
        Prefix string `xml:"Prefix"`
}

type Transition struct {
        Days         int32  `xml:"Days"`
        StorageClass string `xml:"StorageClass"`
        Backend      string `xml:"Backend"`
}

type Expiration struct {
        Days int32 `xml:"Days"`
        //Delete marker will be used in later release
        //ExpiredObjectDeleteMarker string   `xml:"ExpiredObjectDeleteMArker"`
}

type AbortIncompleteMultipartUpload struct {
        DaysAfterInitiation int32 `xml:"DaysAfterInitiation"`
}

type StorageClass struct {
        Name string `xml:"Name"`
        Tier int32  `xml:"Tier"`
}

type ListStorageClasses struct {
        Xmlns   string         `xml:"xmlns,attr"`
        Classes []StorageClass `xml:"Class"`
}

type VersioningConfiguration struct {
        XMLName xml.Name `xml:"VersioningConfiguration"`
        Status  string   `xml:"Status"`
}
</pre>
		
		<pre class="file" id="file99" style="display: none">package utils

import (
        "crypto/aes"
        "crypto/cipher"
        "crypto/rand"
        "io"
)
import log "github.com/sirupsen/logrus"

func EncryptWithAES256RandomKey(data []byte, key []byte) (error, []byte) <span class="cov0" title="0">{
        // use the key, get the cipher
        cipherBlock, cipherErr := aes.NewCipher(key)
        if cipherErr != nil </span><span class="cov0" title="0">{
                log.Errorf("Encryption error, cipher not generated")
                return cipherErr, nil
        }</span>
        // use the cipher block to encrypt
        // gcm or Galois/Counter Mode, is a mode of operation
        // for symmetric key cryptographic block ciphers
        // https://en.wikipedia.org/wiki/Galois/Counter_Mode
        <span class="cov0" title="0">aesgcm, gcmErr := cipher.NewGCM(cipherBlock)
        if gcmErr != nil </span><span class="cov0" title="0">{
                log.Errorf("Encryption error, GCM not generated")
                return gcmErr, nil
        }</span>
        // NonceSize is default 12 bytes
        <span class="cov0" title="0">nonce := make([]byte, aesgcm.NonceSize())
        _, nonceErr := io.ReadFull(rand.Reader, nonce)
        if nonceErr != nil </span><span class="cov0" title="0">{
                log.Errorf("Encryption error, GCM nonce not created")
                return nonceErr, nil
        }</span>

        // use the aes gcm to seal the data
        <span class="cov0" title="0">encBytes := aesgcm.Seal(nonce, nonce, data, nil)
        return nil, encBytes</span>
}

func DecryptWithAES256(data []byte, key []byte) (error, []byte) <span class="cov0" title="0">{
        // use the key, get the cipher
        cipherBlock, cipherErr := aes.NewCipher(key)
        if cipherErr != nil </span><span class="cov0" title="0">{
                log.Errorf("Decryption error, cipher not generated")
                return cipherErr, nil
        }</span>
        // use the cipher block to decrypt
        // gcm or Galois/Counter Mode, is a mode of operation
        // for symmetric key cryptographic block ciphers
        // https://en.wikipedia.org/wiki/Galois/Counter_Mode
        <span class="cov0" title="0">aesgcm, gcmErr := cipher.NewGCM(cipherBlock)
        if gcmErr != nil </span><span class="cov0" title="0">{
                log.Errorf("Decryption error, GCM not generated")
                return gcmErr, nil
        }</span>
        <span class="cov0" title="0">nonceSize := aesgcm.NonceSize()
        nonce, ciphertext := data[:nonceSize], data[nonceSize:]
        // use the aes gcm to open the data
        decBytes, decErr := aesgcm.Open(nil, nonce, ciphertext, nil)
        if decErr != nil </span><span class="cov0" title="0">{
                log.Errorf("Decryption error during open %s", decErr)
                return decErr, nil
        }</span>
        <span class="cov0" title="0">return decErr, decBytes</span>
}

func GetRandom32BitKey() ([]byte, error) <span class="cov0" title="0">{
        key := make([]byte, 32)

        _, err := rand.Read(key)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("Error generating random 32 bit key %s", err)
                return nil, err
        }</span>
        <span class="cov0" title="0">log.Infof("Generated random 32 bit key")
        return key, nil</span>
}


</pre>
		
		<pre class="file" id="file100" style="display: none">// Copyright 2019 The soda Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package utils

import (
        "context"
        "crypto/md5"
        "encoding/hex"
        "github.com/soda/multi-cloud/backend/proto"
        log "github.com/sirupsen/logrus"
)

type Database struct {
        Credential string `conf:"credential,username:password@tcp(ip:port)/dbname"`
        Driver     string `conf:"driver,mongodb"`
        Endpoint   string `conf:"endpoint,localhost:27017"`
}

// Tier1, Tier99 and Tier999 just like the tiers of hot, warm, cold.
// In the future, we will provide the ability for users to add new storage tiers, if we use 1, 2 and 3, then no space for new storage tiers.
const (
        Tier1   = 1
        Tier99  = 99
        Tier999 = 999
)

const (
        AWS_STANDARD    = "STANDARD"
        AWS_STANDARD_IA = "STANDARD_IA"
        AWS_GLACIER     = "GLACIER"
)

const (
        CEPH_STANDARD = "STDANDARD"
)

const (
        GCS_MULTI_REGIONAL = "MULTI_REGIONAL"
        GCS_REGIONAL       = "REGIONAL"
        GCS_NEARLINE       = "NEARLINE"
        GCS_COLDLINE       = "COLDLINE"
)

//Object Storage Type
const (
        OSTYPE_soda       = "soda"
        OSTYPE_AWS           = "aws-s3"
        OSTYPE_Azure         = "azure-blob"
        OSTYPE_OBS           = "hw-obs"
        OSTYPE_GCS           = "gcp-s3"
        OSTYPE_CEPH          = "ceph-s3"
        OSTYPE_FUSIONSTORAGE = "fusionstorage-object"
)

const (
        DBKEY_DELETEMARKER   = "isdeletemarker"
        DBKEY_INITFLAG       = "initflag"
        DBKEY_OBJECTKEY      = "objectkey"
        DBKEY_UPLOADID       = "uploadid"
        DBKEY_LASTMODIFIED   = "lastmodified"
        DBKEY_SUPPOSEDSTATUS = "supposedstatus"
        DBKEY_LOCKOBJ_OBJKEY = "objkey"
        DBKEY_BUCKET         = "bucket"
        DBKEY_INITTIME       = "inittime"
        DBKEY_NAME           = "name"
        DBKEY_LIFECYCLE      = "lifecycleconfiguration"
        DBKEY_ID             = "id"
)

type ObjsCountInfo struct {
        Size  int64
        Count int64
}

const (
        MaxObjectList  = 1000 // Limit number of objects in a listObjectsResponse.
        MaxUploadsList = 1000 // Limit number of uploads in a listUploadsResponse.
        MaxPartsList   = 1000 // Limit number of parts in a listPartsResponse.
)

const (
        VersioningEnabled   = "Enabled"
        VersioningDisabled  = "Disabled"
        VersioningSuspended = "Suspended"
)

type ListObjsAppendInfo struct {
        Prefixes   []string
        Truncated  bool
        NextMarker string
}

const (
        MoveType_Invalid = iota
        MoveType_MoveCrossBuckets
        MoveType_ChangeLocation
        MoveType_ChangeStorageTier
)

const (
        RequestType_Lifecycle = "lifecycle"
)

func Md5Content(data []byte) string <span class="cov0" title="0">{
        md5Ctx := md5.New()
        md5Ctx.Write(data)
        cipherStr := md5Ctx.Sum(nil)
        //value := base64.StdEncoding.EncodeToString(cipherStr)
        value := hex.EncodeToString(cipherStr)
        return value
}</span>

func GetBackend(ctx context.Context, backedClient backend.BackendService, backendName string) (*backend.BackendDetail,
        error) <span class="cov0" title="0">{
        log.Infof("backendName is %v:\n", backendName)
        backendRep, backendErr := backedClient.ListBackend(ctx, &amp;backend.ListBackendRequest{
                Offset: 0,
                Limit:  1,
                Filter: map[string]string{"name": backendName}})
        log.Infof("backendErr is %v:", backendErr)
        if backendErr != nil </span><span class="cov0" title="0">{
                log.Errorf("get backend %s failed.", backendName)
                return nil, backendErr
        }</span>
        <span class="cov0" title="0">log.Infof("backendRep is %v:", backendRep)
        backend := backendRep.Backends[0]
        return backend, nil</span>
}
</pre>
		
		<pre class="file" id="file101" style="display: none">// Code generated by protoc-gen-micro. DO NOT EDIT.
// source: s3.proto

/*
Package s3 is a generated protocol buffer package.

It is generated from these files:
        s3.proto

It has these top-level messages:
        ListObjectPartsRequest
        Part
        ListObjectPartsResponse
        AbortMultipartRequest
        CompletePart
        CompleteMultipartRequest
        CompleteMultipartResponse
        InitMultiPartRequest
        InitMultiPartResponse
        PutDataStream
        UploadPartRequest
        UploadPartResponse
        CopyObjectRequest
        CopyObjectResponse
        MoveObjectRequest
        MoveObjectResponse
        PutObjectRequest
        GetObjectResponse
        GetObjectMetaResult
        PutObjectResponse
        PutBucketACLRequest
        BucketACL
        BucketVersioning
        ObjACL
        PutObjACLRequest
        BaseBucketRequest
        BaseObjRequest
        CopyObjPartRequest
        CopyObjPartResponse
        ServerSideEncryption
        RedirectAllRequestsTo
        Redirect
        Condition
        RoutingRules
        WebsiteConfiguration
        CORSConfiguration
        Destination
        ReplicationRole
        ReplicationConfiguration
        Tag
        LifecycleFilter
        Action
        AbortMultipartUpload
        LifecycleRule
        PutBucketLifecycleRequest
        GetBucketLifecycleResponse
        ReplicationInfo
        Acl
        GetBucketResponse
        Bucket
        Partion
        Version
        Object
        ListBucketsResponse
        BaseResponse
        BaseRequest
        ListObjectsRequest
        ListObjectsResponse
        CountObjectsResponse
        DeleteObjectInput
        DeleteObjectOutput
        GetObjectInput
        MultipartUpload
        ListParts
        TList
        Tier2ClassName
        GetTierMapResponse
        UpdateObjMetaRequest
        StorageClass
        GetStorageClassesResponse
        GetBackendTypeByTierRequest
        GetBackendTypeByTierResponse
        MultipartUploadRecord
        ListBucketUploadRequest
        Owner
        Upload
        ListBucketUploadResult
        ListBucketUploadResponse
*/
package s3

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
        client "github.com/micro/go-micro/client"
        server "github.com/micro/go-micro/server"
        context "context"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ client.Option
var _ server.Option

// Client API for S3 service

type S3Service interface {
        ListBuckets(ctx context.Context, in *BaseRequest, opts ...client.CallOption) (*ListBucketsResponse, error)
        CreateBucket(ctx context.Context, in *Bucket, opts ...client.CallOption) (*BaseResponse, error)
        DeleteBucket(ctx context.Context, in *Bucket, opts ...client.CallOption) (*BaseResponse, error)
        GetBucket(ctx context.Context, in *Bucket, opts ...client.CallOption) (*GetBucketResponse, error)
        GetObjectMeta(ctx context.Context, in *Object, opts ...client.CallOption) (*GetObjectMetaResult, error)
        UpdateObjectMeta(ctx context.Context, in *Object, opts ...client.CallOption) (*PutObjectResponse, error)
        ListObjects(ctx context.Context, in *ListObjectsRequest, opts ...client.CallOption) (*ListObjectsResponse, error)
        CountObjects(ctx context.Context, in *ListObjectsRequest, opts ...client.CallOption) (*CountObjectsResponse, error)
        PutObject(ctx context.Context, opts ...client.CallOption) (S3_PutObjectService, error)
        UpdateObject(ctx context.Context, in *Object, opts ...client.CallOption) (*BaseResponse, error)
        GetObject(ctx context.Context, in *GetObjectInput, opts ...client.CallOption) (S3_GetObjectService, error)
        DeleteObject(ctx context.Context, in *DeleteObjectInput, opts ...client.CallOption) (*DeleteObjectOutput, error)
        GetTierMap(ctx context.Context, in *BaseRequest, opts ...client.CallOption) (*GetTierMapResponse, error)
        UpdateObjMeta(ctx context.Context, in *UpdateObjMetaRequest, opts ...client.CallOption) (*BaseResponse, error)
        GetStorageClasses(ctx context.Context, in *BaseRequest, opts ...client.CallOption) (*GetStorageClassesResponse, error)
        GetBackendTypeByTier(ctx context.Context, in *GetBackendTypeByTierRequest, opts ...client.CallOption) (*GetBackendTypeByTierResponse, error)
        DeleteBucketLifecycle(ctx context.Context, in *BaseRequest, opts ...client.CallOption) (*BaseResponse, error)
        PutBucketLifecycle(ctx context.Context, in *PutBucketLifecycleRequest, opts ...client.CallOption) (*BaseResponse, error)
        GetBucketLifecycle(ctx context.Context, in *BaseRequest, opts ...client.CallOption) (*GetBucketLifecycleResponse, error)
        ListBucketLifecycle(ctx context.Context, in *BaseRequest, opts ...client.CallOption) (*ListBucketsResponse, error)
        UpdateBucket(ctx context.Context, in *Bucket, opts ...client.CallOption) (*BaseResponse, error)
        ListBucketUploadRecords(ctx context.Context, in *ListBucketUploadRequest, opts ...client.CallOption) (*ListBucketUploadResponse, error)
        InitMultipartUpload(ctx context.Context, in *InitMultiPartRequest, opts ...client.CallOption) (*InitMultiPartResponse, error)
        AbortMultipartUpload(ctx context.Context, in *AbortMultipartRequest, opts ...client.CallOption) (*BaseResponse, error)
        CompleteMultipartUpload(ctx context.Context, in *CompleteMultipartRequest, opts ...client.CallOption) (*CompleteMultipartResponse, error)
        UploadPart(ctx context.Context, opts ...client.CallOption) (S3_UploadPartService, error)
        ListObjectParts(ctx context.Context, in *ListObjectPartsRequest, opts ...client.CallOption) (*ListObjectPartsResponse, error)
        AppendObject(ctx context.Context, in *BaseRequest, opts ...client.CallOption) (*BaseResponse, error)
        PostObject(ctx context.Context, in *BaseRequest, opts ...client.CallOption) (*BaseResponse, error)
        // For lifecycle, may need some change.
        AddUploadRecord(ctx context.Context, in *MultipartUploadRecord, opts ...client.CallOption) (*BaseResponse, error)
        DeleteUploadRecord(ctx context.Context, in *MultipartUploadRecord, opts ...client.CallOption) (*BaseResponse, error)
        HeadObject(ctx context.Context, in *BaseObjRequest, opts ...client.CallOption) (*Object, error)
        MoveObject(ctx context.Context, in *MoveObjectRequest, opts ...client.CallOption) (*MoveObjectResponse, error)
        CopyObject(ctx context.Context, in *CopyObjectRequest, opts ...client.CallOption) (*CopyObjectResponse, error)
        CopyObjPart(ctx context.Context, in *CopyObjPartRequest, opts ...client.CallOption) (*CopyObjPartResponse, error)
        PutObjACL(ctx context.Context, in *PutObjACLRequest, opts ...client.CallOption) (*BaseResponse, error)
        GetObjACL(ctx context.Context, in *BaseObjRequest, opts ...client.CallOption) (*ObjACL, error)
        GetBucketLocation(ctx context.Context, in *BaseRequest, opts ...client.CallOption) (*BaseResponse, error)
        GetBucketVersioning(ctx context.Context, in *BaseBucketRequest, opts ...client.CallOption) (*BucketVersioning, error)
        PutBucketACL(ctx context.Context, in *PutBucketACLRequest, opts ...client.CallOption) (*BaseResponse, error)
        GetBucketACL(ctx context.Context, in *BaseBucketRequest, opts ...client.CallOption) (*BucketACL, error)
        PutBucketCORS(ctx context.Context, in *BaseRequest, opts ...client.CallOption) (*BaseResponse, error)
        GetBucketCORS(ctx context.Context, in *BaseRequest, opts ...client.CallOption) (*BaseResponse, error)
        DeleteBucketCORS(ctx context.Context, in *BaseRequest, opts ...client.CallOption) (*BaseResponse, error)
        PutBucketPolicy(ctx context.Context, in *BaseRequest, opts ...client.CallOption) (*BaseResponse, error)
        GetBucketPolicy(ctx context.Context, in *BaseRequest, opts ...client.CallOption) (*BaseResponse, error)
        DeleteBucketPolicy(ctx context.Context, in *BaseRequest, opts ...client.CallOption) (*BaseResponse, error)
        HeadBucket(ctx context.Context, in *BaseRequest, opts ...client.CallOption) (*Bucket, error)
}

type s3Service struct {
        c    client.Client
        name string
}

func NewS3Service(name string, c client.Client) S3Service <span class="cov8" title="1">{
        if c == nil </span><span class="cov0" title="0">{
                c = client.NewClient()
        }</span>
        <span class="cov8" title="1">if len(name) == 0 </span><span class="cov0" title="0">{
                name = "s3"
        }</span>
        <span class="cov8" title="1">return &amp;s3Service{
                c:    c,
                name: name,
        }</span>
}

func (c *s3Service) ListBuckets(ctx context.Context, in *BaseRequest, opts ...client.CallOption) (*ListBucketsResponse, error) <span class="cov8" title="1">{
        req := c.c.NewRequest(c.name, "S3.ListBuckets", in)
        out := new(ListBucketsResponse)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (c *s3Service) CreateBucket(ctx context.Context, in *Bucket, opts ...client.CallOption) (*BaseResponse, error) <span class="cov8" title="1">{
        req := c.c.NewRequest(c.name, "S3.CreateBucket", in)
        out := new(BaseResponse)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (c *s3Service) DeleteBucket(ctx context.Context, in *Bucket, opts ...client.CallOption) (*BaseResponse, error) <span class="cov0" title="0">{
        req := c.c.NewRequest(c.name, "S3.DeleteBucket", in)
        out := new(BaseResponse)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *s3Service) GetBucket(ctx context.Context, in *Bucket, opts ...client.CallOption) (*GetBucketResponse, error) <span class="cov8" title="1">{
        req := c.c.NewRequest(c.name, "S3.GetBucket", in)
        out := new(GetBucketResponse)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (c *s3Service) GetObjectMeta(ctx context.Context, in *Object, opts ...client.CallOption) (*GetObjectMetaResult, error) <span class="cov0" title="0">{
        req := c.c.NewRequest(c.name, "S3.GetObjectMeta", in)
        out := new(GetObjectMetaResult)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *s3Service) UpdateObjectMeta(ctx context.Context, in *Object, opts ...client.CallOption) (*PutObjectResponse, error) <span class="cov0" title="0">{
        req := c.c.NewRequest(c.name, "S3.UpdateObjectMeta", in)
        out := new(PutObjectResponse)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *s3Service) ListObjects(ctx context.Context, in *ListObjectsRequest, opts ...client.CallOption) (*ListObjectsResponse, error) <span class="cov8" title="1">{
        req := c.c.NewRequest(c.name, "S3.ListObjects", in)
        out := new(ListObjectsResponse)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (c *s3Service) CountObjects(ctx context.Context, in *ListObjectsRequest, opts ...client.CallOption) (*CountObjectsResponse, error) <span class="cov0" title="0">{
        req := c.c.NewRequest(c.name, "S3.CountObjects", in)
        out := new(CountObjectsResponse)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *s3Service) PutObject(ctx context.Context, opts ...client.CallOption) (S3_PutObjectService, error) <span class="cov8" title="1">{
        req := c.c.NewRequest(c.name, "S3.PutObject", &amp;PutDataStream{})
        stream, err := c.c.Stream(ctx, req, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;s3ServicePutObject{stream}, nil</span>
}

type S3_PutObjectService interface {
        SendMsg(interface{}) error
        RecvMsg(interface{}) error
        Close() error
        Send(*PutDataStream) error
}

type s3ServicePutObject struct {
        stream client.Stream
}

func (x *s3ServicePutObject) Close() error <span class="cov8" title="1">{
        return x.stream.Close()
}</span>

func (x *s3ServicePutObject) SendMsg(m interface{}) error <span class="cov8" title="1">{
        return x.stream.Send(m)
}</span>

func (x *s3ServicePutObject) RecvMsg(m interface{}) error <span class="cov8" title="1">{
        return x.stream.Recv(m)
}</span>

func (x *s3ServicePutObject) Send(m *PutDataStream) error <span class="cov8" title="1">{
        return x.stream.Send(m)
}</span>

func (c *s3Service) UpdateObject(ctx context.Context, in *Object, opts ...client.CallOption) (*BaseResponse, error) <span class="cov0" title="0">{
        req := c.c.NewRequest(c.name, "S3.UpdateObject", in)
        out := new(BaseResponse)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *s3Service) GetObject(ctx context.Context, in *GetObjectInput, opts ...client.CallOption) (S3_GetObjectService, error) <span class="cov0" title="0">{
        req := c.c.NewRequest(c.name, "S3.GetObject", &amp;GetObjectInput{})
        stream, err := c.c.Stream(ctx, req, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if err := stream.Send(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;s3ServiceGetObject{stream}, nil</span>
}

type S3_GetObjectService interface {
        SendMsg(interface{}) error
        RecvMsg(interface{}) error
        Close() error
        Recv() (*GetObjectResponse, error)
}

type s3ServiceGetObject struct {
        stream client.Stream
}

func (x *s3ServiceGetObject) Close() error <span class="cov0" title="0">{
        return x.stream.Close()
}</span>

func (x *s3ServiceGetObject) SendMsg(m interface{}) error <span class="cov0" title="0">{
        return x.stream.Send(m)
}</span>

func (x *s3ServiceGetObject) RecvMsg(m interface{}) error <span class="cov0" title="0">{
        return x.stream.Recv(m)
}</span>

func (x *s3ServiceGetObject) Recv() (*GetObjectResponse, error) <span class="cov0" title="0">{
        m := new(GetObjectResponse)
        err := x.stream.Recv(m)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return m, nil</span>
}

func (c *s3Service) DeleteObject(ctx context.Context, in *DeleteObjectInput, opts ...client.CallOption) (*DeleteObjectOutput, error) <span class="cov0" title="0">{
        req := c.c.NewRequest(c.name, "S3.DeleteObject", in)
        out := new(DeleteObjectOutput)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *s3Service) GetTierMap(ctx context.Context, in *BaseRequest, opts ...client.CallOption) (*GetTierMapResponse, error) <span class="cov0" title="0">{
        req := c.c.NewRequest(c.name, "S3.GetTierMap", in)
        out := new(GetTierMapResponse)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *s3Service) UpdateObjMeta(ctx context.Context, in *UpdateObjMetaRequest, opts ...client.CallOption) (*BaseResponse, error) <span class="cov0" title="0">{
        req := c.c.NewRequest(c.name, "S3.UpdateObjMeta", in)
        out := new(BaseResponse)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *s3Service) GetStorageClasses(ctx context.Context, in *BaseRequest, opts ...client.CallOption) (*GetStorageClassesResponse, error) <span class="cov0" title="0">{
        req := c.c.NewRequest(c.name, "S3.GetStorageClasses", in)
        out := new(GetStorageClassesResponse)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *s3Service) GetBackendTypeByTier(ctx context.Context, in *GetBackendTypeByTierRequest, opts ...client.CallOption) (*GetBackendTypeByTierResponse, error) <span class="cov0" title="0">{
        req := c.c.NewRequest(c.name, "S3.GetBackendTypeByTier", in)
        out := new(GetBackendTypeByTierResponse)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *s3Service) DeleteBucketLifecycle(ctx context.Context, in *BaseRequest, opts ...client.CallOption) (*BaseResponse, error) <span class="cov0" title="0">{
        req := c.c.NewRequest(c.name, "S3.DeleteBucketLifecycle", in)
        out := new(BaseResponse)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *s3Service) PutBucketLifecycle(ctx context.Context, in *PutBucketLifecycleRequest, opts ...client.CallOption) (*BaseResponse, error) <span class="cov0" title="0">{
        req := c.c.NewRequest(c.name, "S3.PutBucketLifecycle", in)
        out := new(BaseResponse)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *s3Service) GetBucketLifecycle(ctx context.Context, in *BaseRequest, opts ...client.CallOption) (*GetBucketLifecycleResponse, error) <span class="cov8" title="1">{
        req := c.c.NewRequest(c.name, "S3.GetBucketLifecycle", in)
        out := new(GetBucketLifecycleResponse)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (c *s3Service) ListBucketLifecycle(ctx context.Context, in *BaseRequest, opts ...client.CallOption) (*ListBucketsResponse, error) <span class="cov0" title="0">{
        req := c.c.NewRequest(c.name, "S3.ListBucketLifecycle", in)
        out := new(ListBucketsResponse)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *s3Service) UpdateBucket(ctx context.Context, in *Bucket, opts ...client.CallOption) (*BaseResponse, error) <span class="cov0" title="0">{
        req := c.c.NewRequest(c.name, "S3.UpdateBucket", in)
        out := new(BaseResponse)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *s3Service) ListBucketUploadRecords(ctx context.Context, in *ListBucketUploadRequest, opts ...client.CallOption) (*ListBucketUploadResponse, error) <span class="cov0" title="0">{
        req := c.c.NewRequest(c.name, "S3.ListBucketUploadRecords", in)
        out := new(ListBucketUploadResponse)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *s3Service) InitMultipartUpload(ctx context.Context, in *InitMultiPartRequest, opts ...client.CallOption) (*InitMultiPartResponse, error) <span class="cov0" title="0">{
        req := c.c.NewRequest(c.name, "S3.InitMultipartUpload", in)
        out := new(InitMultiPartResponse)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *s3Service) AbortMultipartUpload(ctx context.Context, in *AbortMultipartRequest, opts ...client.CallOption) (*BaseResponse, error) <span class="cov0" title="0">{
        req := c.c.NewRequest(c.name, "S3.AbortMultipartUpload", in)
        out := new(BaseResponse)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *s3Service) CompleteMultipartUpload(ctx context.Context, in *CompleteMultipartRequest, opts ...client.CallOption) (*CompleteMultipartResponse, error) <span class="cov0" title="0">{
        req := c.c.NewRequest(c.name, "S3.CompleteMultipartUpload", in)
        out := new(CompleteMultipartResponse)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *s3Service) UploadPart(ctx context.Context, opts ...client.CallOption) (S3_UploadPartService, error) <span class="cov0" title="0">{
        req := c.c.NewRequest(c.name, "S3.UploadPart", &amp;PutDataStream{})
        stream, err := c.c.Stream(ctx, req, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;s3ServiceUploadPart{stream}, nil</span>
}

type S3_UploadPartService interface {
        SendMsg(interface{}) error
        RecvMsg(interface{}) error
        Close() error
        Send(*PutDataStream) error
}

type s3ServiceUploadPart struct {
        stream client.Stream
}

func (x *s3ServiceUploadPart) Close() error <span class="cov0" title="0">{
        return x.stream.Close()
}</span>

func (x *s3ServiceUploadPart) SendMsg(m interface{}) error <span class="cov0" title="0">{
        return x.stream.Send(m)
}</span>

func (x *s3ServiceUploadPart) RecvMsg(m interface{}) error <span class="cov0" title="0">{
        return x.stream.Recv(m)
}</span>

func (x *s3ServiceUploadPart) Send(m *PutDataStream) error <span class="cov0" title="0">{
        return x.stream.Send(m)
}</span>

func (c *s3Service) ListObjectParts(ctx context.Context, in *ListObjectPartsRequest, opts ...client.CallOption) (*ListObjectPartsResponse, error) <span class="cov0" title="0">{
        req := c.c.NewRequest(c.name, "S3.ListObjectParts", in)
        out := new(ListObjectPartsResponse)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *s3Service) AppendObject(ctx context.Context, in *BaseRequest, opts ...client.CallOption) (*BaseResponse, error) <span class="cov0" title="0">{
        req := c.c.NewRequest(c.name, "S3.AppendObject", in)
        out := new(BaseResponse)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *s3Service) PostObject(ctx context.Context, in *BaseRequest, opts ...client.CallOption) (*BaseResponse, error) <span class="cov0" title="0">{
        req := c.c.NewRequest(c.name, "S3.PostObject", in)
        out := new(BaseResponse)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *s3Service) AddUploadRecord(ctx context.Context, in *MultipartUploadRecord, opts ...client.CallOption) (*BaseResponse, error) <span class="cov0" title="0">{
        req := c.c.NewRequest(c.name, "S3.AddUploadRecord", in)
        out := new(BaseResponse)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *s3Service) DeleteUploadRecord(ctx context.Context, in *MultipartUploadRecord, opts ...client.CallOption) (*BaseResponse, error) <span class="cov0" title="0">{
        req := c.c.NewRequest(c.name, "S3.DeleteUploadRecord", in)
        out := new(BaseResponse)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *s3Service) HeadObject(ctx context.Context, in *BaseObjRequest, opts ...client.CallOption) (*Object, error) <span class="cov0" title="0">{
        req := c.c.NewRequest(c.name, "S3.HeadObject", in)
        out := new(Object)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *s3Service) MoveObject(ctx context.Context, in *MoveObjectRequest, opts ...client.CallOption) (*MoveObjectResponse, error) <span class="cov0" title="0">{
        req := c.c.NewRequest(c.name, "S3.MoveObject", in)
        out := new(MoveObjectResponse)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *s3Service) CopyObject(ctx context.Context, in *CopyObjectRequest, opts ...client.CallOption) (*CopyObjectResponse, error) <span class="cov0" title="0">{
        req := c.c.NewRequest(c.name, "S3.CopyObject", in)
        out := new(CopyObjectResponse)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *s3Service) CopyObjPart(ctx context.Context, in *CopyObjPartRequest, opts ...client.CallOption) (*CopyObjPartResponse, error) <span class="cov0" title="0">{
        req := c.c.NewRequest(c.name, "S3.CopyObjPart", in)
        out := new(CopyObjPartResponse)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *s3Service) PutObjACL(ctx context.Context, in *PutObjACLRequest, opts ...client.CallOption) (*BaseResponse, error) <span class="cov0" title="0">{
        req := c.c.NewRequest(c.name, "S3.PutObjACL", in)
        out := new(BaseResponse)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *s3Service) GetObjACL(ctx context.Context, in *BaseObjRequest, opts ...client.CallOption) (*ObjACL, error) <span class="cov0" title="0">{
        req := c.c.NewRequest(c.name, "S3.GetObjACL", in)
        out := new(ObjACL)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *s3Service) GetBucketLocation(ctx context.Context, in *BaseRequest, opts ...client.CallOption) (*BaseResponse, error) <span class="cov0" title="0">{
        req := c.c.NewRequest(c.name, "S3.GetBucketLocation", in)
        out := new(BaseResponse)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *s3Service) GetBucketVersioning(ctx context.Context, in *BaseBucketRequest, opts ...client.CallOption) (*BucketVersioning, error) <span class="cov0" title="0">{
        req := c.c.NewRequest(c.name, "S3.GetBucketVersioning", in)
        out := new(BucketVersioning)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *s3Service) PutBucketACL(ctx context.Context, in *PutBucketACLRequest, opts ...client.CallOption) (*BaseResponse, error) <span class="cov0" title="0">{
        req := c.c.NewRequest(c.name, "S3.PutBucketACL", in)
        out := new(BaseResponse)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *s3Service) GetBucketACL(ctx context.Context, in *BaseBucketRequest, opts ...client.CallOption) (*BucketACL, error) <span class="cov0" title="0">{
        req := c.c.NewRequest(c.name, "S3.GetBucketACL", in)
        out := new(BucketACL)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *s3Service) PutBucketCORS(ctx context.Context, in *BaseRequest, opts ...client.CallOption) (*BaseResponse, error) <span class="cov0" title="0">{
        req := c.c.NewRequest(c.name, "S3.PutBucketCORS", in)
        out := new(BaseResponse)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *s3Service) GetBucketCORS(ctx context.Context, in *BaseRequest, opts ...client.CallOption) (*BaseResponse, error) <span class="cov0" title="0">{
        req := c.c.NewRequest(c.name, "S3.GetBucketCORS", in)
        out := new(BaseResponse)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *s3Service) DeleteBucketCORS(ctx context.Context, in *BaseRequest, opts ...client.CallOption) (*BaseResponse, error) <span class="cov0" title="0">{
        req := c.c.NewRequest(c.name, "S3.DeleteBucketCORS", in)
        out := new(BaseResponse)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *s3Service) PutBucketPolicy(ctx context.Context, in *BaseRequest, opts ...client.CallOption) (*BaseResponse, error) <span class="cov0" title="0">{
        req := c.c.NewRequest(c.name, "S3.PutBucketPolicy", in)
        out := new(BaseResponse)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *s3Service) GetBucketPolicy(ctx context.Context, in *BaseRequest, opts ...client.CallOption) (*BaseResponse, error) <span class="cov0" title="0">{
        req := c.c.NewRequest(c.name, "S3.GetBucketPolicy", in)
        out := new(BaseResponse)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *s3Service) DeleteBucketPolicy(ctx context.Context, in *BaseRequest, opts ...client.CallOption) (*BaseResponse, error) <span class="cov0" title="0">{
        req := c.c.NewRequest(c.name, "S3.DeleteBucketPolicy", in)
        out := new(BaseResponse)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *s3Service) HeadBucket(ctx context.Context, in *BaseRequest, opts ...client.CallOption) (*Bucket, error) <span class="cov0" title="0">{
        req := c.c.NewRequest(c.name, "S3.HeadBucket", in)
        out := new(Bucket)
        err := c.c.Call(ctx, req, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// Server API for S3 service

type S3Handler interface {
        ListBuckets(context.Context, *BaseRequest, *ListBucketsResponse) error
        CreateBucket(context.Context, *Bucket, *BaseResponse) error
        DeleteBucket(context.Context, *Bucket, *BaseResponse) error
        GetBucket(context.Context, *Bucket, *GetBucketResponse) error
        GetObjectMeta(context.Context, *Object, *GetObjectMetaResult) error
        UpdateObjectMeta(context.Context, *Object, *PutObjectResponse) error
        ListObjects(context.Context, *ListObjectsRequest, *ListObjectsResponse) error
        CountObjects(context.Context, *ListObjectsRequest, *CountObjectsResponse) error
        PutObject(context.Context, S3_PutObjectStream) error
        UpdateObject(context.Context, *Object, *BaseResponse) error
        GetObject(context.Context, *GetObjectInput, S3_GetObjectStream) error
        DeleteObject(context.Context, *DeleteObjectInput, *DeleteObjectOutput) error
        GetTierMap(context.Context, *BaseRequest, *GetTierMapResponse) error
        UpdateObjMeta(context.Context, *UpdateObjMetaRequest, *BaseResponse) error
        GetStorageClasses(context.Context, *BaseRequest, *GetStorageClassesResponse) error
        GetBackendTypeByTier(context.Context, *GetBackendTypeByTierRequest, *GetBackendTypeByTierResponse) error
        DeleteBucketLifecycle(context.Context, *BaseRequest, *BaseResponse) error
        PutBucketLifecycle(context.Context, *PutBucketLifecycleRequest, *BaseResponse) error
        GetBucketLifecycle(context.Context, *BaseRequest, *GetBucketLifecycleResponse) error
        ListBucketLifecycle(context.Context, *BaseRequest, *ListBucketsResponse) error
        UpdateBucket(context.Context, *Bucket, *BaseResponse) error
        ListBucketUploadRecords(context.Context, *ListBucketUploadRequest, *ListBucketUploadResponse) error
        InitMultipartUpload(context.Context, *InitMultiPartRequest, *InitMultiPartResponse) error
        AbortMultipartUpload(context.Context, *AbortMultipartRequest, *BaseResponse) error
        CompleteMultipartUpload(context.Context, *CompleteMultipartRequest, *CompleteMultipartResponse) error
        UploadPart(context.Context, S3_UploadPartStream) error
        ListObjectParts(context.Context, *ListObjectPartsRequest, *ListObjectPartsResponse) error
        AppendObject(context.Context, *BaseRequest, *BaseResponse) error
        PostObject(context.Context, *BaseRequest, *BaseResponse) error
        // For lifecycle, may need some change.
        AddUploadRecord(context.Context, *MultipartUploadRecord, *BaseResponse) error
        DeleteUploadRecord(context.Context, *MultipartUploadRecord, *BaseResponse) error
        HeadObject(context.Context, *BaseObjRequest, *Object) error
        MoveObject(context.Context, *MoveObjectRequest, *MoveObjectResponse) error
        CopyObject(context.Context, *CopyObjectRequest, *CopyObjectResponse) error
        CopyObjPart(context.Context, *CopyObjPartRequest, *CopyObjPartResponse) error
        PutObjACL(context.Context, *PutObjACLRequest, *BaseResponse) error
        GetObjACL(context.Context, *BaseObjRequest, *ObjACL) error
        GetBucketLocation(context.Context, *BaseRequest, *BaseResponse) error
        GetBucketVersioning(context.Context, *BaseBucketRequest, *BucketVersioning) error
        PutBucketACL(context.Context, *PutBucketACLRequest, *BaseResponse) error
        GetBucketACL(context.Context, *BaseBucketRequest, *BucketACL) error
        PutBucketCORS(context.Context, *BaseRequest, *BaseResponse) error
        GetBucketCORS(context.Context, *BaseRequest, *BaseResponse) error
        DeleteBucketCORS(context.Context, *BaseRequest, *BaseResponse) error
        PutBucketPolicy(context.Context, *BaseRequest, *BaseResponse) error
        GetBucketPolicy(context.Context, *BaseRequest, *BaseResponse) error
        DeleteBucketPolicy(context.Context, *BaseRequest, *BaseResponse) error
        HeadBucket(context.Context, *BaseRequest, *Bucket) error
}

func RegisterS3Handler(s server.Server, hdlr S3Handler, opts ...server.HandlerOption) error <span class="cov0" title="0">{
        type s3 interface {
                ListBuckets(ctx context.Context, in *BaseRequest, out *ListBucketsResponse) error
                CreateBucket(ctx context.Context, in *Bucket, out *BaseResponse) error
                DeleteBucket(ctx context.Context, in *Bucket, out *BaseResponse) error
                GetBucket(ctx context.Context, in *Bucket, out *GetBucketResponse) error
                GetObjectMeta(ctx context.Context, in *Object, out *GetObjectMetaResult) error
                UpdateObjectMeta(ctx context.Context, in *Object, out *PutObjectResponse) error
                ListObjects(ctx context.Context, in *ListObjectsRequest, out *ListObjectsResponse) error
                CountObjects(ctx context.Context, in *ListObjectsRequest, out *CountObjectsResponse) error
                PutObject(ctx context.Context, stream server.Stream) error
                UpdateObject(ctx context.Context, in *Object, out *BaseResponse) error
                GetObject(ctx context.Context, stream server.Stream) error
                DeleteObject(ctx context.Context, in *DeleteObjectInput, out *DeleteObjectOutput) error
                GetTierMap(ctx context.Context, in *BaseRequest, out *GetTierMapResponse) error
                UpdateObjMeta(ctx context.Context, in *UpdateObjMetaRequest, out *BaseResponse) error
                GetStorageClasses(ctx context.Context, in *BaseRequest, out *GetStorageClassesResponse) error
                GetBackendTypeByTier(ctx context.Context, in *GetBackendTypeByTierRequest, out *GetBackendTypeByTierResponse) error
                DeleteBucketLifecycle(ctx context.Context, in *BaseRequest, out *BaseResponse) error
                PutBucketLifecycle(ctx context.Context, in *PutBucketLifecycleRequest, out *BaseResponse) error
                GetBucketLifecycle(ctx context.Context, in *BaseRequest, out *GetBucketLifecycleResponse) error
                ListBucketLifecycle(ctx context.Context, in *BaseRequest, out *ListBucketsResponse) error
                UpdateBucket(ctx context.Context, in *Bucket, out *BaseResponse) error
                ListBucketUploadRecords(ctx context.Context, in *ListBucketUploadRequest, out *ListBucketUploadResponse) error
                InitMultipartUpload(ctx context.Context, in *InitMultiPartRequest, out *InitMultiPartResponse) error
                AbortMultipartUpload(ctx context.Context, in *AbortMultipartRequest, out *BaseResponse) error
                CompleteMultipartUpload(ctx context.Context, in *CompleteMultipartRequest, out *CompleteMultipartResponse) error
                UploadPart(ctx context.Context, stream server.Stream) error
                ListObjectParts(ctx context.Context, in *ListObjectPartsRequest, out *ListObjectPartsResponse) error
                AppendObject(ctx context.Context, in *BaseRequest, out *BaseResponse) error
                PostObject(ctx context.Context, in *BaseRequest, out *BaseResponse) error
                AddUploadRecord(ctx context.Context, in *MultipartUploadRecord, out *BaseResponse) error
                DeleteUploadRecord(ctx context.Context, in *MultipartUploadRecord, out *BaseResponse) error
                HeadObject(ctx context.Context, in *BaseObjRequest, out *Object) error
                MoveObject(ctx context.Context, in *MoveObjectRequest, out *MoveObjectResponse) error
                CopyObject(ctx context.Context, in *CopyObjectRequest, out *CopyObjectResponse) error
                CopyObjPart(ctx context.Context, in *CopyObjPartRequest, out *CopyObjPartResponse) error
                PutObjACL(ctx context.Context, in *PutObjACLRequest, out *BaseResponse) error
                GetObjACL(ctx context.Context, in *BaseObjRequest, out *ObjACL) error
                GetBucketLocation(ctx context.Context, in *BaseRequest, out *BaseResponse) error
                GetBucketVersioning(ctx context.Context, in *BaseBucketRequest, out *BucketVersioning) error
                PutBucketACL(ctx context.Context, in *PutBucketACLRequest, out *BaseResponse) error
                GetBucketACL(ctx context.Context, in *BaseBucketRequest, out *BucketACL) error
                PutBucketCORS(ctx context.Context, in *BaseRequest, out *BaseResponse) error
                GetBucketCORS(ctx context.Context, in *BaseRequest, out *BaseResponse) error
                DeleteBucketCORS(ctx context.Context, in *BaseRequest, out *BaseResponse) error
                PutBucketPolicy(ctx context.Context, in *BaseRequest, out *BaseResponse) error
                GetBucketPolicy(ctx context.Context, in *BaseRequest, out *BaseResponse) error
                DeleteBucketPolicy(ctx context.Context, in *BaseRequest, out *BaseResponse) error
                HeadBucket(ctx context.Context, in *BaseRequest, out *Bucket) error
        }
        type S3 struct {
                s3
        }
        h := &amp;s3Handler{hdlr}
        return s.Handle(s.NewHandler(&amp;S3{h}, opts...))
}</span>

type s3Handler struct {
        S3Handler
}

func (h *s3Handler) ListBuckets(ctx context.Context, in *BaseRequest, out *ListBucketsResponse) error <span class="cov0" title="0">{
        return h.S3Handler.ListBuckets(ctx, in, out)
}</span>

func (h *s3Handler) CreateBucket(ctx context.Context, in *Bucket, out *BaseResponse) error <span class="cov0" title="0">{
        return h.S3Handler.CreateBucket(ctx, in, out)
}</span>

func (h *s3Handler) DeleteBucket(ctx context.Context, in *Bucket, out *BaseResponse) error <span class="cov0" title="0">{
        return h.S3Handler.DeleteBucket(ctx, in, out)
}</span>

func (h *s3Handler) GetBucket(ctx context.Context, in *Bucket, out *GetBucketResponse) error <span class="cov0" title="0">{
        return h.S3Handler.GetBucket(ctx, in, out)
}</span>

func (h *s3Handler) GetObjectMeta(ctx context.Context, in *Object, out *GetObjectMetaResult) error <span class="cov0" title="0">{
        return h.S3Handler.GetObjectMeta(ctx, in, out)
}</span>

func (h *s3Handler) UpdateObjectMeta(ctx context.Context, in *Object, out *PutObjectResponse) error <span class="cov0" title="0">{
        return h.S3Handler.UpdateObjectMeta(ctx, in, out)
}</span>

func (h *s3Handler) ListObjects(ctx context.Context, in *ListObjectsRequest, out *ListObjectsResponse) error <span class="cov0" title="0">{
        return h.S3Handler.ListObjects(ctx, in, out)
}</span>

func (h *s3Handler) CountObjects(ctx context.Context, in *ListObjectsRequest, out *CountObjectsResponse) error <span class="cov0" title="0">{
        return h.S3Handler.CountObjects(ctx, in, out)
}</span>

func (h *s3Handler) PutObject(ctx context.Context, stream server.Stream) error <span class="cov0" title="0">{
        return h.S3Handler.PutObject(ctx, &amp;s3PutObjectStream{stream})
}</span>

type S3_PutObjectStream interface {
        SendMsg(interface{}) error
        RecvMsg(interface{}) error
        Close() error
        Recv() (*PutDataStream, error)
}

type s3PutObjectStream struct {
        stream server.Stream
}

func (x *s3PutObjectStream) Close() error <span class="cov0" title="0">{
        return x.stream.Close()
}</span>

func (x *s3PutObjectStream) SendMsg(m interface{}) error <span class="cov0" title="0">{
        return x.stream.Send(m)
}</span>

func (x *s3PutObjectStream) RecvMsg(m interface{}) error <span class="cov0" title="0">{
        return x.stream.Recv(m)
}</span>

func (x *s3PutObjectStream) Recv() (*PutDataStream, error) <span class="cov0" title="0">{
        m := new(PutDataStream)
        if err := x.stream.Recv(m); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return m, nil</span>
}

func (h *s3Handler) UpdateObject(ctx context.Context, in *Object, out *BaseResponse) error <span class="cov0" title="0">{
        return h.S3Handler.UpdateObject(ctx, in, out)
}</span>

func (h *s3Handler) GetObject(ctx context.Context, stream server.Stream) error <span class="cov0" title="0">{
        m := new(GetObjectInput)
        if err := stream.Recv(m); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return h.S3Handler.GetObject(ctx, m, &amp;s3GetObjectStream{stream})</span>
}

type S3_GetObjectStream interface {
        SendMsg(interface{}) error
        RecvMsg(interface{}) error
        Close() error
        Send(*GetObjectResponse) error
}

type s3GetObjectStream struct {
        stream server.Stream
}

func (x *s3GetObjectStream) Close() error <span class="cov0" title="0">{
        return x.stream.Close()
}</span>

func (x *s3GetObjectStream) SendMsg(m interface{}) error <span class="cov0" title="0">{
        return x.stream.Send(m)
}</span>

func (x *s3GetObjectStream) RecvMsg(m interface{}) error <span class="cov0" title="0">{
        return x.stream.Recv(m)
}</span>

func (x *s3GetObjectStream) Send(m *GetObjectResponse) error <span class="cov0" title="0">{
        return x.stream.Send(m)
}</span>

func (h *s3Handler) DeleteObject(ctx context.Context, in *DeleteObjectInput, out *DeleteObjectOutput) error <span class="cov0" title="0">{
        return h.S3Handler.DeleteObject(ctx, in, out)
}</span>

func (h *s3Handler) GetTierMap(ctx context.Context, in *BaseRequest, out *GetTierMapResponse) error <span class="cov0" title="0">{
        return h.S3Handler.GetTierMap(ctx, in, out)
}</span>

func (h *s3Handler) UpdateObjMeta(ctx context.Context, in *UpdateObjMetaRequest, out *BaseResponse) error <span class="cov0" title="0">{
        return h.S3Handler.UpdateObjMeta(ctx, in, out)
}</span>

func (h *s3Handler) GetStorageClasses(ctx context.Context, in *BaseRequest, out *GetStorageClassesResponse) error <span class="cov0" title="0">{
        return h.S3Handler.GetStorageClasses(ctx, in, out)
}</span>

func (h *s3Handler) GetBackendTypeByTier(ctx context.Context, in *GetBackendTypeByTierRequest, out *GetBackendTypeByTierResponse) error <span class="cov0" title="0">{
        return h.S3Handler.GetBackendTypeByTier(ctx, in, out)
}</span>

func (h *s3Handler) DeleteBucketLifecycle(ctx context.Context, in *BaseRequest, out *BaseResponse) error <span class="cov0" title="0">{
        return h.S3Handler.DeleteBucketLifecycle(ctx, in, out)
}</span>

func (h *s3Handler) PutBucketLifecycle(ctx context.Context, in *PutBucketLifecycleRequest, out *BaseResponse) error <span class="cov0" title="0">{
        return h.S3Handler.PutBucketLifecycle(ctx, in, out)
}</span>

func (h *s3Handler) GetBucketLifecycle(ctx context.Context, in *BaseRequest, out *GetBucketLifecycleResponse) error <span class="cov0" title="0">{
        return h.S3Handler.GetBucketLifecycle(ctx, in, out)
}</span>

func (h *s3Handler) ListBucketLifecycle(ctx context.Context, in *BaseRequest, out *ListBucketsResponse) error <span class="cov0" title="0">{
        return h.S3Handler.ListBucketLifecycle(ctx, in, out)
}</span>

func (h *s3Handler) UpdateBucket(ctx context.Context, in *Bucket, out *BaseResponse) error <span class="cov0" title="0">{
        return h.S3Handler.UpdateBucket(ctx, in, out)
}</span>

func (h *s3Handler) ListBucketUploadRecords(ctx context.Context, in *ListBucketUploadRequest, out *ListBucketUploadResponse) error <span class="cov0" title="0">{
        return h.S3Handler.ListBucketUploadRecords(ctx, in, out)
}</span>

func (h *s3Handler) InitMultipartUpload(ctx context.Context, in *InitMultiPartRequest, out *InitMultiPartResponse) error <span class="cov0" title="0">{
        return h.S3Handler.InitMultipartUpload(ctx, in, out)
}</span>

func (h *s3Handler) AbortMultipartUpload(ctx context.Context, in *AbortMultipartRequest, out *BaseResponse) error <span class="cov0" title="0">{
        return h.S3Handler.AbortMultipartUpload(ctx, in, out)
}</span>

func (h *s3Handler) CompleteMultipartUpload(ctx context.Context, in *CompleteMultipartRequest, out *CompleteMultipartResponse) error <span class="cov0" title="0">{
        return h.S3Handler.CompleteMultipartUpload(ctx, in, out)
}</span>

func (h *s3Handler) UploadPart(ctx context.Context, stream server.Stream) error <span class="cov0" title="0">{
        return h.S3Handler.UploadPart(ctx, &amp;s3UploadPartStream{stream})
}</span>

type S3_UploadPartStream interface {
        SendMsg(interface{}) error
        RecvMsg(interface{}) error
        Close() error
        Recv() (*PutDataStream, error)
}

type s3UploadPartStream struct {
        stream server.Stream
}

func (x *s3UploadPartStream) Close() error <span class="cov0" title="0">{
        return x.stream.Close()
}</span>

func (x *s3UploadPartStream) SendMsg(m interface{}) error <span class="cov0" title="0">{
        return x.stream.Send(m)
}</span>

func (x *s3UploadPartStream) RecvMsg(m interface{}) error <span class="cov0" title="0">{
        return x.stream.Recv(m)
}</span>

func (x *s3UploadPartStream) Recv() (*PutDataStream, error) <span class="cov0" title="0">{
        m := new(PutDataStream)
        if err := x.stream.Recv(m); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return m, nil</span>
}

func (h *s3Handler) ListObjectParts(ctx context.Context, in *ListObjectPartsRequest, out *ListObjectPartsResponse) error <span class="cov0" title="0">{
        return h.S3Handler.ListObjectParts(ctx, in, out)
}</span>

func (h *s3Handler) AppendObject(ctx context.Context, in *BaseRequest, out *BaseResponse) error <span class="cov0" title="0">{
        return h.S3Handler.AppendObject(ctx, in, out)
}</span>

func (h *s3Handler) PostObject(ctx context.Context, in *BaseRequest, out *BaseResponse) error <span class="cov0" title="0">{
        return h.S3Handler.PostObject(ctx, in, out)
}</span>

func (h *s3Handler) AddUploadRecord(ctx context.Context, in *MultipartUploadRecord, out *BaseResponse) error <span class="cov0" title="0">{
        return h.S3Handler.AddUploadRecord(ctx, in, out)
}</span>

func (h *s3Handler) DeleteUploadRecord(ctx context.Context, in *MultipartUploadRecord, out *BaseResponse) error <span class="cov0" title="0">{
        return h.S3Handler.DeleteUploadRecord(ctx, in, out)
}</span>

func (h *s3Handler) HeadObject(ctx context.Context, in *BaseObjRequest, out *Object) error <span class="cov0" title="0">{
        return h.S3Handler.HeadObject(ctx, in, out)
}</span>

func (h *s3Handler) MoveObject(ctx context.Context, in *MoveObjectRequest, out *MoveObjectResponse) error <span class="cov0" title="0">{
        return h.S3Handler.MoveObject(ctx, in, out)
}</span>

func (h *s3Handler) CopyObject(ctx context.Context, in *CopyObjectRequest, out *CopyObjectResponse) error <span class="cov0" title="0">{
        return h.S3Handler.CopyObject(ctx, in, out)
}</span>

func (h *s3Handler) CopyObjPart(ctx context.Context, in *CopyObjPartRequest, out *CopyObjPartResponse) error <span class="cov0" title="0">{
        return h.S3Handler.CopyObjPart(ctx, in, out)
}</span>

func (h *s3Handler) PutObjACL(ctx context.Context, in *PutObjACLRequest, out *BaseResponse) error <span class="cov0" title="0">{
        return h.S3Handler.PutObjACL(ctx, in, out)
}</span>

func (h *s3Handler) GetObjACL(ctx context.Context, in *BaseObjRequest, out *ObjACL) error <span class="cov0" title="0">{
        return h.S3Handler.GetObjACL(ctx, in, out)
}</span>

func (h *s3Handler) GetBucketLocation(ctx context.Context, in *BaseRequest, out *BaseResponse) error <span class="cov0" title="0">{
        return h.S3Handler.GetBucketLocation(ctx, in, out)
}</span>

func (h *s3Handler) GetBucketVersioning(ctx context.Context, in *BaseBucketRequest, out *BucketVersioning) error <span class="cov0" title="0">{
        return h.S3Handler.GetBucketVersioning(ctx, in, out)
}</span>

func (h *s3Handler) PutBucketACL(ctx context.Context, in *PutBucketACLRequest, out *BaseResponse) error <span class="cov0" title="0">{
        return h.S3Handler.PutBucketACL(ctx, in, out)
}</span>

func (h *s3Handler) GetBucketACL(ctx context.Context, in *BaseBucketRequest, out *BucketACL) error <span class="cov0" title="0">{
        return h.S3Handler.GetBucketACL(ctx, in, out)
}</span>

func (h *s3Handler) PutBucketCORS(ctx context.Context, in *BaseRequest, out *BaseResponse) error <span class="cov0" title="0">{
        return h.S3Handler.PutBucketCORS(ctx, in, out)
}</span>

func (h *s3Handler) GetBucketCORS(ctx context.Context, in *BaseRequest, out *BaseResponse) error <span class="cov0" title="0">{
        return h.S3Handler.GetBucketCORS(ctx, in, out)
}</span>

func (h *s3Handler) DeleteBucketCORS(ctx context.Context, in *BaseRequest, out *BaseResponse) error <span class="cov0" title="0">{
        return h.S3Handler.DeleteBucketCORS(ctx, in, out)
}</span>

func (h *s3Handler) PutBucketPolicy(ctx context.Context, in *BaseRequest, out *BaseResponse) error <span class="cov0" title="0">{
        return h.S3Handler.PutBucketPolicy(ctx, in, out)
}</span>

func (h *s3Handler) GetBucketPolicy(ctx context.Context, in *BaseRequest, out *BaseResponse) error <span class="cov0" title="0">{
        return h.S3Handler.GetBucketPolicy(ctx, in, out)
}</span>

func (h *s3Handler) DeleteBucketPolicy(ctx context.Context, in *BaseRequest, out *BaseResponse) error <span class="cov0" title="0">{
        return h.S3Handler.DeleteBucketPolicy(ctx, in, out)
}</span>

func (h *s3Handler) HeadBucket(ctx context.Context, in *BaseRequest, out *Bucket) error <span class="cov0" title="0">{
        return h.S3Handler.HeadBucket(ctx, in, out)
}</span>
</pre>
		
		<pre class="file" id="file102" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// source: s3.proto

package s3

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type ListObjectPartsRequest struct {
        BucketName           string   `protobuf:"bytes,1,opt,name=bucketName,proto3" json:"bucketName,omitempty"`
        ObjectKey            string   `protobuf:"bytes,2,opt,name=objectKey,proto3" json:"objectKey,omitempty"`
        EncodingType         string   `protobuf:"bytes,3,opt,name=encodingType,proto3" json:"encodingType,omitempty"`
        UploadId             string   `protobuf:"bytes,4,opt,name=uploadId,proto3" json:"uploadId,omitempty"`
        MaxParts             int64    `protobuf:"varint,5,opt,name=maxParts,proto3" json:"maxParts,omitempty"`
        PartNumberMarker     int64    `protobuf:"varint,6,opt,name=partNumberMarker,proto3" json:"partNumberMarker,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *ListObjectPartsRequest) Reset()         <span class="cov0" title="0">{ *m = ListObjectPartsRequest{} }</span>
func (m *ListObjectPartsRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*ListObjectPartsRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*ListObjectPartsRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_s3_ac4a79723b1dd58e, []int{0}
}</span>
func (m *ListObjectPartsRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_ListObjectPartsRequest.Unmarshal(m, b)
}</span>
func (m *ListObjectPartsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_ListObjectPartsRequest.Marshal(b, m, deterministic)
}</span>
func (dst *ListObjectPartsRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_ListObjectPartsRequest.Merge(dst, src)
}</span>
func (m *ListObjectPartsRequest) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_ListObjectPartsRequest.Size(m)
}</span>
func (m *ListObjectPartsRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_ListObjectPartsRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_ListObjectPartsRequest proto.InternalMessageInfo

func (m *ListObjectPartsRequest) GetBucketName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.BucketName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *ListObjectPartsRequest) GetObjectKey() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ObjectKey
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *ListObjectPartsRequest) GetEncodingType() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.EncodingType
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *ListObjectPartsRequest) GetUploadId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.UploadId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *ListObjectPartsRequest) GetMaxParts() int64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.MaxParts
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *ListObjectPartsRequest) GetPartNumberMarker() int64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.PartNumberMarker
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type Part struct {
        PartNumber           int64    `protobuf:"varint,1,opt,name=PartNumber,proto3" json:"PartNumber,omitempty"`
        ETag                 string   `protobuf:"bytes,2,opt,name=ETag,proto3" json:"ETag,omitempty"`
        LastModified         string   `protobuf:"bytes,3,opt,name=LastModified,proto3" json:"LastModified,omitempty"`
        Size                 int64    `protobuf:"varint,4,opt,name=Size,proto3" json:"Size,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *Part) Reset()         <span class="cov0" title="0">{ *m = Part{} }</span>
func (m *Part) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*Part) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*Part) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_s3_ac4a79723b1dd58e, []int{1}
}</span>
func (m *Part) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_Part.Unmarshal(m, b)
}</span>
func (m *Part) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_Part.Marshal(b, m, deterministic)
}</span>
func (dst *Part) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_Part.Merge(dst, src)
}</span>
func (m *Part) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_Part.Size(m)
}</span>
func (m *Part) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_Part.DiscardUnknown(m)
}</span>

var xxx_messageInfo_Part proto.InternalMessageInfo

func (m *Part) GetPartNumber() int64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.PartNumber
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *Part) GetETag() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ETag
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Part) GetLastModified() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.LastModified
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Part) GetSize() int64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Size
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type ListObjectPartsResponse struct {
        ErrorCode            int32    `protobuf:"varint,1,opt,name=ErrorCode,proto3" json:"ErrorCode,omitempty"`
        Initiator            *Owner   `protobuf:"bytes,2,opt,name=Initiator,proto3" json:"Initiator,omitempty"`
        Owner                *Owner   `protobuf:"bytes,3,opt,name=Owner,proto3" json:"Owner,omitempty"`
        StorageClass         string   `protobuf:"bytes,4,opt,name=StorageClass,proto3" json:"StorageClass,omitempty"`
        PartNumberMarker     int64    `protobuf:"varint,5,opt,name=PartNumberMarker,proto3" json:"PartNumberMarker,omitempty"`
        NextPartNumberMarker int64    `protobuf:"varint,6,opt,name=NextPartNumberMarker,proto3" json:"NextPartNumberMarker,omitempty"`
        MaxParts             int64    `protobuf:"varint,7,opt,name=MaxParts,proto3" json:"MaxParts,omitempty"`
        IsTruncated          bool     `protobuf:"varint,8,opt,name=IsTruncated,proto3" json:"IsTruncated,omitempty"`
        Parts                []*Part  `protobuf:"bytes,9,rep,name=Parts,proto3" json:"Parts,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *ListObjectPartsResponse) Reset()         <span class="cov0" title="0">{ *m = ListObjectPartsResponse{} }</span>
func (m *ListObjectPartsResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*ListObjectPartsResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*ListObjectPartsResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_s3_ac4a79723b1dd58e, []int{2}
}</span>
func (m *ListObjectPartsResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_ListObjectPartsResponse.Unmarshal(m, b)
}</span>
func (m *ListObjectPartsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_ListObjectPartsResponse.Marshal(b, m, deterministic)
}</span>
func (dst *ListObjectPartsResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_ListObjectPartsResponse.Merge(dst, src)
}</span>
func (m *ListObjectPartsResponse) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_ListObjectPartsResponse.Size(m)
}</span>
func (m *ListObjectPartsResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_ListObjectPartsResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_ListObjectPartsResponse proto.InternalMessageInfo

func (m *ListObjectPartsResponse) GetErrorCode() int32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ErrorCode
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *ListObjectPartsResponse) GetInitiator() *Owner <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Initiator
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *ListObjectPartsResponse) GetOwner() *Owner <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Owner
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *ListObjectPartsResponse) GetStorageClass() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.StorageClass
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *ListObjectPartsResponse) GetPartNumberMarker() int64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.PartNumberMarker
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *ListObjectPartsResponse) GetNextPartNumberMarker() int64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.NextPartNumberMarker
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *ListObjectPartsResponse) GetMaxParts() int64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.MaxParts
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *ListObjectPartsResponse) GetIsTruncated() bool <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.IsTruncated
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (m *ListObjectPartsResponse) GetParts() []*Part <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Parts
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type AbortMultipartRequest struct {
        BucketName           string   `protobuf:"bytes,1,opt,name=bucketName,proto3" json:"bucketName,omitempty"`
        ObjectKey            string   `protobuf:"bytes,2,opt,name=objectKey,proto3" json:"objectKey,omitempty"`
        UploadId             string   `protobuf:"bytes,3,opt,name=uploadId,proto3" json:"uploadId,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *AbortMultipartRequest) Reset()         <span class="cov0" title="0">{ *m = AbortMultipartRequest{} }</span>
func (m *AbortMultipartRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*AbortMultipartRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*AbortMultipartRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_s3_ac4a79723b1dd58e, []int{3}
}</span>
func (m *AbortMultipartRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_AbortMultipartRequest.Unmarshal(m, b)
}</span>
func (m *AbortMultipartRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_AbortMultipartRequest.Marshal(b, m, deterministic)
}</span>
func (dst *AbortMultipartRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_AbortMultipartRequest.Merge(dst, src)
}</span>
func (m *AbortMultipartRequest) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_AbortMultipartRequest.Size(m)
}</span>
func (m *AbortMultipartRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_AbortMultipartRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_AbortMultipartRequest proto.InternalMessageInfo

func (m *AbortMultipartRequest) GetBucketName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.BucketName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *AbortMultipartRequest) GetObjectKey() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ObjectKey
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *AbortMultipartRequest) GetUploadId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.UploadId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type CompletePart struct {
        PartNumber           int64    `protobuf:"varint,1,opt,name=partNumber,proto3" json:"partNumber,omitempty"`
        ETag                 string   `protobuf:"bytes,2,opt,name=eTag,proto3" json:"eTag,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *CompletePart) Reset()         <span class="cov0" title="0">{ *m = CompletePart{} }</span>
func (m *CompletePart) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*CompletePart) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*CompletePart) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_s3_ac4a79723b1dd58e, []int{4}
}</span>
func (m *CompletePart) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_CompletePart.Unmarshal(m, b)
}</span>
func (m *CompletePart) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_CompletePart.Marshal(b, m, deterministic)
}</span>
func (dst *CompletePart) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_CompletePart.Merge(dst, src)
}</span>
func (m *CompletePart) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_CompletePart.Size(m)
}</span>
func (m *CompletePart) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_CompletePart.DiscardUnknown(m)
}</span>

var xxx_messageInfo_CompletePart proto.InternalMessageInfo

func (m *CompletePart) GetPartNumber() int64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.PartNumber
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *CompletePart) GetETag() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ETag
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type CompleteMultipartRequest struct {
        BucketName           string          `protobuf:"bytes,1,opt,name=bucketName,proto3" json:"bucketName,omitempty"`
        ObjectKey            string          `protobuf:"bytes,2,opt,name=objectKey,proto3" json:"objectKey,omitempty"`
        UploadId             string          `protobuf:"bytes,3,opt,name=uploadId,proto3" json:"uploadId,omitempty"`
        CompleteParts        []*CompletePart `protobuf:"bytes,4,rep,name=completeParts,proto3" json:"completeParts,omitempty"`
        SourceVersionID      string          `protobuf:"bytes,5,opt,name=sourceVersionID,proto3" json:"sourceVersionID,omitempty"`
        RequestType          string          `protobuf:"bytes,6,opt,name=requestType,proto3" json:"requestType,omitempty"`
        Tier                 int32           `protobuf:"varint,7,opt,name=tier,proto3" json:"tier,omitempty"`
        XXX_NoUnkeyedLiteral struct{}        `json:"-"`
        XXX_unrecognized     []byte          `json:"-"`
        XXX_sizecache        int32           `json:"-"`
}

func (m *CompleteMultipartRequest) Reset()         <span class="cov0" title="0">{ *m = CompleteMultipartRequest{} }</span>
func (m *CompleteMultipartRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*CompleteMultipartRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*CompleteMultipartRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_s3_ac4a79723b1dd58e, []int{5}
}</span>
func (m *CompleteMultipartRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_CompleteMultipartRequest.Unmarshal(m, b)
}</span>
func (m *CompleteMultipartRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_CompleteMultipartRequest.Marshal(b, m, deterministic)
}</span>
func (dst *CompleteMultipartRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_CompleteMultipartRequest.Merge(dst, src)
}</span>
func (m *CompleteMultipartRequest) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_CompleteMultipartRequest.Size(m)
}</span>
func (m *CompleteMultipartRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_CompleteMultipartRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_CompleteMultipartRequest proto.InternalMessageInfo

func (m *CompleteMultipartRequest) GetBucketName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.BucketName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *CompleteMultipartRequest) GetObjectKey() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ObjectKey
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *CompleteMultipartRequest) GetUploadId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.UploadId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *CompleteMultipartRequest) GetCompleteParts() []*CompletePart <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.CompleteParts
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *CompleteMultipartRequest) GetSourceVersionID() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.SourceVersionID
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *CompleteMultipartRequest) GetRequestType() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.RequestType
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *CompleteMultipartRequest) GetTier() int32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Tier
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type CompleteMultipartResponse struct {
        ErrorCode            int32    `protobuf:"varint,1,opt,name=errorCode,proto3" json:"errorCode,omitempty"`
        UploadID             string   `protobuf:"bytes,2,opt,name=uploadID,proto3" json:"uploadID,omitempty"`
        ETag                 string   `protobuf:"bytes,3,opt,name=eTag,proto3" json:"eTag,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *CompleteMultipartResponse) Reset()         <span class="cov0" title="0">{ *m = CompleteMultipartResponse{} }</span>
func (m *CompleteMultipartResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*CompleteMultipartResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*CompleteMultipartResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_s3_ac4a79723b1dd58e, []int{6}
}</span>
func (m *CompleteMultipartResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_CompleteMultipartResponse.Unmarshal(m, b)
}</span>
func (m *CompleteMultipartResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_CompleteMultipartResponse.Marshal(b, m, deterministic)
}</span>
func (dst *CompleteMultipartResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_CompleteMultipartResponse.Merge(dst, src)
}</span>
func (m *CompleteMultipartResponse) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_CompleteMultipartResponse.Size(m)
}</span>
func (m *CompleteMultipartResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_CompleteMultipartResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_CompleteMultipartResponse proto.InternalMessageInfo

func (m *CompleteMultipartResponse) GetErrorCode() int32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ErrorCode
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *CompleteMultipartResponse) GetUploadID() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.UploadID
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *CompleteMultipartResponse) GetETag() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ETag
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type InitMultiPartRequest struct {
        BucketName           string            `protobuf:"bytes,1,opt,name=bucketName,proto3" json:"bucketName,omitempty"`
        ObjectKey            string            `protobuf:"bytes,2,opt,name=objectKey,proto3" json:"objectKey,omitempty"`
        Acl                  *Acl              `protobuf:"bytes,3,opt,name=acl,proto3" json:"acl,omitempty"`
        Tier                 int32             `protobuf:"varint,4,opt,name=tier,proto3" json:"tier,omitempty"`
        Location             string            `protobuf:"bytes,5,opt,name=location,proto3" json:"location,omitempty"`
        Attrs                map[string]string `protobuf:"bytes,6,rep,name=attrs,proto3" json:"attrs,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
        XXX_NoUnkeyedLiteral struct{}          `json:"-"`
        XXX_unrecognized     []byte            `json:"-"`
        XXX_sizecache        int32             `json:"-"`
}

func (m *InitMultiPartRequest) Reset()         <span class="cov0" title="0">{ *m = InitMultiPartRequest{} }</span>
func (m *InitMultiPartRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*InitMultiPartRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*InitMultiPartRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_s3_ac4a79723b1dd58e, []int{7}
}</span>
func (m *InitMultiPartRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_InitMultiPartRequest.Unmarshal(m, b)
}</span>
func (m *InitMultiPartRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_InitMultiPartRequest.Marshal(b, m, deterministic)
}</span>
func (dst *InitMultiPartRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_InitMultiPartRequest.Merge(dst, src)
}</span>
func (m *InitMultiPartRequest) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_InitMultiPartRequest.Size(m)
}</span>
func (m *InitMultiPartRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_InitMultiPartRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_InitMultiPartRequest proto.InternalMessageInfo

func (m *InitMultiPartRequest) GetBucketName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.BucketName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *InitMultiPartRequest) GetObjectKey() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ObjectKey
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *InitMultiPartRequest) GetAcl() *Acl <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Acl
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *InitMultiPartRequest) GetTier() int32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Tier
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *InitMultiPartRequest) GetLocation() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Location
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *InitMultiPartRequest) GetAttrs() map[string]string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Attrs
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type InitMultiPartResponse struct {
        ErrorCode            int32    `protobuf:"varint,1,opt,name=errorCode,proto3" json:"errorCode,omitempty"`
        UploadID             string   `protobuf:"bytes,2,opt,name=uploadID,proto3" json:"uploadID,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *InitMultiPartResponse) Reset()         <span class="cov0" title="0">{ *m = InitMultiPartResponse{} }</span>
func (m *InitMultiPartResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*InitMultiPartResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*InitMultiPartResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_s3_ac4a79723b1dd58e, []int{8}
}</span>
func (m *InitMultiPartResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_InitMultiPartResponse.Unmarshal(m, b)
}</span>
func (m *InitMultiPartResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_InitMultiPartResponse.Marshal(b, m, deterministic)
}</span>
func (dst *InitMultiPartResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_InitMultiPartResponse.Merge(dst, src)
}</span>
func (m *InitMultiPartResponse) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_InitMultiPartResponse.Size(m)
}</span>
func (m *InitMultiPartResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_InitMultiPartResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_InitMultiPartResponse proto.InternalMessageInfo

func (m *InitMultiPartResponse) GetErrorCode() int32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ErrorCode
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *InitMultiPartResponse) GetUploadID() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.UploadID
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type PutDataStream struct {
        Data                 []byte   `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *PutDataStream) Reset()         <span class="cov0" title="0">{ *m = PutDataStream{} }</span>
func (m *PutDataStream) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*PutDataStream) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*PutDataStream) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_s3_ac4a79723b1dd58e, []int{9}
}</span>
func (m *PutDataStream) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_PutDataStream.Unmarshal(m, b)
}</span>
func (m *PutDataStream) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov8" title="1">{
        return xxx_messageInfo_PutDataStream.Marshal(b, m, deterministic)
}</span>
func (dst *PutDataStream) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_PutDataStream.Merge(dst, src)
}</span>
func (m *PutDataStream) XXX_Size() int <span class="cov8" title="1">{
        return xxx_messageInfo_PutDataStream.Size(m)
}</span>
func (m *PutDataStream) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_PutDataStream.DiscardUnknown(m)
}</span>

var xxx_messageInfo_PutDataStream proto.InternalMessageInfo

func (m *PutDataStream) GetData() []byte <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Data
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type UploadPartRequest struct {
        BucketName           string   `protobuf:"bytes,1,opt,name=bucketName,proto3" json:"bucketName,omitempty"`
        ObjectKey            string   `protobuf:"bytes,2,opt,name=objectKey,proto3" json:"objectKey,omitempty"`
        UploadId             string   `protobuf:"bytes,3,opt,name=uploadId,proto3" json:"uploadId,omitempty"`
        PartId               int32    `protobuf:"varint,4,opt,name=partId,proto3" json:"partId,omitempty"`
        Size                 int64    `protobuf:"varint,5,opt,name=size,proto3" json:"size,omitempty"`
        Md5Hex               string   `protobuf:"bytes,6,opt,name=md5Hex,proto3" json:"md5Hex,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *UploadPartRequest) Reset()         <span class="cov0" title="0">{ *m = UploadPartRequest{} }</span>
func (m *UploadPartRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*UploadPartRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*UploadPartRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_s3_ac4a79723b1dd58e, []int{10}
}</span>
func (m *UploadPartRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_UploadPartRequest.Unmarshal(m, b)
}</span>
func (m *UploadPartRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_UploadPartRequest.Marshal(b, m, deterministic)
}</span>
func (dst *UploadPartRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_UploadPartRequest.Merge(dst, src)
}</span>
func (m *UploadPartRequest) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_UploadPartRequest.Size(m)
}</span>
func (m *UploadPartRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_UploadPartRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_UploadPartRequest proto.InternalMessageInfo

func (m *UploadPartRequest) GetBucketName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.BucketName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *UploadPartRequest) GetObjectKey() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ObjectKey
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *UploadPartRequest) GetUploadId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.UploadId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *UploadPartRequest) GetPartId() int32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.PartId
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *UploadPartRequest) GetSize() int64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Size
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *UploadPartRequest) GetMd5Hex() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Md5Hex
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type UploadPartResponse struct {
        ErrorCode            int32    `protobuf:"varint,1,opt,name=errorCode,proto3" json:"errorCode,omitempty"`
        ETag                 string   `protobuf:"bytes,2,opt,name=eTag,proto3" json:"eTag,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *UploadPartResponse) Reset()         <span class="cov0" title="0">{ *m = UploadPartResponse{} }</span>
func (m *UploadPartResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*UploadPartResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*UploadPartResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_s3_ac4a79723b1dd58e, []int{11}
}</span>
func (m *UploadPartResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_UploadPartResponse.Unmarshal(m, b)
}</span>
func (m *UploadPartResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_UploadPartResponse.Marshal(b, m, deterministic)
}</span>
func (dst *UploadPartResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_UploadPartResponse.Merge(dst, src)
}</span>
func (m *UploadPartResponse) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_UploadPartResponse.Size(m)
}</span>
func (m *UploadPartResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_UploadPartResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_UploadPartResponse proto.InternalMessageInfo

func (m *UploadPartResponse) GetErrorCode() int32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ErrorCode
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *UploadPartResponse) GetETag() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ETag
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type CopyObjectRequest struct {
        SrcBucketName        string   `protobuf:"bytes,1,opt,name=srcBucketName,proto3" json:"srcBucketName,omitempty"`
        TargetBucketName     string   `protobuf:"bytes,2,opt,name=targetBucketName,proto3" json:"targetBucketName,omitempty"`
        SrcObjectName        string   `protobuf:"bytes,3,opt,name=srcObjectName,proto3" json:"srcObjectName,omitempty"`
        TargetObjectName     string   `protobuf:"bytes,4,opt,name=targetObjectName,proto3" json:"targetObjectName,omitempty"`
        TargetBackend        string   `protobuf:"bytes,5,opt,name=targetBackend,proto3" json:"targetBackend,omitempty"`
        TargetTier           int32    `protobuf:"varint,6,opt,name=targetTier,proto3" json:"targetTier,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *CopyObjectRequest) Reset()         <span class="cov0" title="0">{ *m = CopyObjectRequest{} }</span>
func (m *CopyObjectRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*CopyObjectRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*CopyObjectRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_s3_ac4a79723b1dd58e, []int{12}
}</span>
func (m *CopyObjectRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_CopyObjectRequest.Unmarshal(m, b)
}</span>
func (m *CopyObjectRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_CopyObjectRequest.Marshal(b, m, deterministic)
}</span>
func (dst *CopyObjectRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_CopyObjectRequest.Merge(dst, src)
}</span>
func (m *CopyObjectRequest) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_CopyObjectRequest.Size(m)
}</span>
func (m *CopyObjectRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_CopyObjectRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_CopyObjectRequest proto.InternalMessageInfo

func (m *CopyObjectRequest) GetSrcBucketName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.SrcBucketName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *CopyObjectRequest) GetTargetBucketName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.TargetBucketName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *CopyObjectRequest) GetSrcObjectName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.SrcObjectName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *CopyObjectRequest) GetTargetObjectName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.TargetObjectName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *CopyObjectRequest) GetTargetBackend() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.TargetBackend
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *CopyObjectRequest) GetTargetTier() int32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.TargetTier
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type CopyObjectResponse struct {
        ErrorCode            int32    `protobuf:"varint,1,opt,name=errorCode,proto3" json:"errorCode,omitempty"`
        Md5                  string   `protobuf:"bytes,2,opt,name=md5,proto3" json:"md5,omitempty"`
        LastModified         int64    `protobuf:"varint,3,opt,name=lastModified,proto3" json:"lastModified,omitempty"`
        VersionId            string   `protobuf:"bytes,4,opt,name=versionId,proto3" json:"versionId,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *CopyObjectResponse) Reset()         <span class="cov0" title="0">{ *m = CopyObjectResponse{} }</span>
func (m *CopyObjectResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*CopyObjectResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*CopyObjectResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_s3_ac4a79723b1dd58e, []int{13}
}</span>
func (m *CopyObjectResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_CopyObjectResponse.Unmarshal(m, b)
}</span>
func (m *CopyObjectResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_CopyObjectResponse.Marshal(b, m, deterministic)
}</span>
func (dst *CopyObjectResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_CopyObjectResponse.Merge(dst, src)
}</span>
func (m *CopyObjectResponse) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_CopyObjectResponse.Size(m)
}</span>
func (m *CopyObjectResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_CopyObjectResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_CopyObjectResponse proto.InternalMessageInfo

func (m *CopyObjectResponse) GetErrorCode() int32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ErrorCode
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *CopyObjectResponse) GetMd5() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Md5
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *CopyObjectResponse) GetLastModified() int64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.LastModified
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *CopyObjectResponse) GetVersionId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.VersionId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type MoveObjectRequest struct {
        SrcObject            string   `protobuf:"bytes,1,opt,name=srcObject,proto3" json:"srcObject,omitempty"`
        TargetObject         string   `protobuf:"bytes,2,opt,name=targetObject,proto3" json:"targetObject,omitempty"`
        SrcBucket            string   `protobuf:"bytes,3,opt,name=srcBucket,proto3" json:"srcBucket,omitempty"`
        TargetBucket         string   `protobuf:"bytes,4,opt,name=targetBucket,proto3" json:"targetBucket,omitempty"`
        TargetLocation       string   `protobuf:"bytes,5,opt,name=targetLocation,proto3" json:"targetLocation,omitempty"`
        TargetTier           int32    `protobuf:"varint,6,opt,name=targetTier,proto3" json:"targetTier,omitempty"`
        MoveType             int32    `protobuf:"varint,7,opt,name=moveType,proto3" json:"moveType,omitempty"`
        SrcObjectVersion     string   `protobuf:"bytes,8,opt,name=srcObjectVersion,proto3" json:"srcObjectVersion,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *MoveObjectRequest) Reset()         <span class="cov0" title="0">{ *m = MoveObjectRequest{} }</span>
func (m *MoveObjectRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*MoveObjectRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*MoveObjectRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_s3_ac4a79723b1dd58e, []int{14}
}</span>
func (m *MoveObjectRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_MoveObjectRequest.Unmarshal(m, b)
}</span>
func (m *MoveObjectRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_MoveObjectRequest.Marshal(b, m, deterministic)
}</span>
func (dst *MoveObjectRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_MoveObjectRequest.Merge(dst, src)
}</span>
func (m *MoveObjectRequest) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_MoveObjectRequest.Size(m)
}</span>
func (m *MoveObjectRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_MoveObjectRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_MoveObjectRequest proto.InternalMessageInfo

func (m *MoveObjectRequest) GetSrcObject() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.SrcObject
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *MoveObjectRequest) GetTargetObject() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.TargetObject
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *MoveObjectRequest) GetSrcBucket() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.SrcBucket
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *MoveObjectRequest) GetTargetBucket() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.TargetBucket
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *MoveObjectRequest) GetTargetLocation() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.TargetLocation
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *MoveObjectRequest) GetTargetTier() int32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.TargetTier
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *MoveObjectRequest) GetMoveType() int32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.MoveType
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *MoveObjectRequest) GetSrcObjectVersion() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.SrcObjectVersion
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type MoveObjectResponse struct {
        ObjMeta              *Object  `protobuf:"bytes,1,opt,name=objMeta,proto3" json:"objMeta,omitempty"`
        Status               string   `protobuf:"bytes,2,opt,name=status,proto3" json:"status,omitempty"`
        Md5                  string   `protobuf:"bytes,3,opt,name=md5,proto3" json:"md5,omitempty"`
        VersionId            string   `protobuf:"bytes,4,opt,name=versionId,proto3" json:"versionId,omitempty"`
        LastModified         int64    `protobuf:"varint,5,opt,name=lastModified,proto3" json:"lastModified,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *MoveObjectResponse) Reset()         <span class="cov0" title="0">{ *m = MoveObjectResponse{} }</span>
func (m *MoveObjectResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*MoveObjectResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*MoveObjectResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_s3_ac4a79723b1dd58e, []int{15}
}</span>
func (m *MoveObjectResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_MoveObjectResponse.Unmarshal(m, b)
}</span>
func (m *MoveObjectResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_MoveObjectResponse.Marshal(b, m, deterministic)
}</span>
func (dst *MoveObjectResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_MoveObjectResponse.Merge(dst, src)
}</span>
func (m *MoveObjectResponse) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_MoveObjectResponse.Size(m)
}</span>
func (m *MoveObjectResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_MoveObjectResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_MoveObjectResponse proto.InternalMessageInfo

func (m *MoveObjectResponse) GetObjMeta() *Object <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ObjMeta
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *MoveObjectResponse) GetStatus() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Status
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *MoveObjectResponse) GetMd5() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Md5
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *MoveObjectResponse) GetVersionId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.VersionId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *MoveObjectResponse) GetLastModified() int64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.LastModified
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type PutObjectRequest struct {
        BucketName           string            `protobuf:"bytes,1,opt,name=BucketName,proto3" json:"BucketName,omitempty"`
        ObjectKey            string            `protobuf:"bytes,2,opt,name=ObjectKey,proto3" json:"ObjectKey,omitempty"`
        Acl                  *Acl              `protobuf:"bytes,3,opt,name=Acl,proto3" json:"Acl,omitempty"`
        Attrs                map[string]string `protobuf:"bytes,4,rep,name=attrs,proto3" json:"attrs,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
        Location             string            `protobuf:"bytes,5,opt,name=location,proto3" json:"location,omitempty"`
        Size                 int64             `protobuf:"varint,6,opt,name=size,proto3" json:"size,omitempty"`
        ContentType          string            `protobuf:"bytes,7,opt,name=contentType,proto3" json:"contentType,omitempty"`
        XXX_NoUnkeyedLiteral struct{}          `json:"-"`
        XXX_unrecognized     []byte            `json:"-"`
        XXX_sizecache        int32             `json:"-"`
}

func (m *PutObjectRequest) Reset()         <span class="cov0" title="0">{ *m = PutObjectRequest{} }</span>
func (m *PutObjectRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*PutObjectRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*PutObjectRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_s3_ac4a79723b1dd58e, []int{16}
}</span>
func (m *PutObjectRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_PutObjectRequest.Unmarshal(m, b)
}</span>
func (m *PutObjectRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov8" title="1">{
        return xxx_messageInfo_PutObjectRequest.Marshal(b, m, deterministic)
}</span>
func (dst *PutObjectRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_PutObjectRequest.Merge(dst, src)
}</span>
func (m *PutObjectRequest) XXX_Size() int <span class="cov8" title="1">{
        return xxx_messageInfo_PutObjectRequest.Size(m)
}</span>
func (m *PutObjectRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_PutObjectRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_PutObjectRequest proto.InternalMessageInfo

func (m *PutObjectRequest) GetBucketName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.BucketName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *PutObjectRequest) GetObjectKey() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ObjectKey
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *PutObjectRequest) GetAcl() *Acl <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Acl
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *PutObjectRequest) GetAttrs() map[string]string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Attrs
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *PutObjectRequest) GetLocation() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Location
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *PutObjectRequest) GetSize() int64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Size
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *PutObjectRequest) GetContentType() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ContentType
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type GetObjectResponse struct {
        ErrorCode            int32    `protobuf:"varint,1,opt,name=errorCode,proto3" json:"errorCode,omitempty"`
        Data                 []byte   `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *GetObjectResponse) Reset()         <span class="cov0" title="0">{ *m = GetObjectResponse{} }</span>
func (m *GetObjectResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*GetObjectResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*GetObjectResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_s3_ac4a79723b1dd58e, []int{17}
}</span>
func (m *GetObjectResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_GetObjectResponse.Unmarshal(m, b)
}</span>
func (m *GetObjectResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_GetObjectResponse.Marshal(b, m, deterministic)
}</span>
func (dst *GetObjectResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_GetObjectResponse.Merge(dst, src)
}</span>
func (m *GetObjectResponse) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_GetObjectResponse.Size(m)
}</span>
func (m *GetObjectResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_GetObjectResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_GetObjectResponse proto.InternalMessageInfo

func (m *GetObjectResponse) GetErrorCode() int32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ErrorCode
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *GetObjectResponse) GetData() []byte <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Data
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type GetObjectMetaResult struct {
        ErrorCode            int32    `protobuf:"varint,1,opt,name=errorCode,proto3" json:"errorCode,omitempty"`
        Object               *Object  `protobuf:"bytes,2,opt,name=object,proto3" json:"object,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *GetObjectMetaResult) Reset()         <span class="cov0" title="0">{ *m = GetObjectMetaResult{} }</span>
func (m *GetObjectMetaResult) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*GetObjectMetaResult) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*GetObjectMetaResult) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_s3_ac4a79723b1dd58e, []int{18}
}</span>
func (m *GetObjectMetaResult) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_GetObjectMetaResult.Unmarshal(m, b)
}</span>
func (m *GetObjectMetaResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_GetObjectMetaResult.Marshal(b, m, deterministic)
}</span>
func (dst *GetObjectMetaResult) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_GetObjectMetaResult.Merge(dst, src)
}</span>
func (m *GetObjectMetaResult) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_GetObjectMetaResult.Size(m)
}</span>
func (m *GetObjectMetaResult) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_GetObjectMetaResult.DiscardUnknown(m)
}</span>

var xxx_messageInfo_GetObjectMetaResult proto.InternalMessageInfo

func (m *GetObjectMetaResult) GetErrorCode() int32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ErrorCode
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *GetObjectMetaResult) GetObject() *Object <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Object
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type PutObjectResponse struct {
        ErrorCode            int32    `protobuf:"varint,1,opt,name=errorCode,proto3" json:"errorCode,omitempty"`
        ObjMeta              *Object  `protobuf:"bytes,2,opt,name=objMeta,proto3" json:"objMeta,omitempty"`
        Status               string   `protobuf:"bytes,3,opt,name=status,proto3" json:"status,omitempty"`
        Md5                  string   `protobuf:"bytes,4,opt,name=md5,proto3" json:"md5,omitempty"`
        VersionId            string   `protobuf:"bytes,5,opt,name=versionId,proto3" json:"versionId,omitempty"`
        LastModified         int64    `protobuf:"varint,6,opt,name=lastModified,proto3" json:"lastModified,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *PutObjectResponse) Reset()         <span class="cov8" title="1">{ *m = PutObjectResponse{} }</span>
func (m *PutObjectResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*PutObjectResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*PutObjectResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_s3_ac4a79723b1dd58e, []int{19}
}</span>
func (m *PutObjectResponse) XXX_Unmarshal(b []byte) error <span class="cov8" title="1">{
        return xxx_messageInfo_PutObjectResponse.Unmarshal(m, b)
}</span>
func (m *PutObjectResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_PutObjectResponse.Marshal(b, m, deterministic)
}</span>
func (dst *PutObjectResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_PutObjectResponse.Merge(dst, src)
}</span>
func (m *PutObjectResponse) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_PutObjectResponse.Size(m)
}</span>
func (m *PutObjectResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_PutObjectResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_PutObjectResponse proto.InternalMessageInfo

func (m *PutObjectResponse) GetErrorCode() int32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ErrorCode
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *PutObjectResponse) GetObjMeta() *Object <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ObjMeta
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *PutObjectResponse) GetStatus() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Status
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *PutObjectResponse) GetMd5() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Md5
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *PutObjectResponse) GetVersionId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.VersionId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *PutObjectResponse) GetLastModified() int64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.LastModified
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type PutBucketACLRequest struct {
        ACLConfig            *BucketACL `protobuf:"bytes,1,opt,name=ACLConfig,proto3" json:"ACLConfig,omitempty"`
        XXX_NoUnkeyedLiteral struct{}   `json:"-"`
        XXX_unrecognized     []byte     `json:"-"`
        XXX_sizecache        int32      `json:"-"`
}

func (m *PutBucketACLRequest) Reset()         <span class="cov0" title="0">{ *m = PutBucketACLRequest{} }</span>
func (m *PutBucketACLRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*PutBucketACLRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*PutBucketACLRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_s3_ac4a79723b1dd58e, []int{20}
}</span>
func (m *PutBucketACLRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_PutBucketACLRequest.Unmarshal(m, b)
}</span>
func (m *PutBucketACLRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_PutBucketACLRequest.Marshal(b, m, deterministic)
}</span>
func (dst *PutBucketACLRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_PutBucketACLRequest.Merge(dst, src)
}</span>
func (m *PutBucketACLRequest) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_PutBucketACLRequest.Size(m)
}</span>
func (m *PutBucketACLRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_PutBucketACLRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_PutBucketACLRequest proto.InternalMessageInfo

func (m *PutBucketACLRequest) GetACLConfig() *BucketACL <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ACLConfig
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type BucketACL struct {
        BucketName           string   `protobuf:"bytes,1,opt,name=BucketName,proto3" json:"BucketName,omitempty"`
        CannedAcl            string   `protobuf:"bytes,2,opt,name=CannedAcl,proto3" json:"CannedAcl,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *BucketACL) Reset()         <span class="cov0" title="0">{ *m = BucketACL{} }</span>
func (m *BucketACL) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*BucketACL) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*BucketACL) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_s3_ac4a79723b1dd58e, []int{21}
}</span>
func (m *BucketACL) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_BucketACL.Unmarshal(m, b)
}</span>
func (m *BucketACL) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_BucketACL.Marshal(b, m, deterministic)
}</span>
func (dst *BucketACL) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_BucketACL.Merge(dst, src)
}</span>
func (m *BucketACL) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_BucketACL.Size(m)
}</span>
func (m *BucketACL) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_BucketACL.DiscardUnknown(m)
}</span>

var xxx_messageInfo_BucketACL proto.InternalMessageInfo

func (m *BucketACL) GetBucketName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.BucketName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *BucketACL) GetCannedAcl() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.CannedAcl
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type BucketVersioning struct {
        Status               string   `protobuf:"bytes,1,opt,name=Status,proto3" json:"Status,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *BucketVersioning) Reset()         <span class="cov0" title="0">{ *m = BucketVersioning{} }</span>
func (m *BucketVersioning) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*BucketVersioning) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*BucketVersioning) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_s3_ac4a79723b1dd58e, []int{22}
}</span>
func (m *BucketVersioning) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_BucketVersioning.Unmarshal(m, b)
}</span>
func (m *BucketVersioning) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_BucketVersioning.Marshal(b, m, deterministic)
}</span>
func (dst *BucketVersioning) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_BucketVersioning.Merge(dst, src)
}</span>
func (m *BucketVersioning) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_BucketVersioning.Size(m)
}</span>
func (m *BucketVersioning) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_BucketVersioning.DiscardUnknown(m)
}</span>

var xxx_messageInfo_BucketVersioning proto.InternalMessageInfo

func (m *BucketVersioning) GetStatus() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Status
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type ObjACL struct {
        BucketName           string   `protobuf:"bytes,1,opt,name=BucketName,proto3" json:"BucketName,omitempty"`
        ObjectKey            string   `protobuf:"bytes,2,opt,name=ObjectKey,proto3" json:"ObjectKey,omitempty"`
        CannedAcl            string   `protobuf:"bytes,3,opt,name=CannedAcl,proto3" json:"CannedAcl,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *ObjACL) Reset()         <span class="cov0" title="0">{ *m = ObjACL{} }</span>
func (m *ObjACL) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*ObjACL) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*ObjACL) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_s3_ac4a79723b1dd58e, []int{23}
}</span>
func (m *ObjACL) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_ObjACL.Unmarshal(m, b)
}</span>
func (m *ObjACL) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_ObjACL.Marshal(b, m, deterministic)
}</span>
func (dst *ObjACL) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_ObjACL.Merge(dst, src)
}</span>
func (m *ObjACL) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_ObjACL.Size(m)
}</span>
func (m *ObjACL) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_ObjACL.DiscardUnknown(m)
}</span>

var xxx_messageInfo_ObjACL proto.InternalMessageInfo

func (m *ObjACL) GetBucketName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.BucketName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *ObjACL) GetObjectKey() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ObjectKey
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *ObjACL) GetCannedAcl() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.CannedAcl
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type PutObjACLRequest struct {
        Context              string   `protobuf:"bytes,1,opt,name=Context,proto3" json:"Context,omitempty"`
        ACLConfig            *ObjACL  `protobuf:"bytes,2,opt,name=ACLConfig,proto3" json:"ACLConfig,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *PutObjACLRequest) Reset()         <span class="cov0" title="0">{ *m = PutObjACLRequest{} }</span>
func (m *PutObjACLRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*PutObjACLRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*PutObjACLRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_s3_ac4a79723b1dd58e, []int{24}
}</span>
func (m *PutObjACLRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_PutObjACLRequest.Unmarshal(m, b)
}</span>
func (m *PutObjACLRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_PutObjACLRequest.Marshal(b, m, deterministic)
}</span>
func (dst *PutObjACLRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_PutObjACLRequest.Merge(dst, src)
}</span>
func (m *PutObjACLRequest) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_PutObjACLRequest.Size(m)
}</span>
func (m *PutObjACLRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_PutObjACLRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_PutObjACLRequest proto.InternalMessageInfo

func (m *PutObjACLRequest) GetContext() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Context
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *PutObjACLRequest) GetACLConfig() *ObjACL <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ACLConfig
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type BaseBucketRequest struct {
        Context              string   `protobuf:"bytes,1,opt,name=Context,proto3" json:"Context,omitempty"`
        BucketName           string   `protobuf:"bytes,2,opt,name=BucketName,proto3" json:"BucketName,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *BaseBucketRequest) Reset()         <span class="cov0" title="0">{ *m = BaseBucketRequest{} }</span>
func (m *BaseBucketRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*BaseBucketRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*BaseBucketRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_s3_ac4a79723b1dd58e, []int{25}
}</span>
func (m *BaseBucketRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_BaseBucketRequest.Unmarshal(m, b)
}</span>
func (m *BaseBucketRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_BaseBucketRequest.Marshal(b, m, deterministic)
}</span>
func (dst *BaseBucketRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_BaseBucketRequest.Merge(dst, src)
}</span>
func (m *BaseBucketRequest) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_BaseBucketRequest.Size(m)
}</span>
func (m *BaseBucketRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_BaseBucketRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_BaseBucketRequest proto.InternalMessageInfo

func (m *BaseBucketRequest) GetContext() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Context
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *BaseBucketRequest) GetBucketName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.BucketName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type BaseObjRequest struct {
        Context              string   `protobuf:"bytes,1,opt,name=Context,proto3" json:"Context,omitempty"`
        BucketName           string   `protobuf:"bytes,2,opt,name=BucketName,proto3" json:"BucketName,omitempty"`
        ObjectKey            string   `protobuf:"bytes,3,opt,name=ObjectKey,proto3" json:"ObjectKey,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *BaseObjRequest) Reset()         <span class="cov0" title="0">{ *m = BaseObjRequest{} }</span>
func (m *BaseObjRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*BaseObjRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*BaseObjRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_s3_ac4a79723b1dd58e, []int{26}
}</span>
func (m *BaseObjRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_BaseObjRequest.Unmarshal(m, b)
}</span>
func (m *BaseObjRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_BaseObjRequest.Marshal(b, m, deterministic)
}</span>
func (dst *BaseObjRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_BaseObjRequest.Merge(dst, src)
}</span>
func (m *BaseObjRequest) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_BaseObjRequest.Size(m)
}</span>
func (m *BaseObjRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_BaseObjRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_BaseObjRequest proto.InternalMessageInfo

func (m *BaseObjRequest) GetContext() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Context
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *BaseObjRequest) GetBucketName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.BucketName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *BaseObjRequest) GetObjectKey() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ObjectKey
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type CopyObjPartRequest struct {
        SourceBucket         string   `protobuf:"bytes,1,opt,name=SourceBucket,proto3" json:"SourceBucket,omitempty"`
        SourceObject         string   `protobuf:"bytes,2,opt,name=SourceObject,proto3" json:"SourceObject,omitempty"`
        TargetBucket         string   `protobuf:"bytes,3,opt,name=TargetBucket,proto3" json:"TargetBucket,omitempty"`
        TargetObject         string   `protobuf:"bytes,4,opt,name=TargetObject,proto3" json:"TargetObject,omitempty"`
        TargetLocation       string   `protobuf:"bytes,5,opt,name=TargetLocation,proto3" json:"TargetLocation,omitempty"`
        UploadID             string   `protobuf:"bytes,6,opt,name=UploadID,proto3" json:"UploadID,omitempty"`
        PartID               int64    `protobuf:"varint,7,opt,name=PartID,proto3" json:"PartID,omitempty"`
        ReadOffset           int64    `protobuf:"varint,8,opt,name=ReadOffset,proto3" json:"ReadOffset,omitempty"`
        ReadLength           int64    `protobuf:"varint,9,opt,name=ReadLength,proto3" json:"ReadLength,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *CopyObjPartRequest) Reset()         <span class="cov0" title="0">{ *m = CopyObjPartRequest{} }</span>
func (m *CopyObjPartRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*CopyObjPartRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*CopyObjPartRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_s3_ac4a79723b1dd58e, []int{27}
}</span>
func (m *CopyObjPartRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_CopyObjPartRequest.Unmarshal(m, b)
}</span>
func (m *CopyObjPartRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_CopyObjPartRequest.Marshal(b, m, deterministic)
}</span>
func (dst *CopyObjPartRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_CopyObjPartRequest.Merge(dst, src)
}</span>
func (m *CopyObjPartRequest) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_CopyObjPartRequest.Size(m)
}</span>
func (m *CopyObjPartRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_CopyObjPartRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_CopyObjPartRequest proto.InternalMessageInfo

func (m *CopyObjPartRequest) GetSourceBucket() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.SourceBucket
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *CopyObjPartRequest) GetSourceObject() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.SourceObject
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *CopyObjPartRequest) GetTargetBucket() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.TargetBucket
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *CopyObjPartRequest) GetTargetObject() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.TargetObject
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *CopyObjPartRequest) GetTargetLocation() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.TargetLocation
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *CopyObjPartRequest) GetUploadID() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.UploadID
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *CopyObjPartRequest) GetPartID() int64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.PartID
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *CopyObjPartRequest) GetReadOffset() int64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ReadOffset
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *CopyObjPartRequest) GetReadLength() int64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ReadLength
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type CopyObjPartResponse struct {
        ErrorCode            int32    `protobuf:"varint,1,opt,name=ErrorCode,proto3" json:"ErrorCode,omitempty"`
        LastModified         int64    `protobuf:"varint,2,opt,name=LastModified,proto3" json:"LastModified,omitempty"`
        Etag                 string   `protobuf:"bytes,3,opt,name=Etag,proto3" json:"Etag,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *CopyObjPartResponse) Reset()         <span class="cov0" title="0">{ *m = CopyObjPartResponse{} }</span>
func (m *CopyObjPartResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*CopyObjPartResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*CopyObjPartResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_s3_ac4a79723b1dd58e, []int{28}
}</span>
func (m *CopyObjPartResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_CopyObjPartResponse.Unmarshal(m, b)
}</span>
func (m *CopyObjPartResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_CopyObjPartResponse.Marshal(b, m, deterministic)
}</span>
func (dst *CopyObjPartResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_CopyObjPartResponse.Merge(dst, src)
}</span>
func (m *CopyObjPartResponse) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_CopyObjPartResponse.Size(m)
}</span>
func (m *CopyObjPartResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_CopyObjPartResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_CopyObjPartResponse proto.InternalMessageInfo

func (m *CopyObjPartResponse) GetErrorCode() int32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ErrorCode
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *CopyObjPartResponse) GetLastModified() int64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.LastModified
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *CopyObjPartResponse) GetEtag() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Etag
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type ServerSideEncryption struct {
        SseType              string   `protobuf:"bytes,1,opt,name=sseType,proto3" json:"sseType,omitempty"`
        EncryptionKey        []byte   `protobuf:"bytes,2,opt,name=encryptionKey,proto3" json:"encryptionKey,omitempty"`
        InitilizationVector  []byte   `protobuf:"bytes,3,opt,name=initilizationVector,proto3" json:"initilizationVector,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *ServerSideEncryption) Reset()         <span class="cov0" title="0">{ *m = ServerSideEncryption{} }</span>
func (m *ServerSideEncryption) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*ServerSideEncryption) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*ServerSideEncryption) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_s3_ac4a79723b1dd58e, []int{29}
}</span>
func (m *ServerSideEncryption) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_ServerSideEncryption.Unmarshal(m, b)
}</span>
func (m *ServerSideEncryption) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_ServerSideEncryption.Marshal(b, m, deterministic)
}</span>
func (dst *ServerSideEncryption) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_ServerSideEncryption.Merge(dst, src)
}</span>
func (m *ServerSideEncryption) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_ServerSideEncryption.Size(m)
}</span>
func (m *ServerSideEncryption) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_ServerSideEncryption.DiscardUnknown(m)
}</span>

var xxx_messageInfo_ServerSideEncryption proto.InternalMessageInfo

func (m *ServerSideEncryption) GetSseType() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.SseType
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *ServerSideEncryption) GetEncryptionKey() []byte <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.EncryptionKey
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *ServerSideEncryption) GetInitilizationVector() []byte <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.InitilizationVector
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type RedirectAllRequestsTo struct {
        HostName             string   `protobuf:"bytes,1,opt,name=hostName,proto3" json:"hostName,omitempty"`
        Protocol             []string `protobuf:"bytes,2,rep,name=protocol,proto3" json:"protocol,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *RedirectAllRequestsTo) Reset()         <span class="cov0" title="0">{ *m = RedirectAllRequestsTo{} }</span>
func (m *RedirectAllRequestsTo) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*RedirectAllRequestsTo) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*RedirectAllRequestsTo) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_s3_ac4a79723b1dd58e, []int{30}
}</span>
func (m *RedirectAllRequestsTo) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_RedirectAllRequestsTo.Unmarshal(m, b)
}</span>
func (m *RedirectAllRequestsTo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_RedirectAllRequestsTo.Marshal(b, m, deterministic)
}</span>
func (dst *RedirectAllRequestsTo) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_RedirectAllRequestsTo.Merge(dst, src)
}</span>
func (m *RedirectAllRequestsTo) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_RedirectAllRequestsTo.Size(m)
}</span>
func (m *RedirectAllRequestsTo) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_RedirectAllRequestsTo.DiscardUnknown(m)
}</span>

var xxx_messageInfo_RedirectAllRequestsTo proto.InternalMessageInfo

func (m *RedirectAllRequestsTo) GetHostName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.HostName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *RedirectAllRequestsTo) GetProtocol() []string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Protocol
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type Redirect struct {
        Protocol             string   `protobuf:"bytes,1,opt,name=protocol,proto3" json:"protocol,omitempty"`
        HostName             string   `protobuf:"bytes,2,opt,name=hostName,proto3" json:"hostName,omitempty"`
        ReplaceKeyPrefixWith string   `protobuf:"bytes,3,opt,name=replaceKeyPrefixWith,proto3" json:"replaceKeyPrefixWith,omitempty"`
        ReplaceKeyWith       string   `protobuf:"bytes,4,opt,name=replaceKeyWith,proto3" json:"replaceKeyWith,omitempty"`
        HttpRedirectCode     string   `protobuf:"bytes,5,opt,name=httpRedirectCode,proto3" json:"httpRedirectCode,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *Redirect) Reset()         <span class="cov0" title="0">{ *m = Redirect{} }</span>
func (m *Redirect) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*Redirect) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*Redirect) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_s3_ac4a79723b1dd58e, []int{31}
}</span>
func (m *Redirect) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_Redirect.Unmarshal(m, b)
}</span>
func (m *Redirect) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_Redirect.Marshal(b, m, deterministic)
}</span>
func (dst *Redirect) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_Redirect.Merge(dst, src)
}</span>
func (m *Redirect) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_Redirect.Size(m)
}</span>
func (m *Redirect) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_Redirect.DiscardUnknown(m)
}</span>

var xxx_messageInfo_Redirect proto.InternalMessageInfo

func (m *Redirect) GetProtocol() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Protocol
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Redirect) GetHostName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.HostName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Redirect) GetReplaceKeyPrefixWith() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ReplaceKeyPrefixWith
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Redirect) GetReplaceKeyWith() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ReplaceKeyWith
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Redirect) GetHttpRedirectCode() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.HttpRedirectCode
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type Condition struct {
        KeyPrefixEquals             string   `protobuf:"bytes,1,opt,name=keyPrefixEquals,proto3" json:"keyPrefixEquals,omitempty"`
        HttpErrorCodeReturnedEquals string   `protobuf:"bytes,2,opt,name=httpErrorCodeReturnedEquals,proto3" json:"httpErrorCodeReturnedEquals,omitempty"`
        XXX_NoUnkeyedLiteral        struct{} `json:"-"`
        XXX_unrecognized            []byte   `json:"-"`
        XXX_sizecache               int32    `json:"-"`
}

func (m *Condition) Reset()         <span class="cov0" title="0">{ *m = Condition{} }</span>
func (m *Condition) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*Condition) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*Condition) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_s3_ac4a79723b1dd58e, []int{32}
}</span>
func (m *Condition) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_Condition.Unmarshal(m, b)
}</span>
func (m *Condition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_Condition.Marshal(b, m, deterministic)
}</span>
func (dst *Condition) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_Condition.Merge(dst, src)
}</span>
func (m *Condition) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_Condition.Size(m)
}</span>
func (m *Condition) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_Condition.DiscardUnknown(m)
}</span>

var xxx_messageInfo_Condition proto.InternalMessageInfo

func (m *Condition) GetKeyPrefixEquals() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.KeyPrefixEquals
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Condition) GetHttpErrorCodeReturnedEquals() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.HttpErrorCodeReturnedEquals
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type RoutingRules struct {
        Redirect             *Redirect  `protobuf:"bytes,1,opt,name=redirect,proto3" json:"redirect,omitempty"`
        Condition            *Condition `protobuf:"bytes,2,opt,name=condition,proto3" json:"condition,omitempty"`
        XXX_NoUnkeyedLiteral struct{}   `json:"-"`
        XXX_unrecognized     []byte     `json:"-"`
        XXX_sizecache        int32      `json:"-"`
}

func (m *RoutingRules) Reset()         <span class="cov0" title="0">{ *m = RoutingRules{} }</span>
func (m *RoutingRules) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*RoutingRules) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*RoutingRules) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_s3_ac4a79723b1dd58e, []int{33}
}</span>
func (m *RoutingRules) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_RoutingRules.Unmarshal(m, b)
}</span>
func (m *RoutingRules) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_RoutingRules.Marshal(b, m, deterministic)
}</span>
func (dst *RoutingRules) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_RoutingRules.Merge(dst, src)
}</span>
func (m *RoutingRules) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_RoutingRules.Size(m)
}</span>
func (m *RoutingRules) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_RoutingRules.DiscardUnknown(m)
}</span>

var xxx_messageInfo_RoutingRules proto.InternalMessageInfo

func (m *RoutingRules) GetRedirect() *Redirect <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Redirect
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *RoutingRules) GetCondition() *Condition <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Condition
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type WebsiteConfiguration struct {
        IndexDocument         string                 `protobuf:"bytes,1,opt,name=indexDocument,proto3" json:"indexDocument,omitempty"`
        ErrorDocument         string                 `protobuf:"bytes,2,opt,name=errorDocument,proto3" json:"errorDocument,omitempty"`
        RedirectAllRequestsTo *RedirectAllRequestsTo `protobuf:"bytes,3,opt,name=redirectAllRequestsTo,proto3" json:"redirectAllRequestsTo,omitempty"`
        RoutingRules          []*RoutingRules        `protobuf:"bytes,4,rep,name=routingRules,proto3" json:"routingRules,omitempty"`
        XXX_NoUnkeyedLiteral  struct{}               `json:"-"`
        XXX_unrecognized      []byte                 `json:"-"`
        XXX_sizecache         int32                  `json:"-"`
}

func (m *WebsiteConfiguration) Reset()         <span class="cov0" title="0">{ *m = WebsiteConfiguration{} }</span>
func (m *WebsiteConfiguration) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*WebsiteConfiguration) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*WebsiteConfiguration) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_s3_ac4a79723b1dd58e, []int{34}
}</span>
func (m *WebsiteConfiguration) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_WebsiteConfiguration.Unmarshal(m, b)
}</span>
func (m *WebsiteConfiguration) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_WebsiteConfiguration.Marshal(b, m, deterministic)
}</span>
func (dst *WebsiteConfiguration) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_WebsiteConfiguration.Merge(dst, src)
}</span>
func (m *WebsiteConfiguration) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_WebsiteConfiguration.Size(m)
}</span>
func (m *WebsiteConfiguration) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_WebsiteConfiguration.DiscardUnknown(m)
}</span>

var xxx_messageInfo_WebsiteConfiguration proto.InternalMessageInfo

func (m *WebsiteConfiguration) GetIndexDocument() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.IndexDocument
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *WebsiteConfiguration) GetErrorDocument() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ErrorDocument
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *WebsiteConfiguration) GetRedirectAllRequestsTo() *RedirectAllRequestsTo <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.RedirectAllRequestsTo
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *WebsiteConfiguration) GetRoutingRules() []*RoutingRules <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.RoutingRules
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type CORSConfiguration struct {
        Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
        AllowedMethods       string   `protobuf:"bytes,2,opt,name=allowedMethods,proto3" json:"allowedMethods,omitempty"`
        AllowedOrigins       string   `protobuf:"bytes,3,opt,name=allowedOrigins,proto3" json:"allowedOrigins,omitempty"`
        AllowedHeaders       string   `protobuf:"bytes,4,opt,name=allowedHeaders,proto3" json:"allowedHeaders,omitempty"`
        MaxAgeSeconds        string   `protobuf:"bytes,5,opt,name=maxAgeSeconds,proto3" json:"maxAgeSeconds,omitempty"`
        ExposedHeaders       string   `protobuf:"bytes,6,opt,name=exposedHeaders,proto3" json:"exposedHeaders,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *CORSConfiguration) Reset()         <span class="cov0" title="0">{ *m = CORSConfiguration{} }</span>
func (m *CORSConfiguration) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*CORSConfiguration) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*CORSConfiguration) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_s3_ac4a79723b1dd58e, []int{35}
}</span>
func (m *CORSConfiguration) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_CORSConfiguration.Unmarshal(m, b)
}</span>
func (m *CORSConfiguration) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_CORSConfiguration.Marshal(b, m, deterministic)
}</span>
func (dst *CORSConfiguration) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_CORSConfiguration.Merge(dst, src)
}</span>
func (m *CORSConfiguration) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_CORSConfiguration.Size(m)
}</span>
func (m *CORSConfiguration) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_CORSConfiguration.DiscardUnknown(m)
}</span>

var xxx_messageInfo_CORSConfiguration proto.InternalMessageInfo

func (m *CORSConfiguration) GetId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *CORSConfiguration) GetAllowedMethods() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.AllowedMethods
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *CORSConfiguration) GetAllowedOrigins() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.AllowedOrigins
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *CORSConfiguration) GetAllowedHeaders() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.AllowedHeaders
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *CORSConfiguration) GetMaxAgeSeconds() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.MaxAgeSeconds
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *CORSConfiguration) GetExposedHeaders() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ExposedHeaders
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type Destination struct {
        Bucket               string   `protobuf:"bytes,1,opt,name=bucket,proto3" json:"bucket,omitempty"`
        StorageClass         string   `protobuf:"bytes,2,opt,name=storageClass,proto3" json:"storageClass,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *Destination) Reset()         <span class="cov0" title="0">{ *m = Destination{} }</span>
func (m *Destination) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*Destination) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*Destination) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_s3_ac4a79723b1dd58e, []int{36}
}</span>
func (m *Destination) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_Destination.Unmarshal(m, b)
}</span>
func (m *Destination) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_Destination.Marshal(b, m, deterministic)
}</span>
func (dst *Destination) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_Destination.Merge(dst, src)
}</span>
func (m *Destination) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_Destination.Size(m)
}</span>
func (m *Destination) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_Destination.DiscardUnknown(m)
}</span>

var xxx_messageInfo_Destination proto.InternalMessageInfo

func (m *Destination) GetBucket() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Bucket
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Destination) GetStorageClass() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.StorageClass
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type ReplicationRole struct {
        Id                   string       `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
        Prefix               string       `protobuf:"bytes,2,opt,name=prefix,proto3" json:"prefix,omitempty"`
        Enabled              bool         `protobuf:"varint,3,opt,name=enabled,proto3" json:"enabled,omitempty"`
        Destination          *Destination `protobuf:"bytes,4,opt,name=destination,proto3" json:"destination,omitempty"`
        XXX_NoUnkeyedLiteral struct{}     `json:"-"`
        XXX_unrecognized     []byte       `json:"-"`
        XXX_sizecache        int32        `json:"-"`
}

func (m *ReplicationRole) Reset()         <span class="cov0" title="0">{ *m = ReplicationRole{} }</span>
func (m *ReplicationRole) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*ReplicationRole) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*ReplicationRole) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_s3_ac4a79723b1dd58e, []int{37}
}</span>
func (m *ReplicationRole) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_ReplicationRole.Unmarshal(m, b)
}</span>
func (m *ReplicationRole) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_ReplicationRole.Marshal(b, m, deterministic)
}</span>
func (dst *ReplicationRole) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_ReplicationRole.Merge(dst, src)
}</span>
func (m *ReplicationRole) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_ReplicationRole.Size(m)
}</span>
func (m *ReplicationRole) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_ReplicationRole.DiscardUnknown(m)
}</span>

var xxx_messageInfo_ReplicationRole proto.InternalMessageInfo

func (m *ReplicationRole) GetId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *ReplicationRole) GetPrefix() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Prefix
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *ReplicationRole) GetEnabled() bool <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Enabled
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (m *ReplicationRole) GetDestination() *Destination <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Destination
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type ReplicationConfiguration struct {
        Role                 string             `protobuf:"bytes,1,opt,name=role,proto3" json:"role,omitempty"`
        Rules                []*ReplicationRole `protobuf:"bytes,2,rep,name=rules,proto3" json:"rules,omitempty"`
        XXX_NoUnkeyedLiteral struct{}           `json:"-"`
        XXX_unrecognized     []byte             `json:"-"`
        XXX_sizecache        int32              `json:"-"`
}

func (m *ReplicationConfiguration) Reset()         <span class="cov0" title="0">{ *m = ReplicationConfiguration{} }</span>
func (m *ReplicationConfiguration) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*ReplicationConfiguration) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*ReplicationConfiguration) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_s3_ac4a79723b1dd58e, []int{38}
}</span>
func (m *ReplicationConfiguration) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_ReplicationConfiguration.Unmarshal(m, b)
}</span>
func (m *ReplicationConfiguration) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_ReplicationConfiguration.Marshal(b, m, deterministic)
}</span>
func (dst *ReplicationConfiguration) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_ReplicationConfiguration.Merge(dst, src)
}</span>
func (m *ReplicationConfiguration) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_ReplicationConfiguration.Size(m)
}</span>
func (m *ReplicationConfiguration) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_ReplicationConfiguration.DiscardUnknown(m)
}</span>

var xxx_messageInfo_ReplicationConfiguration proto.InternalMessageInfo

func (m *ReplicationConfiguration) GetRole() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Role
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *ReplicationConfiguration) GetRules() []*ReplicationRole <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Rules
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type Tag struct {
        Key                  string   `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
        Val                  string   `protobuf:"bytes,2,opt,name=val,proto3" json:"val,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *Tag) Reset()         <span class="cov0" title="0">{ *m = Tag{} }</span>
func (m *Tag) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*Tag) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*Tag) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_s3_ac4a79723b1dd58e, []int{39}
}</span>
func (m *Tag) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_Tag.Unmarshal(m, b)
}</span>
func (m *Tag) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_Tag.Marshal(b, m, deterministic)
}</span>
func (dst *Tag) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_Tag.Merge(dst, src)
}</span>
func (m *Tag) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_Tag.Size(m)
}</span>
func (m *Tag) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_Tag.DiscardUnknown(m)
}</span>

var xxx_messageInfo_Tag proto.InternalMessageInfo

func (m *Tag) GetKey() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Key
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Tag) GetVal() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Val
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type LifecycleFilter struct {
        // Object prefix for lifecycle filter
        Prefix               string   `protobuf:"bytes,1,opt,name=prefix,proto3" json:"prefix,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *LifecycleFilter) Reset()         <span class="cov0" title="0">{ *m = LifecycleFilter{} }</span>
func (m *LifecycleFilter) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*LifecycleFilter) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*LifecycleFilter) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_s3_ac4a79723b1dd58e, []int{40}
}</span>
func (m *LifecycleFilter) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_LifecycleFilter.Unmarshal(m, b)
}</span>
func (m *LifecycleFilter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_LifecycleFilter.Marshal(b, m, deterministic)
}</span>
func (dst *LifecycleFilter) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_LifecycleFilter.Merge(dst, src)
}</span>
func (m *LifecycleFilter) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_LifecycleFilter.Size(m)
}</span>
func (m *LifecycleFilter) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_LifecycleFilter.DiscardUnknown(m)
}</span>

var xxx_messageInfo_LifecycleFilter proto.InternalMessageInfo

func (m *LifecycleFilter) GetPrefix() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Prefix
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type Action struct {
        // Name of the action transition/expiration
        Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
        // Days after creation of object
        Days int32 `protobuf:"varint,2,opt,name=days,proto3" json:"days,omitempty"`
        // Delete marker in case of expiration for versioned bucket
        DeleteMarker string `protobuf:"bytes,3,opt,name=deleteMarker,proto3" json:"deleteMarker,omitempty"`
        // Storage class tier of the object where object is to be transitioned
        Tier int32 `protobuf:"varint,4,opt,name=tier,proto3" json:"tier,omitempty"`
        // Destination backend of the object/bucket for Cross-cloud transition
        Backend              string   `protobuf:"bytes,5,opt,name=backend,proto3" json:"backend,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *Action) Reset()         <span class="cov0" title="0">{ *m = Action{} }</span>
func (m *Action) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*Action) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*Action) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_s3_ac4a79723b1dd58e, []int{41}
}</span>
func (m *Action) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_Action.Unmarshal(m, b)
}</span>
func (m *Action) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_Action.Marshal(b, m, deterministic)
}</span>
func (dst *Action) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_Action.Merge(dst, src)
}</span>
func (m *Action) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_Action.Size(m)
}</span>
func (m *Action) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_Action.DiscardUnknown(m)
}</span>

var xxx_messageInfo_Action proto.InternalMessageInfo

func (m *Action) GetName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Action) GetDays() int32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Days
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *Action) GetDeleteMarker() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.DeleteMarker
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Action) GetTier() int32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Tier
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *Action) GetBackend() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Backend
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type AbortMultipartUpload struct {
        // Days after which the abort operation will be performed on incomplete upload
        DaysAfterInitiation  int32    `protobuf:"varint,1,opt,name=daysAfterInitiation,proto3" json:"daysAfterInitiation,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *AbortMultipartUpload) Reset()         <span class="cov0" title="0">{ *m = AbortMultipartUpload{} }</span>
func (m *AbortMultipartUpload) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*AbortMultipartUpload) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*AbortMultipartUpload) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_s3_ac4a79723b1dd58e, []int{42}
}</span>
func (m *AbortMultipartUpload) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_AbortMultipartUpload.Unmarshal(m, b)
}</span>
func (m *AbortMultipartUpload) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_AbortMultipartUpload.Marshal(b, m, deterministic)
}</span>
func (dst *AbortMultipartUpload) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_AbortMultipartUpload.Merge(dst, src)
}</span>
func (m *AbortMultipartUpload) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_AbortMultipartUpload.Size(m)
}</span>
func (m *AbortMultipartUpload) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_AbortMultipartUpload.DiscardUnknown(m)
}</span>

var xxx_messageInfo_AbortMultipartUpload proto.InternalMessageInfo

func (m *AbortMultipartUpload) GetDaysAfterInitiation() int32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.DaysAfterInitiation
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type LifecycleRule struct {
        Id                             string                `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
        Status                         string                `protobuf:"bytes,2,opt,name=status,proto3" json:"status,omitempty"`
        Filter                         *LifecycleFilter      `protobuf:"bytes,3,opt,name=filter,proto3" json:"filter,omitempty"`
        Actions                        []*Action             `protobuf:"bytes,4,rep,name=actions,proto3" json:"actions,omitempty"`
        AbortIncompleteMultipartUpload *AbortMultipartUpload `protobuf:"bytes,5,opt,name=abortIncompleteMultipartUpload,proto3" json:"abortIncompleteMultipartUpload,omitempty"`
        XXX_NoUnkeyedLiteral           struct{}              `json:"-"`
        XXX_unrecognized               []byte                `json:"-"`
        XXX_sizecache                  int32                 `json:"-"`
}

func (m *LifecycleRule) Reset()         <span class="cov0" title="0">{ *m = LifecycleRule{} }</span>
func (m *LifecycleRule) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*LifecycleRule) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*LifecycleRule) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_s3_ac4a79723b1dd58e, []int{43}
}</span>
func (m *LifecycleRule) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_LifecycleRule.Unmarshal(m, b)
}</span>
func (m *LifecycleRule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_LifecycleRule.Marshal(b, m, deterministic)
}</span>
func (dst *LifecycleRule) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_LifecycleRule.Merge(dst, src)
}</span>
func (m *LifecycleRule) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_LifecycleRule.Size(m)
}</span>
func (m *LifecycleRule) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_LifecycleRule.DiscardUnknown(m)
}</span>

var xxx_messageInfo_LifecycleRule proto.InternalMessageInfo

func (m *LifecycleRule) GetId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *LifecycleRule) GetStatus() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Status
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *LifecycleRule) GetFilter() *LifecycleFilter <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Filter
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *LifecycleRule) GetActions() []*Action <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Actions
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *LifecycleRule) GetAbortIncompleteMultipartUpload() *AbortMultipartUpload <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.AbortIncompleteMultipartUpload
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type PutBucketLifecycleRequest struct {
        BucketName           string           `protobuf:"bytes,1,opt,name=bucketName,proto3" json:"bucketName,omitempty"`
        Lc                   []*LifecycleRule `protobuf:"bytes,2,rep,name=lc,proto3" json:"lc,omitempty"`
        XXX_NoUnkeyedLiteral struct{}         `json:"-"`
        XXX_unrecognized     []byte           `json:"-"`
        XXX_sizecache        int32            `json:"-"`
}

func (m *PutBucketLifecycleRequest) Reset()         <span class="cov0" title="0">{ *m = PutBucketLifecycleRequest{} }</span>
func (m *PutBucketLifecycleRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*PutBucketLifecycleRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*PutBucketLifecycleRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_s3_ac4a79723b1dd58e, []int{44}
}</span>
func (m *PutBucketLifecycleRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_PutBucketLifecycleRequest.Unmarshal(m, b)
}</span>
func (m *PutBucketLifecycleRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_PutBucketLifecycleRequest.Marshal(b, m, deterministic)
}</span>
func (dst *PutBucketLifecycleRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_PutBucketLifecycleRequest.Merge(dst, src)
}</span>
func (m *PutBucketLifecycleRequest) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_PutBucketLifecycleRequest.Size(m)
}</span>
func (m *PutBucketLifecycleRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_PutBucketLifecycleRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_PutBucketLifecycleRequest proto.InternalMessageInfo

func (m *PutBucketLifecycleRequest) GetBucketName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.BucketName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *PutBucketLifecycleRequest) GetLc() []*LifecycleRule <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Lc
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type GetBucketLifecycleResponse struct {
        ErrorCode            int32            `protobuf:"varint,1,opt,name=errorCode,proto3" json:"errorCode,omitempty"`
        Lc                   []*LifecycleRule `protobuf:"bytes,2,rep,name=lc,proto3" json:"lc,omitempty"`
        XXX_NoUnkeyedLiteral struct{}         `json:"-"`
        XXX_unrecognized     []byte           `json:"-"`
        XXX_sizecache        int32            `json:"-"`
}

func (m *GetBucketLifecycleResponse) Reset()         <span class="cov8" title="1">{ *m = GetBucketLifecycleResponse{} }</span>
func (m *GetBucketLifecycleResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*GetBucketLifecycleResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*GetBucketLifecycleResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_s3_ac4a79723b1dd58e, []int{45}
}</span>
func (m *GetBucketLifecycleResponse) XXX_Unmarshal(b []byte) error <span class="cov8" title="1">{
        return xxx_messageInfo_GetBucketLifecycleResponse.Unmarshal(m, b)
}</span>
func (m *GetBucketLifecycleResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_GetBucketLifecycleResponse.Marshal(b, m, deterministic)
}</span>
func (dst *GetBucketLifecycleResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_GetBucketLifecycleResponse.Merge(dst, src)
}</span>
func (m *GetBucketLifecycleResponse) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_GetBucketLifecycleResponse.Size(m)
}</span>
func (m *GetBucketLifecycleResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_GetBucketLifecycleResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_GetBucketLifecycleResponse proto.InternalMessageInfo

func (m *GetBucketLifecycleResponse) GetErrorCode() int32 <span class="cov8" title="1">{
        if m != nil </span><span class="cov8" title="1">{
                return m.ErrorCode
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *GetBucketLifecycleResponse) GetLc() []*LifecycleRule <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Lc
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type ReplicationInfo struct {
        Status               string   `protobuf:"bytes,1,opt,name=status,proto3" json:"status,omitempty"`
        Backend              string   `protobuf:"bytes,2,opt,name=backend,proto3" json:"backend,omitempty"`
        StorageClass         string   `protobuf:"bytes,3,opt,name=storageClass,proto3" json:"storageClass,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *ReplicationInfo) Reset()         <span class="cov0" title="0">{ *m = ReplicationInfo{} }</span>
func (m *ReplicationInfo) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*ReplicationInfo) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*ReplicationInfo) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_s3_ac4a79723b1dd58e, []int{46}
}</span>
func (m *ReplicationInfo) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_ReplicationInfo.Unmarshal(m, b)
}</span>
func (m *ReplicationInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_ReplicationInfo.Marshal(b, m, deterministic)
}</span>
func (dst *ReplicationInfo) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_ReplicationInfo.Merge(dst, src)
}</span>
func (m *ReplicationInfo) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_ReplicationInfo.Size(m)
}</span>
func (m *ReplicationInfo) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_ReplicationInfo.DiscardUnknown(m)
}</span>

var xxx_messageInfo_ReplicationInfo proto.InternalMessageInfo

func (m *ReplicationInfo) GetStatus() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Status
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *ReplicationInfo) GetBackend() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Backend
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *ReplicationInfo) GetStorageClass() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.StorageClass
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type Acl struct {
        CannedAcl            string   `protobuf:"bytes,1,opt,name=cannedAcl,proto3" json:"cannedAcl,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *Acl) Reset()         <span class="cov0" title="0">{ *m = Acl{} }</span>
func (m *Acl) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*Acl) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*Acl) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_s3_ac4a79723b1dd58e, []int{47}
}</span>
func (m *Acl) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_Acl.Unmarshal(m, b)
}</span>
func (m *Acl) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_Acl.Marshal(b, m, deterministic)
}</span>
func (dst *Acl) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_Acl.Merge(dst, src)
}</span>
func (m *Acl) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_Acl.Size(m)
}</span>
func (m *Acl) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_Acl.DiscardUnknown(m)
}</span>

var xxx_messageInfo_Acl proto.InternalMessageInfo

func (m *Acl) GetCannedAcl() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.CannedAcl
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type GetBucketResponse struct {
        ErrorCode            int32    `protobuf:"varint,1,opt,name=errorCode,proto3" json:"errorCode,omitempty"`
        BucketMeta           *Bucket  `protobuf:"bytes,2,opt,name=bucketMeta,proto3" json:"bucketMeta,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *GetBucketResponse) Reset()         <span class="cov8" title="1">{ *m = GetBucketResponse{} }</span>
func (m *GetBucketResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*GetBucketResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*GetBucketResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_s3_ac4a79723b1dd58e, []int{48}
}</span>
func (m *GetBucketResponse) XXX_Unmarshal(b []byte) error <span class="cov8" title="1">{
        return xxx_messageInfo_GetBucketResponse.Unmarshal(m, b)
}</span>
func (m *GetBucketResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_GetBucketResponse.Marshal(b, m, deterministic)
}</span>
func (dst *GetBucketResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_GetBucketResponse.Merge(dst, src)
}</span>
func (m *GetBucketResponse) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_GetBucketResponse.Size(m)
}</span>
func (m *GetBucketResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_GetBucketResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_GetBucketResponse proto.InternalMessageInfo

func (m *GetBucketResponse) GetErrorCode() int32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ErrorCode
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *GetBucketResponse) GetBucketMeta() *Bucket <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.BucketMeta
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type Bucket struct {
        Name                     string                    `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
        TenantId                 string                    `protobuf:"bytes,2,opt,name=tenantId,proto3" json:"tenantId,omitempty"`
        UserId                   string                    `protobuf:"bytes,3,opt,name=userId,proto3" json:"userId,omitempty"`
        Acl                      *Acl                      `protobuf:"bytes,4,opt,name=acl,proto3" json:"acl,omitempty"`
        CreateTime               int64                     `protobuf:"varint,5,opt,name=createTime,proto3" json:"createTime,omitempty"`
        Id                       string                    `protobuf:"bytes,6,opt,name=id,proto3" json:"id,omitempty"`
        Deleted                  bool                      `protobuf:"varint,7,opt,name=deleted,proto3" json:"deleted,omitempty"`
        ServerSideEncryption     *ServerSideEncryption     `protobuf:"bytes,8,opt,name=serverSideEncryption,proto3" json:"serverSideEncryption,omitempty"`
        Versioning               *BucketVersioning         `protobuf:"bytes,9,opt,name=versioning,proto3" json:"versioning,omitempty"`
        DefaultLocation          string                    `protobuf:"bytes,10,opt,name=defaultLocation,proto3" json:"defaultLocation,omitempty"`
        WebsiteConfiguration     *WebsiteConfiguration     `protobuf:"bytes,11,opt,name=websiteConfiguration,proto3" json:"websiteConfiguration,omitempty"`
        Cors                     *CORSConfiguration        `protobuf:"bytes,12,opt,name=cors,proto3" json:"cors,omitempty"`
        ReplicationConfiguration *ReplicationConfiguration `protobuf:"bytes,13,opt,name=replicationConfiguration,proto3" json:"replicationConfiguration,omitempty"`
        LifecycleConfiguration   []*LifecycleRule          `protobuf:"bytes,14,rep,name=lifecycleConfiguration,proto3" json:"lifecycleConfiguration,omitempty"`
        BucketPolicy             string                    `protobuf:"bytes,15,opt,name=bucketPolicy,proto3" json:"bucketPolicy,omitempty"`
        Usages                   int64                     `protobuf:"varint,16,opt,name=usages,proto3" json:"usages,omitempty"`
        Tier                     int32                     `protobuf:"varint,17,opt,name=tier,proto3" json:"tier,omitempty"`
        ReplicationInfo          []*ReplicationInfo        `protobuf:"bytes,18,rep,name=replicationInfo,proto3" json:"replicationInfo,omitempty"`
        XXX_NoUnkeyedLiteral     struct{}                  `json:"-"`
        XXX_unrecognized         []byte                    `json:"-"`
        XXX_sizecache            int32                     `json:"-"`
}

func (m *Bucket) Reset()         <span class="cov0" title="0">{ *m = Bucket{} }</span>
func (m *Bucket) String() string <span class="cov8" title="1">{ return proto.CompactTextString(m) }</span>
func (*Bucket) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*Bucket) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_s3_ac4a79723b1dd58e, []int{49}
}</span>
func (m *Bucket) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_Bucket.Unmarshal(m, b)
}</span>
func (m *Bucket) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov8" title="1">{
        return xxx_messageInfo_Bucket.Marshal(b, m, deterministic)
}</span>
func (dst *Bucket) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_Bucket.Merge(dst, src)
}</span>
func (m *Bucket) XXX_Size() int <span class="cov8" title="1">{
        return xxx_messageInfo_Bucket.Size(m)
}</span>
func (m *Bucket) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_Bucket.DiscardUnknown(m)
}</span>

var xxx_messageInfo_Bucket proto.InternalMessageInfo

func (m *Bucket) GetName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Bucket) GetTenantId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.TenantId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Bucket) GetUserId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.UserId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Bucket) GetAcl() *Acl <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Acl
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *Bucket) GetCreateTime() int64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.CreateTime
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *Bucket) GetId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Bucket) GetDeleted() bool <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Deleted
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (m *Bucket) GetServerSideEncryption() *ServerSideEncryption <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ServerSideEncryption
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *Bucket) GetVersioning() *BucketVersioning <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Versioning
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *Bucket) GetDefaultLocation() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.DefaultLocation
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Bucket) GetWebsiteConfiguration() *WebsiteConfiguration <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.WebsiteConfiguration
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *Bucket) GetCors() *CORSConfiguration <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Cors
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *Bucket) GetReplicationConfiguration() *ReplicationConfiguration <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ReplicationConfiguration
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *Bucket) GetLifecycleConfiguration() []*LifecycleRule <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.LifecycleConfiguration
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *Bucket) GetBucketPolicy() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.BucketPolicy
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Bucket) GetUsages() int64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Usages
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *Bucket) GetTier() int32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Tier
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *Bucket) GetReplicationInfo() []*ReplicationInfo <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ReplicationInfo
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type Partion struct {
        Key                  string   `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
        PartNumber           int64    `protobuf:"varint,2,opt,name=partNumber,proto3" json:"partNumber,omitempty"`
        Size                 int64    `protobuf:"varint,3,opt,name=size,proto3" json:"size,omitempty"`
        Etag                 string   `protobuf:"bytes,4,opt,name=etag,proto3" json:"etag,omitempty"`
        LastModified         int64    `protobuf:"varint,5,opt,name=lastModified,proto3" json:"lastModified,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *Partion) Reset()         <span class="cov0" title="0">{ *m = Partion{} }</span>
func (m *Partion) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*Partion) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*Partion) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_s3_ac4a79723b1dd58e, []int{50}
}</span>
func (m *Partion) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_Partion.Unmarshal(m, b)
}</span>
func (m *Partion) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_Partion.Marshal(b, m, deterministic)
}</span>
func (dst *Partion) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_Partion.Merge(dst, src)
}</span>
func (m *Partion) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_Partion.Size(m)
}</span>
func (m *Partion) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_Partion.DiscardUnknown(m)
}</span>

var xxx_messageInfo_Partion proto.InternalMessageInfo

func (m *Partion) GetKey() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Key
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Partion) GetPartNumber() int64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.PartNumber
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *Partion) GetSize() int64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Size
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *Partion) GetEtag() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Etag
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Partion) GetLastModified() int64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.LastModified
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type Version struct {
        Versionid            string   `protobuf:"bytes,1,opt,name=versionid,proto3" json:"versionid,omitempty"`
        Etag                 string   `protobuf:"bytes,2,opt,name=etag,proto3" json:"etag,omitempty"`
        IsLatest             string   `protobuf:"bytes,3,opt,name=isLatest,proto3" json:"isLatest,omitempty"`
        LastModified         int64    `protobuf:"varint,4,opt,name=lastModified,proto3" json:"lastModified,omitempty"`
        Size                 int64    `protobuf:"varint,5,opt,name=size,proto3" json:"size,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *Version) Reset()         <span class="cov0" title="0">{ *m = Version{} }</span>
func (m *Version) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*Version) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*Version) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_s3_ac4a79723b1dd58e, []int{51}
}</span>
func (m *Version) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_Version.Unmarshal(m, b)
}</span>
func (m *Version) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_Version.Marshal(b, m, deterministic)
}</span>
func (dst *Version) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_Version.Merge(dst, src)
}</span>
func (m *Version) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_Version.Size(m)
}</span>
func (m *Version) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_Version.DiscardUnknown(m)
}</span>

var xxx_messageInfo_Version proto.InternalMessageInfo

func (m *Version) GetVersionid() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Versionid
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Version) GetEtag() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Etag
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Version) GetIsLatest() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.IsLatest
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Version) GetLastModified() int64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.LastModified
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *Version) GetSize() int64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Size
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type Object struct {
        ObjectKey               string                `protobuf:"bytes,1,opt,name=objectKey,proto3" json:"objectKey,omitempty"`
        BucketName              string                `protobuf:"bytes,2,opt,name=bucketName,proto3" json:"bucketName,omitempty"`
        TenantId                string                `protobuf:"bytes,3,opt,name=tenantId,proto3" json:"tenantId,omitempty"`
        UserId                  string                `protobuf:"bytes,4,opt,name=userId,proto3" json:"userId,omitempty"`
        VersionId               string                `protobuf:"bytes,5,opt,name=versionId,proto3" json:"versionId,omitempty"`
        ObjectId                string                `protobuf:"bytes,6,opt,name=objectId,proto3" json:"objectId,omitempty"`
        ContentType             string                `protobuf:"bytes,7,opt,name=contentType,proto3" json:"contentType,omitempty"`
        ContentMd5              string                `protobuf:"bytes,8,opt,name=contentMd5,proto3" json:"contentMd5,omitempty"`
        Versions                []*Version            `protobuf:"bytes,9,rep,name=versions,proto3" json:"versions,omitempty"`
        StorageClass            string                `protobuf:"bytes,10,opt,name=storageClass,proto3" json:"storageClass,omitempty"`
        ServerSideEncryption    *ServerSideEncryption `protobuf:"bytes,11,opt,name=serverSideEncryption,proto3" json:"serverSideEncryption,omitempty"`
        WebsiteRedirectLocation string                `protobuf:"bytes,12,opt,name=websiteRedirectLocation,proto3" json:"websiteRedirectLocation,omitempty"`
        Acl                     *Acl                  `protobuf:"bytes,13,opt,name=acl,proto3" json:"acl,omitempty"`
        Location                string                `protobuf:"bytes,14,opt,name=location,proto3" json:"location,omitempty"`
        IsNull                  bool                  `protobuf:"varint,15,opt,name=isNull,proto3" json:"isNull,omitempty"`
        DeleteMarker            bool                  `protobuf:"varint,16,opt,name=deleteMarker,proto3" json:"deleteMarker,omitempty"`
        Size                    int64                 `protobuf:"varint,17,opt,name=size,proto3" json:"size,omitempty"`
        Tags                    []*Tag                `protobuf:"bytes,18,rep,name=tags,proto3" json:"tags,omitempty"`
        LastModified            int64                 `protobuf:"varint,19,opt,name=lastModified,proto3" json:"lastModified,omitempty"`
        Etag                    string                `protobuf:"bytes,20,opt,name=etag,proto3" json:"etag,omitempty"`
        Tier                    int32                 `protobuf:"varint,21,opt,name=tier,proto3" json:"tier,omitempty"`
        Type                    int32                 `protobuf:"varint,22,opt,name=type,proto3" json:"type,omitempty"`
        NullVersion             bool                  `protobuf:"varint,23,opt,name=nullVersion,proto3" json:"nullVersion,omitempty"`
        CustomAttributes        map[string]string     `protobuf:"bytes,24,rep,name=customAttributes,proto3" json:"customAttributes,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
        StorageMeta             string                `protobuf:"bytes,25,opt,name=storageMeta,proto3" json:"storageMeta,omitempty"`
        XXX_NoUnkeyedLiteral    struct{}              `json:"-"`
        XXX_unrecognized        []byte                `json:"-"`
        XXX_sizecache           int32                 `json:"-"`
}

func (m *Object) Reset()         <span class="cov0" title="0">{ *m = Object{} }</span>
func (m *Object) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*Object) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*Object) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_s3_ac4a79723b1dd58e, []int{52}
}</span>
func (m *Object) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_Object.Unmarshal(m, b)
}</span>
func (m *Object) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_Object.Marshal(b, m, deterministic)
}</span>
func (dst *Object) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_Object.Merge(dst, src)
}</span>
func (m *Object) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_Object.Size(m)
}</span>
func (m *Object) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_Object.DiscardUnknown(m)
}</span>

var xxx_messageInfo_Object proto.InternalMessageInfo

func (m *Object) GetObjectKey() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ObjectKey
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Object) GetBucketName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.BucketName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Object) GetTenantId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.TenantId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Object) GetUserId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.UserId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Object) GetVersionId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.VersionId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Object) GetObjectId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ObjectId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Object) GetContentType() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ContentType
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Object) GetContentMd5() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ContentMd5
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Object) GetVersions() []*Version <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Versions
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *Object) GetStorageClass() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.StorageClass
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Object) GetServerSideEncryption() *ServerSideEncryption <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ServerSideEncryption
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *Object) GetWebsiteRedirectLocation() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.WebsiteRedirectLocation
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Object) GetAcl() *Acl <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Acl
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *Object) GetLocation() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Location
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Object) GetIsNull() bool <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.IsNull
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (m *Object) GetDeleteMarker() bool <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.DeleteMarker
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (m *Object) GetSize() int64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Size
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *Object) GetTags() []*Tag <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Tags
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *Object) GetLastModified() int64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.LastModified
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *Object) GetEtag() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Etag
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Object) GetTier() int32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Tier
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *Object) GetType() int32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Type
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *Object) GetNullVersion() bool <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.NullVersion
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (m *Object) GetCustomAttributes() map[string]string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.CustomAttributes
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *Object) GetStorageMeta() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.StorageMeta
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type ListBucketsResponse struct {
        ErrorCode            int32     `protobuf:"varint,1,opt,name=errorCode,proto3" json:"errorCode,omitempty"`
        Buckets              []*Bucket `protobuf:"bytes,2,rep,name=buckets,proto3" json:"buckets,omitempty"`
        XXX_NoUnkeyedLiteral struct{}  `json:"-"`
        XXX_unrecognized     []byte    `json:"-"`
        XXX_sizecache        int32     `json:"-"`
}

func (m *ListBucketsResponse) Reset()         <span class="cov8" title="1">{ *m = ListBucketsResponse{} }</span>
func (m *ListBucketsResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*ListBucketsResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*ListBucketsResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_s3_ac4a79723b1dd58e, []int{53}
}</span>
func (m *ListBucketsResponse) XXX_Unmarshal(b []byte) error <span class="cov8" title="1">{
        return xxx_messageInfo_ListBucketsResponse.Unmarshal(m, b)
}</span>
func (m *ListBucketsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_ListBucketsResponse.Marshal(b, m, deterministic)
}</span>
func (dst *ListBucketsResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_ListBucketsResponse.Merge(dst, src)
}</span>
func (m *ListBucketsResponse) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_ListBucketsResponse.Size(m)
}</span>
func (m *ListBucketsResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_ListBucketsResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_ListBucketsResponse proto.InternalMessageInfo

func (m *ListBucketsResponse) GetErrorCode() int32 <span class="cov8" title="1">{
        if m != nil </span><span class="cov8" title="1">{
                return m.ErrorCode
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *ListBucketsResponse) GetBuckets() []*Bucket <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Buckets
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type BaseResponse struct {
        ErrorCode            int32    `protobuf:"varint,1,opt,name=errorCode,proto3" json:"errorCode,omitempty"`
        Msg                  string   `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *BaseResponse) Reset()         <span class="cov8" title="1">{ *m = BaseResponse{} }</span>
func (m *BaseResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*BaseResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*BaseResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_s3_ac4a79723b1dd58e, []int{54}
}</span>
func (m *BaseResponse) XXX_Unmarshal(b []byte) error <span class="cov8" title="1">{
        return xxx_messageInfo_BaseResponse.Unmarshal(m, b)
}</span>
func (m *BaseResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_BaseResponse.Marshal(b, m, deterministic)
}</span>
func (dst *BaseResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_BaseResponse.Merge(dst, src)
}</span>
func (m *BaseResponse) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_BaseResponse.Size(m)
}</span>
func (m *BaseResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_BaseResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_BaseResponse proto.InternalMessageInfo

func (m *BaseResponse) GetErrorCode() int32 <span class="cov8" title="1">{
        if m != nil </span><span class="cov8" title="1">{
                return m.ErrorCode
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *BaseResponse) GetMsg() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Msg
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type BaseRequest struct {
        Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *BaseRequest) Reset()         <span class="cov0" title="0">{ *m = BaseRequest{} }</span>
func (m *BaseRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*BaseRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*BaseRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_s3_ac4a79723b1dd58e, []int{55}
}</span>
func (m *BaseRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_BaseRequest.Unmarshal(m, b)
}</span>
func (m *BaseRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov8" title="1">{
        return xxx_messageInfo_BaseRequest.Marshal(b, m, deterministic)
}</span>
func (dst *BaseRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_BaseRequest.Merge(dst, src)
}</span>
func (m *BaseRequest) XXX_Size() int <span class="cov8" title="1">{
        return xxx_messageInfo_BaseRequest.Size(m)
}</span>
func (m *BaseRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_BaseRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_BaseRequest proto.InternalMessageInfo

func (m *BaseRequest) GetId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type ListObjectsRequest struct {
        Bucket       string `protobuf:"bytes,1,opt,name=bucket,proto3" json:"bucket,omitempty"`
        Versioned    bool   `protobuf:"varint,2,opt,name=versioned,proto3" json:"versioned,omitempty"`
        Version      int32  `protobuf:"varint,3,opt,name=version,proto3" json:"version,omitempty"`
        Delimiter    string `protobuf:"bytes,4,opt,name=delimiter,proto3" json:"delimiter,omitempty"`
        EncodingType string `protobuf:"bytes,5,opt,name=encodingType,proto3" json:"encodingType,omitempty"`
        MaxKeys      int32  `protobuf:"varint,6,opt,name=maxKeys,proto3" json:"maxKeys,omitempty"`
        Prefix       string `protobuf:"bytes,7,opt,name=prefix,proto3" json:"prefix,omitempty"`
        // v1 specific
        Marker string `protobuf:"bytes,8,opt,name=marker,proto3" json:"marker,omitempty"`
        // v2 specific
        ContinuationToken string `protobuf:"bytes,9,opt,name=continuationToken,proto3" json:"continuationToken,omitempty"`
        StartAfter        string `protobuf:"bytes,10,opt,name=startAfter,proto3" json:"startAfter,omitempty"`
        FetchOwner        bool   `protobuf:"varint,11,opt,name=fetchOwner,proto3" json:"fetchOwner,omitempty"`
        // versioned specific
        KeyMarker       string `protobuf:"bytes,12,opt,name=keyMarker,proto3" json:"keyMarker,omitempty"`
        VersionIdMarker string `protobuf:"bytes,13,opt,name=versionIdMarker,proto3" json:"versionIdMarker,omitempty"`
        // for internal use, for example, lifecycle management may need to filter objects by tier, or create time.
        Filter               map[string]string `protobuf:"bytes,14,rep,name=filter,proto3" json:"filter,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
        XXX_NoUnkeyedLiteral struct{}          `json:"-"`
        XXX_unrecognized     []byte            `json:"-"`
        XXX_sizecache        int32             `json:"-"`
}

func (m *ListObjectsRequest) Reset()         <span class="cov0" title="0">{ *m = ListObjectsRequest{} }</span>
func (m *ListObjectsRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*ListObjectsRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*ListObjectsRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_s3_ac4a79723b1dd58e, []int{56}
}</span>
func (m *ListObjectsRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_ListObjectsRequest.Unmarshal(m, b)
}</span>
func (m *ListObjectsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov8" title="1">{
        return xxx_messageInfo_ListObjectsRequest.Marshal(b, m, deterministic)
}</span>
func (dst *ListObjectsRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_ListObjectsRequest.Merge(dst, src)
}</span>
func (m *ListObjectsRequest) XXX_Size() int <span class="cov8" title="1">{
        return xxx_messageInfo_ListObjectsRequest.Size(m)
}</span>
func (m *ListObjectsRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_ListObjectsRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_ListObjectsRequest proto.InternalMessageInfo

func (m *ListObjectsRequest) GetBucket() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Bucket
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *ListObjectsRequest) GetVersioned() bool <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Versioned
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (m *ListObjectsRequest) GetVersion() int32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Version
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *ListObjectsRequest) GetDelimiter() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Delimiter
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *ListObjectsRequest) GetEncodingType() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.EncodingType
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *ListObjectsRequest) GetMaxKeys() int32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.MaxKeys
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *ListObjectsRequest) GetPrefix() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Prefix
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *ListObjectsRequest) GetMarker() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Marker
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *ListObjectsRequest) GetContinuationToken() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ContinuationToken
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *ListObjectsRequest) GetStartAfter() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.StartAfter
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *ListObjectsRequest) GetFetchOwner() bool <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.FetchOwner
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (m *ListObjectsRequest) GetKeyMarker() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.KeyMarker
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *ListObjectsRequest) GetVersionIdMarker() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.VersionIdMarker
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *ListObjectsRequest) GetFilter() map[string]string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Filter
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type ListObjectsResponse struct {
        ErrorCode int32 `protobuf:"varint,1,opt,name=errorCode,proto3" json:"errorCode,omitempty"`
        // Indicates whether the returned list objects response is truncated. A
        // value of true indicates that the list was truncated. The list can be truncated
        // if the number of objects exceeds the limit allowed or specified
        // by max keys.
        IsTruncated bool `protobuf:"varint,2,opt,name=isTruncated,proto3" json:"isTruncated,omitempty"`
        // When response is truncated (the IsTruncated element value in the response
        // is true), you can use the key name in this field as marker in the subsequent
        // request to get next set of objects.
        //
        // NOTE: This element is returned only if you have delimiter request parameter
        // specified.
        NextMarker string `protobuf:"bytes,3,opt,name=nextMarker,proto3" json:"nextMarker,omitempty"`
        // List of prefixes for this request.
        Prefixes []string `protobuf:"bytes,4,rep,name=Prefixes,proto3" json:"Prefixes,omitempty"`
        // List of objects info for this request.
        Objects              []*Object `protobuf:"bytes,5,rep,name=objects,proto3" json:"objects,omitempty"`
        XXX_NoUnkeyedLiteral struct{}  `json:"-"`
        XXX_unrecognized     []byte    `json:"-"`
        XXX_sizecache        int32     `json:"-"`
}

func (m *ListObjectsResponse) Reset()         <span class="cov8" title="1">{ *m = ListObjectsResponse{} }</span>
func (m *ListObjectsResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*ListObjectsResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*ListObjectsResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_s3_ac4a79723b1dd58e, []int{57}
}</span>
func (m *ListObjectsResponse) XXX_Unmarshal(b []byte) error <span class="cov8" title="1">{
        return xxx_messageInfo_ListObjectsResponse.Unmarshal(m, b)
}</span>
func (m *ListObjectsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_ListObjectsResponse.Marshal(b, m, deterministic)
}</span>
func (dst *ListObjectsResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_ListObjectsResponse.Merge(dst, src)
}</span>
func (m *ListObjectsResponse) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_ListObjectsResponse.Size(m)
}</span>
func (m *ListObjectsResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_ListObjectsResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_ListObjectsResponse proto.InternalMessageInfo

func (m *ListObjectsResponse) GetErrorCode() int32 <span class="cov8" title="1">{
        if m != nil </span><span class="cov8" title="1">{
                return m.ErrorCode
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *ListObjectsResponse) GetIsTruncated() bool <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.IsTruncated
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (m *ListObjectsResponse) GetNextMarker() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.NextMarker
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *ListObjectsResponse) GetPrefixes() []string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Prefixes
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *ListObjectsResponse) GetObjects() []*Object <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Objects
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type CountObjectsResponse struct {
        Count                int64    `protobuf:"varint,1,opt,name=Count,proto3" json:"Count,omitempty"`
        Size                 int64    `protobuf:"varint,2,opt,name=Size,proto3" json:"Size,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *CountObjectsResponse) Reset()         <span class="cov0" title="0">{ *m = CountObjectsResponse{} }</span>
func (m *CountObjectsResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*CountObjectsResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*CountObjectsResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_s3_ac4a79723b1dd58e, []int{58}
}</span>
func (m *CountObjectsResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_CountObjectsResponse.Unmarshal(m, b)
}</span>
func (m *CountObjectsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_CountObjectsResponse.Marshal(b, m, deterministic)
}</span>
func (dst *CountObjectsResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_CountObjectsResponse.Merge(dst, src)
}</span>
func (m *CountObjectsResponse) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_CountObjectsResponse.Size(m)
}</span>
func (m *CountObjectsResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_CountObjectsResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_CountObjectsResponse proto.InternalMessageInfo

func (m *CountObjectsResponse) GetCount() int64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Count
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *CountObjectsResponse) GetSize() int64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Size
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type DeleteObjectInput struct {
        Bucket               string   `protobuf:"bytes,1,opt,name=bucket,proto3" json:"bucket,omitempty"`
        Key                  string   `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
        VersioId             string   `protobuf:"bytes,3,opt,name=versioId,proto3" json:"versioId,omitempty"`
        StorageMeta          string   `protobuf:"bytes,4,opt,name=storageMeta,proto3" json:"storageMeta,omitempty"`
        ETag                 string   `protobuf:"bytes,5,opt,name=eTag,proto3" json:"eTag,omitempty"`
        ObjectId             string   `protobuf:"bytes,6,opt,name=objectId,proto3" json:"objectId,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteObjectInput) Reset()         <span class="cov0" title="0">{ *m = DeleteObjectInput{} }</span>
func (m *DeleteObjectInput) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*DeleteObjectInput) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*DeleteObjectInput) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_s3_ac4a79723b1dd58e, []int{59}
}</span>
func (m *DeleteObjectInput) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_DeleteObjectInput.Unmarshal(m, b)
}</span>
func (m *DeleteObjectInput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_DeleteObjectInput.Marshal(b, m, deterministic)
}</span>
func (dst *DeleteObjectInput) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_DeleteObjectInput.Merge(dst, src)
}</span>
func (m *DeleteObjectInput) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_DeleteObjectInput.Size(m)
}</span>
func (m *DeleteObjectInput) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_DeleteObjectInput.DiscardUnknown(m)
}</span>

var xxx_messageInfo_DeleteObjectInput proto.InternalMessageInfo

func (m *DeleteObjectInput) GetBucket() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Bucket
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *DeleteObjectInput) GetKey() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Key
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *DeleteObjectInput) GetVersioId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.VersioId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *DeleteObjectInput) GetStorageMeta() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.StorageMeta
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *DeleteObjectInput) GetETag() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ETag
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *DeleteObjectInput) GetObjectId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ObjectId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type DeleteObjectOutput struct {
        ErrorCode            int32    `protobuf:"varint,1,opt,name=errorCode,proto3" json:"errorCode,omitempty"`
        DeleteMarker         bool     `protobuf:"varint,2,opt,name=deleteMarker,proto3" json:"deleteMarker,omitempty"`
        VersionId            string   `protobuf:"bytes,3,opt,name=versionId,proto3" json:"versionId,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteObjectOutput) Reset()         <span class="cov0" title="0">{ *m = DeleteObjectOutput{} }</span>
func (m *DeleteObjectOutput) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*DeleteObjectOutput) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*DeleteObjectOutput) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_s3_ac4a79723b1dd58e, []int{60}
}</span>
func (m *DeleteObjectOutput) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_DeleteObjectOutput.Unmarshal(m, b)
}</span>
func (m *DeleteObjectOutput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_DeleteObjectOutput.Marshal(b, m, deterministic)
}</span>
func (dst *DeleteObjectOutput) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_DeleteObjectOutput.Merge(dst, src)
}</span>
func (m *DeleteObjectOutput) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_DeleteObjectOutput.Size(m)
}</span>
func (m *DeleteObjectOutput) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_DeleteObjectOutput.DiscardUnknown(m)
}</span>

var xxx_messageInfo_DeleteObjectOutput proto.InternalMessageInfo

func (m *DeleteObjectOutput) GetErrorCode() int32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ErrorCode
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *DeleteObjectOutput) GetDeleteMarker() bool <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.DeleteMarker
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (m *DeleteObjectOutput) GetVersionId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.VersionId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type GetObjectInput struct {
        Bucket               string   `protobuf:"bytes,1,opt,name=Bucket,proto3" json:"Bucket,omitempty"`
        Key                  string   `protobuf:"bytes,2,opt,name=Key,proto3" json:"Key,omitempty"`
        VersionId            string   `protobuf:"bytes,3,opt,name=VersionId,proto3" json:"VersionId,omitempty"`
        Offset               int64    `protobuf:"varint,4,opt,name=Offset,proto3" json:"Offset,omitempty"`
        Length               int64    `protobuf:"varint,5,opt,name=Length,proto3" json:"Length,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *GetObjectInput) Reset()         <span class="cov0" title="0">{ *m = GetObjectInput{} }</span>
func (m *GetObjectInput) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*GetObjectInput) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*GetObjectInput) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_s3_ac4a79723b1dd58e, []int{61}
}</span>
func (m *GetObjectInput) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_GetObjectInput.Unmarshal(m, b)
}</span>
func (m *GetObjectInput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_GetObjectInput.Marshal(b, m, deterministic)
}</span>
func (dst *GetObjectInput) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_GetObjectInput.Merge(dst, src)
}</span>
func (m *GetObjectInput) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_GetObjectInput.Size(m)
}</span>
func (m *GetObjectInput) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_GetObjectInput.DiscardUnknown(m)
}</span>

var xxx_messageInfo_GetObjectInput proto.InternalMessageInfo

func (m *GetObjectInput) GetBucket() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Bucket
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *GetObjectInput) GetKey() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Key
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *GetObjectInput) GetVersionId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.VersionId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *GetObjectInput) GetOffset() int64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Offset
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *GetObjectInput) GetLength() int64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Length
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type MultipartUpload struct {
        Bucket               string   `protobuf:"bytes,1,opt,name=bucket,proto3" json:"bucket,omitempty"`
        Key                  string   `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
        UploadId             string   `protobuf:"bytes,3,opt,name=uploadId,proto3" json:"uploadId,omitempty"`
        ObjectId             string   `protobuf:"bytes,4,opt,name=objectId,proto3" json:"objectId,omitempty"`
        Location             string   `protobuf:"bytes,5,opt,name=location,proto3" json:"location,omitempty"`
        Tier                 int32    `protobuf:"varint,6,opt,name=tier,proto3" json:"tier,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *MultipartUpload) Reset()         <span class="cov0" title="0">{ *m = MultipartUpload{} }</span>
func (m *MultipartUpload) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*MultipartUpload) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*MultipartUpload) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_s3_ac4a79723b1dd58e, []int{62}
}</span>
func (m *MultipartUpload) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_MultipartUpload.Unmarshal(m, b)
}</span>
func (m *MultipartUpload) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_MultipartUpload.Marshal(b, m, deterministic)
}</span>
func (dst *MultipartUpload) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_MultipartUpload.Merge(dst, src)
}</span>
func (m *MultipartUpload) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_MultipartUpload.Size(m)
}</span>
func (m *MultipartUpload) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_MultipartUpload.DiscardUnknown(m)
}</span>

var xxx_messageInfo_MultipartUpload proto.InternalMessageInfo

func (m *MultipartUpload) GetBucket() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Bucket
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *MultipartUpload) GetKey() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Key
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *MultipartUpload) GetUploadId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.UploadId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *MultipartUpload) GetObjectId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ObjectId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *MultipartUpload) GetLocation() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Location
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *MultipartUpload) GetTier() int32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Tier
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type ListParts struct {
        Bucket               string   `protobuf:"bytes,1,opt,name=Bucket,proto3" json:"Bucket,omitempty"`
        Key                  string   `protobuf:"bytes,2,opt,name=Key,proto3" json:"Key,omitempty"`
        UploadId             string   `protobuf:"bytes,3,opt,name=uploadId,proto3" json:"uploadId,omitempty"`
        MaxParts             int64    `protobuf:"varint,4,opt,name=MaxParts,proto3" json:"MaxParts,omitempty"`
        PartNumberMarker     int64    `protobuf:"varint,5,opt,name=PartNumberMarker,proto3" json:"PartNumberMarker,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *ListParts) Reset()         <span class="cov0" title="0">{ *m = ListParts{} }</span>
func (m *ListParts) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*ListParts) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*ListParts) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_s3_ac4a79723b1dd58e, []int{63}
}</span>
func (m *ListParts) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_ListParts.Unmarshal(m, b)
}</span>
func (m *ListParts) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_ListParts.Marshal(b, m, deterministic)
}</span>
func (dst *ListParts) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_ListParts.Merge(dst, src)
}</span>
func (m *ListParts) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_ListParts.Size(m)
}</span>
func (m *ListParts) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_ListParts.DiscardUnknown(m)
}</span>

var xxx_messageInfo_ListParts proto.InternalMessageInfo

func (m *ListParts) GetBucket() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Bucket
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *ListParts) GetKey() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Key
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *ListParts) GetUploadId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.UploadId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *ListParts) GetMaxParts() int64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.MaxParts
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *ListParts) GetPartNumberMarker() int64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.PartNumberMarker
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type TList struct {
        Tier                 []int32  `protobuf:"varint,1,rep,packed,name=Tier,proto3" json:"Tier,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *TList) Reset()         <span class="cov0" title="0">{ *m = TList{} }</span>
func (m *TList) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*TList) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*TList) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_s3_ac4a79723b1dd58e, []int{64}
}</span>
func (m *TList) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_TList.Unmarshal(m, b)
}</span>
func (m *TList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_TList.Marshal(b, m, deterministic)
}</span>
func (dst *TList) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_TList.Merge(dst, src)
}</span>
func (m *TList) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_TList.Size(m)
}</span>
func (m *TList) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_TList.DiscardUnknown(m)
}</span>

var xxx_messageInfo_TList proto.InternalMessageInfo

func (m *TList) GetTier() []int32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Tier
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type Tier2ClassName struct {
        Lst                  map[int32]string `protobuf:"bytes,1,rep,name=lst,proto3" json:"lst,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
        XXX_NoUnkeyedLiteral struct{}         `json:"-"`
        XXX_unrecognized     []byte           `json:"-"`
        XXX_sizecache        int32            `json:"-"`
}

func (m *Tier2ClassName) Reset()         <span class="cov0" title="0">{ *m = Tier2ClassName{} }</span>
func (m *Tier2ClassName) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*Tier2ClassName) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*Tier2ClassName) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_s3_ac4a79723b1dd58e, []int{65}
}</span>
func (m *Tier2ClassName) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_Tier2ClassName.Unmarshal(m, b)
}</span>
func (m *Tier2ClassName) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_Tier2ClassName.Marshal(b, m, deterministic)
}</span>
func (dst *Tier2ClassName) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_Tier2ClassName.Merge(dst, src)
}</span>
func (m *Tier2ClassName) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_Tier2ClassName.Size(m)
}</span>
func (m *Tier2ClassName) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_Tier2ClassName.DiscardUnknown(m)
}</span>

var xxx_messageInfo_Tier2ClassName proto.InternalMessageInfo

func (m *Tier2ClassName) GetLst() map[int32]string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Lst
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type GetTierMapResponse struct {
        Transition           []string                   `protobuf:"bytes,1,rep,name=Transition,proto3" json:"Transition,omitempty"`
        Tier2Name            map[string]*Tier2ClassName `protobuf:"bytes,2,rep,name=Tier2Name,proto3" json:"Tier2Name,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
        XXX_NoUnkeyedLiteral struct{}                   `json:"-"`
        XXX_unrecognized     []byte                     `json:"-"`
        XXX_sizecache        int32                      `json:"-"`
}

func (m *GetTierMapResponse) Reset()         <span class="cov0" title="0">{ *m = GetTierMapResponse{} }</span>
func (m *GetTierMapResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*GetTierMapResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*GetTierMapResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_s3_ac4a79723b1dd58e, []int{66}
}</span>
func (m *GetTierMapResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_GetTierMapResponse.Unmarshal(m, b)
}</span>
func (m *GetTierMapResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_GetTierMapResponse.Marshal(b, m, deterministic)
}</span>
func (dst *GetTierMapResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_GetTierMapResponse.Merge(dst, src)
}</span>
func (m *GetTierMapResponse) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_GetTierMapResponse.Size(m)
}</span>
func (m *GetTierMapResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_GetTierMapResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_GetTierMapResponse proto.InternalMessageInfo

func (m *GetTierMapResponse) GetTransition() []string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Transition
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *GetTierMapResponse) GetTier2Name() map[string]*Tier2ClassName <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Tier2Name
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type UpdateObjMetaRequest struct {
        ObjKey               string            `protobuf:"bytes,1,opt,name=ObjKey,proto3" json:"ObjKey,omitempty"`
        BucketName           string            `protobuf:"bytes,2,opt,name=BucketName,proto3" json:"BucketName,omitempty"`
        LastModified         int64             `protobuf:"varint,3,opt,name=LastModified,proto3" json:"LastModified,omitempty"`
        Setting              map[string]string `protobuf:"bytes,4,rep,name=Setting,proto3" json:"Setting,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
        XXX_NoUnkeyedLiteral struct{}          `json:"-"`
        XXX_unrecognized     []byte            `json:"-"`
        XXX_sizecache        int32             `json:"-"`
}

func (m *UpdateObjMetaRequest) Reset()         <span class="cov0" title="0">{ *m = UpdateObjMetaRequest{} }</span>
func (m *UpdateObjMetaRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*UpdateObjMetaRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*UpdateObjMetaRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_s3_ac4a79723b1dd58e, []int{67}
}</span>
func (m *UpdateObjMetaRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_UpdateObjMetaRequest.Unmarshal(m, b)
}</span>
func (m *UpdateObjMetaRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_UpdateObjMetaRequest.Marshal(b, m, deterministic)
}</span>
func (dst *UpdateObjMetaRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_UpdateObjMetaRequest.Merge(dst, src)
}</span>
func (m *UpdateObjMetaRequest) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_UpdateObjMetaRequest.Size(m)
}</span>
func (m *UpdateObjMetaRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_UpdateObjMetaRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_UpdateObjMetaRequest proto.InternalMessageInfo

func (m *UpdateObjMetaRequest) GetObjKey() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ObjKey
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *UpdateObjMetaRequest) GetBucketName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.BucketName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *UpdateObjMetaRequest) GetLastModified() int64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.LastModified
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *UpdateObjMetaRequest) GetSetting() map[string]string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Setting
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type StorageClass struct {
        Name                 string   `protobuf:"bytes,1,opt,name=Name,proto3" json:"Name,omitempty"`
        Tier                 int32    `protobuf:"varint,2,opt,name=Tier,proto3" json:"Tier,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *StorageClass) Reset()         <span class="cov0" title="0">{ *m = StorageClass{} }</span>
func (m *StorageClass) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*StorageClass) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*StorageClass) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_s3_ac4a79723b1dd58e, []int{68}
}</span>
func (m *StorageClass) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_StorageClass.Unmarshal(m, b)
}</span>
func (m *StorageClass) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_StorageClass.Marshal(b, m, deterministic)
}</span>
func (dst *StorageClass) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_StorageClass.Merge(dst, src)
}</span>
func (m *StorageClass) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_StorageClass.Size(m)
}</span>
func (m *StorageClass) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_StorageClass.DiscardUnknown(m)
}</span>

var xxx_messageInfo_StorageClass proto.InternalMessageInfo

func (m *StorageClass) GetName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *StorageClass) GetTier() int32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Tier
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type GetStorageClassesResponse struct {
        Classes              []*StorageClass `protobuf:"bytes,1,rep,name=classes,proto3" json:"classes,omitempty"`
        XXX_NoUnkeyedLiteral struct{}        `json:"-"`
        XXX_unrecognized     []byte          `json:"-"`
        XXX_sizecache        int32           `json:"-"`
}

func (m *GetStorageClassesResponse) Reset()         <span class="cov0" title="0">{ *m = GetStorageClassesResponse{} }</span>
func (m *GetStorageClassesResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*GetStorageClassesResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*GetStorageClassesResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_s3_ac4a79723b1dd58e, []int{69}
}</span>
func (m *GetStorageClassesResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_GetStorageClassesResponse.Unmarshal(m, b)
}</span>
func (m *GetStorageClassesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_GetStorageClassesResponse.Marshal(b, m, deterministic)
}</span>
func (dst *GetStorageClassesResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_GetStorageClassesResponse.Merge(dst, src)
}</span>
func (m *GetStorageClassesResponse) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_GetStorageClassesResponse.Size(m)
}</span>
func (m *GetStorageClassesResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_GetStorageClassesResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_GetStorageClassesResponse proto.InternalMessageInfo

func (m *GetStorageClassesResponse) GetClasses() []*StorageClass <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Classes
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type GetBackendTypeByTierRequest struct {
        Tier                 int32    `protobuf:"varint,1,opt,name=Tier,proto3" json:"Tier,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *GetBackendTypeByTierRequest) Reset()         <span class="cov0" title="0">{ *m = GetBackendTypeByTierRequest{} }</span>
func (m *GetBackendTypeByTierRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*GetBackendTypeByTierRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*GetBackendTypeByTierRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_s3_ac4a79723b1dd58e, []int{70}
}</span>
func (m *GetBackendTypeByTierRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_GetBackendTypeByTierRequest.Unmarshal(m, b)
}</span>
func (m *GetBackendTypeByTierRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_GetBackendTypeByTierRequest.Marshal(b, m, deterministic)
}</span>
func (dst *GetBackendTypeByTierRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_GetBackendTypeByTierRequest.Merge(dst, src)
}</span>
func (m *GetBackendTypeByTierRequest) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_GetBackendTypeByTierRequest.Size(m)
}</span>
func (m *GetBackendTypeByTierRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_GetBackendTypeByTierRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_GetBackendTypeByTierRequest proto.InternalMessageInfo

func (m *GetBackendTypeByTierRequest) GetTier() int32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Tier
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type GetBackendTypeByTierResponse struct {
        Types                []string `protobuf:"bytes,1,rep,name=Types,proto3" json:"Types,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *GetBackendTypeByTierResponse) Reset()         <span class="cov0" title="0">{ *m = GetBackendTypeByTierResponse{} }</span>
func (m *GetBackendTypeByTierResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*GetBackendTypeByTierResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*GetBackendTypeByTierResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_s3_ac4a79723b1dd58e, []int{71}
}</span>
func (m *GetBackendTypeByTierResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_GetBackendTypeByTierResponse.Unmarshal(m, b)
}</span>
func (m *GetBackendTypeByTierResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_GetBackendTypeByTierResponse.Marshal(b, m, deterministic)
}</span>
func (dst *GetBackendTypeByTierResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_GetBackendTypeByTierResponse.Merge(dst, src)
}</span>
func (m *GetBackendTypeByTierResponse) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_GetBackendTypeByTierResponse.Size(m)
}</span>
func (m *GetBackendTypeByTierResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_GetBackendTypeByTierResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_GetBackendTypeByTierResponse proto.InternalMessageInfo

func (m *GetBackendTypeByTierResponse) GetTypes() []string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Types
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type MultipartUploadRecord struct {
        ObjectKey            string   `protobuf:"bytes,1,opt,name=ObjectKey,proto3" json:"ObjectKey,omitempty"`
        Bucket               string   `protobuf:"bytes,2,opt,name=Bucket,proto3" json:"Bucket,omitempty"`
        Backend              string   `protobuf:"bytes,3,opt,name=Backend,proto3" json:"Backend,omitempty"`
        UploadId             string   `protobuf:"bytes,4,opt,name=UploadId,proto3" json:"UploadId,omitempty"`
        InitTime             int64    `protobuf:"varint,5,opt,name=InitTime,proto3" json:"InitTime,omitempty"`
        TenantId             string   `protobuf:"bytes,6,opt,name=tenantId,proto3" json:"tenantId,omitempty"`
        UserId               string   `protobuf:"bytes,7,opt,name=userId,proto3" json:"userId,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *MultipartUploadRecord) Reset()         <span class="cov0" title="0">{ *m = MultipartUploadRecord{} }</span>
func (m *MultipartUploadRecord) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*MultipartUploadRecord) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*MultipartUploadRecord) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_s3_ac4a79723b1dd58e, []int{72}
}</span>
func (m *MultipartUploadRecord) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_MultipartUploadRecord.Unmarshal(m, b)
}</span>
func (m *MultipartUploadRecord) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_MultipartUploadRecord.Marshal(b, m, deterministic)
}</span>
func (dst *MultipartUploadRecord) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_MultipartUploadRecord.Merge(dst, src)
}</span>
func (m *MultipartUploadRecord) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_MultipartUploadRecord.Size(m)
}</span>
func (m *MultipartUploadRecord) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_MultipartUploadRecord.DiscardUnknown(m)
}</span>

var xxx_messageInfo_MultipartUploadRecord proto.InternalMessageInfo

func (m *MultipartUploadRecord) GetObjectKey() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ObjectKey
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *MultipartUploadRecord) GetBucket() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Bucket
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *MultipartUploadRecord) GetBackend() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Backend
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *MultipartUploadRecord) GetUploadId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.UploadId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *MultipartUploadRecord) GetInitTime() int64 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.InitTime
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *MultipartUploadRecord) GetTenantId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.TenantId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *MultipartUploadRecord) GetUserId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.UserId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type ListBucketUploadRequest struct {
        BucketName           string   `protobuf:"bytes,1,opt,name=bucketName,proto3" json:"bucketName,omitempty"`
        Delimiter            string   `protobuf:"bytes,2,opt,name=delimiter,proto3" json:"delimiter,omitempty"`
        EncodingType         string   `protobuf:"bytes,3,opt,name=encodingType,proto3" json:"encodingType,omitempty"`
        MaxUploads           int32    `protobuf:"varint,4,opt,name=maxUploads,proto3" json:"maxUploads,omitempty"`
        KeyMarker            string   `protobuf:"bytes,5,opt,name=keyMarker,proto3" json:"keyMarker,omitempty"`
        Prefix               string   `protobuf:"bytes,6,opt,name=prefix,proto3" json:"prefix,omitempty"`
        UploadIdMarker       string   `protobuf:"bytes,7,opt,name=uploadIdMarker,proto3" json:"uploadIdMarker,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *ListBucketUploadRequest) Reset()         <span class="cov0" title="0">{ *m = ListBucketUploadRequest{} }</span>
func (m *ListBucketUploadRequest) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*ListBucketUploadRequest) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*ListBucketUploadRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_s3_ac4a79723b1dd58e, []int{73}
}</span>
func (m *ListBucketUploadRequest) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_ListBucketUploadRequest.Unmarshal(m, b)
}</span>
func (m *ListBucketUploadRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_ListBucketUploadRequest.Marshal(b, m, deterministic)
}</span>
func (dst *ListBucketUploadRequest) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_ListBucketUploadRequest.Merge(dst, src)
}</span>
func (m *ListBucketUploadRequest) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_ListBucketUploadRequest.Size(m)
}</span>
func (m *ListBucketUploadRequest) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_ListBucketUploadRequest.DiscardUnknown(m)
}</span>

var xxx_messageInfo_ListBucketUploadRequest proto.InternalMessageInfo

func (m *ListBucketUploadRequest) GetBucketName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.BucketName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *ListBucketUploadRequest) GetDelimiter() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Delimiter
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *ListBucketUploadRequest) GetEncodingType() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.EncodingType
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *ListBucketUploadRequest) GetMaxUploads() int32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.MaxUploads
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *ListBucketUploadRequest) GetKeyMarker() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.KeyMarker
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *ListBucketUploadRequest) GetPrefix() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Prefix
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *ListBucketUploadRequest) GetUploadIdMarker() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.UploadIdMarker
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type Owner struct {
        Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
        DisplayName          string   `protobuf:"bytes,2,opt,name=displayName,proto3" json:"displayName,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *Owner) Reset()         <span class="cov0" title="0">{ *m = Owner{} }</span>
func (m *Owner) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*Owner) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*Owner) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_s3_ac4a79723b1dd58e, []int{74}
}</span>
func (m *Owner) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_Owner.Unmarshal(m, b)
}</span>
func (m *Owner) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_Owner.Marshal(b, m, deterministic)
}</span>
func (dst *Owner) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_Owner.Merge(dst, src)
}</span>
func (m *Owner) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_Owner.Size(m)
}</span>
func (m *Owner) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_Owner.DiscardUnknown(m)
}</span>

var xxx_messageInfo_Owner proto.InternalMessageInfo

func (m *Owner) GetId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Owner) GetDisplayName() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.DisplayName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type Upload struct {
        Key                  string   `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
        UploadId             string   `protobuf:"bytes,2,opt,name=uploadId,proto3" json:"uploadId,omitempty"`
        Initiator            *Owner   `protobuf:"bytes,3,opt,name=initiator,proto3" json:"initiator,omitempty"`
        Owner                *Owner   `protobuf:"bytes,4,opt,name=owner,proto3" json:"owner,omitempty"`
        StorageClass         string   `protobuf:"bytes,5,opt,name=storageClass,proto3" json:"storageClass,omitempty"`
        Initiated            string   `protobuf:"bytes,6,opt,name=initiated,proto3" json:"initiated,omitempty"`
        XXX_NoUnkeyedLiteral struct{} `json:"-"`
        XXX_unrecognized     []byte   `json:"-"`
        XXX_sizecache        int32    `json:"-"`
}

func (m *Upload) Reset()         <span class="cov0" title="0">{ *m = Upload{} }</span>
func (m *Upload) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*Upload) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*Upload) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_s3_ac4a79723b1dd58e, []int{75}
}</span>
func (m *Upload) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_Upload.Unmarshal(m, b)
}</span>
func (m *Upload) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_Upload.Marshal(b, m, deterministic)
}</span>
func (dst *Upload) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_Upload.Merge(dst, src)
}</span>
func (m *Upload) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_Upload.Size(m)
}</span>
func (m *Upload) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_Upload.DiscardUnknown(m)
}</span>

var xxx_messageInfo_Upload proto.InternalMessageInfo

func (m *Upload) GetKey() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Key
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Upload) GetUploadId() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.UploadId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Upload) GetInitiator() *Owner <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Initiator
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *Upload) GetOwner() *Owner <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Owner
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *Upload) GetStorageClass() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.StorageClass
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Upload) GetInitiated() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Initiated
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type ListBucketUploadResult struct {
        IsTruncated          bool      `protobuf:"varint,1,opt,name=isTruncated,proto3" json:"isTruncated,omitempty"`
        NextKeyMarker        string    `protobuf:"bytes,2,opt,name=nextKeyMarker,proto3" json:"nextKeyMarker,omitempty"`
        NextUploadIdMarker   string    `protobuf:"bytes,3,opt,name=nextUploadIdMarker,proto3" json:"nextUploadIdMarker,omitempty"`
        CommonPrefix         []string  `protobuf:"bytes,4,rep,name=commonPrefix,proto3" json:"commonPrefix,omitempty"`
        Uploads              []*Upload `protobuf:"bytes,5,rep,name=uploads,proto3" json:"uploads,omitempty"`
        XXX_NoUnkeyedLiteral struct{}  `json:"-"`
        XXX_unrecognized     []byte    `json:"-"`
        XXX_sizecache        int32     `json:"-"`
}

func (m *ListBucketUploadResult) Reset()         <span class="cov0" title="0">{ *m = ListBucketUploadResult{} }</span>
func (m *ListBucketUploadResult) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*ListBucketUploadResult) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*ListBucketUploadResult) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_s3_ac4a79723b1dd58e, []int{76}
}</span>
func (m *ListBucketUploadResult) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_ListBucketUploadResult.Unmarshal(m, b)
}</span>
func (m *ListBucketUploadResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_ListBucketUploadResult.Marshal(b, m, deterministic)
}</span>
func (dst *ListBucketUploadResult) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_ListBucketUploadResult.Merge(dst, src)
}</span>
func (m *ListBucketUploadResult) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_ListBucketUploadResult.Size(m)
}</span>
func (m *ListBucketUploadResult) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_ListBucketUploadResult.DiscardUnknown(m)
}</span>

var xxx_messageInfo_ListBucketUploadResult proto.InternalMessageInfo

func (m *ListBucketUploadResult) GetIsTruncated() bool <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.IsTruncated
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (m *ListBucketUploadResult) GetNextKeyMarker() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.NextKeyMarker
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *ListBucketUploadResult) GetNextUploadIdMarker() string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.NextUploadIdMarker
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *ListBucketUploadResult) GetCommonPrefix() []string <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.CommonPrefix
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *ListBucketUploadResult) GetUploads() []*Upload <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Uploads
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type ListBucketUploadResponse struct {
        ErrorCode            int32                   `protobuf:"varint,1,opt,name=errorCode,proto3" json:"errorCode,omitempty"`
        Result               *ListBucketUploadResult `protobuf:"bytes,2,opt,name=result,proto3" json:"result,omitempty"`
        XXX_NoUnkeyedLiteral struct{}                `json:"-"`
        XXX_unrecognized     []byte                  `json:"-"`
        XXX_sizecache        int32                   `json:"-"`
}

func (m *ListBucketUploadResponse) Reset()         <span class="cov0" title="0">{ *m = ListBucketUploadResponse{} }</span>
func (m *ListBucketUploadResponse) String() string <span class="cov0" title="0">{ return proto.CompactTextString(m) }</span>
func (*ListBucketUploadResponse) ProtoMessage()    {<span class="cov0" title="0">}</span>
func (*ListBucketUploadResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return fileDescriptor_s3_ac4a79723b1dd58e, []int{77}
}</span>
func (m *ListBucketUploadResponse) XXX_Unmarshal(b []byte) error <span class="cov0" title="0">{
        return xxx_messageInfo_ListBucketUploadResponse.Unmarshal(m, b)
}</span>
func (m *ListBucketUploadResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) <span class="cov0" title="0">{
        return xxx_messageInfo_ListBucketUploadResponse.Marshal(b, m, deterministic)
}</span>
func (dst *ListBucketUploadResponse) XXX_Merge(src proto.Message) <span class="cov0" title="0">{
        xxx_messageInfo_ListBucketUploadResponse.Merge(dst, src)
}</span>
func (m *ListBucketUploadResponse) XXX_Size() int <span class="cov0" title="0">{
        return xxx_messageInfo_ListBucketUploadResponse.Size(m)
}</span>
func (m *ListBucketUploadResponse) XXX_DiscardUnknown() <span class="cov0" title="0">{
        xxx_messageInfo_ListBucketUploadResponse.DiscardUnknown(m)
}</span>

var xxx_messageInfo_ListBucketUploadResponse proto.InternalMessageInfo

func (m *ListBucketUploadResponse) GetErrorCode() int32 <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.ErrorCode
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *ListBucketUploadResponse) GetResult() *ListBucketUploadResult <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Result
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func init() <span class="cov8" title="1">{
        proto.RegisterType((*ListObjectPartsRequest)(nil), "ListObjectPartsRequest")
        proto.RegisterType((*Part)(nil), "Part")
        proto.RegisterType((*ListObjectPartsResponse)(nil), "ListObjectPartsResponse")
        proto.RegisterType((*AbortMultipartRequest)(nil), "AbortMultipartRequest")
        proto.RegisterType((*CompletePart)(nil), "CompletePart")
        proto.RegisterType((*CompleteMultipartRequest)(nil), "CompleteMultipartRequest")
        proto.RegisterType((*CompleteMultipartResponse)(nil), "CompleteMultipartResponse")
        proto.RegisterType((*InitMultiPartRequest)(nil), "InitMultiPartRequest")
        proto.RegisterMapType((map[string]string)(nil), "InitMultiPartRequest.AttrsEntry")
        proto.RegisterType((*InitMultiPartResponse)(nil), "InitMultiPartResponse")
        proto.RegisterType((*PutDataStream)(nil), "PutDataStream")
        proto.RegisterType((*UploadPartRequest)(nil), "UploadPartRequest")
        proto.RegisterType((*UploadPartResponse)(nil), "UploadPartResponse")
        proto.RegisterType((*CopyObjectRequest)(nil), "CopyObjectRequest")
        proto.RegisterType((*CopyObjectResponse)(nil), "CopyObjectResponse")
        proto.RegisterType((*MoveObjectRequest)(nil), "MoveObjectRequest")
        proto.RegisterType((*MoveObjectResponse)(nil), "MoveObjectResponse")
        proto.RegisterType((*PutObjectRequest)(nil), "PutObjectRequest")
        proto.RegisterMapType((map[string]string)(nil), "PutObjectRequest.AttrsEntry")
        proto.RegisterType((*GetObjectResponse)(nil), "GetObjectResponse")
        proto.RegisterType((*GetObjectMetaResult)(nil), "GetObjectMetaResult")
        proto.RegisterType((*PutObjectResponse)(nil), "PutObjectResponse")
        proto.RegisterType((*PutBucketACLRequest)(nil), "PutBucketACLRequest")
        proto.RegisterType((*BucketACL)(nil), "BucketACL")
        proto.RegisterType((*BucketVersioning)(nil), "BucketVersioning")
        proto.RegisterType((*ObjACL)(nil), "ObjACL")
        proto.RegisterType((*PutObjACLRequest)(nil), "PutObjACLRequest")
        proto.RegisterType((*BaseBucketRequest)(nil), "BaseBucketRequest")
        proto.RegisterType((*BaseObjRequest)(nil), "BaseObjRequest")
        proto.RegisterType((*CopyObjPartRequest)(nil), "CopyObjPartRequest")
        proto.RegisterType((*CopyObjPartResponse)(nil), "CopyObjPartResponse")
        proto.RegisterType((*ServerSideEncryption)(nil), "ServerSideEncryption")
        proto.RegisterType((*RedirectAllRequestsTo)(nil), "RedirectAllRequestsTo")
        proto.RegisterType((*Redirect)(nil), "Redirect")
        proto.RegisterType((*Condition)(nil), "Condition")
        proto.RegisterType((*RoutingRules)(nil), "RoutingRules")
        proto.RegisterType((*WebsiteConfiguration)(nil), "WebsiteConfiguration")
        proto.RegisterType((*CORSConfiguration)(nil), "CORSConfiguration")
        proto.RegisterType((*Destination)(nil), "Destination")
        proto.RegisterType((*ReplicationRole)(nil), "ReplicationRole")
        proto.RegisterType((*ReplicationConfiguration)(nil), "ReplicationConfiguration")
        proto.RegisterType((*Tag)(nil), "Tag")
        proto.RegisterType((*LifecycleFilter)(nil), "LifecycleFilter")
        proto.RegisterType((*Action)(nil), "Action")
        proto.RegisterType((*AbortMultipartUpload)(nil), "AbortMultipartUpload")
        proto.RegisterType((*LifecycleRule)(nil), "LifecycleRule")
        proto.RegisterType((*PutBucketLifecycleRequest)(nil), "PutBucketLifecycleRequest")
        proto.RegisterType((*GetBucketLifecycleResponse)(nil), "GetBucketLifecycleResponse")
        proto.RegisterType((*ReplicationInfo)(nil), "ReplicationInfo")
        proto.RegisterType((*Acl)(nil), "Acl")
        proto.RegisterType((*GetBucketResponse)(nil), "GetBucketResponse")
        proto.RegisterType((*Bucket)(nil), "Bucket")
        proto.RegisterType((*Partion)(nil), "Partion")
        proto.RegisterType((*Version)(nil), "Version")
        proto.RegisterType((*Object)(nil), "Object")
        proto.RegisterMapType((map[string]string)(nil), "Object.CustomAttributesEntry")
        proto.RegisterType((*ListBucketsResponse)(nil), "ListBucketsResponse")
        proto.RegisterType((*BaseResponse)(nil), "BaseResponse")
        proto.RegisterType((*BaseRequest)(nil), "BaseRequest")
        proto.RegisterType((*ListObjectsRequest)(nil), "ListObjectsRequest")
        proto.RegisterMapType((map[string]string)(nil), "ListObjectsRequest.FilterEntry")
        proto.RegisterType((*ListObjectsResponse)(nil), "ListObjectsResponse")
        proto.RegisterType((*CountObjectsResponse)(nil), "CountObjectsResponse")
        proto.RegisterType((*DeleteObjectInput)(nil), "DeleteObjectInput")
        proto.RegisterType((*DeleteObjectOutput)(nil), "DeleteObjectOutput")
        proto.RegisterType((*GetObjectInput)(nil), "GetObjectInput")
        proto.RegisterType((*MultipartUpload)(nil), "MultipartUpload")
        proto.RegisterType((*ListParts)(nil), "ListParts")
        proto.RegisterType((*TList)(nil), "TList")
        proto.RegisterType((*Tier2ClassName)(nil), "Tier2ClassName")
        proto.RegisterMapType((map[int32]string)(nil), "Tier2ClassName.LstEntry")
        proto.RegisterType((*GetTierMapResponse)(nil), "GetTierMapResponse")
        proto.RegisterMapType((map[string]*Tier2ClassName)(nil), "GetTierMapResponse.Tier2NameEntry")
        proto.RegisterType((*UpdateObjMetaRequest)(nil), "UpdateObjMetaRequest")
        proto.RegisterMapType((map[string]string)(nil), "UpdateObjMetaRequest.SettingEntry")
        proto.RegisterType((*StorageClass)(nil), "StorageClass")
        proto.RegisterType((*GetStorageClassesResponse)(nil), "GetStorageClassesResponse")
        proto.RegisterType((*GetBackendTypeByTierRequest)(nil), "GetBackendTypeByTierRequest")
        proto.RegisterType((*GetBackendTypeByTierResponse)(nil), "GetBackendTypeByTierResponse")
        proto.RegisterType((*MultipartUploadRecord)(nil), "MultipartUploadRecord")
        proto.RegisterType((*ListBucketUploadRequest)(nil), "ListBucketUploadRequest")
        proto.RegisterType((*Owner)(nil), "Owner")
        proto.RegisterType((*Upload)(nil), "Upload")
        proto.RegisterType((*ListBucketUploadResult)(nil), "ListBucketUploadResult")
        proto.RegisterType((*ListBucketUploadResponse)(nil), "ListBucketUploadResponse")
}</span>

func init() <span class="cov8" title="1">{ proto.RegisterFile("s3.proto", fileDescriptor_s3_ac4a79723b1dd58e) }</span>

var fileDescriptor_s3_ac4a79723b1dd58e = []byte{
        // 4300 bytes of a gzipped FileDescriptorProto
        0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x3b, 0x4d, 0x6f, 0x1c, 0xc9,
        0x75, 0xec, 0xf9, 0x22, 0xe7, 0x0d, 0x3f, 0x8b, 0x1f, 0x1a, 0x8d, 0xb4, 0x32, 0x53, 0xd6, 0x6a,
        0xe9, 0x4d, 0x52, 0x96, 0x28, 0xef, 0x7a, 0x57, 0x71, 0xec, 0xa5, 0x46, 0x1f, 0x4b, 0x2c, 0xb9,
        0x64, 0x9a, 0x94, 0x0c, 0x38, 0x08, 0x82, 0x66, 0x77, 0x91, 0x6a, 0xa9, 0xd9, 0x3d, 0xdb, 0x5d,
        0xa3, 0x25, 0x7d, 0x4c, 0x80, 0xc4, 0xb9, 0x24, 0xc7, 0x20, 0xb9, 0xfa, 0x90, 0x00, 0x39, 0x05,
        0xc8, 0x31, 0x07, 0x5f, 0x72, 0xc9, 0x35, 0x87, 0x00, 0x39, 0xe4, 0x92, 0x53, 0x80, 0xfc, 0x00,
        0xe7, 0x10, 0x20, 0xa8, 0xcf, 0xae, 0xfe, 0x18, 0x0e, 0xe5, 0x35, 0x7c, 0x9a, 0xae, 0x57, 0xaf,
        0xaa, 0x5e, 0xbd, 0x7a, 0xef, 0xd5, 0x7b, 0xaf, 0xde, 0xc0, 0x5c, 0xf6, 0x90, 0x8c, 0xd2, 0x84,
        0x25, 0xf8, 0x3f, 0x1d, 0xd8, 0xd8, 0x0b, 0x33, 0x76, 0x70, 0xf2, 0x9a, 0xfa, 0xec, 0xd0, 0x4b,
        0x59, 0xe6, 0xd2, 0xaf, 0xc6, 0x34, 0x63, 0xe8, 0x0e, 0xc0, 0xc9, 0xd8, 0x7f, 0x43, 0xd9, 0x97,
        0xde, 0x39, 0xed, 0x3b, 0x9b, 0xce, 0x56, 0xd7, 0xb5, 0x20, 0xe8, 0x36, 0x74, 0x13, 0x31, 0xea,
        0x0b, 0x7a, 0xd9, 0x6f, 0x88, 0xee, 0x1c, 0x80, 0x30, 0xcc, 0xd3, 0xd8, 0x4f, 0x82, 0x30, 0x3e,
        0x3b, 0xbe, 0x1c, 0xd1, 0x7e, 0x53, 0x20, 0x14, 0x60, 0x68, 0x00, 0x73, 0xe3, 0x51, 0x94, 0x78,
        0xc1, 0x6e, 0xd0, 0x6f, 0x89, 0x7e, 0xd3, 0xe6, 0x7d, 0xe7, 0xde, 0x85, 0x20, 0xa8, 0xdf, 0xde,
        0x74, 0xb6, 0x9a, 0xae, 0x69, 0xa3, 0x0f, 0x61, 0x79, 0xe4, 0xa5, 0xec, 0xcb, 0xf1, 0xf9, 0x09,
        0x4d, 0xf7, 0xbd, 0xf4, 0x0d, 0x4d, 0xfb, 0x1d, 0x81, 0x53, 0x81, 0xe3, 0x14, 0x5a, 0x7c, 0x10,
        0xdf, 0xcd, 0xa1, 0xe9, 0x13, 0xbb, 0x69, 0xba, 0x16, 0x04, 0x21, 0x68, 0x3d, 0x3d, 0xf6, 0xce,
        0xd4, 0x46, 0xc4, 0x37, 0xdf, 0xc3, 0x9e, 0x97, 0xb1, 0xfd, 0x24, 0x08, 0x4f, 0x43, 0x1a, 0xe8,
        0x3d, 0xd8, 0x30, 0x3e, 0xee, 0x28, 0xfc, 0x29, 0x15, 0xf4, 0x37, 0x5d, 0xf1, 0x8d, 0xff, 0xa3,
        0x01, 0x37, 0x2a, 0x4c, 0xcd, 0x46, 0x49, 0x9c, 0x09, 0xae, 0x3d, 0x4d, 0xd3, 0x24, 0x1d, 0x26,
        0x81, 0x64, 0x6a, 0xdb, 0xcd, 0x01, 0xe8, 0x2e, 0x74, 0x77, 0xe3, 0x90, 0x85, 0x1e, 0x4b, 0x52,
        0x41, 0x4a, 0x6f, 0xbb, 0x43, 0x0e, 0xbe, 0x8e, 0x69, 0xea, 0xe6, 0x1d, 0xe8, 0x36, 0xb4, 0x05,
        0x4c, 0x10, 0x94, 0x63, 0x48, 0x20, 0xa7, 0xfa, 0x88, 0x25, 0xa9, 0x77, 0x46, 0x87, 0x91, 0x97,
        0x65, 0x8a, 0xb3, 0x05, 0x18, 0xe7, 0xe0, 0x61, 0x99, 0x83, 0x92, 0xcb, 0x15, 0x38, 0xda, 0x86,
        0xb5, 0x2f, 0xe9, 0x05, 0x3b, 0xac, 0xe7, 0x78, 0x6d, 0x1f, 0x3f, 0xbd, 0x7d, 0x7d, 0x7a, 0xb3,
        0xf2, 0xf4, 0x74, 0x1b, 0x6d, 0x42, 0x6f, 0x37, 0x3b, 0x4e, 0xc7, 0xb1, 0xef, 0x31, 0x1a, 0xf4,
        0xe7, 0x36, 0x9d, 0xad, 0x39, 0xd7, 0x06, 0xa1, 0x5b, 0xd0, 0x96, 0x43, 0xbb, 0x9b, 0xcd, 0xad,
        0xde, 0x76, 0x9b, 0xf0, 0x96, 0x2b, 0x61, 0xf8, 0x2b, 0x58, 0xdf, 0x39, 0x49, 0x52, 0xb6, 0x3f,
        0x8e, 0x58, 0xc8, 0x8f, 0xfb, 0xd7, 0x23, 0xaf, 0xb6, 0x2c, 0x36, 0x8b, 0xb2, 0x88, 0x1f, 0xc3,
        0xfc, 0x30, 0x39, 0x1f, 0x45, 0x94, 0x51, 0x2d, 0x4b, 0xa3, 0x8a, 0x2c, 0x8d, 0x0a, 0xb2, 0x44,
        0x2d, 0x59, 0xe2, 0xdf, 0xf8, 0x2f, 0x1a, 0xd0, 0xd7, 0x93, 0xfc, 0xe6, 0x48, 0x47, 0x0f, 0x61,
        0xc1, 0xb7, 0x48, 0xe7, 0xd2, 0xc0, 0x59, 0xba, 0x40, 0xec, 0x0d, 0xb9, 0x45, 0x1c, 0xb4, 0x05,
        0x4b, 0x59, 0x32, 0x4e, 0x7d, 0xfa, 0x92, 0xa6, 0x59, 0x98, 0xc4, 0xbb, 0x4f, 0x84, 0x70, 0x74,
        0xdd, 0x32, 0x98, 0x9f, 0x65, 0x2a, 0xf7, 0x20, 0x94, 0xbc, 0x23, 0xb0, 0x6c, 0x10, 0xe7, 0x05,
        0x0b, 0x69, 0x2a, 0xa4, 0xa0, 0xed, 0x8a, 0x6f, 0x1c, 0xc2, 0xcd, 0x1a, 0x56, 0xe4, 0x0a, 0x42,
        0xcb, 0x0a, 0x62, 0x00, 0xd6, 0x5e, 0x9f, 0x28, 0x46, 0x98, 0xb6, 0x61, 0x7b, 0xd3, 0x62, 0xfb,
        0x5f, 0x36, 0x60, 0x8d, 0x2b, 0x8e, 0x58, 0xe7, 0xf0, 0xd7, 0xc6, 0xf2, 0x0d, 0x68, 0x7a, 0x7e,
        0xa4, 0xf4, 0xaf, 0x45, 0x76, 0xfc, 0xc8, 0xe5, 0x00, 0xb3, 0xdb, 0x56, 0xbe, 0x5b, 0x4e, 0x72,
        0x94, 0xf8, 0x1e, 0x0b, 0x93, 0x58, 0xb1, 0xd1, 0xb4, 0xd1, 0xc7, 0xd0, 0xf6, 0x18, 0x4b, 0xb3,
        0x7e, 0x47, 0x1c, 0xcb, 0x26, 0xa9, 0xa3, 0x95, 0xec, 0x70, 0x94, 0xa7, 0x31, 0x4b, 0x2f, 0x5d,
        0x89, 0x3e, 0xf8, 0x04, 0x20, 0x07, 0xa2, 0x65, 0x68, 0xbe, 0xa1, 0x97, 0x6a, 0x13, 0xfc, 0x13,
        0xad, 0x41, 0xfb, 0xad, 0x17, 0x8d, 0xa9, 0xa2, 0x5c, 0x36, 0x1e, 0x35, 0x3e, 0x71, 0xf0, 0x1f,
        0xc0, 0x7a, 0x69, 0x8d, 0x6f, 0xca, 0x77, 0xfc, 0x6d, 0x58, 0x38, 0x1c, 0xb3, 0x27, 0x1e, 0xf3,
        0x8e, 0x58, 0x4a, 0xbd, 0x73, 0xce, 0x85, 0xc0, 0x63, 0x9e, 0x98, 0x65, 0xde, 0x15, 0xdf, 0xf8,
        0x1f, 0x1d, 0x58, 0x79, 0x21, 0x46, 0x1c, 0xfe, 0x46, 0x04, 0x7f, 0x03, 0x3a, 0x5c, 0xac, 0xd4,
        0xcd, 0xd2, 0x76, 0x55, 0x8b, 0xd3, 0x96, 0x71, 0x7b, 0x2d, 0xad, 0x9d, 0xf8, 0xe6, 0xb8, 0xe7,
        0xc1, 0x47, 0x9f, 0xd3, 0x0b, 0x25, 0xc0, 0xaa, 0x85, 0x9f, 0x01, 0xb2, 0x49, 0xbe, 0x16, 0xa3,
        0xea, 0x74, 0xff, 0xff, 0x1c, 0x58, 0x19, 0x26, 0xa3, 0x4b, 0x79, 0x1f, 0xe8, 0xbd, 0xdf, 0x85,
        0x85, 0x2c, 0xf5, 0x1f, 0x97, 0xb7, 0x5f, 0x04, 0x72, 0x4b, 0xcd, 0xbc, 0xf4, 0x8c, 0x32, 0x0b,
        0x51, 0xce, 0x5d, 0x81, 0xab, 0x19, 0xe5, 0x2a, 0x02, 0xb1, 0x69, 0x66, 0xcc, 0x81, 0xf9, 0x8c,
        0x16, 0x62, 0xcb, 0x9e, 0xd1, 0xc2, 0xbd, 0x0b, 0x0b, 0x6a, 0x15, 0xcf, 0x7f, 0x43, 0xe3, 0x40,
        0x09, 0x70, 0x11, 0xc8, 0x4f, 0x51, 0x02, 0x8e, 0x43, 0x75, 0x2f, 0xb4, 0x5d, 0x0b, 0x82, 0xff,
        0xcc, 0x01, 0x64, 0xef, 0xff, 0x5a, 0x8c, 0x5c, 0x86, 0xe6, 0x79, 0xf0, 0x91, 0xda, 0x2b, 0xff,
        0xe4, 0x17, 0x5b, 0x54, 0xbe, 0x8e, 0x9b, 0x6e, 0x01, 0xc6, 0xe7, 0x7c, 0xab, 0xac, 0x93, 0xf6,
        0x29, 0x72, 0x00, 0xfe, 0xbb, 0x06, 0xac, 0xec, 0x27, 0x6f, 0x69, 0xf1, 0x20, 0x6e, 0x43, 0xd7,
        0x70, 0x48, 0x1d, 0x42, 0x0e, 0xe0, 0xab, 0xda, 0x6c, 0x51, 0x04, 0x15, 0x60, 0x6a, 0x06, 0x79,
        0x12, 0x8a, 0xe9, 0x39, 0x20, 0x9f, 0x41, 0x21, 0xb4, 0xec, 0x19, 0x14, 0xce, 0x3d, 0x58, 0x94,
        0xed, 0xbd, 0xa2, 0xa9, 0x28, 0x41, 0xa7, 0xb1, 0x5a, 0xb8, 0x4d, 0xc9, 0x5b, 0x2a, 0xac, 0xb1,
        0x34, 0xb9, 0xa6, 0xcd, 0x0f, 0xde, 0x6c, 0x4b, 0x99, 0x70, 0x71, 0xfb, 0x76, 0xdd, 0x0a, 0x1c,
        0xff, 0xdc, 0x01, 0x64, 0x73, 0x4a, 0x1d, 0xd9, 0x6f, 0xc1, 0x6c, 0x72, 0xf2, 0x7a, 0x9f, 0x2a,
        0xe5, 0xee, 0x6d, 0xcf, 0x12, 0x85, 0xa1, 0xe1, 0x5c, 0x99, 0x32, 0xe6, 0xb1, 0x71, 0xa6, 0x38,
        0xa5, 0x5a, 0xfa, 0x3c, 0x9b, 0xf9, 0x79, 0x5e, 0x79, 0x56, 0x95, 0xd3, 0x6e, 0x57, 0x4f, 0x1b,
        0xff, 0x7d, 0x03, 0x96, 0x0f, 0xc7, 0xac, 0x78, 0x9c, 0x77, 0x00, 0x2a, 0x4a, 0x65, 0x41, 0xf8,
        0xb2, 0x07, 0x65, 0x9b, 0x72, 0x60, 0x5b, 0xf6, 0x9d, 0xb2, 0x65, 0xdf, 0xf1, 0x23, 0xb4, 0xad,
        0x2d, 0xb5, 0xbc, 0x40, 0x6f, 0x93, 0xf2, 0xba, 0x55, 0x2b, 0x7d, 0xa5, 0xe5, 0xd7, 0x76, 0xa8,
        0x63, 0xd9, 0xa1, 0x4d, 0xe8, 0xf9, 0x49, 0xcc, 0x68, 0xcc, 0xcc, 0xf9, 0x75, 0x5d, 0x1b, 0xf4,
        0x0d, 0xec, 0xfe, 0x53, 0x58, 0x79, 0x4e, 0xd9, 0x3b, 0x69, 0xa0, 0x36, 0xe3, 0x0d, 0xcb, 0x8c,
        0x1f, 0xc3, 0xaa, 0x99, 0x86, 0x1f, 0xb7, 0x4b, 0xb3, 0x71, 0xc4, 0xa6, 0x4c, 0xf4, 0x2d, 0xe8,
        0x24, 0xb9, 0xf2, 0x58, 0x42, 0xa3, 0xc0, 0xf8, 0x17, 0x0e, 0xac, 0x58, 0xfc, 0xbc, 0x16, 0x75,
        0x96, 0x28, 0x36, 0xa6, 0x8a, 0x62, 0xb3, 0x4e, 0x14, 0x5b, 0x13, 0x44, 0xb1, 0x3d, 0x4d, 0x14,
        0x3b, 0x35, 0xa2, 0xf8, 0x23, 0x58, 0x3d, 0x1c, 0x2b, 0x6d, 0xde, 0x19, 0xee, 0x69, 0x61, 0xdc,
        0x82, 0xee, 0xce, 0x70, 0x6f, 0x98, 0xc4, 0xa7, 0xe1, 0x99, 0x52, 0x19, 0x20, 0x39, 0x56, 0xde,
        0x89, 0x77, 0xa1, 0x6b, 0xe0, 0xd7, 0x91, 0xe1, 0xa1, 0x17, 0xc7, 0x34, 0xe0, 0xb2, 0xaa, 0x64,
        0xd8, 0x00, 0xf0, 0x87, 0xb0, 0x2c, 0x71, 0x95, 0x36, 0x87, 0xf1, 0x19, 0xe7, 0xc5, 0x91, 0xe4,
        0x85, 0x9c, 0x4d, 0xb5, 0x70, 0x00, 0x9d, 0x83, 0x93, 0xd7, 0xd7, 0x5c, 0xf3, 0x0a, 0xbd, 0x29,
        0x50, 0xd4, 0x2c, 0x53, 0x74, 0xa4, 0xf5, 0xd4, 0x62, 0x4d, 0x1f, 0x66, 0x87, 0x5c, 0xb4, 0x2f,
        0xb4, 0xd1, 0xd5, 0x4d, 0xf4, 0xbe, 0xcd, 0x34, 0xeb, 0x70, 0x4b, 0x1c, 0xdb, 0x87, 0x95, 0xc7,
        0x5e, 0x46, 0x25, 0x89, 0xd3, 0x67, 0x2d, 0xee, 0xaf, 0x51, 0xde, 0x1f, 0x7e, 0x05, 0x8b, 0x7c,
        0xba, 0x83, 0x93, 0xd7, 0xdf, 0x78, 0xae, 0x22, 0xaf, 0x9a, 0x25, 0x5e, 0xe1, 0x5f, 0x34, 0xcc,
        0x7d, 0x68, 0x3b, 0x43, 0x3c, 0x70, 0x13, 0xfe, 0xb5, 0xba, 0x27, 0x1c, 0x15, 0xb8, 0x59, 0xb0,
        0x1c, 0xa7, 0x78, 0x1b, 0xd9, 0x30, 0x8e, 0x73, 0x6c, 0xdf, 0x37, 0x2a, 0x6c, 0xb5, 0x61, 0x39,
        0x8e, 0x9a, 0xa7, 0x65, 0xe3, 0xa8, 0x79, 0xee, 0xc1, 0xe2, 0x71, 0xed, 0x9d, 0x54, 0x84, 0x72,
        0x33, 0xf7, 0x42, 0xfb, 0x86, 0xd2, 0x81, 0x32, 0x6d, 0x2e, 0x76, 0x7c, 0x8b, 0xbb, 0x4f, 0x54,
        0x18, 0xa8, 0x5a, 0x9c, 0x81, 0x2e, 0xf5, 0x82, 0x83, 0xd3, 0xd3, 0x8c, 0x32, 0x71, 0x0b, 0x35,
        0x5d, 0x0b, 0xa2, 0xfb, 0xf7, 0x68, 0x7c, 0xc6, 0x5e, 0xf5, 0xbb, 0x79, 0xbf, 0x84, 0xe0, 0x37,
        0xb0, 0x5a, 0xe0, 0xe0, 0xb5, 0xa2, 0xeb, 0x72, 0x3c, 0xdf, 0x90, 0x7a, 0x5c, 0x8e, 0xe7, 0x9f,
        0xb2, 0x3c, 0x88, 0xe0, 0xdf, 0xf8, 0x67, 0x0e, 0xac, 0x1d, 0xd1, 0xf4, 0x2d, 0x4d, 0x8f, 0xc2,
        0x80, 0x3e, 0x8d, 0xfd, 0xf4, 0x72, 0x24, 0x76, 0xde, 0x87, 0xd9, 0x2c, 0x93, 0x97, 0xad, 0x12,
        0x10, 0xd5, 0xe4, 0x8e, 0x13, 0x35, 0x78, 0x5a, 0x61, 0xe6, 0xdd, 0x22, 0x10, 0xdd, 0x87, 0xd5,
        0x90, 0x47, 0xf5, 0x51, 0xf8, 0x53, 0xc1, 0xca, 0x97, 0xd4, 0xe7, 0x81, 0x7f, 0x53, 0xe0, 0xd6,
        0x75, 0xe1, 0x03, 0x58, 0x77, 0x69, 0x10, 0xa6, 0xd4, 0x67, 0x3b, 0x51, 0xa4, 0x24, 0x27, 0x3b,
        0x4e, 0xf8, 0x21, 0xbc, 0x4a, 0x32, 0x5b, 0x77, 0x4d, 0x9b, 0xf7, 0x89, 0x6c, 0x8f, 0x9f, 0x70,
        0x63, 0xd1, 0xe4, 0x7d, 0xba, 0x8d, 0xff, 0xd5, 0x81, 0x39, 0x3d, 0x63, 0x01, 0x51, 0x4d, 0xa2,
        0xdb, 0x85, 0x05, 0x1a, 0xa5, 0x05, 0xb6, 0x61, 0x2d, 0xa5, 0xa3, 0xc8, 0xf3, 0xe9, 0x17, 0xf4,
        0xf2, 0x30, 0xa5, 0xa7, 0xe1, 0xc5, 0x8f, 0x43, 0xf6, 0x4a, 0x31, 0xb1, 0xb6, 0x8f, 0x4b, 0x57,
        0x0e, 0x17, 0xd8, 0x52, 0x06, 0x4b, 0x50, 0xee, 0xb5, 0xbc, 0x62, 0x6c, 0xa4, 0x69, 0x14, 0x27,
        0x2b, 0xe5, 0xb0, 0x02, 0xc7, 0x5f, 0x43, 0x77, 0x98, 0xc4, 0x41, 0x28, 0x0e, 0x67, 0x0b, 0x96,
        0xde, 0xe8, 0x15, 0x9f, 0x7e, 0x35, 0xf6, 0x22, 0x6d, 0xfa, 0xca, 0x60, 0xf4, 0x19, 0xdc, 0xe2,
        0x53, 0x19, 0x41, 0x71, 0x29, 0x1b, 0xa7, 0x31, 0x0d, 0xd4, 0x28, 0xb9, 0xdb, 0xab, 0x50, 0xf0,
        0x1f, 0xc3, 0xbc, 0x9b, 0x8c, 0x59, 0x18, 0x9f, 0xb9, 0xe3, 0x88, 0x66, 0xe8, 0x7d, 0x98, 0x4b,
        0x15, 0x61, 0xca, 0xea, 0x77, 0x89, 0xa6, 0xd4, 0x35, 0x5d, 0xfc, 0x76, 0xf0, 0x35, 0xbd, 0xca,
        0xd0, 0x01, 0x31, 0x3b, 0x70, 0xf3, 0x4e, 0xfc, 0x5f, 0x0e, 0xac, 0xfd, 0x98, 0x9e, 0x64, 0x21,
        0xa3, 0xd2, 0xfa, 0x8d, 0x53, 0xa9, 0x7c, 0x77, 0x61, 0x21, 0x8c, 0x03, 0x7a, 0xf1, 0x24, 0xf1,
        0xc7, 0xe7, 0x34, 0xd6, 0x56, 0xa3, 0x08, 0x14, 0xe2, 0xc8, 0x49, 0x37, 0x58, 0x72, 0x4f, 0x45,
        0x20, 0xda, 0x83, 0xf5, 0xb4, 0x4e, 0xb8, 0x94, 0x37, 0xb4, 0x41, 0x6a, 0x45, 0xcf, 0xad, 0x1f,
        0x84, 0x1e, 0xc0, 0x7c, 0x6a, 0xf1, 0xc4, 0x64, 0x1e, 0x6c, 0x46, 0xb9, 0x05, 0x14, 0xfc, 0xdf,
        0x3c, 0x50, 0x3a, 0x70, 0x8f, 0x8a, 0x5b, 0x5c, 0x84, 0x46, 0x18, 0xa8, 0x7d, 0x35, 0xc2, 0x80,
        0x4b, 0x8e, 0x17, 0x45, 0xc9, 0xd7, 0x34, 0xd8, 0xa7, 0xec, 0x55, 0x12, 0xe8, 0x13, 0x2a, 0x41,
        0x2d, 0xbc, 0x83, 0x34, 0x3c, 0x0b, 0x63, 0xed, 0x06, 0x94, 0xa0, 0x16, 0xde, 0xe7, 0xd4, 0x0b,
        0x68, 0xaa, 0x53, 0x66, 0x25, 0x28, 0x67, 0xe2, 0xb9, 0x77, 0xb1, 0x73, 0x46, 0x8f, 0x28, 0x3f,
        0x98, 0x4c, 0x07, 0x43, 0x05, 0x20, 0x9f, 0x8d, 0x5e, 0x8c, 0x92, 0x2c, 0x9f, 0x4d, 0xda, 0xc4,
        0x12, 0x14, 0xef, 0x42, 0xef, 0x09, 0xcd, 0x58, 0x18, 0xcb, 0x4d, 0x6e, 0x40, 0xe7, 0xc4, 0x36,
        0xfb, 0xaa, 0xc5, 0x6d, 0x56, 0x66, 0x67, 0xf3, 0x94, 0xc1, 0xb7, 0x61, 0xf8, 0x4f, 0x1d, 0x58,
        0x72, 0xe9, 0x28, 0x0a, 0xa5, 0x41, 0x76, 0x93, 0x88, 0x56, 0x98, 0xc6, 0xe3, 0x61, 0x21, 0xf3,
        0xda, 0x2d, 0x97, 0x2d, 0x6e, 0xc2, 0x68, 0xec, 0x9d, 0x44, 0x2a, 0x9e, 0x9a, 0x73, 0x75, 0x13,
        0x11, 0xe8, 0x05, 0x39, 0x81, 0x82, 0x27, 0xbd, 0xed, 0x79, 0x62, 0x11, 0xed, 0xda, 0x08, 0xf8,
        0x25, 0xf4, 0x2d, 0x22, 0x8a, 0x47, 0x88, 0xa0, 0x95, 0x26, 0x91, 0xb6, 0x4c, 0xe2, 0x1b, 0xdd,
        0x83, 0x76, 0x2a, 0x04, 0xa3, 0x21, 0x04, 0x63, 0x99, 0x94, 0xb6, 0xe0, 0xca, 0x6e, 0xfc, 0x1d,
        0x68, 0x1e, 0x7b, 0x67, 0x35, 0xce, 0xee, 0x32, 0x34, 0xdf, 0x7a, 0xda, 0xfd, 0xe1, 0x9f, 0xf8,
        0x3b, 0xb0, 0xb4, 0x17, 0x9e, 0x52, 0xff, 0xd2, 0x8f, 0xe8, 0xb3, 0x30, 0x62, 0x34, 0xb5, 0xf6,
        0xed, 0xd8, 0xfb, 0xc6, 0x7f, 0xe2, 0x40, 0x67, 0xc7, 0xd7, 0xc4, 0xc5, 0xb9, 0xd9, 0x14, 0xdf,
        0xd2, 0xf7, 0xbd, 0x94, 0xec, 0x6e, 0xbb, 0xe2, 0x9b, 0x1f, 0x45, 0x40, 0x45, 0xd2, 0x4a, 0x26,
        0x40, 0xd5, 0xbd, 0x6a, 0xc3, 0x6a, 0x13, 0x40, 0x7d, 0x98, 0x3d, 0x29, 0x84, 0xcf, 0xba, 0x89,
        0x3f, 0x87, 0xb5, 0x62, 0x2e, 0x53, 0xde, 0x9b, 0xfc, 0x5e, 0xe0, 0x2b, 0xee, 0x9c, 0x32, 0x9a,
        0xaa, 0xb4, 0x2f, 0x3f, 0x02, 0x79, 0xa1, 0xd5, 0x75, 0x71, 0xfb, 0xb0, 0x60, 0xb6, 0xce, 0x95,
        0xa9, 0x4e, 0x00, 0x6a, 0xe3, 0xb2, 0x2d, 0xe8, 0x9c, 0x0a, 0x56, 0x29, 0x2d, 0x5f, 0x26, 0x25,
        0x16, 0xba, 0xaa, 0x9f, 0x7b, 0xdc, 0x9e, 0xe0, 0x98, 0xd6, 0xe5, 0x59, 0x22, 0x39, 0xe8, 0x6a,
        0x38, 0xfa, 0x23, 0xb8, 0xe3, 0xf1, 0x0d, 0xed, 0xc6, 0x7e, 0x39, 0xc1, 0x27, 0xb7, 0x26, 0x38,
        0xd0, 0xdb, 0x5e, 0x27, 0x75, 0xfb, 0x76, 0xa7, 0x0c, 0xc6, 0x7f, 0x08, 0x37, 0x8d, 0x93, 0x9d,
        0xef, 0xf6, 0x9a, 0xb9, 0xa4, 0x3b, 0xd0, 0x88, 0x7c, 0x25, 0x6c, 0x8b, 0xa4, 0xc0, 0x2c, 0xb7,
        0x11, 0xf9, 0xf8, 0x27, 0x30, 0x78, 0x4e, 0xab, 0x93, 0x5f, 0x2b, 0x18, 0x99, 0x36, 0xf7, 0x59,
        0x41, 0x41, 0x77, 0xe3, 0xd3, 0xc4, 0x3a, 0x0f, 0xa7, 0x70, 0x1e, 0x96, 0xb4, 0x34, 0x0a, 0xd2,
        0x52, 0x31, 0x05, 0xcd, 0x1a, 0x53, 0xf0, 0x6d, 0x11, 0xbe, 0x72, 0x6a, 0x7d, 0xe3, 0x8d, 0xab,
        0x94, 0x86, 0x01, 0xe0, 0x9f, 0x88, 0x58, 0x50, 0xfb, 0xcd, 0xd7, 0xda, 0xe0, 0x07, 0x9a, 0xb9,
        0x85, 0x80, 0x4b, 0x4d, 0x61, 0x75, 0xe1, 0x5f, 0xb6, 0xa1, 0xa3, 0x7c, 0xcc, 0x3a, 0xbd, 0x1a,
        0xc0, 0x1c, 0xa3, 0xb1, 0x17, 0xb3, 0x5d, 0xbd, 0x3d, 0xd3, 0xe6, 0x1c, 0x19, 0x67, 0x34, 0x35,
        0xc9, 0x3c, 0xd5, 0xd2, 0xc9, 0xd6, 0x56, 0x39, 0xd9, 0x7a, 0x07, 0xc0, 0x4f, 0xa9, 0xc7, 0xe8,
        0x71, 0x78, 0xae, 0x13, 0x7a, 0x16, 0x44, 0x69, 0x40, 0xc7, 0x68, 0x40, 0x1f, 0x66, 0xa5, 0xae,
        0x06, 0xc2, 0x19, 0x9d, 0x73, 0x75, 0x13, 0xed, 0xc2, 0x5a, 0x56, 0xe3, 0xdf, 0x09, 0xbf, 0x94,
        0x0b, 0x6b, 0x9d, 0xf3, 0xe7, 0xd6, 0x0e, 0x41, 0x0f, 0x00, 0xde, 0x9a, 0xa8, 0x4b, 0x38, 0xae,
        0xbd, 0xed, 0x15, 0x52, 0x0e, 0xc7, 0x5c, 0x0b, 0x89, 0x3b, 0x2a, 0x01, 0x3d, 0xf5, 0xc6, 0x51,
        0xee, 0x68, 0x83, 0x74, 0x54, 0x4a, 0x60, 0x4e, 0xe7, 0xd7, 0x35, 0x4e, 0x40, 0xbf, 0xa7, 0xe8,
        0xac, 0xf3, 0x10, 0xdc, 0xda, 0x21, 0xe8, 0x1e, 0xb4, 0xfc, 0x24, 0xcd, 0xfa, 0xf3, 0x62, 0x28,
        0x22, 0x95, 0x6b, 0xd7, 0x15, 0xfd, 0xe8, 0x05, 0xf4, 0xd3, 0x09, 0x56, 0xbd, 0xbf, 0x20, 0xc6,
        0xde, 0x24, 0x93, 0xcc, 0xbe, 0x3b, 0x71, 0x28, 0x7a, 0x06, 0x1b, 0x91, 0xd6, 0x92, 0xe2, 0xa4,
        0x8b, 0xb5, 0x4a, 0x34, 0x01, 0x9b, 0xeb, 0x84, 0x14, 0xbe, 0xc3, 0x24, 0x0a, 0xfd, 0xcb, 0xfe,
        0x92, 0xd4, 0x09, 0x1b, 0x26, 0xe5, 0xca, 0x3b, 0xa3, 0x59, 0x7f, 0x59, 0xc6, 0x20, 0xb2, 0x65,
        0x6c, 0xf5, 0x8a, 0x65, 0xab, 0x1f, 0xc1, 0x52, 0x5a, 0x54, 0xd4, 0x3e, 0xaa, 0x5e, 0x4f, 0x1c,
        0xee, 0x96, 0x11, 0xf1, 0x9f, 0x3b, 0x30, 0xcb, 0xa3, 0x11, 0x4e, 0x57, 0xf5, 0xb6, 0x2a, 0x3e,
        0x1a, 0x35, 0xea, 0x1e, 0x8d, 0x44, 0x42, 0xa8, 0x69, 0x25, 0x84, 0x10, 0xb4, 0x28, 0x0f, 0x46,
        0x5a, 0x2a, 0x99, 0xcc, 0xe4, 0xa3, 0xe4, 0xd4, 0xbc, 0xd8, 0x5f, 0x39, 0x30, 0xab, 0x84, 0xcd,
        0x4a, 0x6d, 0x98, 0xeb, 0x20, 0x07, 0x98, 0x15, 0x1a, 0xd6, 0x0a, 0x03, 0x98, 0x0b, 0xb3, 0x3d,
        0x8f, 0xd1, 0x4c, 0xc7, 0x8e, 0xa6, 0x5d, 0x59, 0xbd, 0x55, 0x93, 0x83, 0xad, 0x49, 0xb1, 0xe3,
        0xbf, 0x9e, 0x15, 0x79, 0x06, 0x95, 0x2c, 0xcd, 0x73, 0xfa, 0x4e, 0x39, 0xa7, 0x5f, 0xb4, 0xe2,
        0x8d, 0x8a, 0x15, 0xb7, 0x0d, 0x48, 0x73, 0xa2, 0x01, 0x69, 0x15, 0x0c, 0xc8, 0xd5, 0xd9, 0x9d,
        0x01, 0xcc, 0xc9, 0xe5, 0x77, 0xb5, 0xb1, 0x30, 0xed, 0xe9, 0x19, 0x39, 0x61, 0x84, 0x64, 0x73,
        0x3f, 0xf8, 0x48, 0xa5, 0x53, 0x2d, 0x08, 0xba, 0x0b, 0x73, 0x6a, 0x29, 0xfd, 0x9c, 0x39, 0x47,
        0xd4, 0xd1, 0xb8, 0xa6, 0xa7, 0x62, 0xda, 0xa1, 0x6a, 0xda, 0x27, 0x1a, 0xa9, 0xde, 0xbb, 0x1b,
        0xa9, 0x4f, 0xe0, 0x86, 0x32, 0x0a, 0xda, 0xa3, 0x37, 0x96, 0x67, 0x5e, 0xac, 0x3c, 0xa9, 0x5b,
        0xdb, 0xe2, 0x85, 0xb2, 0x2d, 0xb6, 0x53, 0x9d, 0x8b, 0xa5, 0x54, 0xe7, 0x06, 0x74, 0xc2, 0xec,
        0xcb, 0x71, 0x14, 0x09, 0xed, 0x9c, 0x73, 0x55, 0xab, 0xe2, 0x4f, 0x2d, 0x8b, 0xde, 0x8a, 0x3f,
        0x25, 0x64, 0x69, 0xc5, 0xd2, 0x8a, 0x3e, 0xb4, 0x98, 0x77, 0x96, 0x29, 0xc5, 0x6c, 0x91, 0x63,
        0xef, 0xcc, 0x15, 0x90, 0x8a, 0x74, 0xae, 0xd6, 0x4b, 0xa7, 0x90, 0xf8, 0x35, 0x4b, 0xe2, 0xb5,
        0x25, 0x58, 0xb7, 0x2c, 0x01, 0x87, 0xf1, 0x33, 0xdf, 0x50, 0x30, 0x7e, 0xd8, 0x9b, 0xd0, 0x8b,
        0xc7, 0x51, 0xa4, 0x93, 0xe7, 0x37, 0xe4, 0xd3, 0xb5, 0x05, 0x42, 0xbb, 0xb0, 0xec, 0x8f, 0x33,
        0x96, 0x9c, 0xef, 0x30, 0x96, 0x86, 0x27, 0x63, 0x46, 0xb3, 0x7e, 0x5f, 0xd0, 0xf9, 0x9e, 0x4a,
        0x4f, 0x92, 0x61, 0xa9, 0x5f, 0xa6, 0x8c, 0x2b, 0xc3, 0xf8, 0x62, 0xea, 0xfc, 0xc5, 0x9d, 0x7b,
        0x53, 0xca, 0x9e, 0x05, 0x1a, 0x0c, 0x61, 0xbd, 0x76, 0xb2, 0x77, 0x4a, 0x0c, 0xbf, 0x84, 0xd5,
        0xbd, 0x30, 0x53, 0xde, 0x40, 0x76, 0xfd, 0xe4, 0xab, 0xd4, 0x49, 0xed, 0xbd, 0x1b, 0x5f, 0x40,
        0xc3, 0xf1, 0x0f, 0x61, 0xfe, 0xb1, 0x97, 0xd1, 0x77, 0x78, 0xed, 0xc9, 0xce, 0xcc, 0x6b, 0x4f,
        0x76, 0x86, 0xdf, 0x83, 0x9e, 0x1c, 0x2f, 0xbd, 0xbb, 0x92, 0x3b, 0x8b, 0xff, 0xb6, 0x05, 0x28,
        0xaf, 0xb1, 0x30, 0x45, 0x2b, 0x93, 0xc2, 0xa8, 0xdc, 0x04, 0xa8, 0xbc, 0xcf, 0x9c, 0x9b, 0x03,
        0xb8, 0x67, 0xa0, 0x1a, 0xc2, 0xa6, 0xb4, 0x5d, 0xdd, 0xe4, 0xe3, 0x02, 0x1a, 0x85, 0xe7, 0x21,
        0x53, 0x4e, 0x7d, 0xd7, 0xcd, 0x01, 0x95, 0x22, 0x97, 0x76, 0x4d, 0x91, 0x4b, 0x1f, 0x66, 0xcf,
        0xbd, 0x8b, 0x2f, 0xe8, 0x65, 0xa6, 0x9e, 0x6b, 0x74, 0xd3, 0x0a, 0x4d, 0x66, 0x0b, 0x21, 0xd9,
        0x06, 0x74, 0xce, 0xa5, 0x46, 0xcc, 0xa9, 0xe7, 0x48, 0xa9, 0x0b, 0xbf, 0x03, 0x2b, 0xdc, 0xb0,
        0x84, 0xf1, 0x58, 0xe8, 0xd5, 0x71, 0xf2, 0x86, 0xc6, 0xc2, 0xc3, 0xe8, 0xba, 0xd5, 0x0e, 0x6e,
        0x98, 0x32, 0xe6, 0xa5, 0x4c, 0x44, 0x0a, 0xca, 0xa0, 0x58, 0x10, 0xde, 0x7f, 0x4a, 0x99, 0xff,
        0x4a, 0x56, 0x92, 0xf4, 0x04, 0x4b, 0x2c, 0x08, 0xdf, 0xf9, 0x1b, 0x7a, 0xa9, 0x54, 0x53, 0x5a,
        0x85, 0x1c, 0xc0, 0x7d, 0x16, 0x63, 0x41, 0x15, 0xce, 0x82, 0xf4, 0x59, 0x4a, 0x60, 0xf4, 0x7d,
        0x13, 0x5f, 0xc8, 0x9b, 0xfd, 0x5b, 0xa4, 0x7a, 0x6c, 0x44, 0x46, 0x1a, 0x52, 0x13, 0x14, 0xfa,
        0xe0, 0x53, 0xe8, 0x59, 0xe0, 0x77, 0x92, 0xe9, 0x7f, 0x72, 0xa4, 0x50, 0x9b, 0x55, 0xae, 0x25,
        0x83, 0x9b, 0xd0, 0x0b, 0xad, 0xc2, 0x14, 0x29, 0x25, 0x36, 0x88, 0xf3, 0x2c, 0xa6, 0x17, 0xac,
        0x10, 0xff, 0x59, 0x10, 0x6e, 0x05, 0x65, 0x62, 0x49, 0xa5, 0x3b, 0xba, 0xae, 0x69, 0xab, 0xf7,
        0x0a, 0x4e, 0x4e, 0xbf, 0xad, 0x54, 0xc6, 0x7a, 0xaf, 0xe0, 0x70, 0xfc, 0x19, 0xac, 0x0d, 0x93,
        0x71, 0x5c, 0x21, 0x7b, 0x0d, 0xda, 0x02, 0xae, 0x4a, 0x4d, 0x64, 0xc3, 0x54, 0x1e, 0x35, 0xac,
        0xca, 0xa3, 0x7f, 0x70, 0x60, 0xe5, 0x89, 0xb0, 0x9f, 0x72, 0x8e, 0xdd, 0x78, 0x34, 0x9e, 0xac,
        0x14, 0x8a, 0xa5, 0x8d, 0x9c, 0xa5, 0x03, 0x7d, 0x5b, 0xe5, 0xb7, 0xab, 0x6e, 0x97, 0xed, 0x51,
        0xab, 0x62, 0x8f, 0xcc, 0xdb, 0x77, 0x3b, 0x7f, 0xfb, 0xbe, 0xea, 0x76, 0xc5, 0x0c, 0x90, 0x4d,
        0xec, 0xc1, 0x98, 0x71, 0x6a, 0xaf, 0x3e, 0xa4, 0xf2, 0xa5, 0xd1, 0xa8, 0xb9, 0x34, 0x0a, 0xf7,
        0x7d, 0xb3, 0xfc, 0x08, 0xfc, 0x33, 0x07, 0x16, 0xcd, 0x1b, 0x96, 0x61, 0x50, 0x21, 0xe7, 0xae,
        0x23, 0x98, 0x65, 0x68, 0xe6, 0x8f, 0x1d, 0x4d, 0xf5, 0xcc, 0xf1, 0xb2, 0x3c, 0xb5, 0x01, 0xf0,
        0x79, 0x54, 0x46, 0x5b, 0xfa, 0x45, 0xaa, 0xc5, 0xe1, 0x2a, 0x93, 0x2d, 0x7d, 0x22, 0xd5, 0xc2,
        0x3f, 0x77, 0x60, 0xa9, 0x1c, 0xfb, 0xbf, 0xd3, 0x61, 0x4d, 0x2c, 0x7f, 0xb0, 0xd9, 0xde, 0x2a,
        0x39, 0x35, 0x53, 0x9e, 0x25, 0x59, 0xfe, 0xb2, 0x2c, 0xcb, 0x75, 0xfe, 0xc6, 0x81, 0x2e, 0xd7,
        0x26, 0x59, 0x1c, 0x74, 0x7d, 0x5e, 0x4d, 0xa1, 0xcf, 0x14, 0x88, 0xb5, 0x4a, 0x05, 0x62, 0xef,
        0x50, 0x9c, 0x86, 0x6f, 0x41, 0xfb, 0x98, 0xd3, 0xc6, 0x09, 0x17, 0x4f, 0xe2, 0xce, 0x66, 0x93,
        0x13, 0x2e, 0xea, 0x0e, 0x18, 0x2c, 0xf2, 0xdf, 0x6d, 0xe1, 0x3f, 0xa9, 0xda, 0x87, 0x66, 0x94,
        0x31, 0x81, 0xd4, 0xdb, 0xee, 0x93, 0x62, 0x2f, 0xd9, 0xcb, 0x98, 0x34, 0x41, 0x1c, 0x69, 0xf0,
        0x31, 0xcc, 0x69, 0x80, 0x6d, 0x7c, 0xda, 0xd3, 0x8c, 0xcf, 0xbf, 0x38, 0x80, 0x9e, 0xcb, 0xe7,
        0xf8, 0x7d, 0x6f, 0x64, 0x94, 0xf8, 0x0e, 0xc0, 0x71, 0xea, 0xc5, 0x59, 0xa8, 0x52, 0x39, 0xdc,
        0x3a, 0x58, 0x10, 0xf4, 0x19, 0x74, 0x05, 0x39, 0xca, 0xef, 0xe5, 0x04, 0x62, 0x52, 0x9d, 0x87,
        0x18, 0x24, 0x49, 0x6a, 0x3e, 0x68, 0xb0, 0xaf, 0xb6, 0x6b, 0x3a, 0x6b, 0x6c, 0xe6, 0xfb, 0x36,
        0xd9, 0xbd, 0xed, 0xa5, 0x12, 0x0b, 0xec, 0x7d, 0xfc, 0x8f, 0x03, 0x6b, 0x2f, 0x46, 0x81, 0x27,
        0xd4, 0x53, 0xbe, 0xf5, 0x9a, 0x3b, 0xf6, 0xe0, 0xe4, 0x75, 0xee, 0xbd, 0xab, 0xd6, 0xd4, 0x47,
        0xb1, 0xba, 0x72, 0xca, 0xf2, 0xf3, 0xcb, 0x0f, 0x60, 0xf6, 0x88, 0x32, 0xc6, 0x63, 0xe7, 0x96,
        0xe2, 0x41, 0x1d, 0x0d, 0x44, 0x21, 0x49, 0x1e, 0xe8, 0x21, 0x83, 0x47, 0x30, 0x6f, 0x77, 0xbc,
        0xd3, 0x9d, 0xf1, 0x71, 0xb1, 0x6c, 0x92, 0x0b, 0x94, 0x95, 0x48, 0x12, 0xdf, 0x46, 0xc8, 0x54,
        0x56, 0x50, 0x08, 0xd9, 0x13, 0xb8, 0xf9, 0x9c, 0x32, 0x7b, 0x28, 0xcd, 0x2d, 0xf7, 0x07, 0x30,
        0xeb, 0x4b, 0x90, 0x92, 0xb9, 0x05, 0x62, 0x63, 0xba, 0xba, 0x17, 0x3f, 0x80, 0x5b, 0xcf, 0x4d,
        0x41, 0x0d, 0xf7, 0x1b, 0x1e, 0x5f, 0xf2, 0xd9, 0x35, 0xcb, 0x73, 0xe9, 0xce, 0x17, 0xfe, 0x1e,
        0xdc, 0xae, 0x1f, 0x92, 0xdf, 0x1a, 0x1c, 0x9a, 0x29, 0x59, 0x93, 0x0d, 0xfc, 0x6f, 0x0e, 0xac,
        0x97, 0xd3, 0x6e, 0xd4, 0x4f, 0xd2, 0xa0, 0xf8, 0x66, 0xe9, 0x54, 0xeb, 0x22, 0xb4, 0xda, 0x37,
        0x0a, 0x6a, 0xdf, 0x87, 0x59, 0x5d, 0x1b, 0x24, 0x75, 0x5c, 0x37, 0xad, 0x67, 0x41, 0x63, 0x82,
        0x5e, 0x58, 0xea, 0xbf, 0x1b, 0x87, 0xcc, 0x4a, 0xdc, 0x98, 0x76, 0x21, 0xc2, 0xeb, 0x4c, 0x8c,
        0xf0, 0x66, 0xed, 0x08, 0x0f, 0xff, 0xaf, 0x23, 0x2b, 0x6e, 0x25, 0x51, 0x7a, 0x5b, 0xd7, 0xae,
        0x31, 0xcb, 0x5d, 0xbc, 0xc6, 0x34, 0x17, 0xaf, 0xae, 0x8e, 0xf9, 0x0e, 0xc0, 0xb9, 0x77, 0x21,
        0x57, 0xcd, 0x54, 0xea, 0xd7, 0x82, 0x14, 0x5d, 0xa9, 0x76, 0xd9, 0x95, 0xca, 0xdd, 0xc0, 0x4e,
        0xc1, 0x0d, 0xbc, 0x07, 0x8b, 0xda, 0x5c, 0xaa, 0xa1, 0x72, 0xcf, 0x25, 0x28, 0xfe, 0x54, 0x55,
        0x03, 0x57, 0x32, 0xbe, 0x9b, 0xd0, 0x0b, 0xc2, 0x6c, 0x14, 0x79, 0x97, 0x96, 0x42, 0xda, 0x20,
        0xfc, 0xcf, 0x0e, 0x74, 0xd4, 0xb5, 0x53, 0x55, 0x15, 0xdb, 0x7c, 0x37, 0x4a, 0xe6, 0xfb, 0x2e,
        0x74, 0x43, 0x53, 0xa7, 0x5c, 0xac, 0x42, 0xce, 0x3b, 0xd0, 0x6d, 0x68, 0x27, 0xc2, 0xbb, 0x6c,
        0x15, 0xeb, 0x94, 0x13, 0x5d, 0xa7, 0x5c, 0x88, 0x79, 0xdb, 0x35, 0x31, 0xef, 0x6d, 0xb3, 0x0e,
        0xd5, 0xc2, 0x90, 0x03, 0xf0, 0xbf, 0xab, 0xe2, 0xf5, 0xe2, 0xa9, 0x8b, 0x82, 0x94, 0x92, 0x2f,
        0xe7, 0x54, 0x7d, 0xb9, 0xbb, 0xb0, 0xc0, 0x3d, 0xb7, 0x2f, 0xcc, 0xc1, 0xa8, 0x27, 0xb1, 0x02,
        0x10, 0x11, 0x40, 0x1c, 0xf0, 0xa2, 0x78, 0x10, 0x52, 0x08, 0x6a, 0x7a, 0xf8, 0xa6, 0xfc, 0xe4,
        0xfc, 0x3c, 0x89, 0xa5, 0xdf, 0xa7, 0xbc, 0xc0, 0x02, 0x8c, 0x7b, 0x82, 0x63, 0x25, 0x2b, 0xda,
        0x13, 0x54, 0xb4, 0x6b, 0x38, 0x0e, 0xa1, 0x5f, 0xb3, 0xb1, 0xeb, 0x38, 0xb1, 0xdf, 0x85, 0x4e,
        0x2a, 0x58, 0xa0, 0x2c, 0xfc, 0x0d, 0x52, 0xcf, 0x21, 0x57, 0xa1, 0x6d, 0xff, 0x72, 0x0d, 0x1a,
        0x47, 0x0f, 0xd1, 0x43, 0xe8, 0x59, 0x61, 0x20, 0x9a, 0x27, 0x56, 0xf0, 0x35, 0x58, 0x23, 0x35,
        0x21, 0x22, 0x9e, 0x41, 0x5b, 0x30, 0x3f, 0x14, 0xf9, 0x56, 0x65, 0x0c, 0x74, 0x14, 0x38, 0x58,
        0x20, 0x76, 0xec, 0x27, 0x31, 0xa5, 0xab, 0x37, 0x15, 0xf3, 0x43, 0xe8, 0x9a, 0xe4, 0x74, 0x8e,
        0x86, 0x48, 0x25, 0x63, 0x8d, 0x67, 0xd0, 0x7d, 0x58, 0x28, 0x54, 0x23, 0x21, 0xed, 0x53, 0x0f,
        0xd6, 0x48, 0x4d, 0x99, 0x12, 0x9e, 0x41, 0x0f, 0x60, 0xd9, 0xdc, 0x27, 0x95, 0x41, 0x88, 0x54,
        0x8a, 0x90, 0xf0, 0x0c, 0x7a, 0x24, 0x39, 0xa3, 0x9c, 0x72, 0xb4, 0x5a, 0x13, 0xbf, 0x28, 0x06,
        0x95, 0xfc, 0x76, 0x3c, 0x83, 0x7e, 0x00, 0xf3, 0xb6, 0x47, 0x5f, 0x3f, 0x78, 0x9d, 0xd4, 0x79,
        0xfd, 0x78, 0x06, 0x3d, 0x84, 0xae, 0x21, 0x08, 0x2d, 0x92, 0x42, 0x91, 0x6d, 0x3d, 0xb1, 0x5b,
        0x0e, 0xe7, 0xb4, 0xbd, 0xc3, 0x7c, 0x77, 0x15, 0x4e, 0x7f, 0x4f, 0x70, 0x5a, 0xa1, 0x2d, 0x91,
        0xa2, 0x4f, 0x2c, 0x39, 0x5e, 0x9e, 0xff, 0xbe, 0x83, 0x3e, 0xd5, 0x27, 0xa9, 0x06, 0x22, 0x52,
        0x09, 0x38, 0x06, 0xab, 0xa4, 0xea, 0xd7, 0x0b, 0xe6, 0x43, 0xee, 0xd0, 0x94, 0x44, 0x6c, 0xb5,
        0xc6, 0xd7, 0xc1, 0x33, 0xe8, 0xfb, 0xb0, 0x50, 0xb8, 0xff, 0xd1, 0x7a, 0xad, 0x3f, 0x50, 0xdd,
        0xdc, 0x8f, 0xc4, 0x1b, 0x47, 0xf1, 0x5a, 0x2e, 0x2d, 0x39, 0x20, 0x13, 0x2f, 0x6e, 0x3c, 0x83,
        0x5e, 0xc0, 0x5a, 0xdd, 0xf5, 0x8a, 0x6e, 0x93, 0x2b, 0x2e, 0xea, 0xc1, 0x7b, 0xe4, 0xaa, 0x3b,
        0x19, 0xcf, 0xa0, 0x8f, 0x61, 0xdd, 0x56, 0x04, 0x93, 0xe5, 0x2e, 0xd1, 0x56, 0xd9, 0xcf, 0x0e,
        0xa0, 0xea, 0xd3, 0x17, 0x1a, 0x90, 0x89, 0xef, 0x61, 0xb5, 0x53, 0x54, 0x1f, 0xb8, 0x4a, 0xeb,
        0xde, 0x22, 0x93, 0xdf, 0xc0, 0xf0, 0x0c, 0xfa, 0x3d, 0x3b, 0x59, 0x34, 0x69, 0x8e, 0x2b, 0xac,
        0x85, 0x3c, 0xbb, 0xa9, 0x36, 0xe0, 0xb0, 0xee, 0x36, 0xe7, 0x4e, 0x4a, 0x86, 0xfa, 0x64, 0xc2,
        0x3d, 0x3f, 0xb8, 0x49, 0x26, 0x99, 0x4c, 0x3c, 0x83, 0x9e, 0xc1, 0xaa, 0x29, 0x7b, 0xb7, 0x82,
        0xad, 0xf5, 0xda, 0x82, 0xfb, 0xc1, 0x06, 0xa9, 0xad, 0x91, 0x17, 0x62, 0x55, 0xff, 0x62, 0xbb,
        0x41, 0x6a, 0xff, 0x94, 0x52, 0xdd, 0x9a, 0x0b, 0x37, 0x86, 0xf5, 0xaf, 0x9b, 0xe8, 0x26, 0x99,
        0xf4, 0x07, 0x91, 0xc1, 0x80, 0x4c, 0xfc, 0xc3, 0x04, 0x9e, 0x41, 0x1f, 0x01, 0xe4, 0x75, 0xea,
        0x15, 0x43, 0xb1, 0x4a, 0xaa, 0x45, 0xec, 0xc2, 0x52, 0x3c, 0x83, 0xa5, 0xd2, 0xbf, 0x94, 0xd0,
        0x0d, 0x52, 0xff, 0x67, 0xb0, 0x41, 0x9f, 0x4c, 0xf8, 0x43, 0x13, 0x9e, 0x41, 0xbf, 0x0b, 0xf3,
        0x3b, 0xa3, 0x11, 0x8d, 0x03, 0x65, 0x11, 0xa6, 0x48, 0xf2, 0x6f, 0x03, 0x1c, 0x26, 0x7a, 0xae,
        0x69, 0xc8, 0x8f, 0x60, 0x69, 0x27, 0x08, 0x0a, 0x7e, 0xea, 0x06, 0xa9, 0xf5, 0x5f, 0xab, 0x63,
        0x7f, 0x5f, 0xa7, 0x17, 0x7e, 0xb5, 0xe1, 0x5b, 0x00, 0x9f, 0x53, 0x2f, 0x30, 0xf6, 0xb1, 0x58,
        0x1c, 0x38, 0xd0, 0x76, 0x55, 0x18, 0x29, 0xc8, 0x6b, 0xa5, 0x11, 0x22, 0x95, 0x12, 0xf3, 0xc1,
        0x2a, 0xa9, 0x16, 0x53, 0xcb, 0x81, 0x79, 0x5d, 0x3c, 0x42, 0xa4, 0xf2, 0x27, 0x81, 0xc1, 0x2a,
        0xa9, 0x16, 0xce, 0xcb, 0x3b, 0xc9, 0x2a, 0x7f, 0x43, 0x06, 0xcb, 0x16, 0xe2, 0x35, 0x52, 0x53,
        0x21, 0x87, 0x67, 0xd0, 0x77, 0xf5, 0xad, 0xb2, 0x33, 0xdc, 0x43, 0x2b, 0xa4, 0x5c, 0x97, 0x59,
        0x65, 0xc4, 0x07, 0xfa, 0x9e, 0xe0, 0x03, 0xea, 0xf9, 0xb0, 0x33, 0xdc, 0xc3, 0x33, 0x68, 0xdb,
        0x7a, 0x57, 0x36, 0x2f, 0x06, 0x53, 0x0e, 0xf8, 0x87, 0xa2, 0xa0, 0xb8, 0x52, 0xae, 0x8a, 0x48,
        0xa5, 0xb4, 0x73, 0x50, 0x7d, 0x46, 0x15, 0xb2, 0x3f, 0x6f, 0xd7, 0xdd, 0xa2, 0x35, 0x52, 0x53,
        0x86, 0x5b, 0x5d, 0xf6, 0x3e, 0xcc, 0x9b, 0x65, 0xf9, 0xb0, 0xba, 0xf5, 0xac, 0x42, 0x5d, 0x3c,
        0x83, 0x88, 0xf8, 0x97, 0x8b, 0x84, 0x0c, 0x0f, 0xdc, 0xa3, 0x69, 0x1b, 0x23, 0xc2, 0x37, 0xb9,
        0x3e, 0xfe, 0x03, 0x58, 0xb6, 0x2f, 0x86, 0xeb, 0x0c, 0xb9, 0x0f, 0x4b, 0x86, 0x24, 0xf5, 0xd6,
        0x39, 0x7d, 0x84, 0x21, 0xea, 0x7a, 0x23, 0x1e, 0x6a, 0x25, 0x7a, 0x97, 0x41, 0xef, 0x4b, 0xd5,
        0x51, 0x76, 0xbe, 0x88, 0xac, 0xad, 0x3e, 0x9e, 0x39, 0xe9, 0x88, 0xe2, 0xc2, 0x87, 0xff, 0x1f,
        0x00, 0x00, 0xff, 0xff, 0x2e, 0x78, 0xd6, 0xca, 0x8f, 0x3a, 0x00, 0x00,
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
